<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlockCode</title>
    <link rel="icon" type="image/png" href="img/favicon.png">
    <script src="https://unpkg.com/blockly@10.4.3/blockly.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background: #4C97FF;
            overflow: hidden;
        }

        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }

        .top-bar {
            height: 60px;
            background: #4C97FF;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            gap: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 100;
        }

        /* Font Import for Logo */
        @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@800&display=swap');

        .logo {
            color: white;
            font-size: 28px;
            font-family: 'Nunito', 'Helvetica Neue', Arial, sans-serif;
            font-weight: 800;
            letter-spacing: -0.5px;
            /* Hafif g√∂lge ile belirginle≈ütirme */
            text-shadow: 0 2px 0 rgba(0, 0, 0, 0.1);
        }

        .play-btn {
            width: 48px;
            height: 48px;
            background: #FFBF00;
            border: none;
            border-radius: 16px;
            /* Daha yuvarlak k√∂≈üeler */
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        }

        .play-btn:hover {
            background: #FFA500;
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.3);
        }

        .play-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .play-btn svg {
            margin-left: 2px;
        }

        .info-btn {
            width: 48px;
            height: 48px;
            background: #e0e0e0;
            /* Defaulting to this per original, but user wants darker. */
            background: #999999;
            /* Darker grey */
            border: none;
            border-radius: 16px;
            color: white;
            /* White text */
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
            font-weight: bold;
            font-size: 24px;
            font-family: 'Times New Roman', serif;
            /* Removed margin-right to match gap */
        }

        .info-btn:hover {
            background: #888888;
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.15);
        }

        .info-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .reset-btn {
            width: 48px;
            height: 48px;
            background: #FF6680;
            border: none;
            border-radius: 16px;
            /* Daha yuvarlak k√∂≈üeler */
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        }

        .reset-btn:hover {
            background: #FF4466;
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.3);
        }

        .reset-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .top-btn {
            padding: 10px 24px;
            border: none;
            border-radius: 20px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .run-btn {
            background: #0FBD8C;
            color: white;
        }

        .run-btn:hover {
            background: #0DA574;
            transform: translateY(-2px);
        }

        .stop-btn {
            background: #FF6680;
            color: white;
        }

        .code-btn {
            background: white;
            color: #4C97FF;
            margin-left: auto;
        }

        .tool-btn-small {
            width: 48px;
            height: 48px;
            border: none;
            background: #E9ECEF;
            border-radius: 16px;
            /* Daha yuvarlak k√∂≈üeler */
            color: #495057;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .tool-btn-small:hover {
            background: #DEE2E6;
            transform: translateY(-2px);
        }

        .sidebar {
            width: 70px;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            padding: 0;
            box-shadow: 4px 0 15px rgba(0, 0, 0, 0.08);
            border-right: 1px solid #e0e0e0;
            position: fixed;
            left: 0;
            top: 60px;
            bottom: 0;
            z-index: 50;
            transition: width 0.3s ease;
        }

        .sidebar.expanded {
            width: 280px;
        }

        .sidebar-content {
            width: 70px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
            padding: 15px 0;
            flex-shrink: 0;
            height: 100%;
        }

        .sidebar-divider {
            width: 40px;
            height: 2px;
            background: linear-gradient(90deg, transparent, #ccc, transparent);
            margin: 8px 0;
            flex-shrink: 0;
        }

        /* RGB Control Panel */
        .rgb-control-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 15px 25px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 100;
        }

        .rgb-panel-separator {
            width: 1px;
            height: 40px;
            background: linear-gradient(to bottom, transparent, #ccc, transparent);
            margin: 0 5px;
        }

        .rgb-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .rgb-group-items {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .rgb-group-label {
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        .rgb-led {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 3px solid #ddd;
            transition: all 0.2s;
            position: relative;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
            /* ƒ∞√ß g√∂lge ile derinlik */
        }

        .rgb-led.red {
            background: #fff;
            border-color: #ff6b6b;
        }

        .rgb-led.red.active {
            background: #ff6b6b;
            box-shadow: 0 0 15px #ff6b6b;
        }

        .rgb-led.green {
            background: #fff;
            border-color: #51cf66;
        }

        .rgb-led.green.active {
            background: #51cf66;
            box-shadow: 0 0 15px #51cf66;
        }

        .rgb-led.blue {
            background: #fff;
            border-color: #4dabf7;
        }

        .rgb-led.blue.active {
            background: #4dabf7;
            box-shadow: 0 0 15px #4dabf7;
        }

        .rgb-number-box {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            font-weight: bold;
            transition: all 0.2s;
            border: 3px solid #ddd;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
            /* Sayƒ± kutularƒ±na da hafif derinlik */
        }

        .rgb-number-box.red {
            background: #ffb3b3;
            border-color: #ff6b6b;
            color: #c92a2a;
        }

        .rgb-number-box.green {
            background: #b3e0b3;
            border-color: #51cf66;
            color: #2b8a3e;
        }

        .rgb-number-box.blue {
            background: #b3d9ff;
            border-color: #4dabf7;
            color: #1971c2;
        }

        .rgb-triangle-btn {
            width: 44px;
            height: 44px;
            background: none;
            border: none;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            margin: 0 4px;
            overflow: visible;
            outline: none;
            -webkit-tap-highlight-color: transparent;
            /* 3D Efekt ve G√∂lge */
            filter: drop-shadow(0 4px 0px rgba(0, 0, 0, 0.15));
        }

        .rgb-triangle-btn polygon {
            transition: all 0.2s;
            stroke-width: 4px;
            stroke-linejoin: round;
        }

        .rgb-triangle-btn:hover {
            transform: translateY(-2px);
            /* Hoverda hafif yukarƒ± */
            filter: drop-shadow(0 6px 0px rgba(0, 0, 0, 0.15));
        }

        .rgb-triangle-btn:active {
            transform: translateY(4px) scale(0.95);
            /* Basƒ±nca a≈üaƒüƒ± in */
            filter: drop-shadow(0 0px 0px rgba(0, 0, 0, 0.15));
            /* G√∂lge kaybolur */
        }

        /* Red Button */
        .rgb-triangle-btn.red polygon {
            fill: #ffb3b3;
            stroke: #ff6b6b;
        }

        .rgb-triangle-btn.red:hover polygon {
            fill: #ff9999;
        }

        .rgb-triangle-btn.red.active polygon {
            fill: #ff6b6b;
            /* Active: Fill matches stroke (Solid Vivid) */
        }

        /* Green Button */
        .rgb-triangle-btn.green polygon {
            fill: #b3e0b3;
            stroke: #51cf66;
        }

        .rgb-triangle-btn.green:hover polygon {
            fill: #99d999;
        }

        .rgb-triangle-btn.green.active polygon {
            fill: #51cf66;
        }

        /* Blue Button */
        .rgb-triangle-btn.blue polygon {
            fill: #b3d9ff;
            stroke: #4dabf7;
        }

        .rgb-triangle-btn.blue:hover polygon {
            fill: #99cfff;
        }

        .rgb-triangle-btn.blue.active polygon {
            fill: #4dabf7;
        }

        /* Flash Animation */
        @keyframes flash-glow {
            0% {
                filter: brightness(1) drop-shadow(0 0 0 rgba(255, 255, 255, 0));
                transform: scale(1);
            }

            50% {
                filter: brightness(1.5) drop-shadow(0 0 10px currentColor);
                transform: scale(1.2);
            }

            100% {
                filter: brightness(1) drop-shadow(0 0 0 rgba(255, 255, 255, 0));
                transform: scale(1);
            }
        }

        .rgb-triangle-btn.flash {
            animation: flash-glow 0.5s ease-out;
        }



        .sidebar-bottom-tools {
            margin-top: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
            padding-bottom: 15px;
        }

        /* Blockly toolbox gizle/g√∂ster */
        .blocklyToolboxDiv.hidden {
            display: none !important;
        }

        .blocklyMainBackground {
            transition: transform 0.3s ease;
        }

        .sidebar-panel {
            width: 210px;
            background: white;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.05) inset;
            overflow-y: auto;
            padding: 20px 15px;
            display: none;
            flex-shrink: 0;
        }

        .sidebar.expanded .sidebar-panel {
            display: block;
        }

        .sidebar-panel h3 {
            margin: 0 0 15px 0;
            font-size: 14px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tool-btn {
            width: 45px;
            height: 45px;
            border: none;
            background: white;
            border-radius: 50%;
            font-size: 22px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            flex-shrink: 0;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tool-btn:hover {
            transform: scale(1.15);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        #deviceList {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 10px 0;
            padding: 5px 0;
            width: 100%;
            align-items: center;
        }

        .device-icon {
            width: 40px;
            height: 40px;
            border: 3px solid;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 7px;
            font-weight: bold;
            flex-shrink: 0;
        }

        .device-icon:hover {
            transform: scale(1.15);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .device-icon.active {
            box-shadow: 0 0 0 4px rgba(76, 151, 255, 0.3);
            transform: scale(1.1);
        }

        .device-icon.controller.active,
        .device-icon.selected {
            background-color: #e0e0e0 !important;
            color: black !important;
        }

        .device-icon svg {
            width: 16px;
            height: 16px;
        }

        .device-menu {
            display: none;
        }

        .device-menu-block {
            margin: 12px 0;
            cursor: grab;
            user-select: none;
            display: inline-block;
            transition: all 0.2s;
        }

        .device-menu-block svg {
            display: block;
        }

        .device-menu-block:hover {
            transform: translateY(-2px);
        }

        .device-menu-block:active {
            transform: translateY(1px);
            cursor: grabbing;
        }

        .device-menu-icon {
            font-size: 18px;
            flex-shrink: 0;
        }

        .disconnect-overlay {
            display: none;
            position: fixed;
            top: 70px;
            right: 10px;
            z-index: 1000;
        }

        .disconnect-overlay.show {
            display: block;
        }

        .disconnect-btn-overlay {
            padding: 12px 20px;
            background: #FF6680;
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 102, 128, 0.4);
            transition: all 0.2s;
        }

        .disconnect-btn-overlay:hover {
            background: #FF4466;
            transform: translateY(-2px);
        }

        .delete-block-overlay {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            flex-direction: row;
            gap: 10px;
        }

        .delete-block-overlay.show {
            display: flex;
        }

        .block-action-btn {
            background: #4C97FF;
            color: white;
            border: none;
            padding: 14px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(76, 151, 255, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            width: 50px;
            height: 50px;
        }

        .block-action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 151, 255, 0.5);
        }

        .block-action-btn.delete {
            background: #FF4466;
            box-shadow: 0 4px 15px rgba(255, 68, 102, 0.4);
        }

        .block-action-btn.delete:hover {
            box-shadow: 0 6px 20px rgba(255, 68, 102, 0.5);
        }

        .block-action-btn.help {
            background: #F5A623;
            box-shadow: 0 4px 15px rgba(245, 166, 35, 0.4);
        }

        .block-action-btn.help:hover {
            box-shadow: 0 6px 20px rgba(245, 166, 35, 0.5);
        }

        /* Help Sidebar */
        .help-sidebar {
            position: fixed;
            top: 80px;
            bottom: 80px;
            right: -400px;
            width: 350px;
            height: auto;
            background: white;
            box-shadow: -5px 0 30px rgba(0, 0, 0, 0.15);
            z-index: 20000;
            transition: right 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            display: flex;
            flex-direction: column;
            border-radius: 16px 0 0 16px;
        }

        .help-sidebar.open {
            right: 0;
        }

        .help-header {
            padding: 20px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #FAFAFA;
        }

        .help-header h3 {
            margin: 0;
            font-size: 18px;
            color: #333;
        }

        .help-content {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
            font-size: 14px;
            line-height: 1.6;
            color: #333;
        }

        .help-content h1 {
            font-size: 20px;
            margin-bottom: 15px;
            color: #333;
            font-weight: 700;
        }

        .help-content h2 {
            font-size: 16px;
            margin-top: 20px;
            margin-bottom: 10px;
            color: #444;
            font-weight: 600;
        }

        .help-content p {
            margin-bottom: 12px;
        }

        .help-content code {
            background: #f0f0f0;
            padding: 2px 5px;
            border-radius: 4px;
            font-family: 'Menlo', monospace;
            color: #E01E5A;
            font-size: 0.9em;
        }

        .help-content pre {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            overflow-x: auto;
            margin-bottom: 15px;
            border: 1px solid #eee;
        }

        .help-content ul {
            padding-left: 20px;
            margin-bottom: 15px;
        }

        .help-content li {
            margin-bottom: 5px;
        }

        .delete-block-btn {
            background: #FF4466;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 68, 102, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .delete-block-btn:hover {
            background: #FF4466;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 102, 128, 0.5);
        }

        /* Displays Container */
        .displays-container {
            position: fixed;
            top: 70px;
            right: 20px;
            display: flex;
            gap: 15px;
            z-index: 1000;
            align-items: flex-start;
            pointer-events: none;
            /* Container clicks pass through */
        }

        /* Controller Display Panel ve Motor Display */
        .controller-display,
        .motor-display,
        .color-sensor-display,
        .spike-essential-display {
            display: none;
            /* width/height controlled by content */
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.15);
            min-width: 140px;
            pointer-events: auto;
            /* Enable clicks on panels */
        }

        .controller-header {
            padding: 10px 15px;
            color: white;
            font-weight: bold;
            font-size: 14px;
            border-radius: 12px 12px 0 0;
        }

        .controller-display.active,
        .motor-display.active,
        .color-sensor-display.active,
        .spike-essential-display.active {
            display: block;
        }

        /* Spike Essential Hub Styles */
        .spike-hub-content {
            padding: 12px;
            font-size: 12px;
        }

        .spike-hub-ports {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .spike-hub-port {
            flex: 1;
            background: #f5f5f5;
            border-radius: 8px;
            padding: 8px;
            text-align: center;
        }

        .spike-hub-port-label {
            font-weight: bold;
            color: #666;
            font-size: 11px;
            margin-bottom: 4px;
        }

        .spike-hub-port-status {
            font-size: 10px;
            color: #999;
        }

        .spike-hub-port-status.connected {
            color: #37b24d;
            font-weight: 500;
        }

        .spike-hub-sensors {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .spike-hub-sensor {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 6px 8px;
        }

        .spike-hub-sensor-label {
            font-size: 9px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 2px;
        }

        .spike-hub-sensor-value {
            font-family: monospace;
            font-size: 11px;
            color: #333;
        }

        .spike-hub-tilt {
            grid-column: span 2;
            text-align: center;
        }

        .spike-hub-tilt-icon {
            font-size: 24px;
            margin-bottom: 2px;
        }

        .controller-levers {
            display: flex;
            gap: 15px;
            align-items: center;
            padding: 12px 15px;
            justify-content: center;
        }

        .lever-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .lever-label-mini {
            font-size: 10px;
            font-weight: bold;
            color: #666;
        }

        .lever-bar {
            width: 8px;
            height: 60px;
            background: #e0e0e0;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .lever-bar-fill {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 4px;
            transition: height 0.1s ease-out;
        }

        .lever-bar-fill.left {
            background: linear-gradient(to top, #ff6b6b, #ff8787);
        }

        .lever-bar-fill.right {
            background: linear-gradient(to top, #4C97FF, #7BB3FF);
        }

        .lever-value-mini {
            font-size: 11px;
            font-weight: bold;
            color: #333;
        }

        /* Color Sensor Display Styles */
        .color-sensor-content {
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .color-sensor-circle {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 4px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            background: #f5f5f5;
            position: relative;
        }

        .color-sensor-circle.no-color {
            background: linear-gradient(135deg, #f5f5f5 45%, transparent 45%, transparent 55%, #f5f5f5 55%),
                linear-gradient(45deg, #f5f5f5 45%, #ff4444 45%, #ff4444 55%, #f5f5f5 55%);
            background-size: 100% 100%;
        }

        .color-sensor-circle.color-red {
            background: #FF0000;
            border-color: #CC0000;
        }

        .color-sensor-circle.color-yellow {
            background: #FFD700;
            border-color: #CCB000;
        }

        .color-sensor-circle.color-blue {
            background: #0066FF;
            border-color: #0052CC;
        }

        .color-sensor-circle.color-green {
            background: #00CC00;
            border-color: #009900;
        }

        .color-sensor-circle.color-purple {
            background: #9B59B6;
            border-color: #7D3C98;
        }

        .color-sensor-circle.color-cyan {
            background: #00BCD4;
            border-color: #0097A7;
        }

        .color-sensor-circle.color-white {
            background: #FFFFFF;
            border-color: #CCCCCC;
        }

        .color-sensor-label {
            font-size: 14px;
            font-weight: bold;
            color: #333;
            text-transform: capitalize;
        }

        .color-sensor-details {
            font-size: 11px;
            color: #888;
            text-align: center;
        }

        .workspace-container {
            flex: 1;
            margin-left: 70px;
            position: relative;
            background: white;
            /* Sidebar panel artƒ±k workspace'in √ºst√ºne overlay oluyor, itmiyor */
            /* transition: margin-left 0.3s ease; */
        }

        /* Sidebar a√ßƒ±ldƒ±ƒüƒ±nda workspace'i itme - KALDIRILDI
           Bunun yerine sidebar panel overlay olarak √ßalƒ±≈üƒ±yor */
        /*
        .sidebar.expanded~.workspace-container {
            margin-left: 280px;
        }
        */

        /* Blockly toolbox'ƒ± sola ta≈üƒ±mak i√ßin ek margin */
        #blocklyDiv {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        /* Blockly toolbox stilini √∂zelle≈ütir */
        /* Flyout'un workspace'i itmemesi i√ßin absolute positioning */
        .blocklyToolboxDiv {
            background-color: rgba(255, 255, 255, 0.95) !important;
            border-right: 2px solid #E8E8E8 !important;
            position: absolute !important;
            z-index: 40 !important;
        }

        .blocklyFlyout {
            fill: #EFEFEF !important;
        }

        /* Workspace her zaman flyout geni≈üliƒüi kadar sola doƒüru offset'lensin
           Bu sayede flyout a√ßƒ±lƒ±p kapanƒ±nca bloklar kaymaz */
        .blocklyWorkspace {
            /* Flyout geni≈üliƒüi + biraz bo≈üluk i√ßin sabit margin */
            margin-left: 210px !important;
        }

        /* Flyout background'ƒ± da overlay yap */
        .blocklyFlyoutBackground {
            fill: rgba(239, 239, 239, 0.98) !important;
        }

        /* Blockly flyout SVG'sini workspace'in √ºst√ºne overlay yap */
        .blocklySvg>g.blocklyFlyout {
            z-index: 35;
        }

        /* Pixel Matrix Panel for Color Light Matrix */
        .pixel-panel {
            display: none;
            position: fixed;
            background: #7C3AED;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
            z-index: 10000;
            min-width: 280px;
        }

        .pixel-panel.active {
            display: flex;
            flex-direction: row;
            gap: 15px;
        }

        .pixel-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .pixel-cell {
            width: 54px;
            height: 54px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            border: 3px solid rgba(255, 255, 255, 0.3);
        }

        .pixel-cell:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .pixel-color-picker {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .pixel-color-btn {
            width: 36px;
            height: 20px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.1s, border-color 0.2s;
        }

        .pixel-color-btn:hover {
            transform: scale(1.1);
        }

        .pixel-color-btn.selected {
            border-color: white;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.6);
        }

        .pixel-actions {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }

        .pixel-preset-btn {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.4);
            background: rgba(255, 255, 255, 0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .pixel-preset-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Number Panel Popup */
        .number-panel {
            display: none;
            position: fixed;
            background: #4C97FF;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
            z-index: 10000;
            min-width: 200px;
        }

        .number-panel.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .number-display {
            background: white;
            border: 4px solid #4C97FF;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            font-weight: bold;
            color: #4C97FF;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .number-controls {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .num-btn {
            width: 60px;
            height: 60px;
            border: 3px solid white;
            background: transparent;
            border-radius: 50%;
            color: white;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .num-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .num-btn:active {
            transform: scale(0.95);
        }

        /* Angle Panel Popup */
        .angle-panel {
            display: none;
            position: fixed;
            background: #4C97FF;
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            z-index: 10000;
        }

        .angle-panel.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .angle-display-container {
            position: relative;
            width: 200px;
            height: 200px;
        }

        .angle-circle {
            width: 100%;
            height: 100%;
            background: white;
            border-radius: 50%;
            position: relative;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .angle-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 90px;
            background: #667eea;
            transform-origin: bottom center;
            transform: translate(-50%, -100%) rotate(0deg);
            border-radius: 2px 2px 0 0;
            transition: transform 0.1s ease-out;
            pointer-events: none;
        }

        .angle-center-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 16px;
            height: 16px;
            background: #667eea;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            pointer-events: none;
        }

        .angle-degrees {
            font-size: 32px;
            font-weight: bold;
            color: white;
            min-width: 80px;
            text-align: center;
        }

        /* Fix Number Field Alignment - Targeted via JS Class */
        .number-field-styled>rect {
            fill: white !important;
            stroke: none !important;
            rx: 12px;
            ry: 12px;
        }

        .number-field-styled>text {
            fill: #4C97FF !important;
            font-weight: bold !important;
            dominant-baseline: central !important;
        }

        .angle-markers {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .angle-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 12px;
            background: #ddd;
            transform-origin: bottom center;
        }

        .angle-marker.major {
            height: 18px;
            width: 3px;
            background: #999;
        }

        .angle-marker-label {
            position: absolute;
            font-size: 11px;
            font-weight: bold;
            color: white;
        }

        .angle-controls {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .angle-btn {
            width: 60px;
            height: 60px;
            border: 3px solid white;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            color: white;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .angle-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .angle-btn:active {
            transform: scale(0.95);
        }

        .code-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .code-modal.show {
            display: flex;
        }

        .code-content {
            background: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .code-header h2 {
            color: #4C97FF;
        }

        .close-btn {
            background: #FF6680;
            color: white;
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .close-btn:hover {
            background: #FF4466;
        }

        .code-display {
            background: #F9F9F9;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            white-space: pre-wrap;
            max-height: 400px;
            overflow: auto;
            border: 2px solid #E0E0E0;
        }

        .copy-btn {
            margin-top: 15px;
            padding: 12px 24px;
            background: #4C97FF;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .copy-btn:hover {
            background: #3A7FDF;
        }

        .copy-btn:hover {
            background: #3A7FDF;
        }

        /* Reset Modal Styling */
        .reset-modal {
            display: none;
            position: fixed;
            z-index: 10001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(2px);
            align-items: center;
            justify-content: center;
        }

        .reset-modal.active {
            display: flex;
        }

        .reset-modal-content {
            background-color: #ffffff;
            margin: auto;
            padding: 30px;
            border-radius: 20px;
            width: 420px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            text-align: left;
            color: #333333;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            border: 1px solid #e0e0e0;
        }

        .reset-modal-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 25px;
            font-size: 18px;
            font-weight: 600;
            color: #333333;
        }

        .reset-modal-header svg {
            stroke: #4C97FF;
        }

        .reset-modal-body ul {
            list-style-type: none;
            padding-left: 0;
            margin-bottom: 30px;
            color: #555555;
            font-size: 15px;
            line-height: 2;
        }

        .reset-modal-body ul li {
            position: relative;
            padding-left: 20px;
        }

        .reset-modal-body ul li::before {
            content: "‚Ä¢";
            position: absolute;
            left: 0;
            color: #4C97FF;
            font-weight: bold;
        }

        .reset-modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .reset-modal-btn {
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            outline: none;
            transition: all 0.2s;
        }

        .reset-modal-btn.cancel {
            background-color: #f5f5f5;
            color: #666666;
            border: 2px solid #e0e0e0;
        }

        .reset-modal-btn.cancel:hover {
            background-color: #eeeeee;
            border-color: #cccccc;
        }

        .reset-modal-btn.confirm {
            background-color: #4C97FF;
            color: #ffffff;
        }

        .reset-modal-btn.confirm:hover {
            background-color: #3A7FDF;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(76, 151, 255, 0.3);
        }

        .blocklyMainBackground {
            stroke: none !important;
            fill: #FAFAFA !important;
        }

        .blocklyToolboxDiv {
            background: #F9F9F9 !important;
            border-top: 3px solid #CCCCCC !important;
        }

        .blocklyFlyoutBackground {
            fill: #EFEFEF !important;
            fill-opacity: 0.98 !important;
            stroke: #e0e0e0 !important;
            stroke-width: 1 !important;
            filter: drop-shadow(4px 0 8px rgba(0, 0, 0, 0.08)) !important;
        }

        .blocklyPath {
            stroke-width: 1.5px !important;
        }

        .blocklyText {
            font-size: 18px !important;
            font-weight: 500 !important;
        }

        .blocklyEditableText .blocklyText {
            font-size: 20px !important;
            font-weight: bold !important;
        }

        /* Field kutularƒ±na padding ekle */
        .blocklyEditableText>rect {
            rx: 4 !important;
            ry: 4 !important;
        }

        /* Dropdown i√ßindeki metinleri dikey ortala */
        .blocklyDropdownText {
            dominant-baseline: middle !important;
            alignment-baseline: middle !important;
        }

        /* Dropdown ok simgesine bo≈üluk ekle */
        .blocklyDropDownArrow {
            transform: translateX(5px);
        }

        /* T√ºm field text'leri ortala */
        .blocklyText {
            dominant-baseline: middle !important;
        }

        /* Pulsing animation for active running state */
        @keyframes pulse-green {
            0% {
                box-shadow: 0 0 0 0 rgba(76, 201, 112, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(76, 201, 112, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(76, 201, 112, 0);
            }
        }

        .status-running {
            animation: pulse-green 1.5s infinite;
        }

        .play-btn {
            transition: all 0.3s;
        }
    </style>
</head>

<body>
    <div class="app">
        <div class="top-bar">
            <div class="logo">BlockCode</div>
            <div style="display: flex; gap: 15px;">
                <button class="tool-btn-small" onclick="toggleLanguage()" id="langBtn" title="Dil / Language"
                    style="font-weight: bold; font-size: 14px;">TR</button>
                <div style="width: 1px; background: #e0e0e0; margin: 0 5px;"></div>
                <input type="file" id="importInput" style="display: none;" onchange="importWorkspace(this)"
                    accept=".xml">
                <button class="tool-btn-small" onclick="document.getElementById('importInput').click()"
                    title="ƒ∞√ße Aktar (Import)">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                </button>
                <button class="tool-btn-small" onclick="exportWorkspace()" title="Dƒ±≈üa Aktar (Export)">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                </button>
                <div style="width: 1px; background: #e0e0e0; margin: 0 5px;"></div>
                <button class="info-btn" onclick="openInfoModal()" title="Bilgi / Info">i</button>
                <button class="reset-btn" onclick="resetEverything()" title="Sƒ±fƒ±rla">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
                        <path d="M21 3v5h-5" />
                        <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" />
                        <path d="M3 21v-5h5" />
                    </svg>
                </button>
                <button class="play-btn" onclick="runCode()" title="Kodu √áalƒ±≈ütƒ±r">
                    <svg width="24" height="24" viewBox="0 0 24 24">
                        <path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z" fill="#4CC970" stroke="#FFFFFF"
                            stroke-width="1.5" />
                    </svg>
                </button>
            </div>
        </div>

        <div class="sidebar" id="sidebar">
            <div class="sidebar-content">
                <button class="tool-btn device-add" id="addDeviceBtn" title="Cihaz Ekle">‚ûï</button>
                <div id="deviceList"></div>
                <div class="sidebar-divider"></div>
                <button class="tool-btn" id="startToggle" onclick="toggleStartBlocks()" title="Ba≈ülangƒ±√ß">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="5 3 19 12 5 21 5 3"></polygon>
                    </svg>
                </button>
                <button class="tool-btn" id="controlToggle" onclick="toggleControlBlocks()" title="Kontrol">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <path
                            d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z">
                        </path>
                    </svg>
                </button>
                <button class="tool-btn" id="actionLedToggle" onclick="toggleActionLedBlocks()" title="LED Kontrol">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <circle cx="12" cy="12" r="3"></circle>
                    </svg>
                </button>
                <button class="tool-btn" id="actionNumToggle" onclick="toggleActionNumBlocks()" title="Sayƒ± Kontrol">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                        <line x1="9" y1="9" x2="15" y2="15"></line>
                        <line x1="15" y1="9" x2="9" y2="15"></line>
                    </svg>
                </button>
                <button class="tool-btn" id="actionButtonToggle" onclick="toggleActionButtonBlocks()"
                    title="Tu≈ü Kontrol">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <!-- √ú√ßgen ikonu -->
                        <path d="M12 3L20 20H4L12 3Z"></path>
                    </svg>
                </button>
                <button class="tool-btn" id="operatorToggle" onclick="toggleOperatorBlocks()" title="Operat√∂rler">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <path d="M4 7V4h16v3"></path>
                        <path d="M9 20h6"></path>
                        <path d="M12 4v16"></path>
                    </svg>
                </button>
                <div class="sidebar-divider"></div>
                <div class="sidebar-bottom-tools">
                    <button class="tool-btn" onclick="zoomIn()" title="Yakƒ±nla≈ütƒ±r">üîç+</button>
                    <button class="tool-btn" onclick="zoomOut()" title="Uzakla≈ütƒ±r">üîç‚àí</button>
                </div>
            </div>
            <div class="sidebar-panel" id="sidebarPanel">
                <h3 id="panelTitle">Cihaz Bloklarƒ±</h3>
                <div id="panelContent"></div>
            </div>
        </div>

        <div class="workspace-container">
            <div id="blocklyDiv"></div>

            <!-- RGB Control Panel -->
            <div class="rgb-control-panel">
                <div class="rgb-group">
                    <div class="rgb-group-items">
                        <div class="rgb-led red" id="rgbRedLed" title="Kƒ±rmƒ±zƒ± LED"></div>
                        <div class="rgb-led green" id="rgbGreenLed" title="Ye≈üil LED"></div>
                        <div class="rgb-led blue" id="rgbBlueLed" title="Mavi LED"></div>
                    </div>
                    <span class="rgb-group-label" id="panelLedsLabel">LEDs</span>
                </div>

                <div class="rgb-panel-separator"></div>

                <div class="rgb-group">
                    <div class="rgb-group-items">
                        <div class="rgb-number-box red" id="rgbRedNum">0</div>
                        <div class="rgb-number-box green" id="rgbGreenNum">0</div>
                        <div class="rgb-number-box blue" id="rgbBlueNum">0</div>
                    </div>
                    <span class="rgb-group-label" id="panelNumbersLabel">Numbers</span>
                </div>

                <div class="rgb-panel-separator"></div>

                <div class="rgb-group">
                    <div class="rgb-group-items">
                        <svg id="rgbRedBtn" class="rgb-triangle-btn red" viewBox="0 0 44 44"
                            onmousedown="handleBtnDown('red')" onmouseup="handleBtnUp('red')"
                            onmouseleave="handleBtnUp('red')" ontouchstart="handleBtnDown('red')"
                            ontouchend="handleBtnUp('red')">
                            <polygon points="22,4 4,40 40,40"></polygon>
                        </svg>
                        <svg id="rgbGreenBtn" class="rgb-triangle-btn green" viewBox="0 0 44 44"
                            onmousedown="handleBtnDown('green')" onmouseup="handleBtnUp('green')"
                            onmouseleave="handleBtnUp('green')" ontouchstart="handleBtnDown('green')"
                            ontouchend="handleBtnUp('green')">
                            <polygon points="22,4 4,40 40,40"></polygon>
                        </svg>
                        <svg id="rgbBlueBtn" class="rgb-triangle-btn blue" viewBox="0 0 44 44"
                            onmousedown="handleBtnDown('blue')" onmouseup="handleBtnUp('blue')"
                            onmouseleave="handleBtnUp('blue')" ontouchstart="handleBtnDown('blue')"
                            ontouchend="handleBtnUp('blue')">
                            <polygon points="22,4 4,40 40,40"></polygon>
                        </svg>
                    </div>
                    <span class="rgb-group-label" id="panelButtonsLabel">Buttons</span>
                </div>
            </div>
        </div>

        <!-- Disconnect Button Overlay -->
        <div class="disconnect-overlay" id="disconnectOverlay">
            <button class="disconnect-btn-overlay" onclick="disconnectSelectedDevice()">
                üîå Baƒülantƒ±yƒ± Kes
            </button>
        </div>

        <!-- Blok i≈ülem butonlarƒ± (saƒü alt) -->
        <div class="delete-block-overlay" id="deleteBlockOverlay">
            <button class="block-action-btn help" id="helpBlockBtn" onclick="showBlockHelp()" title="Yardƒ±m">
                <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="#FFFFFF">
                    <path
                        d="M11 18h2v-2h-2v2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4z" />
                </svg>
            </button>
            <button class="block-action-btn" id="duplicateBlockBtn" onclick="duplicateSelectedBlock()" title="Kopyala">
                <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="#FFFFFF">
                    <path
                        d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" />
                </svg>
            </button>
            <button class="block-action-btn delete" id="deleteBlockBtn" onclick="deleteSelectedBlock()" title="Sil">
                <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="#FFFFFF">
                    <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z" />
                </svg>
            </button>
        </div>

        <!-- Controller Display Panel - Kompakt -->
        <div class="displays-container">
            <div class="controller-display" id="controllerDisplay">
                <div class="controller-header" id="controllerHeader">Controller</div>
                <!-- Pil g√∂stergesi -->
                <div id="controllerBatteryInfo"
                    style="position: absolute; top: 38px; right: 10px; font-size: 11px; color: #37b24d; font-family: monospace; display: flex; align-items: center; gap: 3px;">
                    <svg width="18" height="12" viewBox="0 0 24 14" fill="none" stroke="currentColor"
                        stroke-width="1.5">
                        <rect x="1" y="1" width="18" height="12" rx="2" ry="2"></rect>
                        <rect x="19" y="4" width="3" height="6" rx="1" ry="1" fill="currentColor"></rect>
                        <rect id="controllerBatteryFill" x="3" y="3" width="14" height="8" rx="1" ry="1"
                            fill="currentColor" opacity="0.7"></rect>
                    </svg>
                    <span id="controllerBatteryPercent">--%</span>
                </div>
                <div class="controller-levers">
                    <!-- Sol Kol -->
                    <div class="lever-container">
                        <div class="lever-label-mini">L</div>
                        <div class="lever-bar">
                            <div class="lever-bar-fill left" id="leftLeverFill"></div>
                        </div>
                        <div class="lever-value-mini" id="leftLeverValue">50%</div>
                    </div>
                    <!-- Saƒü Kol -->
                    <div class="lever-container">
                        <div class="lever-label-mini">R</div>
                        <div class="lever-bar">
                            <div class="lever-bar-fill right" id="rightLeverFill"></div>
                        </div>
                        <div class="lever-value-mini" id="rightLeverValue">50%</div>
                    </div>
                </div>
            </div>

            <div class="motor-display" id="motorDisplay">
                <div class="controller-header" id="motorHeader">Single Motor</div>
                <!-- Pil g√∂stergesi -->
                <div id="motorBatteryInfo"
                    style="position: absolute; top: 38px; right: 10px; font-size: 11px; color: #37b24d; font-family: monospace; display: flex; align-items: center; gap: 3px;">
                    <svg width="18" height="12" viewBox="0 0 24 14" fill="none" stroke="currentColor"
                        stroke-width="1.5">
                        <!-- Pil g√∂vdesi -->
                        <rect x="1" y="1" width="18" height="12" rx="2" ry="2"></rect>
                        <!-- Pil ba≈üƒ± -->
                        <rect x="19" y="4" width="3" height="6" rx="1" ry="1" fill="currentColor"></rect>
                        <!-- Doluluk g√∂stergesi (JavaScript ile geni≈üliƒüi ayarlanacak) -->
                        <rect id="motorBatteryFill" x="3" y="3" width="14" height="8" rx="1" ry="1" fill="currentColor"
                            opacity="0.7"></rect>
                    </svg>
                    <span id="motorBatteryPercent">--%</span>
                </div>
                <div style="position: relative; width: 100px; height: 104px; margin: 15px auto;">
                    <img src="img/single-motor-body.png" style="width: 100%; height: 100%; object-fit: contain;">
                    <img id="motorShaft" src="img/single-motor-shaft.png"
                        style="position: absolute; top: 12px; left: 0; width: 100%; height: 80%; object-fit: contain; transition: transform 0.1s linear;">
                </div>
                <div id="motorAngleInfo"
                    style="text-align: center; color: #666; font-size: 12px; margin-bottom: 10px; font-weight: bold; font-family: monospace;">
                    0¬∞</div>
            </div>

            <!-- Color Sensor Display Panel -->
            <div class="color-sensor-display" id="colorSensorDisplay">
                <div class="controller-header" id="colorSensorHeader" style="background: #9B59B6;">Color Sensor</div>
                <!-- Pil g√∂stergesi -->
                <div id="colorSensorBatteryInfo"
                    style="position: absolute; top: 38px; right: 10px; font-size: 11px; color: #37b24d; font-family: monospace; display: flex; align-items: center; gap: 3px;">
                    <svg width="18" height="12" viewBox="0 0 24 14" fill="none" stroke="currentColor"
                        stroke-width="1.5">
                        <rect x="1" y="1" width="18" height="12" rx="2" ry="2"></rect>
                        <rect x="19" y="4" width="3" height="6" rx="1" ry="1" fill="currentColor"></rect>
                        <rect id="colorSensorBatteryFill" x="3" y="3" width="14" height="8" rx="1" ry="1"
                            fill="currentColor" opacity="0.7"></rect>
                    </svg>
                    <span id="colorSensorBatteryPercent">--%</span>
                </div>
                <div class="color-sensor-content">
                    <!-- Renk g√∂sterge dairesi -->
                    <div class="color-sensor-circle no-color" id="colorSensorCircle">
                        <svg id="noColorIcon" width="40" height="40" viewBox="0 0 40 40">
                            <circle cx="20" cy="20" r="18" fill="none" stroke="#ccc" stroke-width="3" />
                            <line x1="8" y1="8" x2="32" y2="32" stroke="#ff4444" stroke-width="3"
                                stroke-linecap="round" />
                        </svg>
                    </div>
                    <!-- Renk etiketi -->
                    <div class="color-sensor-label" id="colorSensorLabel">No Color</div>
                    <!-- Detay bilgileri -->
                    <div class="color-sensor-details" id="colorSensorDetails">
                        Reflection: --% | Hue: --¬∞
                    </div>
                </div>
            </div>

            <!-- Spike Essential Hub Display Panel -->
            <div class="spike-essential-display" id="spikeEssentialDisplay">
                <div class="controller-header" id="spikeEssentialHeader" style="background: #F5A623;">Spike Essential
                    Hub</div>
                <!-- Pil g√∂stergesi -->
                <div id="spikeEssentialBatteryInfo"
                    style="position: absolute; top: 38px; right: 10px; font-size: 11px; color: #37b24d; font-family: monospace; display: flex; align-items: center; gap: 3px;">
                    <svg width="18" height="12" viewBox="0 0 24 14" fill="none" stroke="currentColor"
                        stroke-width="1.5">
                        <rect x="1" y="1" width="18" height="12" rx="2" ry="2"></rect>
                        <rect x="19" y="4" width="3" height="6" rx="1" ry="1" fill="currentColor"></rect>
                        <rect id="spikeEssentialBatteryFill" x="3" y="3" width="14" height="8" rx="1" ry="1"
                            fill="currentColor" opacity="0.7"></rect>
                    </svg>
                    <span id="spikeEssentialBatteryPercent">--%</span>
                </div>
                <div class="spike-hub-content">
                    <!-- Port durumlarƒ± -->
                    <div class="spike-hub-ports">
                        <div class="spike-hub-port">
                            <div class="spike-hub-port-label">Port A</div>
                            <div class="spike-hub-port-status" id="spikePortAStatus">Empty</div>
                        </div>
                        <div class="spike-hub-port">
                            <div class="spike-hub-port-label">Port B</div>
                            <div class="spike-hub-port-status" id="spikePortBStatus">Empty</div>
                        </div>
                    </div>
                    <!-- Sens√∂r verileri -->
                    <div class="spike-hub-sensors">
                        <div class="spike-hub-sensor">
                            <div class="spike-hub-sensor-label">Gyro</div>
                            <div class="spike-hub-sensor-value" id="spikeGyroValue">X:-- Y:-- Z:--</div>
                        </div>
                        <div class="spike-hub-sensor">
                            <div class="spike-hub-sensor-label">Accel</div>
                            <div class="spike-hub-sensor-value" id="spikeAccelValue">X:-- Y:-- Z:--</div>
                        </div>
                        <div class="spike-hub-sensor spike-hub-tilt">
                            <div class="spike-hub-sensor-label">Tilt</div>
                            <div class="spike-hub-tilt-icon" id="spikeTiltIcon">‚¨õ</div>
                            <div class="spike-hub-sensor-value" id="spikeTiltValue">--</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Custom Reset Modal -->
        <div id="resetModal" class="reset-modal">
            <div class="reset-modal-content">
                <div class="reset-modal-header">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
                        <path d="M21 3v5h-5" />
                        <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" />
                        <path d="M3 21v-5h5" />
                    </svg>
                    <span id="resetModalTitle">Her ≈üeyi sƒ±fƒ±rlamak istediƒüinize emin misiniz?</span>
                </div>
                <div class="reset-modal-body">
                    <ul id="resetModalList">
                        <!-- List items will be populated by JS -->
                    </ul>
                </div>
                <div class="reset-modal-footer">
                    <button class="reset-modal-btn cancel" id="resetModalCancelBtn"
                        onclick="closeResetModal()">ƒ∞ptal</button>
                    <button class="reset-modal-btn confirm" id="resetModalConfirmBtn"
                        onclick="performReset()">Sƒ±fƒ±rla</button>
                </div>
            </div>
        </div>

        <!-- Import Error Modal -->
        <div id="importErrorModal" class="reset-modal">
            <div class="reset-modal-content" style="max-width: 500px;">
                <div class="reset-modal-header" style="color: #e74c3c;">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10" />
                        <line x1="12" y1="8" x2="12" y2="12" />
                        <line x1="12" y1="16" x2="12.01" y2="16" />
                    </svg>
                    <span id="importErrorTitle">Dosya Y√ºkleme Hatasƒ±</span>
                </div>
                <div class="reset-modal-body">
                    <p id="importErrorMessage" style="margin-bottom: 10px; color: #666;"></p>
                    <pre id="importErrorDetails"
                        style="background: #f5f5f5; padding: 10px; border-radius: 8px; font-size: 12px; max-height: 150px; overflow: auto; white-space: pre-wrap; word-break: break-word; color: #c0392b;"></pre>
                </div>
                <div class="reset-modal-footer">
                    <button class="reset-modal-btn confirm" id="importErrorOkBtn"
                        onclick="closeImportErrorModal()">Tamam</button>
                </div>
            </div>
        </div>

        <!-- Runtime Error Modal -->
        <div id="runtimeErrorModal" class="reset-modal">
            <div class="reset-modal-content">
                <div class="reset-modal-header" style="color: #e74c3c;">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="8" x2="12" y2="12"></line>
                        <line x1="12" y1="16" x2="12.01" y2="16"></line>
                    </svg>
                    <span id="runtimeErrorTitle">Hata</span>
                </div>
                <div class="reset-modal-body">
                    <p id="runtimeErrorMessage" style="color: #666; font-size: 15px; margin: 0; padding-bottom: 10px;">
                    </p>
                </div>
                <div class="reset-modal-footer">
                    <button class="reset-modal-btn confirm" id="runtimeErrorOkBtn" onclick="closeRuntimeErrorModal()"
                        style="background-color: #e74c3c;">Tamam</button>
                </div>
            </div>
        </div>

        <!-- Import Confirmation Modal -->
        <div id="importConfirmModal" class="reset-modal">
            <div class="reset-modal-content" style="max-width: 420px;">
                <div class="reset-modal-header">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" />
                        <polyline points="14 2 14 8 20 8" />
                        <line x1="12" y1="18" x2="12" y2="12" />
                        <line x1="9" y1="15" x2="15" y2="15" />
                    </svg>
                    <span id="importConfirmTitle">Dosya Y√ºkleme</span>
                </div>
                <div class="reset-modal-body" style="text-align: center;">
                    <p id="importConfirmMessage" style="margin-bottom: 8px; font-weight: 500;">Mevcut bloklarƒ±
                        temizleyip y√ºklensin mi?</p>
                    <p id="importConfirmHint" style="font-size: 13px; color: #888;">(ƒ∞ptal'e tƒ±klayarak mevcut bloklara
                        ekleyebilirsiniz)</p>
                </div>
                <div class="reset-modal-footer">
                    <button class="reset-modal-btn cancel" id="importConfirmCancelBtn"
                        onclick="confirmImport(false)">ƒ∞ptal</button>
                    <button class="reset-modal-btn confirm" id="importConfirmOkBtn"
                        onclick="confirmImport(true)">Temizle ve Y√ºkle</button>
                </div>
            </div>
        </div>

        <!-- Device Mapping Modal -->
        <div id="deviceMappingModal" class="reset-modal">
            <div class="reset-modal-content" style="max-width: 500px;">
                <div class="reset-modal-header" style="color: #4C97FF;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 2L2 7l10 5 10-5-10-5z" />
                        <path d="M2 17l10 5 10-5" />
                        <path d="M2 12l10 5 10-5" />
                    </svg>
                    <span id="deviceMappingTitle">Cihaz E≈üle≈ütirme</span>
                </div>
                <div class="reset-modal-body">
                    <p id="deviceMappingMessage" style="margin-bottom: 15px; color: #666;">
                        ƒ∞√ße aktarƒ±lan dosyada baƒülƒ± olmayan cihazlara ait bloklar bulundu. L√ºtfen bu bloklarƒ± mevcut
                        cihazlarla e≈üle≈ütirin:
                    </p>
                    <div id="deviceMappingList" style="max-height: 250px; overflow-y: auto;">
                        <!-- Device mapping rows will be inserted here -->
                    </div>
                </div>
                <div class="reset-modal-footer">
                    <button class="reset-modal-btn cancel" id="deviceMappingSkipBtn"
                        onclick="skipDeviceMapping()">E≈üle≈ütirmeden Devam Et</button>
                    <button class="reset-modal-btn confirm" id="deviceMappingApplyBtn"
                        onclick="applyDeviceMapping()">E≈üle≈ütir ve Y√ºkle</button>
                </div>
            </div>
        </div>

        <!-- Device Remove Confirmation Modal -->
        <div id="removeDeviceModal" class="reset-modal">
            <div class="reset-modal-content" style="width: 380px;">
                <div class="reset-modal-header">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 6h18" />
                        <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" />
                        <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" />
                        <line x1="10" y1="11" x2="10" y2="17" />
                        <line x1="14" y1="11" x2="14" y2="17" />
                    </svg>
                    <span id="removeDeviceModalTitle">Bu cihazƒ± kaldƒ±rmak istediƒüinize emin misiniz?</span>
                </div>
                <div class="reset-modal-footer">
                    <button class="reset-modal-btn cancel" id="removeDeviceCancelBtn"
                        onclick="closeRemoveDeviceModal()">ƒ∞ptal</button>
                    <button class="reset-modal-btn confirm" id="removeDeviceConfirmBtn"
                        style="background-color: #FF4466;" onclick="confirmRemoveDevice()">Kaldƒ±r</button>
                </div>
            </div>
        </div>

        <!-- Device Settings Modal -->
        <div id="deviceSettingsModal" class="reset-modal">
            <div class="reset-modal-content" style="width: 420px;">
                <div class="reset-modal-header" style="background: #4C97FF;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                        <circle cx="12" cy="12" r="3" />
                        <path
                            d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z" />
                    </svg>
                    <span id="deviceSettingsTitle" style="color: white;">Device Settings</span>
                </div>
                <div style="padding: 20px;">
                    <!-- Nickname Setting -->
                    <div style="margin-bottom: 16px;">
                        <label
                            style="display: block; font-size: 12px; font-weight: bold; color: #666; margin-bottom: 6px;">Hub
                            Nickname</label>
                        <div style="display: flex; gap: 8px;">
                            <input type="text" id="deviceNicknameInput" maxlength="14" placeholder="Enter nickname..."
                                style="flex: 1; padding: 10px 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px; outline: none; transition: border-color 0.2s;"
                                onfocus="this.style.borderColor='#4C97FF'" onblur="this.style.borderColor='#e0e0e0'">
                            <button onclick="saveDeviceNickname()"
                                style="background: #4C97FF; color: white; border: none; padding: 10px 16px; border-radius: 8px; cursor: pointer; font-weight: bold;">
                                Save
                            </button>
                        </div>
                        <div style="font-size: 11px; color: #999; margin-top: 4px;">Max 14 characters</div>
                    </div>
                    <!-- LED Color Setting -->
                    <div>
                        <label
                            style="display: block; font-size: 12px; font-weight: bold; color: #666; margin-bottom: 6px;">Hub
                            LED Color</label>
                        <div id="ledColorPicker" style="display: flex; flex-wrap: wrap; gap: 8px;">
                            <!-- Colors will be generated by JS -->
                        </div>
                    </div>
                </div>
                <div class="reset-modal-footer">
                    <button class="reset-modal-btn cancel" onclick="closeDeviceSettings()">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Number Panel Popup -->
    <div class="number-panel" id="numberPanel">
        <div class="number-display" id="numberDisplay">1</div>
        <div class="number-controls">
            <button class="num-btn" id="decrementBtn">‚àí</button>
            <button class="num-btn" id="incrementBtn">+</button>
        </div>
    </div>

    <!-- Angle Panel Popup -->
    <div class="angle-panel" id="anglePanel">
        <div class="angle-display-container">
            <div class="angle-circle" id="angleCircle">
                <div class="angle-markers" id="angleMarkers"></div>
                <div class="angle-indicator" id="angleIndicator"></div>
                <div class="angle-center-dot"></div>
            </div>
        </div>
        <div class="angle-controls">
            <button class="angle-btn" id="angleDecrementBtn">‚àí</button>
            <div class="angle-degrees" id="angleDegrees">0¬∞</div>
            <button class="angle-btn" id="angleIncrementBtn">+</button>
        </div>
    </div>

    <!-- Message Input Panel -->
    <div class="number-panel" id="messagePanel" style="width: 300px;">
        <div
            style="background: white; border: 4px solid #4C97FF; border-radius: 15px; padding: 20px; box-shadow: 0 4px 10px rgba(0,0,0,0.2);">
            <input type="text" id="messageInput" placeholder="Mesaj adƒ±..."
                style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #4C97FF; border-radius: 8px; outline: none; font-weight: bold;">
            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button onclick="saveMessage()"
                    style="flex: 1; padding: 10px; background: #0FBD8C; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer;">
                    ‚úì Kaydet
                </button>
                <button onclick="closeMessagePanel()"
                    style="flex: 1; padding: 10px; background: #FF6680; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer;">
                    √ó ƒ∞ptal
                </button>
            </div>
        </div>
    </div>

    <!-- Pixel Matrix Panel for Color Light Matrix -->
    <div class="pixel-panel" id="pixelPanel">
        <div>
            <div class="pixel-grid" id="pixelGrid">
                <!-- 9 pixel cells will be generated by JS -->
            </div>
            <div class="pixel-actions">
                <button class="pixel-preset-btn" onclick="clearPixelGrid()" title="Clear All">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="white">
                        <path d="M3 3h18v18H3V3zm2 2v14h14V5H5z" />
                    </svg>
                </button>
                <button class="pixel-preset-btn" onclick="fillPixelGrid()" title="Fill All">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="white">
                        <path d="M3 3h18v18H3V3z" />
                    </svg>
                </button>
            </div>
        </div>
        <div class="pixel-color-picker" id="pixelColorPicker">
            <!-- Color buttons will be generated by JS -->
        </div>
    </div>

    <!-- Help Sidebar -->
    <div class="help-sidebar" id="helpSidebar">
        <div class="help-header">
            <h3 id="helpTitle">Block Help</h3>
            <button class="close-btn" onclick="closeBlockHelp()"
                style="width: 30px; height: 30px; font-size: 20px;">√ó</button>
        </div>
        <div class="help-content" id="helpContent">
            <!-- Content will be injected here -->
        </div>
    </div>

    <div class="code-modal" id="codeModal">
        <div class="code-content">
            <div class="code-header">
                <h2>üìù MicroPython</h2>
                <button class="close-btn" onclick="closeModal()">√ó</button>
            </div>
            <div class="code-display" id="codeDisplay"></div>
            <button class="copy-btn" onclick="copyCode()">üìã Kopyala</button>
        </div>
    </div>

    <!-- Device Connection Modal -->
    <!-- Info Modal -->
    <div class="code-modal" id="infoModal">
        <div class="code-content"
            style="max-width: 700px; height: 80vh; max-height: 700px; display: flex; flex-direction: column; overflow: hidden; padding: 15px;">
            <div class="code-header" style="margin-bottom: 8px; padding-bottom: 8px;">
                <h2 id="infoModalTitle" style="margin: 0; font-size: 20px;">‚ÑπÔ∏è Sistem Bilgisi</h2>
                <button class="close-btn" onclick="closeInfoModal()">√ó</button>
            </div>

            <div class="info-tabs" style="display: flex; border-bottom: 2px solid #eee; margin-bottom: 8px;">
                <div class="info-tab active" onclick="switchInfoTab('starters')" id="tab-btn-starters"
                    style="padding: 8px 16px; cursor: pointer; font-weight: bold; border-bottom: 3px solid #4C97FF; color: #4C97FF; transition: all 0.2s; font-size: 14px;">
                    Ba≈ülangƒ±√ßlar</div>
                <div class="info-tab" onclick="switchInfoTab('executions')" id="tab-btn-executions"
                    style="padding: 8px 16px; cursor: pointer; font-weight: bold; color: #888; transition: all 0.2s; font-size: 14px;">
                    √áalƒ±≈ütƒ±rmalar</div>
                <div class="info-tab" onclick="switchInfoTab('devices')" id="tab-btn-devices"
                    style="padding: 8px 16px; cursor: pointer; font-weight: bold; color: #888; transition: all 0.2s; font-size: 14px;">
                    Cihazlar</div>
                <div class="info-tab" onclick="switchInfoTab('graphs')" id="tab-btn-graphs"
                    style="padding: 8px 16px; cursor: pointer; font-weight: bold; color: #888; transition: all 0.2s; font-size: 14px;">
                    Graphs</div>
            </div>

            <div class="info-tab-content" id="tab-starters" style="flex: 1; overflow-y: auto; margin: 0;">
                <ul id="startersList" style="list-style: none; padding: 0; margin: 0;"></ul>
            </div>
            <div class="info-tab-content" id="tab-executions"
                style="display: none; flex: 1; overflow-y: auto; padding: 8px; margin: 0;">
                <div id="executionLogs">
                    <div style="padding: 30px; text-align: center; color: #999;">Hen√ºz √ßalƒ±≈ütƒ±rma kaydƒ± yok.</div>
                </div>
            </div>
            <div class="info-tab-content" id="tab-devices" style="display: none; flex: 1; overflow-y: auto; margin: 0;">
                <ul id="deviceLogsList" style="list-style: none; padding: 0; margin: 0;"></ul>
            </div>
            <div class="info-tab-content" id="tab-graphs"
                style="display: none; flex: 1; overflow-y: auto; margin: 0; padding: 10px;">
                <div style="display: flex; gap: 8px; margin-bottom: 12px; align-items: center; flex-wrap: wrap;">
                    <button onclick="refreshLedGraph()"
                        style="padding: 6px 12px; border: 1px solid #ddd; background: #4C97FF; color: white; border-radius: 16px; cursor: pointer; font-size: 12px;">üîÑ
                        Yenile</button>
                    <button onclick="cancelGraphZoom()" id="cancelZoomBtn"
                        style="padding: 6px 12px; border: 1px solid #ddd; background: #f5f5f5; border-radius: 16px; cursor: pointer; font-size: 12px; display: none;">‚Ü©Ô∏è
                        Zoom ƒ∞ptal</button>
                </div>

                <!-- LED On/Off Graph -->
                <div style="margin-bottom: 15px;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 6px;">
                        <span style="font-weight: bold; font-size: 12px; color: #333;">LED On/Off</span>
                        <div style="flex: 1;"></div>
                        <span style="display: flex; align-items: center; gap: 4px; font-size: 10px;"><span
                                style="width: 8px; height: 8px; background: #ff4444; border-radius: 2px;"></span> Red
                            LED</span>
                        <span style="display: flex; align-items: center; gap: 4px; font-size: 10px;"><span
                                style="width: 8px; height: 8px; background: #44bb44; border-radius: 2px;"></span> Green
                            LED</span>
                        <span style="display: flex; align-items: center; gap: 4px; font-size: 10px;"><span
                                style="width: 8px; height: 8px; background: #4488ff; border-radius: 2px;"></span> Blue
                            LED</span>
                    </div>
                    <div
                        style="background: #fafafa; border: 1px solid #eee; border-radius: 8px; padding: 10px; position: relative;">
                        <canvas id="ledGraphCanvas" width="620" height="60"
                            style="width: 100%; max-width: 620px; cursor: crosshair;"></canvas>
                        <div id="graphSelectionOverlay"
                            style="position: absolute; top: 10px; height: 60px; background: rgba(76, 151, 255, 0.2); border: 1px solid #4C97FF; display: none; pointer-events: none;">
                        </div>
                    </div>
                </div>

                <!-- Numbers Graph -->
                <div style="margin-bottom: 10px;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 6px;">
                        <span style="font-weight: bold; font-size: 12px; color: #333;">Numbers</span>
                        <div style="flex: 1;"></div>
                        <span style="display: flex; align-items: center; gap: 4px; font-size: 10px;"><span
                                style="width: 8px; height: 8px; background: #ff4444; border-radius: 2px;"></span>
                            Red</span>
                        <span style="display: flex; align-items: center; gap: 4px; font-size: 10px;"><span
                                style="width: 8px; height: 8px; background: #44bb44; border-radius: 2px;"></span>
                            Green</span>
                        <span style="display: flex; align-items: center; gap: 4px; font-size: 10px;"><span
                                style="width: 8px; height: 8px; background: #4488ff; border-radius: 2px;"></span>
                            Blue</span>
                    </div>
                    <div
                        style="background: #fafafa; border: 1px solid #eee; border-radius: 8px; padding: 10px; position: relative;">
                        <canvas id="numbersGraphCanvas" width="620" height="120"
                            style="width: 100%; max-width: 620px; cursor: crosshair;"></canvas>
                        <div id="numbersSelectionOverlay"
                            style="position: absolute; top: 10px; height: 120px; background: rgba(76, 151, 255, 0.2); border: 1px solid #4C97FF; display: none; pointer-events: none;">
                        </div>
                    </div>
                </div>

                <!-- Shared Time Labels -->
                <div
                    style="display: flex; justify-content: space-between; font-size: 11px; color: #666; margin-top: 4px; padding: 0 10px;">
                    <span id="graphTimeStart">--:--:--</span>
                    <span id="graphTimeEnd">--:--:--</span>
                </div>
                <div id="graphStatus" style="text-align: center; color: #999; font-size: 12px; margin-top: 6px;">Son 1
                    saat g√∂steriliyor</div>
            </div>
        </div>
    </div>

    <div class="code-modal" id="deviceModal">
        <div class="code-content" style="max-width: 800px;">
            <div class="code-header">
                <h2 id="deviceModalTitle">üì± Bluetooth Cihaz Y√∂netimi</h2>
                <button class="close-btn" onclick="closeDeviceModal()">√ó</button>
            </div>

            <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                <button class="copy-btn" id="scanDeviceBtn" onclick="scanAndConnect()" style="flex: 1.3; margin: 0;">
                    üîç Yeni Cihaz Ara & Baƒülan
                </button>
                <button class="copy-btn" id="addSpecificBtn" onclick="openSpecificDeviceModal()"
                    style="flex: 1; margin: 0; background-color: #6C5CE7; color: white;">
                    ‚ûï √ñzel Cihaz Ekle
                </button>
            </div>

            <div
                style="background: white; border-radius: 8px; border: 2px solid #e0e0e0; overflow: hidden; margin-bottom: 20px;">
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: #4C97FF; color: white;">
                            <th id="thDeviceName" style="padding: 12px; text-align: left; font-size: 14px;">Cihaz Adƒ±
                            </th>
                            <th id="thDeviceId" style="padding: 12px; text-align: left; font-size: 14px;">Cihaz ID</th>
                            <th id="thDeviceStatus" style="padding: 12px; text-align: center; font-size: 14px;">Durum
                            </th>
                            <th id="thDeviceAction" style="padding: 12px; text-align: center; font-size: 14px;">ƒ∞≈ülem
                            </th>
                        </tr>
                    </thead>
                    <tbody id="devicesTableBody">
                        <tr>
                            <td id="noDeviceMsg" colspan="4" style="padding: 30px; text-align: center; color: #999;">
                                Hen√ºz baƒülƒ± cihaz yok. "Yeni Cihaz Ara & Baƒülan" butonuna tƒ±klayƒ±n.
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div id="scanStatus"
                style="display: none; background: #f0f0f0; padding: 15px; border-radius: 8px; margin-bottom: 20px; text-align: center; font-size: 14px;">
                üîç Tarama yapƒ±lƒ±yor...
            </div>
        </div>
    </div>

    <!-- Specific Device Selection Modal -->
    <div class="code-modal" id="specificDeviceModal" style="z-index: 10000;">
        <div class="code-content" style="max-width: 500px; z-index: 10001;">
            <div class="code-header">
                <h2 id="specificModalTitle">Cihaz Tipi Se√ßin</h2>
                <button class="close-btn" onclick="closeSpecificDeviceModal()">√ó</button>
            </div>
            <div style="display: flex; gap: 20px; padding: 20px; justify-content: center; flex-wrap: wrap;">
                <div onclick="scanSpecificDevice('controller')"
                    style="cursor: pointer; padding: 20px; border: 2px solid #ddd; border-radius: 12px; text-align: center; flex: 1; min-width: 120px; transition: all 0.2s; background: white;"
                    onmouseover="this.style.background='#f5f5f5'; this.style.borderColor='#4C97FF'"
                    onmouseout="this.style.background='white'; this.style.borderColor='#ddd'">
                    <img src="img/controller.png" alt="Controller"
                        style="width: 80px; height: 80px; object-fit: contain; margin-bottom: 10px;">
                    <div id="specificLabelController" style="font-weight: bold; font-size: 16px;">Controller</div>
                </div>
                <div onclick="scanSpecificDevice('single_motor')"
                    style="cursor: pointer; padding: 20px; border: 2px solid #ddd; border-radius: 12px; text-align: center; flex: 1; min-width: 120px; transition: all 0.2s; background: white;"
                    onmouseover="this.style.background='#f5f5f5'; this.style.borderColor='#4C97FF'"
                    onmouseout="this.style.background='white'; this.style.borderColor='#ddd'">
                    <img src="img/single-motor.png" alt="Single Motor"
                        style="width: 80px; height: 80px; object-fit: contain; margin-bottom: 10px;">
                    <div id="specificLabelSingleMotor" style="font-weight: bold; font-size: 16px;">Single Motor</div>
                </div>
                <div onclick="scanSpecificDevice('double_motor')"
                    style="cursor: pointer; padding: 20px; border: 2px solid #ddd; border-radius: 12px; text-align: center; flex: 1; min-width: 120px; transition: all 0.2s; background: white;"
                    onmouseover="this.style.background='#f5f5f5'; this.style.borderColor='#4C97FF'"
                    onmouseout="this.style.background='white'; this.style.borderColor='#ddd'">
                    <img src="img/double-motor.png" alt="Double Motor"
                        style="width: 80px; height: 80px; object-fit: contain; margin-bottom: 10px;">
                    <div id="specificLabelDoubleMotor" style="font-weight: bold; font-size: 16px;">Double Motor</div>
                </div>
                <div onclick="scanSpecificDevice('color_sensor')"
                    style="cursor: pointer; padding: 20px; border: 2px solid #ddd; border-radius: 12px; text-align: center; flex: 1; min-width: 120px; transition: all 0.2s; background: white;"
                    onmouseover="this.style.background='#f5f5f5'; this.style.borderColor='#9B59B6'"
                    onmouseout="this.style.background='white'; this.style.borderColor='#ddd'">
                    <img src="img/color-sensor.png" alt="Color Sensor"
                        style="width: 80px; height: 80px; object-fit: contain; margin-bottom: 10px;">
                    <div id="specificLabelColorSensor" style="font-weight: bold; font-size: 16px;">Color Sensor</div>
                </div>
                <div onclick="scanSpecificDevice('spike_essential')"
                    style="cursor: pointer; padding: 20px; border: 2px solid #ddd; border-radius: 12px; text-align: center; flex: 1; min-width: 120px; transition: all 0.2s; background: white;"
                    onmouseover="this.style.background='#f5f5f5'; this.style.borderColor='#F5A623'"
                    onmouseout="this.style.background='white'; this.style.borderColor='#ddd'">
                    <img src="img/essential-hub.png" alt="Essential Hub"
                        style="width: 80px; height: 80px; object-fit: contain; margin-bottom: 10px;">
                    <div id="specificLabelEssentialHub" style="font-weight: bold; font-size: 16px;">Essential Hub</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let workspace;
        let currentNumberField = null;
        let currentValue = 1;
        let minValue = 1;
        let maxValue = 100;
        let messages = ['message1', 'message2']; // Varsayƒ±lan mesajlar
        let currentMessageField = null;
        let currentMessageBlock = null;
        let isToolboxVisible = false;
        let currentToolboxDevice = null;

        // RGB kontrol deƒüi≈ükenleri
        let rgbLedState = { red: false, green: false, blue: false };
        let rgbNumberState = { red: 0, green: 0, blue: 0 };

        // A√ßƒ± se√ßici deƒüi≈ükenleri
        let currentAngleField = null;
        let currentAngle = 0;

        // Motor i≈ülem kilidi - aynƒ± anda sadece bir motor i≈ülemi yapƒ±labilir
        let motorOperationInProgress = false;

        // G√∂rsel g√ºncelleme throttle - 100ms'de bir g√ºncelle
        let lastVisualUpdate = 0;
        const VISUAL_UPDATE_INTERVAL = 100;

        // Controller state tracking
        let controllerState = {
            left: 'RELEASED',  // UP, DOWN, RELEASED
            right: 'RELEASED',
            leftValue: 0,
            rightValue: 0,
            leftPercent: 50,   // 0-100 arasƒ± y√ºzdelik deƒüer
            rightPercent: 50   // 0-100 arasƒ± y√ºzdelik deƒüer
        };

        // Color Sensor state tracking
        let colorSensorState = {
            detectedColor: 'NONE',   // RED, YELLOW, GREEN, BLUE, PURPLE, ORANGE, BLACK, WHITE, CYAN, NONE
            colorIndex: -1,          // Renk indeksi (0-9)
            reflection: 0,           // Yansƒ±ma deƒüeri (0-100)
            hue: 0,                  // Renk tonu (0-360)
            saturation: 0,           // Doygunluk (0-100)
            value: 0,                // Parlaklƒ±k (0-100)
            red: 0,                  // RGB kƒ±rmƒ±zƒ± (0-255)
            green: 0,                // RGB ye≈üil (0-255)
            blue: 0,                 // RGB mavi (0-255)
            deviceId: null           // Hangi cihaza ait
        };

        // Color name mapping (Ger√ßek cihaz verilerinden - Index 7)
        const COLOR_INDEX_MAP = {
            0: 'NONE',      // No color / Renk yok
            2: 'PURPLE',    // Mor
            3: 'BLUE',      // Mavi
            5: 'CYAN',      // A√ßƒ±k Mavi / Cyan  
            6: 'GREEN',     // Ye≈üil
            7: 'YELLOW',    // Sarƒ±
            9: 'RED',       // Kƒ±rmƒ±zƒ±
            10: 'WHITE',    // Beyaz (0x0a)
            0xff: 'NONE',   // ff = Renk yok
            255: 'NONE'     // Alternate no color / Unknown
        };

        // Motor state tracking (PCAP analizinden: Index 8-9 = anlƒ±k a√ßƒ±, Index 13-14 = hedef a√ßƒ±)
        let motorState = {
            currentAngle: 0,      // Anlƒ±k motor a√ßƒ±sƒ± (derece)
            targetAngle: 0,       // Hedef a√ßƒ±
            mode: 0,              // Mode byte (0x00=idle, 0x01=moving, 0x07=holding)
            isMoving: false,      // Motor hareket halinde mi
            deviceId: null        // Hangi cihaza ait
        };

        // Motor monitoring deƒüi≈ükenleri
        let motorMonitoringActive = false;
        let activeMotorDevice = null;
        let activeMotorCharacteristic = null;
        let motorLastVisualUpdate = 0;
        const MOTOR_VISUAL_UPDATE_INTERVAL = 50; // 50ms'de bir g√ºncelle (daha akƒ±cƒ± animasyon)

        // --- ICONS (Simple White SVGs) ---
        const ICON_START = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMTQuNCA2TDE0IDRINXYxN2gydi03aDUuNmwuNCAyaDdWNnoiIGZpbGw9IiM0Q0M5NzAiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIxLjUiLz48L3N2Zz4='; // Green Flag with white outline
        const ICON_BOLT = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNNyAydjExaDN2OWw3LTEyaC00bDQtOHoiLz48L3N2Zz4=';
        const ICON_MSG_IN = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNMjAgNEg0Yy0xLjEgMC0xLjk5LjktMS45OSAyTDIgMThjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY2YzAtMS4xLS45LTItMi0yem0wIDRsLTggNS04LTVWNmw4IDUgOC01djJ6Ii8+PC9zdmc+';
        const ICON_MSG_OUT = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNOSAxNmg2di02aDRsLTctNy03IDdoNHptLTQgMmgxNHYySDV6Ii8+PC9zdmc+';
        const ICON_CLOCK = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNMTIgMkM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptMCAxOGMtNC40MSAwLTgtMy41OS04LThzMy41OS04IDgtOHw4IDMuNTkgOCA4LTMuNTkgOC04IDh6bS41LTExSDExdjZsNS4yIDMuMi44LTEuMy00LjUtMi41ek03IDEyYzAgMi43NiAyLjI0IDUgNSA1czUtMi4yNCA1LTVIN3oiLz48L3N2Zz4='; // Hand/Stop-like icon (using a simplified pause/stop metaphor or just keeping clock but trying to make it look like "duration" or "stop"). Actually user asked for "durma veya stop", so let's use a Hand (Pause/Stop) icon.
        // Better "Stop"/"Hand" icon for Wait:
        const ICON_STOP_HAND = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNMTIgMkM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptLTEgMTRoLTJ2LTZoMnY2em00IDBoLTJ2LTZoMnY2eiIvPjwvc3ZnPg=='; // Pause/Stop circle

        const ICON_LOOP = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNNy41IDE4QTMuNSAzLjUgMCAwIDEgNCAxNC41VjUuNWw0LjIgMi44YTMuNSAzLjUgMCAwIDEgNC4yIDIuOGw2LTUuNkEzLjUgMy41IDAgMCAwIDIwIDUuNUgxNlYyaC0ydjZIMjJ2LTJtLTIgMTMuMkEzLjUgMy41IDAgMCAwIDE2IDE4LjVIMjJWMjJoLTJ2LTZIMTZ2MiIvPjwvc3ZnPg=='; // Trying to find a visually simpler "refresh" or "repeat" icon. Let's use standard Material refresh.
        const ICON_REFRESH = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNMTcuNjUgNi4zNUMxNi4yIDQuOSAxNC4yMSA0IDEyIDRjLTQuNDIgMC03Ljk5IDMuNTgtNy45OSA4czMuNTcgOCA3Ljk5IDhjMy43MyAwIDYuODQtMi41NSA3LjczLTYtMmgtMi4wOGMtLjgyIDIuMzMtMy4wNCA0LTUuNjUgNC0zLjMxIDAtNi0yLjY5LTYtNnMvbS42OS02IDYtNmMgMS42NiAwIDMuMTQuNjkgNC4yMiAxLjc4TDEzIDExaDdWNWwtMi4zNSAyLjM1eiIvPjwvc3ZnPg==';

        const ICON_INFINITY = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNMTguNiA2LjYyYy0xLjQ0IDAtMi44LjU2LTMuNzcgMS41M0wxMiAxMC42NiA5LjE3IDguMTVjLS45Ny0uOTctMi4zMy0xLjUzLTMuNzctMS41My0yLjk0IDAtNS4zMyAyLjM4LTUuMzMyIDUuMzE1UzIuNCAxNy4yNSA1LjQgMTcuMjVjMS40NCAwIDIuOC0uNTYgMy43Ny0xLjUzTDEyIDEzLjM0bDguMDMgOC4wM2MuOTcuOTcgMi41MyAxLjUzIDMuNzcgMS41MyAyLjk0IDAgNS4zMy0yLjM5IDUuMzMtNS4zMyAwLTIuOTMtMi4zOS01LjMzLTUuMzMtNS4zM3ptMCA4LjU1Yy0uNTEgMC0xLjAxLS4yLTEuMzktLjU5TDEyIDEwLjAybDguNDEgOC40MWMtLjM4LjM5LS44OC41OS0xLjQxLjU5em0tOS45Ni05LjgyYy41MSAwIDEuMDEuMiAxLjM5LjU5TDEyIDEwLjM0bC0yLjI5IDIuMjlMOC42NCA5LjY1Yy0uMzgtLjM5LS44OS0uNTktMS40MS0uNTktMS45NiAwLTMuNTUgMS41OS0zLjU1IDMuNTUgMCAxLjk2IDEuNTkgMy41NSAzLjU1IDMuNTUuNTEgMCAxLjAxLS4yIDEuMzktLjU5bDMuMTItMy4xMi01LjEzLTUuMTNjLjM4LS40Mi44OS0uNjMgMS40MS0uNjN6Ii8+PC9zdmc+';
        const ICON_DIAMOND = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNOS4xNyA2bDItMmMyIC44MiAyLjgyIDEuNjQgNC44MyAzLjY0bDMuNjQgNC44M2MtLjgyIDItMS42NCAyLjgyLTMuNjQgNC44M2wtMiAyLTIgLTIgLTMuNjMtNC44M2MuODItMiAxLjY0LTIuODIgMy42My00Ljgzek0xMiAyTDQgMTJsOCAxMCA4LTEwTDExIDJ6Ii8+PHBhdGggZD0iTTE5IDNsLTUgNWgydi00bDQtNGg2eSgiIHRyYW5zZm9ybT0icm90YXRlKDQ1IDEyIDEyKSIvPjwvc3ZnPg=='; // Generic Diamond for Logic, replaced with a filled rhombus or similar if needed. Using a simple rhombus here:
        const ICON_COND_TRUE = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNMTkgM0g1Yy0xLjEgMC0yIC45LTIgMnYxNGMwIDEuMS45IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6bTAgMTZINVY1aDE0djE0em0tNy0yaC0ydi01aDVsLTEgMWg0bC02LTZ6Ii8+PC9zdmc+'; // Placeholder if needed, but let's use a simple diamond shape for logic conditions.
        const ICON_RHOMBUS = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNMTIgMkwyIDEybDEwIDEwIDEwLTEwTDExIDJ6Ii8+PC9zdmc+';
        const ICON_HOURGLASS = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNNiAydjZoLjAxTCA2IDguMDFWMTBsNiA2IDYgNnYybC4wMSAySDZ2NmgxMnYtNmgtLjAxTDE4IDE2di0ybC02LTYgNi02VjZMNT44di02aC0uMDFMNiAyeiIvPjwvc3ZnPg==';

        // Colored Square Icons for RGB blocks (Red, Green, Blue) - No gradients, solid colors.
        // Using slight shadow/bevel effect for "button" look if desired, or flat. User said "kare ≈üeklinde ikonlar".
        const ICON_SQUARE_RED = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IjBmaWxsPSIjRkYwMDAwIj48cmVjdCB4PSI0IiB5PSI0IiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHJ4PSIyIiByeT0iMiIgLz48L3N2Zz4='; // #FF0000 Rounded Rect
        const ICON_SQUARE_GREEN = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IjBmaWxsPSIjMDBGRjAwIj48cmVjdCB4PSI0IiB5PSI0IiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHJ4PSIyIiByeT0iMiIgLz48L3N2Zz4='; // #00FF00
        const ICON_SQUARE_BLUE = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IjBmaWxsPSIjMDAwMEZGIj48cmVjdCB4PSI0IiB5PSI0IiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHJ4PSIyIiByeT0iMiIgLz48L3N2Zz4='; // #0000FF

        // Updating with specific colors requested normally found in blocks (e.g. Red #FF3333, etc) or just pure RGB.
        // Let's use darker shades to stand out on pastel blocks if necessary, or vivid standard colors.
        // Red: #D32F2F, Green: #388E3C, Blue: #1976D2
        const ICON_SQ_RED = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRDMyRjJGIj48cmVjdCB4PSI0IiB5PSI0IiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHJ4PSI0IiByeT0iNCIgLz48L3N2Zz4=';
        const ICON_SQ_GREEN = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjMzg4RTNDIj48cmVjdCB4PSI0IiB5PSI0IiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHJ4PSI0IiByeT0iNCIgLz48L3N2Zz4=';
        const ICON_SQ_BLUE = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjMTk3NkQyIj48cmVjdCB4PSI0IiB5PSI0IiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHJ4PSI0IiByeT0iNCIgLz48L3N2Zz4=';

        // Solid Colored Circle Icons (Red, Green, Blue) - No gradient
        const ICON_CIRCLE_RED = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkYwMDAwIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI4IiAvPjwvc3ZnPg==';
        const ICON_CIRCLE_GREEN = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjMDBGRjAwIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI4IiAvPjwvc3ZnPg==';
        const ICON_CIRCLE_BLUE = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjMDAwMEZGIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI4IiAvPjwvc3ZnPg==';

        // Using specific darker shades if preferred for better contrast on blocks
        const ICON_CIRC_RED = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRDMyRjJGIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI3IiAvPjwvc3ZnPg==';
        const ICON_CIRC_GREEN = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjMzg4RTNDIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI3IiAvPjwvc3ZnPg==';
        const ICON_CIRC_BLUE = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjMTk3NkQyIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI3IiAvPjwvc3ZnPg==';
        // White circle for "Off" state (same size as On state)
        const ICON_CIRC_WHITE = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI3IiAvPjwvc3ZnPg==';

        // Color Sensor Icon
        const ICON_COLOR_SENSOR = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI4IiBmaWxsPSIjZmZmIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMiIvPjxjaXJjbGUgY3g9IjEyIiBjeT0iOCIgcj0iMi41IiBmaWxsPSIjZmYwMDAwIi8+PGNpcmNsZSBjeD0iOCIgY3k9IjE0IiByPSIyLjUiIGZpbGw9IiMwMGZmMDAiLz48Y2lyY2xlIGN4PSIxNiIgY3k9IjE0IiByPSIyLjUiIGZpbGw9IiMwMDAwZmYiLz48L3N2Zz4=';
        // Yellow circle for color sensor blocks
        const ICON_CIRC_YELLOW = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZEOTAwIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI3IiAvPjwvc3ZnPg==';
        // Orange circle
        const ICON_CIRC_ORANGE = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkY5ODAwIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI3IiAvPjwvc3ZnPg==';
        // Cyan circle
        const ICON_CIRC_CYAN = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjMDBCQ0Q0Ij48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI3IiAvPjwvc3ZnPg==';
        // Purple/Violet circle
        const ICON_CIRC_PURPLE = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjOUIyN0IwIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI3IiAvPjwvc3ZnPg==';
        // Black circle
        const ICON_CIRC_BLACK = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjMjEyMTIxIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI3IiAvPjwvc3ZnPg==';


        let controllerMonitoring = null;  // Interval ID for monitoring
        let activeControllerDevice = null; // Aktif controller cihazƒ±
        let activeControllerCharacteristic = null; // DEBUG i√ßin
        let controllerPingInterval = null; // Periyodik ping i√ßin

        // DEBUG: Manuel test fonksiyonu
        window.testControllerCharacteristic = async function () {
            console.log('üß™ Controller characteristic test ba≈ülatƒ±lƒ±yor...');

            if (!activeControllerCharacteristic) {
                console.log('‚ùå activeControllerCharacteristic yok!');
                return;
            }
        };

        // --- VISUAL FIXES ---
        // Safely style Number Fields without breaking Dropdowns
        if (typeof Blockly !== 'undefined') {
            // 1. Add a specific class to Number Fields during initialization
            const originalInitView = Blockly.FieldNumber.prototype.initView;
            Blockly.FieldNumber.prototype.initView = function () {
                originalInitView.call(this);
                if (this.fieldGroup_) {
                    Blockly.utils.dom.addClass(this.fieldGroup_, 'number-field-styled');
                }
            };

            // 2. Add padding to single digits to make them look like circles/pills
            const originalGetText = Blockly.FieldNumber.prototype.getText;
            Blockly.FieldNumber.prototype.getText = function () {
                const text = originalGetText.call(this);
                if (text && text.length === 1) {
                    return ' ' + text + ' '; // Add spaces for visual centering
                }
                return text;
            };
        }

        // --- LANGUAGE SUPPORT ---
        let currentLanguage = 'tr';

        const TRANSLATIONS = {
            tr: {
                lang: "TR",
                import: "ƒ∞√ße Aktar (Import)",
                export: "Dƒ±≈üa Aktar (Export)",
                reset: "Sƒ±fƒ±rla",
                run: "Kodu √áalƒ±≈ütƒ±r",
                add_device: "Cihaz Ekle",

                start_tooltip: "Ba≈ülangƒ±√ß",
                control_tooltip: "Kontrol",
                led_tooltip: "LED Kontrol",
                num_tooltip: "Sayƒ± Kontrol",
                btn_tooltip: "Tu≈ü Kontrol",
                op_tooltip: "Operat√∂rler",
                zoom_in: "Yakƒ±nla≈ütƒ±r",
                zoom_out: "Uzakla≈ütƒ±r",
                reset_view: "G√∂r√ºn√ºm√º Ortala",

                block_random_pre: " rastgele sayƒ±  ",
                block_random_mid: " ile ",
                delete_block: "Bloƒüu Sil",

                modal_reset_title: "Her ≈üeyi sƒ±fƒ±rlamak istediƒüinize emin misiniz?",
                modal_reset_list: "RGB paneli sƒ±fƒ±rlanacak|T√ºm LED'ler s√∂necek|Sayƒ± deƒüerleri 0 olacak|Cihazlar baƒülƒ± kalacak",
                btn_cancel: "ƒ∞ptal",
                btn_reset: "Sƒ±fƒ±rla",

                block_wait_pre: "‚è±Ô∏è ",
                block_wait_post: " saniye bekle  ",
                block_repeat_pre: "üîÑ ",
                block_repeat_post: " kez tekrarla  ",
                block_forever: "‚ôæÔ∏è s√ºrekli tekrarla  ",
                block_if: "üî∂ eƒüer",
                block_then: "ise  ",
                block_then: "ise  ",
                block_else: "deƒüilse  ",
                block_wait_until_pre: "‚è≥ ",
                block_start: "play tƒ±klandƒ±ƒüƒ±nda  ",

                block_wait_pre: " ",
                block_wait_post: " saniye bekle  ",
                block_repeat_pre: " ",
                block_repeat_post: " kez tekrarla  ",
                block_forever: " s√ºrekli tekrarla  ",
                block_if: " eƒüer",
                block_then: "ise  ",
                block_then: "ise  ",
                block_else: "deƒüilse  ",
                block_wait_until_pre: " ",
                block_wait_until_post: " olana kadar bekle  ",
                block_repeat_until_pre: " ",
                block_repeat_until_post: " olana kadar tekrarla  ",

                block_when_pre: "olduƒüunda  ",
                block_when_post: "  ",
                block_message_pre: "alƒ±ndƒ±ƒüƒ±nda  ",
                block_message_post: "  ",
                block_send_mobile_pre: "g√∂nder  ",
                block_send_mobile_post: "  ",

                block_light_get_pre: " ",
                block_light_get_post: " ƒ±≈üƒ±k getir  ",

                block_red_light_on: "  kƒ±rmƒ±zƒ± ƒ±≈üƒ±k yak    ",
                block_red_light_off: "  kƒ±rmƒ±zƒ± ƒ±≈üƒ±k s√∂nd√ºr    ",
                block_green_light_on: "  ye≈üil ƒ±≈üƒ±k yak    ",
                block_green_light_off: "  ye≈üil ƒ±≈üƒ±k s√∂nd√ºr    ",
                block_blue_light_on: "  mavi ƒ±≈üƒ±k yak    ",
                block_blue_light_off: "  mavi ƒ±≈üƒ±k s√∂nd√ºr    ",

                block_red_num: "  kƒ±rmƒ±zƒ± sayƒ± yap  ",
                block_green_num: "  ye≈üil sayƒ± yap  ",
                block_blue_num: "  mavi sayƒ± yap  ",
                block_red_get: "  kƒ±rmƒ±zƒ± sayƒ± √∂ƒüren  ",
                block_green_get: "  ye≈üil sayƒ± √∂ƒüren  ",
                block_blue_get: "  mavi sayƒ± √∂ƒüren  ",

                block_rgb_red_btn_get: " tu≈ü getir  ",
                block_rgb_green_btn_get: " tu≈ü getir  ",
                block_rgb_blue_btn_get: " tu≈ü getir  ",

                block_logic_and: " ve ",
                block_logic_or: " veya ",
                block_logic_not: "deƒüil ",

                panel_leds: "LEDler",
                panel_numbers: "Sayƒ±lar",
                panel_buttons: "Butonlar",

                confirm_reset: "Her ≈üeyi sƒ±fƒ±rlamak istediƒüinize emin misiniz?", // Deprecated but kept for safety
                alert_no_play: "‚ùå Play bloƒüu bulunamadƒ±!\n\n\"üö© play tƒ±klandƒ±ƒüƒ±nda\" bloƒüunu ekleyin.",
                alert_stopped: "‚èπÔ∏è Durduruldu!",
                alert_import_error: "Dosya y√ºklenirken bir hata olu≈ütu! Ge√ßerli bir XML dosyasƒ± se√ßtiƒüinizden emin olun.",
                alert_export_error: "Dƒ±≈üa aktarma sƒ±rasƒ±nda bir hata olu≈ütu!",
                confirm_import: "Mevcut √ßalƒ±≈üma alanƒ± temizlenip, dosya y√ºklensin mi?\n(ƒ∞ptal derseniz mevcut bloklarƒ±n √ºzerine eklenir)",

                scan_btn: "üîç Yeni Cihaz Ara & Baƒülan",
                tbl_name: "Cihaz Adƒ±",
                tbl_id: "Cihaz ID",
                tbl_status: "Durum",
                tbl_action: "ƒ∞≈ülem",
                no_device: "Hen√ºz baƒülƒ± cihaz yok. \"Yeni Cihaz Ara & Baƒülan\" butonuna tƒ±klayƒ±n.",
                scan_status: "üîç Tarama yapƒ±lƒ±yor...",
                status_connected: "Baƒülƒ±",
                status_disconnected: "Kesildi",
                btn_remove: "Kaldƒ±r",
                confirm_remove_device: "Bu cihazƒ± kaldƒ±rmak istediƒüinize emin misiniz?",
                connecting_to: "üì± Baƒülanƒ±yor:",
                connected_to: "‚úÖ Baƒülandƒ±:",
                device_added: "‚úÖ Cihaz eklendi!",
                unknown_device: "Bilinmeyen",
                device_list_opening: "üîç Cihaz listesi a√ßƒ±lƒ±yor...",
                modal_title: "üì± Bluetooth Cihaz Y√∂netimi",
                add_specific_btn: "‚ûï √ñzel Cihaz Ekle",
                specific_modal_title: "Cihaz Tipi Se√ßin",
                specific_type_controller: "Controller",
                specific_type_single_motor: "Single Motor",
                coming_soon: "Yakƒ±nda"
            },
            en: {
                lang: "EN",
                import: "Import",
                export: "Export",
                reset: "Reset",
                run: "Run Code",
                add_device: "Add Device",

                start_tooltip: "Start",
                control_tooltip: "Control",
                led_tooltip: "LED Control",
                num_tooltip: "Number Control",
                btn_tooltip: "Button Control",
                op_tooltip: "Operators",
                zoom_in: "Zoom In",
                zoom_out: "Zoom Out",
                reset_view: "Reset View",

                block_random_pre: " pick random  ",
                block_random_mid: " to ",
                delete_block: "Delete Block",

                modal_reset_title: "Are you sure you want to reset everything?",
                modal_reset_list: "RGB panel will be reset|All LEDs will turn off|Number values will be 0|Devices will stay connected",
                btn_cancel: "Cancel",
                btn_reset: "Reset",

                block_start: "when play clicked  ",

                block_wait_pre: " wait ",
                block_wait_post: " seconds  ",
                block_repeat_pre: " repeat ",
                block_repeat_post: " times  ",
                block_forever: " repeat forever  ",
                block_if: " if",
                block_then: "then  ",
                block_then: "then  ",
                block_else: "else  ",
                block_wait_until_pre: " wait until ",
                block_wait_until_post: "  ",
                block_repeat_until_pre: " repeat until ",
                block_repeat_until_post: "  ",

                block_when_pre: "when ",
                block_when_post: "  ",
                block_message_pre: "when ",
                block_message_post: " received  ",
                block_send_mobile_pre: "send ",
                block_send_mobile_post: "  ",

                block_light_get_pre: " ",
                block_light_get_post: " get light  ",

                block_red_light_on: "  turn red light on    ",
                block_red_light_off: "  turn red light off    ",
                block_green_light_on: "  turn green light on    ",
                block_green_light_off: "  turn green light off    ",
                block_blue_light_on: "  turn blue light on    ",
                block_blue_light_off: "  turn blue light off    ",

                block_red_num: "  set red number to  ",
                block_green_num: "  set green number to  ",
                block_blue_num: "  set blue number to  ",
                block_red_get: "  get red number  ",
                block_green_get: "  get green number  ",
                block_blue_get: "  get blue number  ",

                block_rgb_red_btn_get: " get button  ",
                block_rgb_green_btn_get: " get button  ",
                block_rgb_blue_btn_get: " get button  ",

                block_logic_and: " and ",
                block_logic_or: " or ",
                block_logic_not: "not ",

                panel_leds: "LEDs",
                panel_numbers: "Numbers",
                panel_buttons: "Buttons",

                confirm_reset: "üîÑ Are you sure you want to reset everything?\n\n‚Ä¢ RGB panel will be reset\n‚Ä¢ All LEDs will turn off\n‚Ä¢ Number values will be 0\n‚Ä¢ Devices will stay connected",
                alert_no_play: "‚ùå Play block not found!\n\nAdd \"üö© when play clicked\" block.",
                alert_stopped: "‚èπÔ∏è Stopped!",
                alert_import_error: "Error loading file! Make sure you selected a valid XML file.",
                alert_export_error: "Error exporting workspace!",
                confirm_import: "Clear current workspace before loading?\n(Cancel to append to existing blocks)",

                scan_btn: "üîç Scan & Connect New Device",
                tbl_name: "Device Name",
                tbl_id: "Device ID",
                tbl_status: "Status",
                tbl_action: "Action",
                no_device: "No connected devices. Click \"Scan & Connect New Device\".",
                scan_status: "üîç Scanning...",
                status_connected: "Online",
                status_disconnected: "Offline",
                btn_remove: "Remove",
                confirm_remove_device: "Are you sure you want to remove this device?",
                connecting_to: "üì± Connecting:",
                connected_to: "‚úÖ Connected:",
                device_added: "‚úÖ Device added!",
                unknown_device: "Unknown",
                device_list_opening: "üîç Opening device list...",
                modal_title: "üì± Bluetooth Device Management",
                add_specific_btn: "‚ûï Add Specific Device",
                specific_modal_title: "Select Device Type",
                specific_type_controller: "Controller",
                specific_type_single_motor: "Single Motor",
                coming_soon: "Coming Soon"
            }
        };

        function toggleLanguage() {
            setLanguage(currentLanguage === 'tr' ? 'en' : 'tr');
        }

        function setLanguage(lang) {
            if (!TRANSLATIONS[lang]) return;
            currentLanguage = lang;
            const t = TRANSLATIONS[lang];

            const langBtn = document.getElementById('langBtn');
            if (langBtn) langBtn.textContent = t.lang;

            const addDeviceBtn = document.getElementById('addDeviceBtn');
            if (addDeviceBtn) addDeviceBtn.title = t.add_device;

            const startToggle = document.getElementById('startToggle');
            if (startToggle) startToggle.title = t.start_tooltip;

            const controlToggle = document.getElementById('controlToggle');
            if (controlToggle) controlToggle.title = t.control_tooltip;

            const actionLedToggle = document.getElementById('actionLedToggle');
            if (actionLedToggle) actionLedToggle.title = t.led_tooltip;

            const actionNumToggle = document.getElementById('actionNumToggle');
            if (actionNumToggle) actionNumToggle.title = t.num_tooltip;

            const actionButtonToggle = document.getElementById('actionButtonToggle');
            if (actionButtonToggle) actionButtonToggle.title = t.btn_tooltip;

            const operatorToggle = document.getElementById('operatorToggle');
            if (operatorToggle) operatorToggle.title = t.op_tooltip;

            const resetBtn = document.querySelector('.reset-btn');
            if (resetBtn) resetBtn.title = t.reset;

            const playBtn = document.querySelector('.play-btn');
            if (playBtn) playBtn.title = t.run;

            const importBtn = document.querySelector('button[onclick*="importInput"]');
            if (importBtn) importBtn.title = t.import;

            const exportBtn = document.querySelector('button[onclick="exportWorkspace()"]');
            if (exportBtn) exportBtn.title = t.export;

            const zoomInBtn = document.querySelector('button[onclick="zoomIn()"]');
            if (zoomInBtn) zoomInBtn.title = t.zoom_in;

            const zoomOutBtn = document.querySelector('button[onclick="zoomOut()"]');
            if (zoomOutBtn) zoomOutBtn.title = t.zoom_out;

            const resetViewBtn = document.querySelector('button[onclick="resetView()"]');
            if (resetViewBtn) resetViewBtn.title = t.reset_view;

            // Update Device Modal Texts
            const modalTitle = document.getElementById('deviceModalTitle');
            if (modalTitle) modalTitle.textContent = t.modal_title;

            const scanBtn = document.getElementById('scanDeviceBtn');
            if (scanBtn) scanBtn.textContent = t.scan_btn;

            const thName = document.getElementById('thDeviceName');
            if (thName) thName.textContent = t.tbl_name;

            const thId = document.getElementById('thDeviceId');
            if (thId) thId.textContent = t.tbl_id;

            const thStatus = document.getElementById('thDeviceStatus');
            if (thStatus) thStatus.textContent = t.tbl_status;

            const thAction = document.getElementById('thDeviceAction');
            if (thAction) thAction.textContent = t.tbl_action;

            const noDeviceMsg = document.getElementById('noDeviceMsg');
            if (noDeviceMsg) noDeviceMsg.textContent = t.no_device;

            const scanStatus = document.getElementById('scanStatus');
            if (scanStatus) scanStatus.textContent = t.scan_status;

            // Update Remove Device Modal Translations
            const removeDeviceTitle = document.getElementById('removeDeviceModalTitle');
            if (removeDeviceTitle) removeDeviceTitle.textContent = t.confirm_remove_device;

            const removeDeviceCancelBtn = document.getElementById('removeDeviceCancelBtn');
            if (removeDeviceCancelBtn) removeDeviceCancelBtn.textContent = t.btn_cancel;

            const removeDeviceConfirmBtn = document.getElementById('removeDeviceConfirmBtn');
            if (removeDeviceConfirmBtn) removeDeviceConfirmBtn.textContent = t.btn_remove;

            // Refresh devices table if open to update translations
            updateDevicesTable();

            // Update Reset Modal Translations
            const resetTitle = document.getElementById('resetModalTitle');
            if (resetTitle) resetTitle.textContent = t.modal_reset_title;

            // Populate list from split string
            const resetList = document.getElementById('resetModalList');
            if (resetList && t.modal_reset_list) {
                resetList.innerHTML = t.modal_reset_list.split('|').map(item => `<li>${item}</li>`).join('');
            }

            const resetCancel = document.getElementById('resetModalCancelBtn');
            if (resetCancel) resetCancel.textContent = t.btn_cancel;

            const resetConfirm = document.getElementById('resetModalConfirmBtn');
            if (resetConfirm) resetConfirm.textContent = t.btn_reset;

            const deleteBlockBtn = document.getElementById('deleteBlockBtn');
            if (deleteBlockBtn) {
                deleteBlockBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="#FFFFFF"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>`;
            }

            // Update RGB panel labels
            const panelLedsLabel = document.getElementById('panelLedsLabel');
            if (panelLedsLabel) panelLedsLabel.textContent = t.panel_leds;

            const panelNumbersLabel = document.getElementById('panelNumbersLabel');
            if (panelNumbersLabel) panelNumbersLabel.textContent = t.panel_numbers;

            const panelButtonsLabel = document.getElementById('panelButtonsLabel');
            if (panelButtonsLabel) panelButtonsLabel.textContent = t.panel_buttons;

            // Specific Device Modal Translations
            const addSpecificBtn = document.getElementById('addSpecificBtn');
            if (addSpecificBtn) addSpecificBtn.textContent = t.add_specific_btn;

            const specificModalTitle = document.getElementById('specificModalTitle');
            if (specificModalTitle) specificModalTitle.textContent = t.specific_modal_title;

            const specificLabelController = document.getElementById('specificLabelController');
            if (specificLabelController) specificLabelController.textContent = t.specific_type_controller;

            const specificLabelSingleMotor = document.getElementById('specificLabelSingleMotor');
            if (specificLabelSingleMotor) specificLabelSingleMotor.textContent = t.specific_type_single_motor;

            const specificLabelComingSoon = document.getElementById('specificLabelComingSoon');
            if (specificLabelComingSoon) specificLabelComingSoon.textContent = t.coming_soon || 'Coming Soon';

            // Update Blockly Messages
            if (typeof Blockly !== 'undefined') {
                Blockly.Msg.BLOCK_START = t.block_start;

                Blockly.Msg.BLOCK_WAIT_PRE = t.block_wait_pre;
                Blockly.Msg.BLOCK_WAIT_POST = t.block_wait_post;

                Blockly.Msg.BLOCK_REPEAT_PRE = t.block_repeat_pre;
                Blockly.Msg.BLOCK_REPEAT_PRE = t.block_repeat_pre;
                Blockly.Msg.BLOCK_REPEAT_POST = t.block_repeat_post;

                Blockly.Msg.BLOCK_RANDOM_PRE = t.block_random_pre;
                Blockly.Msg.BLOCK_RANDOM_MID = t.block_random_mid;

                Blockly.Msg.BLOCK_FOREVER = t.block_forever;
                Blockly.Msg.BLOCK_IF = t.block_if;
                Blockly.Msg.BLOCK_THEN = t.block_then;
                Blockly.Msg.BLOCK_ELSE = t.block_else;

                Blockly.Msg.BLOCK_WAIT_UNTIL_PRE = t.block_wait_until_pre;
                Blockly.Msg.BLOCK_WAIT_UNTIL_POST = t.block_wait_until_post;

                Blockly.Msg.BLOCK_REPEAT_UNTIL_PRE = t.block_repeat_until_pre;
                Blockly.Msg.BLOCK_REPEAT_UNTIL_POST = t.block_repeat_until_post;

                Blockly.Msg.BLOCK_WHEN_PRE = t.block_when_pre;
                Blockly.Msg.BLOCK_WHEN_POST = t.block_when_post;
                Blockly.Msg.BLOCK_MESSAGE_PRE = t.block_message_pre;
                Blockly.Msg.BLOCK_MESSAGE_POST = t.block_message_post;
                Blockly.Msg.BLOCK_SEND_MOBILE_PRE = t.block_send_mobile_pre;
                Blockly.Msg.BLOCK_SEND_MOBILE_POST = t.block_send_mobile_post;

                Blockly.Msg.BLOCK_LIGHT_GET_PRE = t.block_light_get_pre;
                Blockly.Msg.BLOCK_LIGHT_GET_POST = t.block_light_get_post;

                Blockly.Msg.BLOCK_RED_ON = t.block_red_light_on;
                Blockly.Msg.BLOCK_RED_OFF = t.block_red_light_off;
                Blockly.Msg.BLOCK_GREEN_ON = t.block_green_light_on;
                Blockly.Msg.BLOCK_GREEN_OFF = t.block_green_light_off;
                Blockly.Msg.BLOCK_BLUE_ON = t.block_blue_light_on;
                Blockly.Msg.BLOCK_BLUE_OFF = t.block_blue_light_off;

                Blockly.Msg.BLOCK_RED_NUM = t.block_red_num;
                Blockly.Msg.BLOCK_GREEN_NUM = t.block_green_num;
                Blockly.Msg.BLOCK_BLUE_NUM = t.block_blue_num;
                Blockly.Msg.BLOCK_RED_GET = t.block_red_get;
                Blockly.Msg.BLOCK_GREEN_GET = t.block_green_get;
                Blockly.Msg.BLOCK_BLUE_GET = t.block_blue_get;

                Blockly.Msg.BLOCK_RED_BTN_GET = t.block_rgb_red_btn_get;
                Blockly.Msg.BLOCK_GREEN_BTN_GET = t.block_rgb_green_btn_get;
                Blockly.Msg.BLOCK_BLUE_BTN_GET = t.block_rgb_blue_btn_get;

                Blockly.Msg.BLOCK_LOGIC_AND = t.block_logic_and;
                Blockly.Msg.BLOCK_LOGIC_OR = t.block_logic_or;
                Blockly.Msg.BLOCK_LOGIC_NOT = t.block_logic_not;
            }

            // Refresh Toolboxes if active
            if (typeof showStartToolbox !== 'undefined') {
                if (currentToolboxMode === 'start') showStartToolbox();
                else if (currentToolboxMode === 'control') showControlToolbox();
                else if (currentToolboxMode === 'action_led') showActionLedToolbox();
                else if (currentToolboxMode === 'action_num') showActionNumToolbox();
                else if (currentToolboxMode === 'action_button') showActionButtonToolbox();
                else if (currentToolboxMode === 'operator') showOperatorToolbox();

                if (workspace) {
                    const xml = Blockly.Xml.workspaceToDom(workspace);
                    workspace.clear();
                    Blockly.Xml.domToWorkspace(xml, workspace);
                }
            }
        }

        function updateControllerVisual() {
            const leftValue = controllerState.leftValue;
            const rightValue = controllerState.rightValue;

            const leftPercent = calculateLeverPercent(leftValue);
            const rightPercent = calculateLeverPercent(rightValue);

            // controllerState'e y√ºzdelikleri kaydet
            controllerState.leftPercent = Math.round(leftPercent);
            controllerState.rightPercent = Math.round(rightPercent);

            // Sol kol
            const leftFill = document.getElementById('leftLeverFill');
            const leftValueEl = document.getElementById('leftLeverValue');
            if (leftFill && leftValueEl) {
                leftFill.style.height = Math.round(leftPercent) + '%';
                leftValueEl.textContent = Math.round(leftPercent) + '%';
            }

            // Saƒü kol
            const rightFill = document.getElementById('rightLeverFill');
            const rightValueEl = document.getElementById('rightLeverValue');
            if (rightFill && rightValueEl) {
                rightFill.style.height = Math.round(rightPercent) + '%';
                rightValueEl.textContent = Math.round(rightPercent) + '%';
            }
        }

        function showControllerDisplay(deviceName, deviceColor) {
            // hideMotorDisplay(); // ARTIK Gƒ∞ZLEMƒ∞YORUZ - Side by side
            const display = document.getElementById('controllerDisplay');
            const header = document.getElementById('controllerHeader');

            if (display) {
                display.classList.add('active');
            }

            if (header) {
                header.textContent = deviceName || 'Controller';
                header.style.background = deviceColor || '#4C97FF';
            }
        }

        function hideControllerDisplay() {
            const display = document.getElementById('controllerDisplay');
            if (display) {
                display.classList.remove('active');
            }
        }

        function showMotorDisplay(device, color, displayName = null) {
            // hideControllerDisplay(); // ARTIK Gƒ∞ZLEMƒ∞YORUZ - Side by side
            const display = document.getElementById('motorDisplay');
            const header = document.getElementById('motorHeader');
            const info = document.getElementById('motorAngleInfo');
            const shaft = document.getElementById('motorShaft');

            if (display && header) {
                header.style.background = color || '#4ecca3';
                header.textContent = displayName || device.name || 'Single Motor';
                display.classList.add('active');

                // Reset visual
                if (shaft) shaft.style.transform = `rotate(0deg)`;
                if (info) info.innerText = "0¬∞";
            }
        }

        function hideMotorDisplay() {
            const display = document.getElementById('motorDisplay');
            if (display) display.classList.remove('active');
        }

        // ===== COLOR SENSOR DISPLAY FUNCTIONS =====
        function showColorSensorDisplay(device, color) {
            const display = document.getElementById('colorSensorDisplay');
            const header = document.getElementById('colorSensorHeader');

            if (display && header) {
                header.style.background = color || '#9B59B6';
                header.textContent = device.name || 'Color Sensor';
                display.classList.add('active');

                // Reset to no color state
                updateColorSensorVisual('NONE', 0, 0);
            }
        }

        function hideColorSensorDisplay() {
            const display = document.getElementById('colorSensorDisplay');
            if (display) display.classList.remove('active');
        }

        function updateColorSensorVisual(colorName, reflection, hue) {
            const circle = document.getElementById('colorSensorCircle');
            const label = document.getElementById('colorSensorLabel');
            const details = document.getElementById('colorSensorDetails');
            const noColorIcon = document.getElementById('noColorIcon');

            if (!circle || !label || !details) return;

            // T√ºm renk sƒ±nƒ±flarƒ±nƒ± temizle
            circle.className = 'color-sensor-circle';

            // Renk isimlerini T√ºrk√ße'ye √ßevir
            const colorNamesTR = {
                'NONE': 'Renk Yok',
                'RED': 'Kƒ±rmƒ±zƒ±',
                'YELLOW': 'Sarƒ±',
                'BLUE': 'Mavi',
                'GREEN': 'Ye≈üil',
                'PURPLE': 'Mor',
                'CYAN': 'A√ßƒ±k Mavi',
                'WHITE': 'Beyaz'
            };

            if (colorName === 'NONE' || !colorName) {
                circle.classList.add('no-color');
                if (noColorIcon) noColorIcon.style.display = 'block';
                label.textContent = colorNamesTR['NONE'];
                label.style.color = '#888';
            } else {
                circle.classList.add('color-' + colorName.toLowerCase());
                if (noColorIcon) noColorIcon.style.display = 'none';
                label.textContent = colorNamesTR[colorName] || colorName;

                // Label rengini ayarla
                const labelColors = {
                    'RED': '#CC0000',
                    'YELLOW': '#B8860B',
                    'BLUE': '#0052CC',
                    'GREEN': '#009900',
                    'PURPLE': '#7D3C98',
                    'CYAN': '#0097A7',
                    'WHITE': '#666666'
                };
                label.style.color = labelColors[colorName] || '#333';
            }

            // Detay bilgilerini g√ºncelle
            const reflectionStr = reflection !== undefined ? reflection + '%' : '--%';
            const hueStr = hue !== undefined ? hue + '¬∞' : '--¬∞';
            details.textContent = `Reflection: ${reflectionStr} | Hue: ${hueStr}`;

            // State'i g√ºncelle
            colorSensorState.detectedColor = colorName;
            colorSensorState.reflection = reflection || 0;
            colorSensorState.hue = hue || 0;
        }

        // Color Sensor notification handler
        function handleColorSensorNotification(event) {
            const value = event.target.value;

            if (value.byteLength < 8) return;

            const data = new Uint8Array(value.buffer);

            // RAW VERƒ∞Yƒ∞ CONSOLE'A YAZDIR (Debug i√ßin devre dƒ±≈üƒ±)
            // const hexString = Array.from(data).map(b => b.toString(16).padStart(2, '0')).join(' ');
            // console.log(`üé® [Color Sensor RAW] (${data.length} bytes): ${hexString}`);

            // Paket yapƒ±sƒ± (19 bytes):
            // [0-3]: 3c 10 00 00 - Header
            // [4]: BATTERY - Batarya y√ºzdesi (5a = 90%)
            // [5]: 00
            // [6]: 0c - Sabit marker
            // [7]: COLOR CODE - RENK KODU!
            //      02=Mor, 03=Mavi, 05=Cyan, 06=Ye≈üil, 07=Sarƒ±, 09=Kƒ±rmƒ±zƒ±, 0a=Beyaz, ff=Yok
            // [8-18]: Diƒüer sens√∂r verileri (reflection, RGB vs.)

            let colorIndex = 0;
            let reflection = 0;
            let battery = 0;

            // Batarya deƒüeri Index 4'te
            if (data.length >= 5) {
                battery = data[4];
            }

            // Index 6'da 0x0c marker'ƒ± kontrol et
            if (data.length >= 8 && data[6] === 0x0c) {
                colorIndex = data[7];

                // Reflection deƒüeri (Index 8 olabilir)
                if (data.length >= 10) {
                    reflection = data[8];
                }
            }

            // Batarya g√∂stergesini g√ºncelle
            if (battery > 0 && battery <= 100) {
                updateColorSensorBattery(battery);
            }

            // Renk indeksini isme √ßevir
            const colorName = COLOR_INDEX_MAP[colorIndex] || 'NONE';

            // G√∂rsel g√ºncelle (throttle)
            const now = Date.now();
            if (now - lastVisualUpdate > VISUAL_UPDATE_INTERVAL) {
                lastVisualUpdate = now;

                // Renk deƒüi≈üimi kontrol√º (√ñNCE kontrol et, SONRA g√ºncelle)
                const colorChanged = colorSensorState.detectedColor !== colorName;

                // G√∂rseli g√ºncelle
                updateColorSensorVisual(colorName, reflection, 0);

                // Eƒüer renk deƒüi≈ütiyse
                if (colorChanged) {
                    console.log(`üé® Color Sensor: ${colorName} (index: ${colorIndex}, battery: ${battery}%)`);

                    // Event bloklarƒ±nƒ± tetikle (renk deƒüi≈ütiƒüinde)
                    triggerColorEvents(colorName);
                }
            }
        }

        // Color Sensor batarya g√∂stergesini g√ºncelle
        function updateColorSensorBattery(percent) {
            const batteryFill = document.getElementById('colorSensorBatteryFill');
            const batteryPercent = document.getElementById('colorSensorBatteryPercent');
            const batteryInfo = document.getElementById('colorSensorBatteryInfo');

            if (batteryPercent) {
                batteryPercent.textContent = percent + '%';
            }

            if (batteryFill) {
                // Batarya doluluk geni≈üliƒüi (max 14px)
                const fillWidth = Math.round((percent / 100) * 14);
                batteryFill.setAttribute('width', fillWidth);
            }

            if (batteryInfo) {
                // Renk ayarla
                let color = '#37b24d'; // Ye≈üil
                if (percent <= 20) {
                    color = '#ff4444'; // Kƒ±rmƒ±zƒ±
                } else if (percent <= 40) {
                    color = '#ffa500'; // Turuncu
                }
                batteryInfo.style.color = color;
            }
        }

        async function startColorSensorMonitoring(device, notifyChar, deviceId, deviceColor) {
            console.log('üé® Color Sensor monitoring ba≈ülatƒ±lƒ±yor...');

            colorSensorState.deviceId = deviceId;

            try {
                // Notification'larƒ± ba≈ülat
                await notifyChar.startNotifications();
                console.log('‚úÖ Color Sensor notifications ba≈ülatƒ±ldƒ±');

                // Event listener ekle
                notifyChar.addEventListener('characteristicvaluechanged', handleColorSensorNotification);

                console.log('‚úÖ Color Sensor monitoring aktif!');

            } catch (err) {
                console.error('‚ùå Color Sensor notification ba≈ülatma hatasƒ±:', err);
            }
        }

        // ===== SPIKE ESSENTIAL HUB DISPLAY FUNCTIONS =====
        // Hub state tracking
        // Hub state tracking
        const spikeHubState = {
            deviceId: null,
            writeChar: null,
            notifyChar: null,
            // Matrix State: Stores current pixels and brightness (0-10) for each port
            matrix: {
                A: { pixels: [0, 0, 0, 0, 0, 0, 0, 0, 0], brightness: 10 },
                B: { pixels: [0, 0, 0, 0, 0, 0, 0, 0, 0], brightness: 10 }
            },
            battery: 0,
            hubColor: 0,
            portA: { connected: false, type: null, typeName: 'Empty' },
            portB: { connected: false, type: null, typeName: 'Empty' },
            gyro: { x: 0, y: 0, z: 0 },
            accel: { x: 0, y: 0, z: 0 },
            tilt: 0,
            tiltName: '--'
        };

        // IO Type names
        const IO_TYPE_NAMES = {
            0x0017: 'RGB Light',
            0x0039: 'Gyroscope',
            0x003A: 'Accelerometer',
            0x003B: 'Tilt Sensor',
            0x003D: 'Color Sensor',
            0x003E: 'Distance Sensor',
            0x003F: 'Force Sensor',
            0x0040: 'Color Light Matrix',
            0x004B: 'Small Motor',
            0x0060: 'Light Matrix'
        };

        // LEGO Hub LED Color Index
        const LEGO_COLORS = {
            0: { name: 'Off', hex: '#333333' },
            1: { name: 'Pink', hex: '#FF69B4' },
            2: { name: 'Purple', hex: '#9932CC' },
            3: { name: 'Blue', hex: '#0000FF' },
            4: { name: 'Light Blue', hex: '#00BFFF' },
            5: { name: 'Cyan', hex: '#00FFFF' },
            6: { name: 'Green', hex: '#00FF00' },
            7: { name: 'Yellow', hex: '#FFFF00' },
            8: { name: 'Orange', hex: '#FFA500' },
            9: { name: 'Red', hex: '#FF0000' },
            10: { name: 'White', hex: '#FFFFFF' }
        };

        // Tilt orientation names and icons
        const TILT_ORIENTATIONS = {
            0: { name: 'Bottom', icon: '‚¨áÔ∏è' },
            1: { name: 'Front', icon: '‚¨ÜÔ∏è' },
            2: { name: 'Back', icon: '‚Ü©Ô∏è' },
            3: { name: 'Right', icon: '‚û°Ô∏è' },
            4: { name: 'Left', icon: '‚¨ÖÔ∏è' },
            5: { name: 'Top', icon: '‚¨ÜÔ∏è' }
        };

        function showSpikeEssentialDisplay(device, color, displayName = null) {
            const display = document.getElementById('spikeEssentialDisplay');
            const header = document.getElementById('spikeEssentialHeader');

            if (display && header) {
                header.style.background = color || '#F5A623';
                header.textContent = displayName || device.name || 'Spike Essential Hub';
                display.classList.add('active');

                // Reset display values
                updateSpikeHubBattery(0);
                updateSpikePortStatus('A', null);
                updateSpikePortStatus('B', null);
            }
        }

        function hideSpikeEssentialDisplay() {
            const display = document.getElementById('spikeEssentialDisplay');
            if (display) display.classList.remove('active');
        }

        function updateSpikeHubBattery(percent) {
            spikeHubState.battery = percent;
            const percentEl = document.getElementById('spikeEssentialBatteryPercent');
            const fillEl = document.getElementById('spikeEssentialBatteryFill');
            const infoEl = document.getElementById('spikeEssentialBatteryInfo');

            if (percentEl) percentEl.textContent = percent + '%';
            if (fillEl) fillEl.setAttribute('width', Math.round(14 * percent / 100));
            if (infoEl) {
                if (percent > 50) infoEl.style.color = '#37b24d';
                else if (percent > 20) infoEl.style.color = '#f59f00';
                else infoEl.style.color = '#e03131';
            }
        }

        function updateSpikePortStatus(port, ioType) {
            const portState = port === 'A' ? spikeHubState.portA : spikeHubState.portB;
            const statusEl = document.getElementById(`spikePort${port}Status`);

            if (ioType === null) {
                portState.connected = false;
                portState.type = null;
                portState.typeName = 'Empty';
            } else {
                portState.connected = true;
                portState.type = ioType;
                portState.typeName = IO_TYPE_NAMES[ioType] || `Type ${ioType.toString(16)}`;
            }

            if (statusEl) {
                statusEl.textContent = portState.typeName;
                statusEl.className = 'spike-hub-port-status' + (portState.connected ? ' connected' : '');
            }
        }

        function updateSpikeGyro(x, y, z) {
            spikeHubState.gyro = { x, y, z };
            const el = document.getElementById('spikeGyroValue');
            if (el) el.textContent = `X:${x} Y:${y} Z:${z}`;
        }

        function updateSpikeAccel(x, y, z) {
            spikeHubState.accel = { x, y, z };
            const el = document.getElementById('spikeAccelValue');
            if (el) el.textContent = `X:${x} Y:${y} Z:${z}`;
        }

        function updateSpikeTilt(yaw, pitch, roll) {
            spikeHubState.tilt = { yaw, pitch, roll };
            spikeHubState.tiltName = `Y:${yaw} P:${pitch} R:${roll}`;

            // Determine icon based on dominant tilt
            let icon = '‚¨õ';
            if (Math.abs(pitch) > 30) icon = pitch > 0 ? '‚¨ÜÔ∏è' : '‚¨áÔ∏è';
            else if (Math.abs(roll) > 30) icon = roll > 0 ? '‚û°Ô∏è' : '‚¨ÖÔ∏è';
            else icon = 'üîò';

            const iconEl = document.getElementById('spikeTiltIcon');
            const valueEl = document.getElementById('spikeTiltValue');
            if (iconEl) iconEl.textContent = icon;
            if (valueEl) valueEl.textContent = `Y:${yaw}¬∞ P:${pitch}¬∞ R:${roll}¬∞`;
        }

        function updateSpikeHubColor(colorIndex) {
            spikeHubState.hubColor = colorIndex;
            const colorData = LEGO_COLORS[colorIndex] || { name: `Color ${colorIndex}`, hex: '#888888' };

            // Update the header with a color indicator
            const header = document.getElementById('spikeEssentialHeader');
            if (header) {
                // Add/update color indicator dot
                let colorDot = document.getElementById('spikeHubColorDot');
                if (!colorDot) {
                    colorDot = document.createElement('span');
                    colorDot.id = 'spikeHubColorDot';
                    colorDot.style.cssText = 'display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-left: 8px; border: 2px solid rgba(255,255,255,0.5); vertical-align: middle;';
                    header.appendChild(colorDot);
                }
                colorDot.style.background = colorData.hex;
                colorDot.title = colorData.name;
            }
        }

        let lastExternalPortLog = 0;
        const externalPortData = { portA: null, portB: null };

        function handleSpikeHubNotification(event) {
            const value = event.target.value;
            if (value.byteLength < 3) return;

            const data = new Uint8Array(value.buffer);
            const msgType = data[2];

            // Hub Property (0x01)
            if (msgType === 0x01 && data.length > 5) {
                const property = data[3];
                // Property 0x01 = Advertising Name
                if (property === 0x01) {
                    let name = "";
                    for (let i = 5; i < data.length; i++) {
                        if (data[i] === 0) break;
                        name += String.fromCharCode(data[i]);
                    }
                    if (name) {
                        console.log("üè∑Ô∏è Hub Adƒ± G√ºncellendi:", name);

                        // Update Panel Header
                        const header = document.getElementById('spikeEssentialHeader');
                        if (header) {
                            // Keep the status circle
                            const statusCircle = header.querySelector('.status-circle');
                            header.textContent = name + ' ';
                            if (statusCircle) header.appendChild(statusCircle);
                        }

                        // Update Connected Device List
                        const device = connectedDevices.find(d => d.id === spikeHubState.deviceId);
                        if (device) {
                            device.name = name;
                            updateDevicesTable();
                        }

                        // Update Nickname Input if not focused
                        const nameInput = document.getElementById('spikeHubNicknameInput');
                        if (nameInput && document.activeElement !== nameInput) {
                            nameInput.value = name;
                        }
                    }
                }
            }

            // Port Output Command Feedback (0x82)
            if (msgType === 0x82) {
                console.log("‚Ü©Ô∏è CMD Feedback:", [...data].map(b => b.toString(16).padStart(2, '0')).join(' '));
            }

            // Port Mode Information (0x44)
            if (msgType === 0x44 && data.length >= 6) {
                const port = data[3];
                const mode = data[4];
                const infoType = data[5];

                // Mode Name (0x00)
                if (infoType === 0x00) {
                    let name = "";
                    for (let i = 6; i < data.length; i++) {
                        if (data[i] === 0) break;
                        name += String.fromCharCode(data[i]);
                    }
                    console.log(`‚ÑπÔ∏è Mode ${mode} Name: ${name}`);
                }
                // Mode Format (0x80)
                else if (infoType === 0x80) {
                    const numValues = data[6];
                    const dataType = data[7]; // 0=8bit, 1=16bit...
                    console.log(`‚ÑπÔ∏è Mode ${mode} Format: ${numValues} values, Type=${dataType}`);
                }
            }

            // Hub Attached I/O (0x04)
            if (msgType === 0x04 && data.length >= 5) {
                const portId = data[3];
                const attachEvent = data[4];

                if (portId === 0x00 || portId === 0x01) {
                    const portLetter = portId === 0x00 ? 'A' : 'B';

                    if (attachEvent === 0x00) {
                        // Detached
                        console.log(`üîå Port ${portLetter}: Detached`);
                        updateSpikePortStatus(portLetter, null);
                        if (portLetter === 'A') externalPortData.portA = null;
                        else externalPortData.portB = null;
                    } else if (attachEvent === 0x01 && data.length >= 7) {
                        // Attached
                        const ioType = data[5] | (data[6] << 8);
                        console.log(`üîå Port ${portLetter}: Attached, IO Type: 0x${ioType.toString(16)} (${ioType})`);
                        updateSpikePortStatus(portLetter, ioType);

                        // Subscribe to the attached device
                        if (spikeHubState.writeChar) {
                            subscribeToExternalPort(spikeHubState.writeChar, portId, ioType);
                        }
                    }
                }
            }

            // Port Value (0x45) - Sensor data
            if (msgType === 0x45 && data.length >= 4) {
                const portId = data[3];

                // External Port A (0x00) or Port B (0x01)
                if (portId === 0x00 || portId === 0x01) {
                    const portLetter = portId === 0x00 ? 'A' : 'B';

                    // Force Sensor (0x003F) - value is in decinewtons, divide by 10
                    if (data.length >= 5) {
                        const portState = portLetter === 'A' ? spikeHubState.portA : spikeHubState.portB;
                        if (portState.type === 0x003F) { // Force Sensor
                            const forceRaw = data[4];
                            // Store raw value (0-100 decinewtons) in state for blocks to use
                            portState.value = forceRaw;

                            const forceN = (forceRaw / 10).toFixed(1);
                            const statusEl = document.getElementById(`spikePort${portLetter}Status`);
                            if (statusEl) statusEl.textContent = `Force: ${forceN}N`;
                        }
                    }
                }

                // Voltage Sensor (Port 0x3C = 60) - Battery
                if (portId === 0x3C && data.length >= 6) {
                    const rawValue = data[4] | (data[5] << 8);
                    const percent = Math.min(100, Math.max(0, Math.round(rawValue / 47)));
                    updateSpikeHubBattery(percent);
                }

                // RGB Status Light (Port 0x31 = 49) - Color index
                if (portId === 0x31 && data.length >= 5) {
                    const colorIndex = data[4];
                    updateSpikeHubColor(colorIndex);
                }

                // Gyroscope (Port 0x61 = 97) - 6 bytes: 3x int16
                if (portId === 0x61 && data.length >= 10) {
                    const x = new DataView(data.buffer).getInt16(4, true);
                    const y = new DataView(data.buffer).getInt16(6, true);
                    const z = new DataView(data.buffer).getInt16(8, true);
                    updateSpikeGyro(x, y, z);
                }

                // Accelerometer (Port 0x62 = 98) - 6 bytes: 3x int16
                if (portId === 0x62 && data.length >= 10) {
                    const x = new DataView(data.buffer).getInt16(4, true);
                    const y = new DataView(data.buffer).getInt16(6, true);
                    const z = new DataView(data.buffer).getInt16(8, true);
                    updateSpikeAccel(x, y, z);
                }

                // Tilt (Port 0x63 = 99) - 6 bytes: Yaw, Pitch, Roll as int16
                if (portId === 0x63 && data.length >= 10) {
                    const yaw = new DataView(data.buffer).getInt16(4, true);
                    const pitch = new DataView(data.buffer).getInt16(6, true);
                    const roll = new DataView(data.buffer).getInt16(8, true);
                    updateSpikeTilt(yaw, pitch, roll);
                }
            }
        }

        // Subscribe to external port device
        async function subscribeToExternalPort(writeChar, portId, ioType) {
            if (!writeChar) return;
            try {
                await new Promise(r => setTimeout(r, 100));
                // Port Input Format Setup (0x41): [Length] [0x00] [0x41] [PortID] [Mode=0] [Delta:4bytes] [Enable=1]
                await writeChar.writeValueWithoutResponse(new Uint8Array([0x0A, 0x00, 0x41, portId, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01]));
                const portLetter = portId === 0x00 ? 'A' : 'B';
                console.log(`‚úÖ Port ${portLetter} subscription sent (IO Type: 0x${ioType.toString(16)})`);
            } catch (e) {
                console.error('‚ùå External port subscription error:', e);
            }
        }

        // Subscribe to sensor notifications
        async function subscribeSpikeHubSensors(writeChar) {
            if (!writeChar) return;

            try {
                // Port Input Format Setup (0x41): Subscribe to sensor data
                // Format: [Length] [0x00] [0x41] [PortID] [Mode] [Delta:4bytes] [Enable]

                // Subscribe to Voltage Sensor (0x3C) for battery
                await writeChar.writeValueWithoutResponse(new Uint8Array([0x0A, 0x00, 0x41, 0x3C, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01]));
                await new Promise(r => setTimeout(r, 50));

                // Subscribe to Gyroscope (0x61)
                await writeChar.writeValueWithoutResponse(new Uint8Array([0x0A, 0x00, 0x41, 0x61, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01]));
                await new Promise(r => setTimeout(r, 50));

                // Subscribe to Accelerometer (0x62)
                await writeChar.writeValueWithoutResponse(new Uint8Array([0x0A, 0x00, 0x41, 0x62, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01]));
                await new Promise(r => setTimeout(r, 50));

                // Subscribe to Tilt (0x63)
                await writeChar.writeValueWithoutResponse(new Uint8Array([0x0A, 0x00, 0x41, 0x63, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01]));
                await new Promise(r => setTimeout(r, 50));

                // Subscribe to RGB Status Light (0x31) for LED color
                await writeChar.writeValueWithoutResponse(new Uint8Array([0x0A, 0x00, 0x41, 0x31, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01]));

                console.log('‚úÖ Spike Hub sensor subscriptions sent');
            } catch (e) {
                console.error('‚ùå Spike Hub sensor subscription error:', e);
            }
        }

        async function startSpikeHubMonitoring(device, notifyChar, writeChar, deviceColor, friendlyName) {
            console.log('üîå Spike Essential Hub monitoring ba≈ülatƒ±lƒ±yor...');

            spikeHubState.deviceId = device.id;
            spikeHubState.notifyChar = notifyChar;
            spikeHubState.writeChar = writeChar;

            try {
                // Start notifications
                await notifyChar.startNotifications();
                console.log('‚úÖ Spike Hub notifications ba≈ülatƒ±ldƒ±');

                // Add event listener
                notifyChar.addEventListener('characteristicvaluechanged', handleSpikeHubNotification);

                // Show display
                showSpikeEssentialDisplay(device, deviceColor, friendlyName);

                // Subscribe to sensors after a short delay
                await new Promise(r => setTimeout(r, 200));
                await subscribeSpikeHubSensors(writeChar);

                console.log('‚úÖ Spike Essential Hub monitoring aktif!');

            } catch (err) {
                console.error('‚ùå Spike Hub notification ba≈ülatma hatasƒ±:', err);
            }
        }

        // Motor notification verisi formatƒ±:
        // Payload[7] = mode byte (0x00=idle, 0x01=moving, 0x07=holding)
        // Payload[8-9] = Anlƒ±k a√ßƒ± (little-endian signed 16-bit)
        // Payload[13-14] = Hedef a√ßƒ± (little-endian signed 16-bit)

        async function startMotorAngleMonitoring(device, notifyChar, deviceId, deviceColor) {
            console.log('‚öôÔ∏è Motor a√ßƒ± monitoring ba≈ülatƒ±lƒ±yor...');

            activeMotorDevice = device;
            activeMotorCharacteristic = notifyChar;
            motorState.deviceId = deviceId;
            motorMonitoringActive = true;

            try {
                // Notification'larƒ± ba≈ülat
                await notifyChar.startNotifications();
                console.log('‚úÖ Motor notifications ba≈ülatƒ±ldƒ±');

                // Event listener ekle
                notifyChar.addEventListener('characteristicvaluechanged', handleMotorNotification);

                console.log('‚úÖ Motor angle monitoring aktif!');

            } catch (err) {
                console.error('‚ùå Motor notification ba≈ülatma hatasƒ±:', err);
                motorMonitoringActive = false;
            }
        }

        function handleMotorNotification(event) {
            const value = event.target.value;

            // Minimum byte gereksinimi
            if (value.byteLength < 4) {
                return;
            }

            // RAW HEX DUMP (Debug i√ßin devre dƒ±≈üƒ±)
            // const bytes = new Uint8Array(value.buffer);
            // const hexDump = [...bytes].map(b => b.toString(16).padStart(2, '0')).join(' ');
            // if (!handleMotorNotification.logCount) handleMotorNotification.logCount = 0;
            // if (handleMotorNotification.logCount < 20) {
            //     console.log(`üì¶ Motor RAW [${value.byteLength} bytes]: ${hexDump}`);
            //     handleMotorNotification.logCount++;
            // }

            let currentAngle = 0;
            let targetAngle = 0;
            let mode = 0;

            // PCAP ANALƒ∞Zƒ∞ sonucu (21 byte paket):
            // 90¬∞:  3c 12 00 00 5a 00 0a 01 07 [5a] 00 00 00 00 5a 00 00 00 11 01 ff
            // 240¬∞: 3c 12 00 00 5a 00 0a 01 07 [f0] 00 00 00 00 ef 00 00 00 11 01 ff
            // Index 9 = Mevcut a√ßƒ± (0x5a=90, 0xf0=240)
            // Index 14 = Hedef a√ßƒ± (yakla≈üƒ±k)
            // Index 8 = Mode byte (0x07 = holding)

            if (value.byteLength >= 15) {
                // Mode byte at index 8
                mode = value.getUint8(8);

                // A√ßƒ± index 9-10'da (little-endian int16 olarak deneyelim √∂nce)
                // Eƒüer 360'tan b√ºy√ºk deƒüerler varsa int16 kullan
                const angleInt16 = value.getInt16(9, true);
                const angleUint8 = value.getUint8(9);

                // 360'tan k√º√ß√ºkse uint8, b√ºy√ºkse int16 kullan
                if (Math.abs(angleInt16) > 360 && angleUint8 <= 255) {
                    // Muhtemelen tek byte
                    currentAngle = angleUint8;
                } else {
                    // int16 olarak dene
                    currentAngle = angleInt16;
                }

                // Hedef a√ßƒ± index 14-15
                if (value.byteLength >= 16) {
                    targetAngle = value.getInt16(14, true);
                    // Aynƒ± mantƒ±k
                    if (Math.abs(targetAngle) > 360) {
                        targetAngle = value.getUint8(14);
                    }
                }
            }
            // Daha kƒ±sa paketler i√ßin fallback
            else if (value.byteLength >= 10) {
                currentAngle = value.getUint8(9);
            }

            // State g√ºncelle
            const prevAngle = motorState.currentAngle;
            motorState.currentAngle = currentAngle;
            motorState.targetAngle = targetAngle;
            motorState.mode = mode;
            motorState.isMoving = (mode === 0x01);

            // Pil y√ºzdesini al (index 4)
            let batteryPercent = 0;
            if (value.byteLength >= 5) {
                batteryPercent = value.getUint8(4);
                // 0-100 arasƒ±na normalize et (bazƒ± cihazlar farklƒ± aralƒ±k kullanabilir)
                if (batteryPercent > 100) {
                    // Belki 0-255 aralƒ±ƒüƒ±nda, y√ºzdeye √ßevir
                    batteryPercent = Math.round((batteryPercent / 255) * 100);
                }
                motorState.battery = batteryPercent;
            }

            // G√∂rsel g√ºncelleme (throttled)
            const now = Date.now();
            if (now - motorLastVisualUpdate >= MOTOR_VISUAL_UPDATE_INTERVAL) {
                motorLastVisualUpdate = now;
                updateMotorAngleDisplay(currentAngle);

                // Pil g√∂stergesini g√ºncelle
                const batteryEl = document.getElementById('motorBatteryPercent');
                const batteryFill = document.getElementById('motorBatteryFill');
                if (batteryEl) {
                    batteryEl.textContent = `${batteryPercent}%`;

                    // Pil doluluk g√∂stergesini g√ºncelle (max geni≈ülik: 14px)
                    if (batteryFill) {
                        const fillWidth = Math.round((batteryPercent / 100) * 14);
                        batteryFill.setAttribute('width', fillWidth);
                    }

                    // Pil d√º≈ü√ºkse rengi deƒüi≈ütir
                    if (batteryPercent < 20) {
                        batteryEl.parentElement.style.color = '#e03131';
                    } else if (batteryPercent < 50) {
                        batteryEl.parentElement.style.color = '#fab005';
                    } else {
                        batteryEl.parentElement.style.color = '#37b24d';
                    }
                }
            }

            // Debug log (sadece deƒüi≈üiklik varsa)
            if (Math.abs(prevAngle - currentAngle) > 1) {
                console.log(`‚öôÔ∏è Motor: ${currentAngle}¬∞ (hedef: ${targetAngle}¬∞, mode: 0x${mode.toString(16)})`);
            }
        }

        function updateMotorAngleDisplay(angle) {
            const shaft = document.getElementById('motorShaft');
            const info = document.getElementById('motorAngleInfo');

            if (shaft) {
                // G√∂rsel d√∂n√º≈ü i√ßin tam a√ßƒ±yƒ± kullanabiliriz (animasyon varsa d√ºzg√ºn d√∂ner)
                shaft.style.transform = `rotate(${angle}deg)`;
            }

            if (info) {
                // Metin g√∂sterimi i√ßin 0-359 arasƒ±na normalize et
                // ((angle % 360) + 360) % 360 form√ºl√º negatif sayƒ±larƒ± da doƒüru i≈üler
                const normalizedAngle = Math.round(((angle % 360) + 360) % 360);
                info.textContent = `${normalizedAngle}¬∞`;
            }
        }

        function stopMotorAngleMonitoring() {
            if (activeMotorCharacteristic) {
                try {
                    activeMotorCharacteristic.removeEventListener('characteristicvaluechanged', handleMotorNotification);
                    activeMotorCharacteristic.stopNotifications();
                } catch (e) {
                    console.log('Motor notification durdurma hatasƒ±:', e);
                }
            }

            motorMonitoringActive = false;
            activeMotorDevice = null;
            activeMotorCharacteristic = null;
            motorState.deviceId = null;

            console.log('‚öôÔ∏è Motor angle monitoring durduruldu');
        }

        // Motor a√ßƒ±sƒ±nƒ± al (bloklar i√ßin)
        function getMotorAngle(deviceId) {
            if (motorState.deviceId === deviceId) {
                return motorState.currentAngle;
            }
            return 0;
        }

        // Global'e ekle
        window.getMotorAngle = getMotorAngle;
        window.motorState = motorState;

        // RGB Display g√ºncelleme fonksiyonlarƒ±
        function updateRGBDisplay() {
            const redLed = document.getElementById('rgbRedLed');
            const greenLed = document.getElementById('rgbGreenLed');
            const blueLed = document.getElementById('rgbBlueLed');

            if (redLed) {
                redLed.classList.toggle('active', rgbLedState.red);
            }
            if (greenLed) {
                greenLed.classList.toggle('active', rgbLedState.green);
            }
            if (blueLed) {
                blueLed.classList.toggle('active', rgbLedState.blue);
            }
        }

        function updateRGBNumberDisplay() {
            const redNum = document.getElementById('rgbRedNum');
            const greenNum = document.getElementById('rgbGreenNum');
            const blueNum = document.getElementById('rgbBlueNum');

            if (redNum) redNum.textContent = rgbNumberState.red;
            if (greenNum) greenNum.textContent = rgbNumberState.green;
            if (blueNum) blueNum.textContent = rgbNumberState.blue;
        }

        // T√ºm a√ßƒ±k pop-up panelleri kapatƒ±r
        function closeAllPopups() {
            closeNumberPanel();
            closeAnglePanel();
            closeMessagePanel();
        }

        // Custom Angle Field (A√ßƒ± se√ßici)
        class CustomAngleField extends Blockly.FieldNumber {
            showEditor_() {
                closeAllPopups(); // √ñnce diƒüerlerini kapat
                const fieldRect = this.getScaledBBox();
                const panel = document.getElementById('anglePanel');

                currentAngle = parseInt(this.getValue()) || 0;
                currentAngleField = this;

                updateAngleDisplay();

                panel.style.left = (fieldRect.right + 10) + 'px';
                panel.style.top = fieldRect.top + 'px';
                panel.classList.add('active');

                // A√ßƒ± dairesi interaksiyonunu kur
                setTimeout(() => {
                    setupAngleCircleInteraction();
                }, 50);

                document.addEventListener('click', closeAnglePanelOnClickOutside);
            }
        }

        // Custom Message Field with Dropdown
        class CustomMessageField extends Blockly.FieldDropdown {
            constructor(value) {
                // Etiketin sonuna bo≈üluk ekle ki ok i≈üareti √ºst√ºne binmesin
                const options = messages.map(m => [m + '   ', m]);
                options.push(['‚ûï Yeni mesaj...', 'NEW']);
                super(options);
                this.setValue(value || messages[0]);
            }

            doValueUpdate_(newValue) {
                super.doValueUpdate_(newValue);

                // NEW se√ßilirse panel a√ß
                if (newValue === 'NEW') {
                    setTimeout(() => {
                        showMessagePanel(this);
                    }, 50);
                    return;
                }
            }

            updateOptions() {
                const currentValue = this.getValue();
                // Etiketin sonuna bo≈üluk ekle ki ok i≈üareti √ºst√ºne binmesin
                const options = messages.map(m => [m + '   ', m]);
                options.push(['‚ûï Yeni mesaj...', 'NEW']);
                this.menuGenerator_ = options;

                // Eƒüer mevcut deƒüer listede yoksa, ilk mesajƒ± se√ß
                if (currentValue === 'NEW' || !messages.includes(currentValue)) {
                    this.setValue(messages[0]);
                }
            }
        }

        function showMessagePanel(field) {
            closeAllPopups(); // √ñnce diƒüerlerini kapat
            currentMessageField = field;
            const panel = document.getElementById('messagePanel');
            const input = document.getElementById('messageInput');

            // Bloƒüun pozisyonunu al
            const block = field.getSourceBlock();
            const blockSvg = block.getSvgRoot();
            const rect = blockSvg.getBoundingClientRect();

            panel.style.left = (rect.right + 20) + 'px';
            panel.style.top = rect.top + 'px';
            panel.classList.add('active');

            input.value = '';
            input.focus();

            // Enter tu≈üu ile kaydet
            input.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    saveMessage();
                } else if (e.key === 'Escape') {
                    closeMessagePanel();
                }
            };

            document.addEventListener('click', closeMessagePanelOnClickOutside);
        }

        function closeMessagePanelOnClickOutside(e) {
            const panel = document.getElementById('messagePanel');
            if (!panel.contains(e.target) && !e.target.closest('.blocklyDropDownDiv')) {
                closeMessagePanel();
            }
        }

        function saveMessage() {
            const input = document.getElementById('messageInput');
            const newMessage = input.value.trim();

            if (newMessage && newMessage !== 'NEW') {
                if (!messages.includes(newMessage)) {
                    messages.push(newMessage);
                    console.log('Yeni mesaj eklendi:', newMessage);
                }

                if (currentMessageField) {
                    // T√ºm mesaj field'larƒ±nƒ± g√ºncelle
                    workspace.getAllBlocks().forEach(block => {
                        ['MESSAGE'].forEach(fieldName => {
                            const field = block.getField(fieldName);
                            if (field && field instanceof CustomMessageField) {
                                field.updateOptions();
                            }
                        });
                    });

                    currentMessageField.setValue(newMessage);
                    currentMessageField = null;
                }
            }

            closeMessagePanel();
        }

        function closeMessagePanel() {
            const panel = document.getElementById('messagePanel');
            panel.classList.remove('active');
            document.removeEventListener('click', closeMessagePanelOnClickOutside);

            // Eƒüer yeni mesaj se√ßilmediyse, ilk mesaja d√∂n
            if (currentMessageField && currentMessageField.getValue() === 'NEW') {
                currentMessageField.setValue(messages[0]);
            }

            currentMessageField = null;
        }

        // ========== PIXEL MATRIX PANEL FOR COLOR LIGHT MATRIX ==========
        const PIXEL_COLORS = [
            { name: 'Pink', hex: '#FF69B4', index: 1 },
            { name: 'Purple', hex: '#E040FB', index: 2 },
            { name: 'Blue', hex: '#2196F3', index: 3 },
            { name: 'Cyan', hex: '#00BCD4', index: 4 },
            { name: 'Teal', hex: '#009688', index: 5 }, // Added Teal
            { name: 'Green', hex: '#4CAF50', index: 6 },
            { name: 'Yellow', hex: '#FFEB3B', index: 7 },
            { name: 'Orange', hex: '#FF9800', index: 8 },
            { name: 'Red', hex: '#F44336', index: 9 },
            { name: 'White', hex: '#FFFFFF', index: 10 },
            { name: 'Off', hex: '#333333', index: 0 }
        ];

        let currentPixelField = null;
        let selectedPixelColor = PIXEL_COLORS[5]; // Default yellow
        let pixelGridData = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // 9 pixels, all off

        function initPixelPanel() {
            const grid = document.getElementById('pixelGrid');
            const colorPicker = document.getElementById('pixelColorPicker');

            // Create 9 pixel cells
            grid.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.className = 'pixel-cell';
                cell.dataset.index = i;
                cell.style.background = '#333333';
                cell.onclick = () => paintPixel(i);
                grid.appendChild(cell);
            }

            // Create color picker content
            colorPicker.innerHTML = '';

            // Selected color indicator
            const selectedIndicator = document.createElement('div');
            selectedIndicator.id = 'pixelSelectedColor';
            selectedIndicator.style.cssText = 'width: 36px; height: 20px; border-radius: 4px; border: 2px solid white; margin-bottom: 8px; background: ' + selectedPixelColor.hex;
            colorPicker.appendChild(selectedIndicator);

            // Color buttons
            PIXEL_COLORS.forEach((color, idx) => {
                const btn = document.createElement('button');
                btn.className = 'pixel-color-btn' + (color === selectedPixelColor ? ' selected' : '');
                btn.style.background = color.hex;
                btn.title = color.name;
                btn.onclick = (e) => {
                    e.stopPropagation();
                    selectPixelColor(idx);
                };
                colorPicker.appendChild(btn);
            });
        }

        function selectPixelColor(idx) {
            selectedPixelColor = PIXEL_COLORS[idx];

            // Update indicator
            const indicator = document.getElementById('pixelSelectedColor');
            if (indicator) indicator.style.background = selectedPixelColor.hex;

            // Update buttons
            document.querySelectorAll('.pixel-color-btn').forEach((btn, i) => {
                btn.classList.toggle('selected', i === idx);
            });
        }

        function paintPixel(index) {
            pixelGridData[index] = selectedPixelColor.index;
            const cells = document.querySelectorAll('.pixel-cell');
            cells[index].style.background = selectedPixelColor.hex;
            updatePixelField();
        }

        function clearPixelGrid() {
            pixelGridData = [0, 0, 0, 0, 0, 0, 0, 0, 0];
            document.querySelectorAll('.pixel-cell').forEach(cell => {
                cell.style.background = '#333333';
            });
            updatePixelField();
        }

        function fillPixelGrid() {
            pixelGridData = pixelGridData.map(() => selectedPixelColor.index);
            document.querySelectorAll('.pixel-cell').forEach(cell => {
                cell.style.background = selectedPixelColor.hex;
            });
            updatePixelField();
        }

        function updatePixelField() {
            if (currentPixelField) {
                currentPixelField.setValue(pixelGridData.join(','));
            }
        }

        function showPixelPanel(field, currentData) {
            closeAllPopups();
            currentPixelField = field;

            // Parse existing data
            if (currentData && currentData !== '0,0,0,0,0,0,0,0,0') {
                pixelGridData = currentData.split(',').map(Number);
            } else {
                pixelGridData = [0, 0, 0, 0, 0, 0, 0, 0, 0];
            }

            // Update grid display
            const cells = document.querySelectorAll('.pixel-cell');
            cells.forEach((cell, i) => {
                const colorObj = PIXEL_COLORS.find(c => c.index === pixelGridData[i]) || PIXEL_COLORS[9];
                cell.style.background = colorObj.hex;
            });

            // Position and show panel
            const fieldRect = field.getScaledBBox();
            const panel = document.getElementById('pixelPanel');
            panel.style.left = `${fieldRect.left}px`;
            panel.style.top = `${fieldRect.bottom + 10}px`;
            panel.classList.add('active');

            setTimeout(() => {
                document.addEventListener('click', closePixelPanelOnClickOutside);
            }, 100);
        }

        function closePixelPanelOnClickOutside(e) {
            const panel = document.getElementById('pixelPanel');
            if (!panel.contains(e.target)) {
                closePixelPanel();
            }
        }

        function closePixelPanel() {
            const panel = document.getElementById('pixelPanel');
            panel.classList.remove('active');
            document.removeEventListener('click', closePixelPanelOnClickOutside);
            currentPixelField = null;
        }

        // Custom Pixel Matrix Field
        class PixelMatrixField extends Blockly.Field {
            constructor(value) {
                super(value || '0,0,0,0,0,0,0,0,0');
                this.SERIALIZABLE = true;
            }

            static fromJson(options) {
                return new PixelMatrixField(options['value']);
            }

            initView() {
                // Create a mini preview of the 3x3 grid
                this.createBorderRect_();
                this.borderRect_.setAttribute('rx', 4);
                this.borderRect_.setAttribute('ry', 4);
                this.borderRect_.style.fill = '#5B21B6';
                this.borderRect_.style.stroke = 'rgba(255,255,255,0.4)';
                this.borderRect_.style.strokeWidth = '2';

                this.size_.width = 30;
                this.size_.height = 24;
            }

            showEditor_() {
                showPixelPanel(this, this.getValue());
            }

            doClassValidation_(newValue) {
                return newValue;
            }

            getDisplayText_() {
                return '';
            }

            // SVG preview of the pattern
            render_() {
                super.render_();
                this.size_.width = 30;
                this.size_.height = 24;
            }
        }

        Blockly.fieldRegistry.register('field_pixel_matrix', PixelMatrixField);

        // Initialize pixel panel on load
        document.addEventListener('DOMContentLoaded', initPixelPanel);
        // ========== END PIXEL MATRIX PANEL ==========

        // Custom Number Field with Popup
        class CustomNumberField extends Blockly.FieldNumber {
            showEditor_() {
                closeAllPopups(); // √ñnce diƒüerlerini kapat
                const fieldRect = this.getScaledBBox();
                const panel = document.getElementById('numberPanel');
                const display = document.getElementById('numberDisplay');

                currentValue = parseInt(this.getValue()) || 1;
                currentNumberField = this;
                minValue = this.min_ || 1;
                maxValue = this.max_ || 100;

                display.textContent = currentValue;

                panel.style.left = (fieldRect.right + 10) + 'px';
                panel.style.top = fieldRect.top + 'px';
                panel.classList.add('active');

                document.addEventListener('click', closeNumberPanelOnClickOutside);
            }
        }

        function closeNumberPanelOnClickOutside(e) {
            const panel = document.getElementById('numberPanel');
            if (!panel.contains(e.target) && !e.target.closest('.blocklyEditableText')) {
                closeNumberPanel();
            }
        }

        function closeNumberPanel() {
            const panel = document.getElementById('numberPanel');
            panel.classList.remove('active');
            document.removeEventListener('click', closeNumberPanelOnClickOutside);

            if (currentNumberField) {
                currentNumberField.setValue(currentValue);
                currentNumberField = null;
            }
        }

        function incrementNumber() {
            if (currentValue < maxValue) {
                currentValue++;
                updateDisplay();
            }
        }

        function decrementNumber() {
            if (currentValue > minValue) {
                currentValue--;
                updateDisplay();
            }
        }

        // Basƒ±lƒ± tutma i√ßin deƒüi≈ükenler
        let holdTimer = null;
        let holdInterval = null;
        let isHolding = false;

        // Basƒ±lƒ± tutma fonksiyonlarƒ±
        function startHold(incrementFunc) {
            isHolding = false;

            // ƒ∞lk tƒ±klama - hemen √ßalƒ±≈ütƒ±r
            incrementFunc();

            // 500ms basƒ±lƒ± tutulursa hƒ±zlƒ± mod ba≈ülat
            holdTimer = setTimeout(() => {
                isHolding = true;
                holdInterval = setInterval(() => {
                    incrementFunc();
                }, 100); // Her 100ms'de bir deƒüi≈üir
            }, 500);
        }

        function stopHold() {
            if (holdTimer) {
                clearTimeout(holdTimer);
                holdTimer = null;
            }
            if (holdInterval) {
                clearInterval(holdInterval);
                holdInterval = null;
            }
            isHolding = false;
        }

        function updateDisplay() {
            document.getElementById('numberDisplay').textContent = currentValue;
        }

        // Event listener'larƒ± sayfa y√ºklendiƒüinde ekle
        window.addEventListener('load', () => {
            const incrementBtn = document.getElementById('incrementBtn');
            const decrementBtn = document.getElementById('decrementBtn');

            if (incrementBtn && decrementBtn) {
                // Artƒ± butonu
                incrementBtn.addEventListener('mousedown', () => startHold(incrementNumber));
                incrementBtn.addEventListener('mouseup', stopHold);
                incrementBtn.addEventListener('mouseleave', stopHold);
                incrementBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startHold(incrementNumber);
                });
                incrementBtn.addEventListener('touchend', stopHold);
                incrementBtn.addEventListener('touchcancel', stopHold);

                // Eksi butonu
                decrementBtn.addEventListener('mousedown', () => startHold(decrementNumber));
                decrementBtn.addEventListener('mouseup', stopHold);
                decrementBtn.addEventListener('mouseleave', stopHold);
                decrementBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startHold(decrementNumber);
                });
                decrementBtn.addEventListener('touchend', stopHold);
                decrementBtn.addEventListener('touchcancel', stopHold);
            }

            // A√ßƒ± se√ßici butonlarƒ±
            const angleIncrementBtn = document.getElementById('angleIncrementBtn');
            const angleDecrementBtn = document.getElementById('angleDecrementBtn');

            if (angleIncrementBtn && angleDecrementBtn) {
                // Artƒ± butonu
                angleIncrementBtn.addEventListener('mousedown', () => startHold(incrementAngle));
                angleIncrementBtn.addEventListener('mouseup', stopHold);
                angleIncrementBtn.addEventListener('mouseleave', stopHold);
                angleIncrementBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startHold(incrementAngle);
                });
                angleIncrementBtn.addEventListener('touchend', stopHold);
                angleIncrementBtn.addEventListener('touchcancel', stopHold);

                // Eksi butonu
                angleDecrementBtn.addEventListener('mousedown', () => startHold(decrementAngle));
                angleDecrementBtn.addEventListener('mouseup', stopHold);
                angleDecrementBtn.addEventListener('mouseleave', stopHold);
                angleDecrementBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startHold(decrementAngle);
                });
                angleDecrementBtn.addEventListener('touchend', stopHold);
                angleDecrementBtn.addEventListener('touchcancel', stopHold);
            }

            // A√ßƒ± i≈üaret√ßilerini olu≈ütur
            createAngleMarkers();

            // A√ßƒ± dairesine tƒ±klama/s√ºr√ºkleme √∂zelliƒüi ekle
            setupAngleCircleInteraction();
        });

        // A√ßƒ± dairesi etkile≈üimi
        let isDraggingAngle = false;

        function setupAngleCircleInteraction() {
            const circle = document.getElementById('angleCircle');
            if (!circle) {
                // Circle hen√ºz yok, daha sonra eklenecek
                return;
            }

            // Mouse olaylarƒ±
            circle.addEventListener('mousedown', (e) => {
                isDraggingAngle = true;
                updateAngleFromMouse(e);
            });

            document.addEventListener('mousemove', (e) => {
                if (isDraggingAngle) {
                    updateAngleFromMouse(e);
                }
            });

            document.addEventListener('mouseup', () => {
                isDraggingAngle = false;
            });

            // Touch olaylarƒ±
            circle.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isDraggingAngle = true;
                updateAngleFromTouch(e);
            });

            document.addEventListener('touchmove', (e) => {
                if (isDraggingAngle) {
                    e.preventDefault();
                    updateAngleFromTouch(e);
                }
            });

            document.addEventListener('touchend', () => {
                isDraggingAngle = false;
            });
        }

        function updateAngleFromMouse(e) {
            const circle = document.getElementById('angleCircle');
            if (!circle) return;

            const rect = circle.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const dx = e.clientX - centerX;
            const dy = e.clientY - centerY;

            calculateAngleFromCoordinates(dx, dy);
        }

        function updateAngleFromTouch(e) {
            const circle = document.getElementById('angleCircle');
            if (!circle || e.touches.length === 0) return;

            const rect = circle.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const touch = e.touches[0];
            const dx = touch.clientX - centerX;
            const dy = touch.clientY - centerY;

            calculateAngleFromCoordinates(dx, dy);
        }

        function calculateAngleFromCoordinates(dx, dy) {
            // A√ßƒ±yƒ± hesapla (radyan cinsinden)
            let angleRad = Math.atan2(dy, dx);

            // Radyandan dereceye √ßevir
            let angleDeg = angleRad * 180 / Math.PI;

            // 0-360 aralƒ±ƒüƒ±na √ßevir (saat 3'ten ba≈ülayarak saat y√∂n√ºnde)
            // atan2 saat 3'ten ba≈ülar, biz saat 12'den ba≈ülatmak istiyoruz
            angleDeg = (angleDeg + 90) % 360;
            if (angleDeg < 0) angleDeg += 360;

            // 1'in katƒ±na yuvarla
            currentAngle = Math.round(angleDeg);
            if (currentAngle === 360) currentAngle = 0;

            updateAngleDisplay();
        }

        // A√ßƒ± se√ßici fonksiyonlarƒ±
        function incrementAngle() {
            currentAngle = (currentAngle + 1) % 360;
            updateAngleDisplay();
        }

        function decrementAngle() {
            currentAngle = (currentAngle - 1 + 360) % 360;
            updateAngleDisplay();
        }

        function updateAngleDisplay() {
            const indicator = document.getElementById('angleIndicator');
            const degrees = document.getElementById('angleDegrees');

            indicator.style.transform = `translate(-50%, -100%) rotate(${currentAngle}deg)`;
            degrees.textContent = `${currentAngle}¬∞`;
        }

        function createAngleMarkers() {
            const markersContainer = document.getElementById('angleMarkers');
            if (!markersContainer) return;

            markersContainer.innerHTML = '';

            // Her 30 derece i√ßin i≈üaret (0, 30, 60, 90, ...)
            for (let angle = 0; angle < 360; angle += 30) {
                const marker = document.createElement('div');
                marker.className = 'angle-marker major';
                marker.style.transform = `translate(-50%, -100%) rotate(${angle}deg)`;
                markersContainer.appendChild(marker);

                // Sadece ana a√ßƒ±larda (0, 90, 180, 270) etiket ekle
                if (angle % 90 === 0) {
                    const label = document.createElement('div');
                    label.className = 'angle-marker-label';
                    label.textContent = angle + '¬∞';

                    // Etiketin pozisyonunu hesapla - daha da i√ße alƒ±ndƒ±
                    const radius = 60; // 72'den 60'a d√º≈ü√ºrd√ºk
                    const rad = (angle - 90) * Math.PI / 180;
                    const x = 50 + radius * Math.cos(rad);
                    const y = 50 + radius * Math.sin(rad);

                    label.style.left = x + '%';
                    label.style.top = y + '%';
                    label.style.transform = 'translate(-50%, -50%)';

                    markersContainer.appendChild(label);
                }
            }

            // Her 15 derece i√ßin k√º√ß√ºk i≈üaret (15, 45, 75, ...)
            for (let angle = 15; angle < 360; angle += 30) {
                const marker = document.createElement('div');
                marker.className = 'angle-marker';
                marker.style.transform = `translate(-50%, -100%) rotate(${angle}deg)`;
                markersContainer.appendChild(marker);
            }
        }

        function closeAnglePanelOnClickOutside(e) {
            const panel = document.getElementById('anglePanel');
            if (!panel.contains(e.target) && !e.target.closest('.blocklyEditableText')) {
                closeAnglePanel();
            }
        }

        function closeAnglePanel() {
            const panel = document.getElementById('anglePanel');
            panel.classList.remove('active');
            document.removeEventListener('click', closeAnglePanelOnClickOutside);

            if (currentAngleField) {
                currentAngleField.setValue(currentAngle);
                currentAngleField = null;
            }
        }

        // Event bloklarƒ±
        Blockly.Blocks['start'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_START, 20, 20, "*"))
                    .appendField(Blockly.Msg.BLOCK_START);
                this.setNextStatement(true, null);
                this.setColour("#E6AC00");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['when_condition'] = {
            init: function () {
                this.appendValueInput("CONDITION")
                    .setCheck("Boolean")
                    .appendField(new Blockly.FieldImage(ICON_BOLT, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_WHEN_PRE);
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_WHEN_POST);
                this.setInputsInline(true);
                this.setNextStatement(true, null);
                this.setColour("#FFBF00");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['when_message_received'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_MSG_IN, 20, 20, "*"))
                    .appendField(Blockly.Msg.BLOCK_MESSAGE_PRE)
                    .appendField(new CustomMessageField('message1'), "MESSAGE")
                    .appendField(Blockly.Msg.BLOCK_MESSAGE_POST);
                this.setNextStatement(true, null);
                this.setColour("#FFBF00");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['send_message'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_MSG_OUT, 20, 20, "*"))
                    .appendField(Blockly.Msg.BLOCK_SEND_MOBILE_PRE)
                    .appendField(new CustomMessageField('message1'), "MESSAGE")
                    .appendField(Blockly.Msg.BLOCK_SEND_MOBILE_POST);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['forward'] = {
            init: function () {
                this.appendValueInput('STEPS')
                    .setCheck('Number')
                    .appendField("‚¨ÜÔ∏è");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FF8C1A");
                this.setInputsInline(true);
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['turn_right'] = {
            init: function () {
                this.appendValueInput('DEG')
                    .setCheck('Number')
                    .appendField("‚Üª");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FF8C1A");
                this.setInputsInline(true);
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['turn_left'] = {
            init: function () {
                this.appendValueInput('DEG')
                    .setCheck('Number')
                    .appendField("‚Ü∫");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FF8C1A");
                this.setInputsInline(true);
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['repeat'] = {
            init: function () {
                this.appendValueInput('TIMES')
                    .setCheck('Number')
                    .appendField(new Blockly.FieldImage(ICON_REFRESH, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_REPEAT_PRE);
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_REPEAT_POST);
                this.appendStatementInput('DO');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setInputsInline(true);
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['wait'] = {
            init: function () {
                this.appendValueInput('SECONDS')
                    .setCheck('Number')
                    .appendField(new Blockly.FieldImage(ICON_STOP_HAND, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_WAIT_PRE);
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_WAIT_POST);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setInputsInline(true);
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['forever'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_INFINITY, 20, 20, "*"))
                    .appendField(Blockly.Msg.BLOCK_FOREVER);
                this.appendStatementInput('DO');
                this.setPreviousStatement(true, null);
                this.setColour("#FFAB19");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['if_then'] = {
            init: function () {
                this.appendValueInput('CONDITION')
                    .setCheck('Boolean')
                    .appendField(new Blockly.FieldImage(ICON_RHOMBUS, 16, 16, "*"))
                    .appendField(Blockly.Msg.BLOCK_IF);
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_THEN);
                this.appendStatementInput('DO');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['if_then_else'] = {
            init: function () {
                this.appendValueInput('CONDITION')
                    .setCheck('Boolean')
                    .appendField(new Blockly.FieldImage(ICON_RHOMBUS, 16, 16, "*"))
                    .appendField(Blockly.Msg.BLOCK_IF);
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_THEN);
                this.appendStatementInput('DO');
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_ELSE);
                this.appendStatementInput('ELSE');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['wait_until'] = {
            init: function () {
                this.appendValueInput('CONDITION')
                    .setCheck('Boolean')
                    .appendField(new Blockly.FieldImage(ICON_HOURGLASS, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_WAIT_UNTIL_PRE);
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_WAIT_UNTIL_POST);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['repeat_until'] = {
            init: function () {
                this.appendValueInput('CONDITION')
                    .setCheck('Boolean')
                    .appendField(new Blockly.FieldImage(ICON_REFRESH, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_REPEAT_UNTIL_PRE);
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_REPEAT_UNTIL_POST);
                this.appendStatementInput('DO');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['alarm'] = {
            init: function () {
                this.appendDummyInput().appendField("üîî");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#CF63CF");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['sound'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üîä")
                    .appendField(new CustomNumberField(300, 100, 1000), 'FREQ');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#CF63CF");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['light'] = {
            init: function () {
                this.appendDummyInput().appendField("üí°");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#0FBD8C");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['led_on'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üü¶")
                    .appendField(new CustomNumberField(90, 0, 255), 'VAL');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5CB1D6");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['led_off'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("‚¨õ")
                    .appendField(new CustomNumberField(90, 0, 255), 'VAL');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5CB1D6");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['smile'] = {
            init: function () {
                this.appendDummyInput().appendField("üòä");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FF6680");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // RGB LED Bloklarƒ±
        Blockly.Blocks['rgb_red_on'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_RED, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_RED_ON);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#ff6b6b");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_green_on'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_GREEN, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_GREEN_ON);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#51cf66");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_blue_on'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_BLUE, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_BLUE_ON);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4dabf7");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // RGB LED S√∂nd√ºr Bloklarƒ±
        Blockly.Blocks['rgb_red_off'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_WHITE, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_RED_OFF);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#ffb3b3");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_green_off'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_WHITE, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_GREEN_OFF);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#b3e0b3");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_blue_off'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_WHITE, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_BLUE_OFF);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#b3d9ff");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_red_num'] = {
            init: function () {
                this.appendValueInput('NUM')
                    .setCheck('Number')
                    .appendField(new Blockly.FieldImage(ICON_SQ_RED, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_RED_NUM);
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#ff6b6b");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_green_num'] = {
            init: function () {
                this.appendValueInput('NUM')
                    .setCheck('Number')
                    .appendField(new Blockly.FieldImage(ICON_SQ_GREEN, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_GREEN_NUM);
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#51cf66");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_blue_num'] = {
            init: function () {
                this.appendValueInput('NUM')
                    .setCheck('Number')
                    .appendField(new Blockly.FieldImage(ICON_SQ_BLUE, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_BLUE_NUM);
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4dabf7");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // RGB Sayƒ± Getir Bloklarƒ± (Yuvarlak ≈üekilli - Number output)
        Blockly.Blocks['rgb_red_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_SQ_RED, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_RED_GET);
                this.setOutput(true, "Number");
                this.setColour("#ff6b6b");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_green_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_SQ_GREEN, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_GREEN_GET);
                this.setOutput(true, "Number");
                this.setColour("#51cf66");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_blue_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_SQ_BLUE, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_BLUE_GET);
                this.setOutput(true, "Number");
                this.setColour("#4dabf7");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // RGB I≈üƒ±k Getir Bloklarƒ± (Altƒ±gen ≈üekilli - Boolean output)
        Blockly.Blocks['rgb_red_light_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_RED, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_LIGHT_GET_POST);
                this.setOutput(true, "Boolean");
                this.setColour("#ff6b6b");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_green_light_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_GREEN, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_LIGHT_GET_POST);
                this.setOutput(true, "Boolean");
                this.setColour("#51cf66");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_blue_light_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_BLUE, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_LIGHT_GET_POST);
                this.setOutput(true, "Boolean");
                this.setColour("#4dabf7");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // RGB Tu≈ü Getir Bloklarƒ± (Altƒ±gen ≈üekilli - Boolean output - √ú√ßgen ikonlu)
        Blockly.Blocks['rgb_red_button_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTEyIDJMMiAyMmgyMEwxMiAyeiIgZmlsbD0iI2NmMTMyMiIvPjwvc3ZnPg==", 24, 24, "*"))
                    .appendField(Blockly.Msg.BLOCK_RED_BTN_GET);
                this.setOutput(true, "Boolean");
                this.setColour("#ff6b6b");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_green_button_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTEyIDJMMiAyMmgyMEwxMiAyeiIgZmlsbD0iIzFhOTAzZSIvPjwvc3ZnPg==", 24, 24, "*"))
                    .appendField(Blockly.Msg.BLOCK_GREEN_BTN_GET);
                this.setOutput(true, "Boolean");
                this.setColour("#51cf66");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_blue_button_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTEyIDJMMiAyMmgyMEwxMiAyeiIgZmlsbD0iIzE5NzFjMiIvPjwvc3ZnPg==", 24, 24, "*"))
                    .appendField(Blockly.Msg.BLOCK_BLUE_BTN_GET);
                this.setOutput(true, "Boolean");
                this.setColour("#4dabf7");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Motor Bloklarƒ±
        // SVG Ikonlar (Base64 encoded)
        const DEVICE_ICONS = {
            'rotate': 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0id2hpdGUiPjxwYXRoIGQ9Ik0xMiA0VjFMNCA1bDQgNFY2YzMuMzEgMCA2IDIuNjkgNiA2IDAgMS4wMS0uMjUgMS45Ny0uNyAyLjhsMS40NiAxLjQ2QzE5LjU0IDE1LjAzIDIwIDEzLjU3IDIwIDEyYzAtNC40Mi0zLjU4LTgtOC04em0wIDE0Yy0zLjMxIDAtNi0yLjY5LTYtNiAwLTEuMDEuMjUtMS45Ny43LTIuOEw1LjI0IDcuNzRDNC40NiA4Ljk3IDQgMTAuNDMgNCAxMmMwIDQuNDIgMy41OCA4IDggOHYzbDQtNC00LTR2M3oiLz48L3N2Zz4=',
            'timer': 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0id2hpdGUiPjxwYXRoIGQ9Ik0xMS45OSAyQzYuNDcgMiAyIDYuNDggMiAxMnM0LjQ3IDEwIDkuOTkgMTBDMTcuNTIgMjIgMjIgMTcuNTIgMjIgMTJTMTcuNTIgMiAxMS45OSAyem0uMDEgMThjLTQuNDIgMC04LTMuNTgtOC04czMuNTgtOCA4LTggOCAzLjU4IDggOC0zLjU4IDgtOCA4em0uNS0xM0gxMXY2bDUuMjUgMy4xNS43NS0xLjIzLTQuNS0yLjY3eiIvPjwvc3ZnPg==',
            'speed': 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0id2hpdGUiPjxwYXRoIGQ9Ik03IDJ2MTFoM3Y5bDctMTJoLTRsNC04eiIvPjwvc3ZnPg==',
            'stop': 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0id2hpdGUiPjxwYXRoIGQ9Ik02IDZoMTJ2MTJINnoiLz48L3N2Zz4=',
            'target': 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0id2hpdGUiPjxwYXRoIGQ9Ik0xMiAyQzYuNDggMiAyIDYuNDggMiAxMnM0LjQ4IDEwIDEwIDEwIDEwLTQuNDggMTAtMTBTMTcuNTIgMiAxMiAyem0wIDE4Yy00LjQxIDAtOC0zLjU5LTgtOHMzLjU5LTggOC04IDggMy41OSA4IDgtMy41OSA4LTggOHptLTUtOGMwIDIuNzYgMi4yNCA1IDUgNXM1LTIuMjQgNS01LTIuMjQtNS01LTUgMi4yNC01IDUgNXoiLz48L3N2Zz4=',
            'play': 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0id2hpdGUiPjxwYXRoIGQ9Ik04IDV2MTRsMTEtN3oiLz48L3N2Zz4=',
            'pin': 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0id2hpdGUiPjxwYXRoIGQ9Ik0xMiAyQzguMSAyIDUgNS4xIDUgOWMwIDUuMiA3IDEzIDcgMTNzNy03LjggNy0xM2MwLTMuOS0zLjEtNy03LTd6bTAgOS41Yy0xLjQgMC0yLjUtMS4xLTIuNS0yLjVzMS4xLTIuNSAyLjUtMi41IDIuNSAxLjEgMi41IDIuNS0xLjEgMi41LTIuNSAyLjV6Ii8+PC9zdmc+'
        };
        Blockly.Blocks['motor_run_rotation'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(DEVICE_ICONS['rotate'], 16, 16, "*"))
                    .appendField("run")
                    .appendField(new Blockly.FieldDropdown([["‚Üª", "CW"], ["‚Ü∫", "CCW"]]), "DIRECTION")
                    .appendField("for")
                    .appendField(new CustomNumberField(1, 1, 100), 'ROTATIONS')
                    .appendField("rotations");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4ECDC4");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['motor_run_to_angle'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(DEVICE_ICONS['target'], 16, 16, "*"))
                    .appendField("run")
                    .appendField(new Blockly.FieldDropdown([["‚Üª", "CW"], ["‚Ü∫", "CCW"]]), "DIRECTION")
                    .appendField("to")
                    .appendField(new CustomAngleField(0, 0, 360), 'ANGLE')
                    .appendField("angle");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4ECDC4");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // YENƒ∞ BLOK: Mutlak pozisyon (0¬∞ referansƒ±na g√∂re)
        Blockly.Blocks['motor_go_to_position'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(DEVICE_ICONS['pin'], 16, 16, "*"))
                    .appendField("go to position ")
                    .appendField(new CustomAngleField(0, 0, 360), 'POSITION')
                    .appendField("¬∞");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4ECDC4");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['motor_start'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(DEVICE_ICONS['play'], 16, 16, "*"))
                    .appendField("start motor ")
                    .appendField(new Blockly.FieldDropdown([["‚Üª", "CW"], ["‚Ü∫", "CCW"]]), "DIRECTION");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4ECDC4");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['motor_stop'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(DEVICE_ICONS['stop'], 16, 16, "*"))
                    .appendField("stop motor");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4ECDC4");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Controller Bloklarƒ±
        Blockly.Blocks['when_lever_position'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üïπÔ∏è when")
                    .appendField(new Blockly.FieldDropdown([
                        ["left", "LEFT"],
                        ["right", "RIGHT"],
                        ["both", "BOTH"],
                        ["any", "ANY"]
                    ]), "LEVER")
                    .appendField("lever is")
                    .appendField(new Blockly.FieldDropdown([
                        ["released", "RELEASED"],
                        ["up", "UP"],
                        ["down", "DOWN"]
                    ]), "POSITION");
                this.setNextStatement(true, null);
                this.setColour("#45B7D1");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['lever_position'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üïπÔ∏è")
                    .appendField(new Blockly.FieldDropdown([
                        ["left", "LEFT"],
                        ["right", "RIGHT"],
                        ["both", "BOTH"],
                        ["any", "ANY"]
                    ]), "LEVER")
                    .appendField("lever is")
                    .appendField(new Blockly.FieldDropdown([
                        ["released", "RELEASED"],
                        ["up", "UP"],
                        ["down", "DOWN"]
                    ]), "POSITION");
                this.setOutput(true, "Boolean");
                this.setColour("#45B7D1");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Yeni: Lever angle/percent bloƒüu (0-100 arasƒ± deƒüer d√∂ner)
        Blockly.Blocks['lever_angle'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üïπÔ∏è")
                    .appendField(new Blockly.FieldDropdown([
                        ["left", "LEFT"],
                        ["right", "RIGHT"]
                    ]), "LEVER")
                    .appendField("lever angle");
                this.setOutput(true, "Number");
                this.setColour("#45B7D1");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // ========== COLOR SENSOR BLOCKS ==========

        // Color Sensor Icon for blocks
        const COLOR_SENSOR_ICON = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgdmlld0JveD0iMCAwIDIwIDIwIj48Y2lyY2xlIGN4PSIxMCIgY3k9IjEwIiByPSI4IiBmaWxsPSIjZmZmIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41Ii8+PGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMyIgZmlsbD0iIzMzMyIvPjwvc3ZnPg==';

        // Color dropdown options (matching LEGO/Spike Prime color codes)
        const COLOR_OPTIONS = [
            ["üî¥ red  ", "RED"],           // 1
            ["üü° yellow  ", "YELLOW"],     // 2
            ["üîµ blue  ", "BLUE"],         // 3
            ["üü¢ green  ", "GREEN"],       // 4
            ["üü£ purple  ", "PURPLE"],     // 5
            ["ü©µ cyan  ", "CYAN"],         // 6
            ["‚ö™ white  ", "WHITE"],       // 7
            ["üö´ none  ", "NONE"]          // 0
        ];

        // When color detected (hat block - event)
        Blockly.Blocks['when_color_detected'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(COLOR_SENSOR_ICON, 20, 20, "*"))
                    .appendField("when")
                    .appendField(new Blockly.FieldDropdown(COLOR_OPTIONS), "COLOR");
                this.appendDummyInput()
                    .appendField("detected");
                this.setInputsInline(true);
                this.setNextStatement(true, null);
                this.setColour("#9B59B6");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Detecting color? (boolean reporter)
        Blockly.Blocks['detecting_color'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(COLOR_SENSOR_ICON, 18, 18, "*"))
                    .appendField("detecting")
                    .appendField(new Blockly.FieldDropdown(COLOR_OPTIONS), "COLOR");
                this.appendDummyInput()
                    .appendField("?");
                this.setInputsInline(true);
                this.setOutput(true, "Boolean");
                this.setColour("#9B59B6");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Color value reporter (returns current detected color as string/number)
        Blockly.Blocks['color_value'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(COLOR_SENSOR_ICON, 18, 18, "*"))
                    .appendField("color");
                this.setOutput(true, "String");
                this.setColour("#9B59B6");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Reflection comparison (reflection < 50 %)
        Blockly.Blocks['reflection_compare'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(COLOR_SENSOR_ICON, 18, 18, "*"))
                    .appendField("reflection")
                    .appendField(new Blockly.FieldDropdown([
                        ["<", "LT"],
                        [">", "GT"],
                        ["=", "EQ"]
                    ]), "OP")
                    .appendField(new Blockly.FieldNumber(50, 0, 100), "VALUE")
                    .appendField("%?");
                this.setOutput(true, "Boolean");
                this.setColour("#9B59B6");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Reflection value reporter (returns 0-100)
        Blockly.Blocks['reflection_value'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(COLOR_SENSOR_ICON, 18, 18, "*"))
                    .appendField("reflection");
                this.setOutput(true, "Number");
                this.setColour("#9B59B6");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Color hue reporter (returns hue value)
        Blockly.Blocks['color_hue'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(COLOR_SENSOR_ICON, 18, 18, "*"))
                    .appendField("color")
                    .appendField(new Blockly.FieldDropdown([
                        ["hue", "HUE"],
                        ["saturation", "SAT"],
                        ["value", "VAL"]
                    ]), "MODE");
                this.setOutput(true, "Number");
                this.setColour("#9B59B6");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // ========== END COLOR SENSOR BLOCKS ==========

        // Operat√∂r Bloklarƒ±
        Blockly.Blocks['math_arithmetic'] = {
            init: function () {
                this.appendValueInput('A')
                    .setCheck('Number');
                this.appendDummyInput()
                    .appendField(new Blockly.FieldDropdown([
                        ["+", "ADD"],
                        ["-", "MINUS"],
                        ["√ó", "MULTIPLY"],
                        ["√∑", "DIVIDE"],
                        ["^", "POWER"],
                        ["mod", "MOD"]
                    ]), "OP");
                this.appendValueInput('B')
                    .setCheck('Number');
                this.setOutput(true, 'Number');
                this.setInputsInline(true);
                this.setColour("#59C059");
            }
        };

        Blockly.Blocks['math_random'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_RANDOM_PRE);
                this.appendValueInput('FROM')
                    .setCheck('Number');
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_RANDOM_MID);
                this.appendValueInput('TO')
                    .setCheck('Number');
                this.setOutput(true, 'Number');
                this.setInputsInline(true);
                this.setColour("#59C059");
            }
        };

        Blockly.Blocks['logic_compare'] = {
            init: function () {
                this.appendValueInput('A')
                    .setCheck('Number');
                this.appendDummyInput()
                    .appendField(new Blockly.FieldDropdown([
                        [">", "GT"],
                        ["<", "LT"],
                        ["=", "EQ"],
                        ["‚â•", "GTE"],
                        ["‚â§", "LTE"]
                    ]), "OP");
                this.appendValueInput('B')
                    .setCheck('Number');
                this.setOutput(true, 'Boolean');
                this.setInputsInline(true);
                this.setColour("#5CB15C");
            }
        };

        Blockly.Blocks['logic_and'] = {
            init: function () {
                this.appendValueInput('A')
                    .setCheck('Boolean');
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_LOGIC_AND);
                this.appendValueInput('B')
                    .setCheck('Boolean');
                this.setOutput(true, 'Boolean');
                this.setInputsInline(true);
                this.setColour("#5CB15C");
            }
        };

        Blockly.Blocks['logic_or'] = {
            init: function () {
                this.appendValueInput('A')
                    .setCheck('Boolean');
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_LOGIC_OR);
                this.appendValueInput('B')
                    .setCheck('Boolean');
                this.setOutput(true, 'Boolean');
                this.setInputsInline(true);
                this.setColour("#5CB15C");
            }
        };

        Blockly.Blocks['logic_negate'] = {
            init: function () {
                this.appendValueInput('BOOL')
                    .setCheck('Boolean')
                    .appendField(Blockly.Msg.BLOCK_LOGIC_NOT);
                this.setOutput(true, 'Boolean');
                this.setColour("#5CB15C");
            }
        };

        // Sayƒ± bloƒüu (shadow bloklar i√ßin)
        Blockly.Blocks['math_number'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new CustomNumberField(0, -999, 999), 'NUM');
                this.setOutput(true, 'Number');
                this.setColour("#59C059");
            }
        };

        // Hub LED Color Block for Spike Essential
        const HUB_LED_ICON = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='18' height='18' viewBox='0 0 24 24' fill='white'%3E%3Ccircle cx='12' cy='12' r='10' stroke='white' stroke-width='2' fill='none'/%3E%3Ccircle cx='12' cy='12' r='5' fill='white'/%3E%3C/svg%3E";

        const HUB_LED_COLORS = [
            ["üî¥", "RED"],
            ["üü†", "ORANGE"],
            ["üü°", "YELLOW"],
            ["üü¢", "GREEN"],
            ["üîµ", "BLUE"],
            ["üü£", "PURPLE"],
            ["ü©∑", "PINK"],
            ["ü©µ", "CYAN"],
            ["‚¨ú", "WHITE"],
            ["‚¨õ", "OFF"]
        ];

        Blockly.Blocks['hub_led_color'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(HUB_LED_ICON, 18, 18, "*"))
                    .appendField("set hub LED to")
                    .appendField(new Blockly.FieldDropdown(HUB_LED_COLORS), "COLOR");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#F5A623");
                this.setTooltip("Set the Hub's LED color");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Hub Orientation Block (is face up?)
        const HUB_ORIENTATION_ICON = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='18' height='18' viewBox='0 0 24 24' fill='white'%3E%3Cpath d='M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5'/%3E%3C/svg%3E";

        const HUB_ORIENTATIONS = [
            ["front", "FRONT"],
            ["back", "BACK"],
            ["top", "TOP"],
            ["bottom", "BOTTOM"],
            ["right side", "RIGHT"],
            ["left side", "LEFT"]
        ];

        Blockly.Blocks['hub_orientation'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(HUB_ORIENTATION_ICON, 18, 18, "*"))
                    .appendField("is")
                    .appendField(new Blockly.FieldDropdown(HUB_ORIENTATIONS), "ORIENTATION")
                    .appendField("up?");
                this.setOutput(true, "Boolean");
                this.setColour("#4FC3F7");
                this.setTooltip("Returns true if the specified face of the hub is facing up");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Color Light Matrix - Turn off pixels
        const MATRIX_ICON = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='18' height='18' viewBox='0 0 24 24' fill='white'%3E%3Crect x='3' y='3' width='5' height='5' rx='1'/%3E%3Crect x='10' y='3' width='5' height='5' rx='1'/%3E%3Crect x='17' y='3' width='5' height='5' rx='1'/%3E%3Crect x='3' y='10' width='5' height='5' rx='1'/%3E%3Crect x='10' y='10' width='5' height='5' rx='1'/%3E%3Crect x='17' y='10' width='5' height='5' rx='1'/%3E%3Crect x='3' y='17' width='5' height='5' rx='1'/%3E%3Crect x='10' y='17' width='5' height='5' rx='1'/%3E%3Crect x='17' y='17' width='5' height='5' rx='1'/%3E%3C/svg%3E";

        const MATRIX_PORTS = [
            ["A", "A"],
            ["B", "B"]
        ];

        Blockly.Blocks['matrix_turn_off'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(MATRIX_ICON, 18, 18, "*"))
                    .appendField(new Blockly.FieldDropdown(MATRIX_PORTS), "PORT")
                    .appendField("turn off pixels");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9B59B6");
                this.setTooltip("Turn off all pixels on the Color Light Matrix");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['matrix_turn_on'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(MATRIX_ICON, 18, 18, "*"))
                    .appendField(new Blockly.FieldDropdown(MATRIX_PORTS), "PORT")
                    .appendField("turn on")
                    .appendField(new PixelMatrixField('0,0,0,0,0,0,0,0,0'), "PATTERN");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9B59B6");
                this.setTooltip("Display a pattern on the Color Light Matrix");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['matrix_set_brightness'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(MATRIX_ICON, 18, 18, "*"))
                    .appendField(new Blockly.FieldDropdown(MATRIX_PORTS), "PORT")
                    .appendField("set pixel brightness to");
                this.appendValueInput("BRIGHTNESS")
                    .setCheck("Number");
                this.appendDummyInput()
                    .appendField("%");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#8c52ff");
                this.setTooltip("Set brightness of matrix (0-100%)");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['matrix_set_pixel_at'] = {
            init: function () {
                // Generate color options from PIXEL_COLORS
                // Make sure PIXEL_COLORS is accessible. If not, fallback to basic list.
                const colorOptions = (typeof PIXEL_COLORS !== 'undefined')
                    ? PIXEL_COLORS.map(c => [c.name, String(c.index)])
                    : [["Black", "0"], ["Pink", "1"], ["Violet", "2"], ["Blue", "3"], ["Cyan", "4"], ["Teal", "5"], ["Green", "6"], ["Yellow", "7"], ["Orange", "8"], ["Red", "9"], ["White", "10"]];

                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(MATRIX_ICON, 18, 18, "*"))
                    .appendField(new Blockly.FieldDropdown(MATRIX_PORTS), "PORT")
                    .appendField("set pixel at")
                    .appendField(new Blockly.FieldDropdown([["1", "1"], ["2", "2"], ["3", "3"]]), "X")
                    .appendField(",")
                    .appendField(new Blockly.FieldDropdown([["1", "1"], ["2", "2"], ["3", "3"]]), "Y")
                    .appendField("to")
                    .appendField(new Blockly.FieldDropdown(colorOptions), "COLOR")
                    .appendField("at");
                this.appendValueInput("BRIGHTNESS").setCheck("Number");
                this.appendDummyInput().appendField("%");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#8c52ff");
                this.setTooltip("Set specific pixel color and brightness");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) this.data = selectedDeviceId;
                });
            }
        };

        Blockly.Blocks['matrix_rotate_pattern'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(MATRIX_ICON, 18, 18, "*"))
                    .appendField(new Blockly.FieldDropdown(MATRIX_PORTS), "PORT")
                    .appendField("rotate")
                    .appendField(new Blockly.FieldDropdown([["‚Ü∑", "CW"], ["‚Ü∂", "CCW"]]), "DIRECTION");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#8c52ff");
                this.setTooltip("Rotate the pattern 90 degrees");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) this.data = selectedDeviceId;
                });
            }
        };
        Blockly.Python = new Blockly.Generator('Python');

        // Force Sensor Blocks
        const FORCE_SENSOR_ICON = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='18' height='18' viewBox='0 0 24 24' fill='white'%3E%3Cpath d='M18 19V5h-6V3c0-.55-.45-1-1-1h-2c-.55 0-1 .45-1 1v2H4v14H2v2h20v-2h-2zm-6 0h-4V5h4v14z'/%3E%3C/svg%3E";

        const FORCE_PORTS = [
            ["A", "A"],
            ["B", "B"]
        ];

        const FORCE_STATES = [
            ["pressed", "PRESSED"],
            ["hard-pressed", "HARD_PRESSED"],
            ["released", "RELEASED"]
        ];

        const FORCE_UNITS = [
            ["newton", "NEWTON"],
            ["%", "PERCENT"]
        ];

        Blockly.Blocks['force_sensor_is_pressed'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(FORCE_SENSOR_ICON, 18, 18, "*"))
                    .appendField(new Blockly.FieldDropdown(FORCE_PORTS), "PORT")
                    .appendField("is")
                    .appendField(new Blockly.FieldDropdown(FORCE_STATES), "STATE")
                    .appendField("?");
                this.setOutput(true, "Boolean");
                this.setColour("#4FC3F7");
                this.setTooltip("Check if the Force Sensor is pressed, hard-pressed, or released");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['force_sensor_pressure'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(FORCE_SENSOR_ICON, 18, 18, "*"))
                    .appendField(new Blockly.FieldDropdown(FORCE_PORTS), "PORT")
                    .appendField("pressure in")
                    .appendField(new Blockly.FieldDropdown(FORCE_UNITS), "UNIT");
                this.setOutput(true, "Number");
                this.setColour("#4FC3F7");
                this.setTooltip("Get the pressure value from the Force Sensor");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };


        Blockly.Python['start'] = () => '# When play clicked\n';
        Blockly.Python['when_condition'] = (b) => {
            const condition = Blockly.Python.valueToCode(b, 'CONDITION', Blockly.Python.ORDER_NONE) || 'True';
            return `# When ${condition}\n`;
        };
        Blockly.Python['when_message_received'] = (b) => {
            const message = b.getFieldValue('MESSAGE');
            return `# When ${message} received\n`;
        };
        Blockly.Python['send_message'] = (b) => {
            const message = b.getFieldValue('MESSAGE');
            return `send_message("${message}")\n`;
        };
        Blockly.Python['forward'] = (b) => `forward(${b.getFieldValue('STEPS')})\n`;
        Blockly.Python['turn_right'] = (b) => `turn_right(${b.getFieldValue('DEG')})\n`;
        Blockly.Python['turn_left'] = (b) => `turn_left(${b.getFieldValue('DEG')})\n`;
        Blockly.Python['repeat'] = (b) => {
            const times = b.getFieldValue('TIMES');
            const branch = Blockly.Python.statementToCode(b, 'DO');
            return `for i in range(${times}):\n${branch}\n`;
        };
        Blockly.Python['wait'] = (b) => `time.sleep(${b.getFieldValue('SECONDS')})\n`;
        Blockly.Python['forever'] = (b) => {
            const branch = Blockly.Python.statementToCode(b, 'DO');
            return `while True:\n${branch}\n`;
        };
        Blockly.Python['if_then'] = (b) => {
            const condition = Blockly.Python.valueToCode(b, 'CONDITION', Blockly.Python.ORDER_NONE) || 'False';
            const branch = Blockly.Python.statementToCode(b, 'DO');
            return `if ${condition}:\n${branch}\n`;
        };
        Blockly.Python['if_then_else'] = (b) => {
            const condition = Blockly.Python.valueToCode(b, 'CONDITION', Blockly.Python.ORDER_NONE) || 'False';
            const branchDo = Blockly.Python.statementToCode(b, 'DO');
            const branchElse = Blockly.Python.statementToCode(b, 'ELSE');
            return `if ${condition}:\n${branchDo}else:\n${branchElse}\n`;
        };
        Blockly.Python['wait_until'] = (b) => {
            const condition = Blockly.Python.valueToCode(b, 'CONDITION', Blockly.Python.ORDER_NONE) || 'False';
            return `while not (${condition}):\n    time.sleep(0.1)\n`;
        };
        Blockly.Python['repeat_until'] = (b) => {
            const condition = Blockly.Python.valueToCode(b, 'CONDITION', Blockly.Python.ORDER_NONE) || 'False';
            const branch = Blockly.Python.statementToCode(b, 'DO');
            return `while not (${condition}):\n${branch}\n`;
        };
        Blockly.Python['alarm'] = () => 'alarm()\n';
        Blockly.Python['sound'] = (b) => `play_tone(${b.getFieldValue('FREQ')})\n`;
        Blockly.Python['light'] = () => 'light_on()\n';
        Blockly.Python['led_on'] = (b) => `led_on(${b.getFieldValue('VAL')})\n`;
        Blockly.Python['led_off'] = (b) => `led_off(${b.getFieldValue('VAL')})\n`;
        Blockly.Python['smile'] = () => 'show_smile()\n';
        Blockly.Python['rgb_red_on'] = () => 'rgb_red_on()\n';
        Blockly.Python['rgb_green_on'] = () => 'rgb_green_on()\n';
        Blockly.Python['rgb_blue_on'] = () => 'rgb_blue_on()\n';
        Blockly.Python['rgb_red_off'] = () => 'rgb_red_off()\n';
        Blockly.Python['rgb_green_off'] = () => 'rgb_green_off()\n';
        Blockly.Python['rgb_blue_off'] = () => 'rgb_blue_off()\n';
        Blockly.Python['rgb_red_num'] = (b) => {
            const num = Blockly.Python.valueToCode(b, 'NUM', Blockly.Python.ORDER_ATOMIC) || '0';
            return `rgb_red_num(${num})\n`;
        };
        Blockly.Python['rgb_green_num'] = (b) => {
            const num = Blockly.Python.valueToCode(b, 'NUM', Blockly.Python.ORDER_ATOMIC) || '0';
            return `rgb_green_num(${num})\n`;
        };
        Blockly.Python['rgb_blue_num'] = (b) => {
            const num = Blockly.Python.valueToCode(b, 'NUM', Blockly.Python.ORDER_ATOMIC) || '0';
            return `rgb_blue_num(${num})\n`;
        };
        Blockly.Python['rgb_red_get'] = () => ['rgb_red_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_green_get'] = () => ['rgb_green_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_blue_get'] = () => ['rgb_blue_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_red_light_get'] = () => ['rgb_red_light_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_green_light_get'] = () => ['rgb_green_light_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_blue_light_get'] = () => ['rgb_blue_light_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_red_button_get'] = () => ['rgb_red_button_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_green_button_get'] = () => ['rgb_green_button_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_blue_button_get'] = () => ['rgb_blue_button_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['motor_run_rotation'] = (b) => {
            const dir = b.getFieldValue('DIRECTION');
            const rot = b.getFieldValue('ROTATIONS');
            return `motor.run_for_rotations(${rot}, ${dir === 'CW' ? '1' : '-1'})\n`;
        };
        Blockly.Python['motor_run_to_angle'] = (b) => {
            const dir = b.getFieldValue('DIRECTION');
            const angle = b.getFieldValue('ANGLE');
            return `motor.run_to_angle(${angle}, ${dir === 'CW' ? '1' : '-1'})\n`;
        };
        Blockly.Python['motor_go_to_position'] = (b) => {
            const position = b.getFieldValue('POSITION');
            return `motor.go_to_position(${position})\n`;
        };
        Blockly.Python['motor_start'] = (b) => {
            const dir = b.getFieldValue('DIRECTION');
            return `motor.start(${dir === 'CW' ? '1' : '-1'})\n`;
        };
        Blockly.Python['motor_stop'] = () => 'motor.stop()\n';
        Blockly.Python['hub_led_color'] = (b) => {
            const color = b.getFieldValue('COLOR');
            return `hub.light.color(Color.${color})\n`;
        };
        Blockly.Python['hub_orientation'] = (b) => {
            const orientationMap = {
                'FRONT': 'Side.FRONT',
                'BACK': 'Side.BACK',
                'TOP': 'Side.TOP',
                'BOTTOM': 'Side.BOTTOM',
                'RIGHT': 'Side.RIGHT',
                'LEFT': 'Side.LEFT'
            };
            const orientation = orientationMap[b.getFieldValue('ORIENTATION')] || 'Side.TOP';
            return [`hub.imu.up() == ${orientation}`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['force_sensor_is_pressed'] = (b) => {
            const port = b.getFieldValue('PORT');
            const state = b.getFieldValue('STATE').toLowerCase(); // pressed, hard_pressed, released
            return [`force_sensor_${port}.is_${state}()`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['force_sensor_pressure'] = (b) => {
            const port = b.getFieldValue('PORT');
            const unit = b.getFieldValue('UNIT');
            if (unit === 'NEWTON') {
                return [`force_sensor_${port}.force()`, Blockly.Python.ORDER_ATOMIC];
            } else {
                return [`force_sensor_${port}.distance()`, Blockly.Python.ORDER_ATOMIC]; // Percentage maps to distance/depth
            }
        };
        Blockly.Python['when_lever_position'] = (b) => {
            const lever = b.getFieldValue('LEVER');
            const position = b.getFieldValue('POSITION');
            return `# When ${lever} lever is ${position}\n`;
        };
        Blockly.Python['lever_position'] = (b) => {
            const lever = b.getFieldValue('LEVER');
            const position = b.getFieldValue('POSITION');
            return [`controller.${lever.toLowerCase()}_lever_is_${position.toLowerCase()}()`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['lever_angle'] = (b) => {
            const lever = b.getFieldValue('LEVER');
            return [`controller.${lever.toLowerCase()}_lever_angle()`, Blockly.Python.ORDER_ATOMIC];
        };

        // ========== COLOR SENSOR PYTHON GENERATORS ==========
        Blockly.Python['when_color_detected'] = (b) => {
            const color = b.getFieldValue('COLOR').toLowerCase();
            return `# when ${color} detected\n`;
        };
        Blockly.Python['detecting_color'] = (b) => {
            const color = b.getFieldValue('COLOR').toLowerCase();
            return [`color_sensor.color() == '${color}'`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['color_value'] = (b) => {
            return [`color_sensor.color()`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['reflection_compare'] = (b) => {
            const ops = { 'GT': '>', 'LT': '<', 'EQ': '==' };
            const op = ops[b.getFieldValue('OP')];
            const value = b.getFieldValue('VALUE');
            return [`color_sensor.reflection() ${op} ${value}`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['reflection_value'] = (b) => {
            return [`color_sensor.reflection()`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['color_hue'] = (b) => {
            const mode = b.getFieldValue('MODE').toLowerCase();
            return [`color_sensor.${mode}()`, Blockly.Python.ORDER_ATOMIC];
        };
        // ========== END COLOR SENSOR PYTHON GENERATORS ==========

        Blockly.Python['math_arithmetic'] = (b) => {
            const ops = {
                'ADD': '+', 'MINUS': '-', 'MULTIPLY': '*',
                'DIVIDE': '/', 'POWER': '**', 'MOD': '%'
            };
            const op = ops[b.getFieldValue('OP')];
            const a = Blockly.Python.valueToCode(b, 'A', Blockly.Python.ORDER_ATOMIC) || '0';
            const bVal = Blockly.Python.valueToCode(b, 'B', Blockly.Python.ORDER_ATOMIC) || '0';
            return [`(${a} ${op} ${bVal})`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['math_random'] = (b) => {
            const from = Blockly.Python.valueToCode(b, 'FROM', Blockly.Python.ORDER_ATOMIC) || '1';
            const to = Blockly.Python.valueToCode(b, 'TO', Blockly.Python.ORDER_ATOMIC) || '10';
            return [`random.randint(${from}, ${to})`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['logic_compare'] = (b) => {
            const ops = { 'GT': '>', 'LT': '<', 'EQ': '==', 'GTE': '>=', 'LTE': '<=' };
            const op = ops[b.getFieldValue('OP')];
            const a = Blockly.Python.valueToCode(b, 'A', Blockly.Python.ORDER_ATOMIC) || '0';
            const bVal = Blockly.Python.valueToCode(b, 'B', Blockly.Python.ORDER_ATOMIC) || '0';
            return [`(${a} ${op} ${bVal})`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['logic_and'] = (b) => {
            const a = Blockly.Python.valueToCode(b, 'A', Blockly.Python.ORDER_ATOMIC) || 'False';
            const bVal = Blockly.Python.valueToCode(b, 'B', Blockly.Python.ORDER_ATOMIC) || 'False';
            return [`(${a} and ${bVal})`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['logic_or'] = (b) => {
            const a = Blockly.Python.valueToCode(b, 'A', Blockly.Python.ORDER_ATOMIC) || 'False';
            const bVal = Blockly.Python.valueToCode(b, 'B', Blockly.Python.ORDER_ATOMIC) || 'False';
            return [`(${a} or ${bVal})`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['logic_negate'] = (b) => {
            const bool = Blockly.Python.valueToCode(b, 'BOOL', Blockly.Python.ORDER_ATOMIC) || 'False';
            return [`not ${bool}`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['math_number'] = (b) => {
            const num = b.getFieldValue('NUM');
            return [num, Blockly.Python.ORDER_ATOMIC];
        };

        function initBlockly() {
            // Dil ayarlarƒ±nƒ± y√ºkle (Blockly.Msg tanƒ±mlarƒ± i√ßin)
            setLanguage(currentLanguage);

            workspace = Blockly.inject('blocklyDiv', {
                grid: {
                    spacing: 25,       // Daha geni≈ü aralƒ±k
                    length: 1,         // Nokta boyutu (1 = k√º√ß√ºk nokta)
                    colour: '#d0d0d0', // Hafif g√∂r√ºn√ºr gri
                    snap: true         // Bloklarƒ± ƒ±zgaraya hizala
                },
                toolbox: `
                    <xml xmlns="https://developers.google.com/blockly/xml">
                        <block type="start"></block>
                        <block type="when_condition"></block>
                        <block type="when_message_received">
                            <field name="MESSAGE">message1</field>
                        </block>
                        <block type="send_message">
                            <field name="MESSAGE">message1</field>
                        </block>
                        <block type="forward">
                            <value name="STEPS">
                                <shadow type="math_number">
                                    <field name="NUM">4</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="turn_right">
                            <value name="DEG">
                                <shadow type="math_number">
                                    <field name="NUM">4</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="turn_left">
                            <value name="DEG">
                                <shadow type="math_number">
                                    <field name="NUM">4</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="repeat">
                            <value name="TIMES">
                                <shadow type="math_number">
                                    <field name="NUM">10</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="alarm"></block>
                        <block type="sound"><field name="FREQ">300</field></block>
                        <block type="light"></block>
                        <block type="led_on"><field name="VAL">90</field></block>
                        <block type="led_off"><field name="VAL">90</field></block>
                        <block type="rgb_red_button_get"></block>
                        <block type="rgb_green_button_get"></block>
                        <block type="rgb_blue_button_get"></block>
                        <block type="smile"></block>
                    </xml>
                `,
                horizontalLayout: false,
                toolboxPosition: 'start',
                renderer: 'zelos',
                zoom: {
                    controls: false,
                    wheel: true,
                    startScale: 1.0,
                    maxScale: 2.0,
                    minScale: 0.5,
                    scaleSpeed: 1.15
                },
                grid: {
                    spacing: 25,       // Daha geni≈ü aralƒ±k
                    length: 1,         // Nokta boyutu (1 = k√º√ß√ºk nokta)
                    colour: '#d0d0d0', // Hafif g√∂r√ºn√ºr gri
                    snap: true         // Bloklarƒ± ƒ±zgaraya hizala
                },
                move: {
                    scrollbars: {
                        horizontal: true,
                        vertical: true
                    },
                    drag: true,
                    wheel: true
                },
                trashcan: false
            });

            // Blok eklendiƒüinde cihaz ikonu ekle
            workspace.addChangeListener(function (event) {
                // Blok se√ßildiƒüinde silme butonunu g√∂ster
                if (event.type === Blockly.Events.SELECTED) {
                    handleBlockSelection(event);
                }

                if (event.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                    const block = workspace.getBlockById(event.blockId);
                    if (block && block.data === selectedDeviceId) {
                        // Bloƒüun SVG'sine cihaz ikonu ekle
                        setTimeout(() => {
                            const blockSvg = block.getSvgRoot();
                            if (blockSvg && !blockSvg.querySelector('.device-badge')) {
                                const deviceIcon = getDeviceIcon(selectedDeviceId);
                                if (deviceIcon) {
                                    const foreignObject = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
                                    foreignObject.setAttribute('x', '2');
                                    foreignObject.setAttribute('y', block.height - 18);
                                    foreignObject.setAttribute('width', '14');
                                    foreignObject.setAttribute('height', '14');
                                    foreignObject.classList.add('device-badge');

                                    const div = document.createElement('div');
                                    div.innerHTML = deviceIcon;
                                    div.style.width = '14px';
                                    div.style.height = '14px';

                                    foreignObject.appendChild(div);
                                    blockSvg.appendChild(foreignObject);
                                }
                            }
                        }, 100);
                    }
                }
            });

            // Workspace drop handler
            setupWorkspaceDrop();

            // Toolbox'ƒ± ba≈ülangƒ±√ßta gizle
            setTimeout(() => {
                hideAllToolboxes();


                // Varsayƒ±lan dili ƒ∞ngilizce yap
                setTimeout(() => {
                    setLanguage('en');
                }, 200);
            }, 100);
        }

        function showCode() {
            const code = Blockly.Python.workspaceToCode(workspace);
            if (!code.trim()) {
                alert('√ñnce blok ekle! üé®');
                return;
            }
            document.getElementById('codeDisplay').textContent = '# MicroPython\n\n' + code;
            document.getElementById('codeModal').classList.add('show');
        }

        function closeModal() {
            document.getElementById('codeModal').classList.remove('show');
        }

        function copyCode() {
            const code = document.getElementById('codeDisplay').textContent;
            navigator.clipboard.writeText(code).then(() => alert('‚úÖ Kopyalandƒ±!'));
        }

        // Global execution control flags
        var isExecutionCancelled = false;
        var isExecutionRunning = false;
        var eventCheckInterval = null;

        async function runCode() {
            const playBtn = document.querySelector('.play-btn');

            // Eƒüer zaten √ßalƒ±≈üƒ±yorsa, durdur
            if (isExecutionRunning) {
                stopExecution();
                return;
            }

            // Yeni √ßalƒ±≈ütƒ±rma ba≈ülat
            isExecutionCancelled = false;
            isExecutionRunning = true;

            // Play butonunu "√ßalƒ±≈üƒ±yor" g√∂r√ºn√ºm√ºne getir
            playBtn.style.background = '#51cf66';
            playBtn.style.boxShadow = 'inset 0 2px 8px rgba(0,0,0,0.3)';
            playBtn.title = 'Durdur / Stop';
            playBtn.classList.add('status-running');

            // Workspace'teki t√ºm bloklarƒ± al
            const allBlocks = workspace.getAllBlocks();

            // "start" bloklarƒ±nƒ± bul ve √ßalƒ±≈ütƒ±r
            const startBlocks = allBlocks.filter(block => block.type === 'start');
            // "when_condition" bloklarƒ±nƒ± bul (Event bloklarƒ±)
            const eventBlocks = allBlocks.filter(block =>
                ['when_condition', 'when_message_received', 'when_color_detected'].includes(block.type)
            );

            if (startBlocks.length === 0 && eventBlocks.length === 0) {
                showRuntimeError(TRANSLATIONS[currentLanguage].alert_no_play);
                stopExecution();
                return;
            }

            console.log('‚ñ∂Ô∏è Kod √ßalƒ±≈ütƒ±rƒ±lƒ±yor...');

            // Create a separate session for each start block
            const activeFlowSessions = new Map(); // flowId -> sessionIndex

            // If no start blocks but we have event blocks, create a session to capture logs
            if (startBlocks.length === 0 && eventBlocks.length > 0) {
                const sessionIndex = startExecutionSession(1, null);
                activeFlowSessions.set(1, sessionIndex);
            }

            // Start bloklarƒ±nƒ± PARALEL olarak √ßalƒ±≈ütƒ±r (hepsi aynƒ± anda ba≈ülar)
            const executeStartBlock = async (startBlock, flowId) => {
                // Create a new session for this flow, passing the block ID for preview
                const sessionIndex = startExecutionSession(flowId, startBlock.id);
                activeFlowSessions.set(flowId, sessionIndex);

                const myFlowId = flowId;

                // Log flow start
                logExecutionToSession(sessionIndex, `<span style="background:#e3f2fd;padding:2px 8px;border-radius:4px;display:inline-block;">üëÜ ${currentLanguage === 'tr' ? '‚ñ∂Ô∏è Kod √ßalƒ±≈ütƒ±rƒ±ldƒ±' : '‚ñ∂Ô∏è Code started'}</span>`);

                let nextBlock = startBlock.getNextBlock();
                while (nextBlock) {
                    if (isExecutionCancelled) {
                        console.log('üõë Kod y√ºr√ºtme iptal edildi.');
                        break;
                    }
                    await executeBlockPlay(nextBlock, myFlowId);
                    nextBlock = nextBlock.getNextBlock();
                }

                // Log flow completion
                if (!isExecutionCancelled) {
                    logExecutionToSession(sessionIndex, currentLanguage === 'tr'
                        ? `<span style="color:#888;">‚úì Bloklar tamamlandƒ±</span>`
                        : `<span style="color:#888;">‚úì Blocks completed</span>`);
                }
            };

            // Store active sessions globally so stop and event listening can access them
            window.activeFlowSessions = activeFlowSessions;
            window.activeFlowCount = startBlocks.length;

            // T√ºm start bloklarƒ±nƒ± paralel olarak ba≈ülat, her birine benzersiz flow ID ver
            await Promise.all(startBlocks.map((startBlock, index) => executeStartBlock(startBlock, index + 1)));

            // Start bloklarƒ± bitti, event dinlemeye ba≈üla
            if (!isExecutionCancelled) {
                startEventListening();
            }
        }

        function stopExecution() {
            console.log('‚èπÔ∏è √áalƒ±≈üma durduruluyor...');

            // Log stop to all active sessions
            logToAllActiveSessions(`<span style="background:#e3f2fd;padding:2px 8px;border-radius:4px;display:inline-block;">üëÜ ${currentLanguage === 'tr' ? '‚èπÔ∏è Durduruldu' : '‚èπÔ∏è Stopped'}</span>`);

            // End all active sessions
            if (window.activeFlowSessions) {
                window.activeFlowSessions.forEach((sessionIndex) => {
                    endExecutionSessionByIndex(sessionIndex);
                });
            }

            isExecutionCancelled = true;
            isExecutionRunning = false;

            // Event dinlemeyi durdur
            if (eventCheckInterval) {
                clearInterval(eventCheckInterval);
                eventCheckInterval = null;
            }

            // Play butonunu normal haline getir
            const playBtn = document.querySelector('.play-btn');
            playBtn.style.background = '#FFBF00';
            playBtn.style.boxShadow = '0 3px 8px rgba(0, 0, 0, 0.2)';
            playBtn.title = 'Kodu √áalƒ±≈ütƒ±r / Run Code';
            playBtn.classList.remove('status-running');
        }

        function startEventListening() {
            console.log('üëÇ Event dinleme ba≈üladƒ±...');

            // Log event listening to all active sessions
            logToAllActiveSessions(`<span style="background:#fff3e0;padding:2px 8px;border-radius:4px;display:inline-block;">${currentLanguage === 'tr' ? 'üëÇ Event dinleniyor...' : 'üëÇ Listening for events...'}</span>`);

            // Play butonunu "dinliyor" (daha koyu ye≈üil) g√∂r√ºn√ºm√ºne getir
            const playBtn = document.querySelector('.play-btn');
            if (playBtn) {
                // √áalƒ±≈üƒ±yor state'inden (#51cf66) daha koyu bir ye≈üil yap
                playBtn.style.background = '#2b8a3e';
                playBtn.title = 'Dinleniyor... (Durdurmak i√ßin tƒ±kla)';
            }

            // Track actively running event blocks to prevent overlapping execution
            const activeEventBlocks = new Set();

            // Her 100ms'de event bloklarƒ±nƒ± kontrol et
            eventCheckInterval = setInterval(async () => {
                if (isExecutionCancelled || !isExecutionRunning) {
                    clearInterval(eventCheckInterval);
                    eventCheckInterval = null;
                    return;
                }

                const allBlocks = workspace.getAllBlocks();

                // when_condition bloklarƒ± (when [condition] true olduƒüunda)
                const conditionBlocks = allBlocks.filter(b => b.type === 'when_condition');
                for (const block of conditionBlocks) {
                    if (isExecutionCancelled) break;

                    // Skip if this block's sequence is already running
                    if (activeEventBlocks.has(block.id)) continue;

                    const conditionBlock = block.getInputTargetBlock('CONDITION');
                    if (conditionBlock) {
                        const result = await executeBlockPlay(conditionBlock);
                        if (result === true) {
                            if (activeEventBlocks.has(block.id)) continue;

                            // Mark as active
                            activeEventBlocks.add(block.id);

                            // Execute sequence asynchronously
                            (async () => {
                                let sessionIndex = -1;
                                try {
                                    // Start a NEW Session for this event execution
                                    const eventFlowId = `event_${block.id}_${Date.now()}`;
                                    const sessionTitle = currentLanguage === 'tr' ? 'Ko≈üul Bloƒüu' : 'Condition Block';
                                    sessionIndex = startExecutionSession(eventFlowId, block.id, sessionTitle);

                                    // Log start
                                    logExecutionToSession(sessionIndex, `<span style="background:#e3f2fd;padding:2px 8px;border-radius:4px;display:inline-block;">üëÜ ${currentLanguage === 'tr' ? '‚ñ∂Ô∏è Kod √ßalƒ±≈ütƒ±rƒ±ldƒ±' : '‚ñ∂Ô∏è Code started'}</span>`);

                                    // Ko≈üul saƒülandƒ±, altƒ±ndaki bloklarƒ± √ßalƒ±≈ütƒ±r
                                    let nextBlock = block.getNextBlock();
                                    while (nextBlock && !isExecutionCancelled) {
                                        await executeBlockPlay(nextBlock, eventFlowId);
                                        nextBlock = nextBlock.getNextBlock();
                                    }

                                    // Log stop
                                    logExecutionToSession(sessionIndex, `<span style="background:#e3f2fd;padding:2px 8px;border-radius:4px;display:inline-block;">üëÜ ${currentLanguage === 'tr' ? '‚èπÔ∏è Durduruldu' : '‚èπÔ∏è Stopped'}</span>`);

                                    // End the session
                                    endExecutionSessionByIndex(sessionIndex);
                                } catch (e) {
                                    console.error("Error in event execution", e);
                                } finally {
                                    activeEventBlocks.delete(block.id);
                                }
                            })();
                        }
                    }
                }

                // when_message_received bloklarƒ±
                // (Bu bloklar message g√∂nderildiƒüinde tetiklenir, ayrƒ±ca y√∂netilir)

            }, 100);
        }

        // Global scope'a ekle
        window.runCode = runCode;
        window.stopExecution = stopExecution;

        async function executeBlockPlay(block, flowId = null, depth = 0) {
            if (!block || isExecutionCancelled) return;

            // Use passed flowId or fall back to global currentFlowId
            const myFlowId = flowId !== null ? flowId : currentFlowId;

            const blockType = block.type;

            // Note: We only log meaningful actions, not every block type

            // Wait bloƒüu - ger√ßek bekleme
            if (blockType === 'wait') {
                // ValueInput'tan baƒülƒ± bloƒüun deƒüerini al
                const secondsBlock = block.getInputTargetBlock('SECONDS');
                let seconds = 1; // varsayƒ±lan
                if (secondsBlock) {
                    // Recursively execute to get value (handles variables, math blocks, etc.)
                    const val = await executeBlockPlay(secondsBlock, myFlowId, depth + 1);
                    seconds = parseFloat(val);
                    if (isNaN(seconds)) seconds = 1;
                }
                console.log(`‚è±Ô∏è ${seconds} saniye bekleniyor...`);
                logExecution(currentLanguage === 'tr' ? `‚è±Ô∏è <b>${seconds}sn</b> bekle` : `‚è±Ô∏è Wait <b>${seconds}s</b>`, myFlowId, depth);
                // Wait sƒ±rasƒ±nda da iptal kontrol√º i√ßin d√∂ng√ºl√º bekleme
                const steps = seconds * 10;
                for (let i = 0; i < steps; i++) {
                    if (isExecutionCancelled) return;
                    await sleep(100);
                }
                console.log(`‚è±Ô∏è ${seconds} saniye bekleme tamamlandƒ±`);
                return;
            }

            // Repeat bloƒüu - d√∂ng√º
            if (blockType === 'repeat') {
                const timesBlock = block.getInputTargetBlock('TIMES');
                let times = 10; // varsayƒ±lan
                if (timesBlock) {
                    times = await executeBlockPlay(timesBlock, myFlowId);
                }
                const doBlock = block.getInputTargetBlock('DO');

                console.log(`üîÑ ${times} kez tekrarlanƒ±yor...`);
                logExecution(currentLanguage === 'tr' ? `üîÑ <b>${times}</b> kez tekrarla` : `üîÑ Repeat <b>${times}</b> times`, myFlowId, depth);
                for (let i = 0; i < times; i++) {
                    if (isExecutionCancelled) break;

                    // Show remaining loops nicely
                    const remaining = times - i;
                    if (i > 0) { // Don't log on first iteration, avoiding clutter
                        logExecution(currentLanguage === 'tr'
                            ? `<span style="color:#666;">üîÑ <b>${remaining}</b> d√∂ng√º kaldƒ±</span>`
                            : `<span style="color:#666;">üîÑ <b>${remaining}</b> ${remaining === 1 ? 'loop' : 'loops'} remaining</span>`, myFlowId, depth);
                    }

                    let innerBlock = doBlock;
                    while (innerBlock) {
                        if (isExecutionCancelled) break;
                        await executeBlockPlay(innerBlock, myFlowId, depth + 1);
                        innerBlock = innerBlock.getNextBlock();
                    }
                }

                logExecution(currentLanguage === 'tr'
                    ? `<span style="color:#888;">üîÑ D√∂ng√º bitti</span>`
                    : `<span style="color:#888;">üîÑ Loop finished</span>`, myFlowId, depth);
                return;
            }

            // If-then bloƒüu
            if (blockType === 'if_then') {
                const conditionBlock = block.getInputTargetBlock('CONDITION');
                const doBlock = block.getInputTargetBlock('DO');

                // Ko≈üulu deƒüerlendir
                let conditionTrue = false;
                let conditionName = '';
                if (conditionBlock) {
                    const result = await executeBlockPlay(conditionBlock, myFlowId, depth + 1);
                    conditionTrue = Boolean(result);
                    // Get human-readable condition name
                    const condType = conditionBlock.type;
                    if (condType === 'rgb_red_light_get') conditionName = currentLanguage === 'tr' ? 'Kƒ±rmƒ±zƒ± ƒ±≈üƒ±k' : 'Red light';
                    else if (condType === 'rgb_green_light_get') conditionName = currentLanguage === 'tr' ? 'Ye≈üil ƒ±≈üƒ±k' : 'Green light';
                    else if (condType === 'rgb_blue_light_get') conditionName = currentLanguage === 'tr' ? 'Mavi ƒ±≈üƒ±k' : 'Blue light';
                    else if (condType === 'rgb_red_button_get') conditionName = currentLanguage === 'tr' ? 'Kƒ±rmƒ±zƒ± buton' : 'Red button';
                    else if (condType === 'rgb_green_button_get') conditionName = currentLanguage === 'tr' ? 'Ye≈üil buton' : 'Green button';
                    else if (condType === 'rgb_blue_button_get') conditionName = currentLanguage === 'tr' ? 'Mavi buton' : 'Blue button';
                    else if (condType === 'logic_compare') conditionName = currentLanguage === 'tr' ? 'Kar≈üƒ±la≈ütƒ±rma' : 'Comparison';
                    else if (condType === 'logic_and') conditionName = currentLanguage === 'tr' ? 'VE ko≈üulu' : 'AND condition';
                    else if (condType === 'logic_or') conditionName = currentLanguage === 'tr' ? 'VEYA ko≈üulu' : 'OR condition';
                    else if (condType === 'logic_negate') conditionName = currentLanguage === 'tr' ? 'DEƒûƒ∞L ko≈üulu' : 'NOT condition';
                    else conditionName = currentLanguage === 'tr' ? 'Ko≈üul' : 'Condition';
                }

                return isUp;
            }

            // Force Sensor - is pressed?
            else if (blockType === 'force_sensor_is_pressed') {
                const port = block.getFieldValue('PORT');
                const state = block.getFieldValue('STATE');

                const portData = port === 'A' ? spikeHubState.portA : spikeHubState.portB;
                let force = 0; // 0-100 (decinewtons)

                // Only read if it appears to be a Force Sensor
                if (portData && portData.type === 0x003F) {
                    force = portData.value || 0;
                }

                if (state === 'PRESSED') {
                    // Pressed: > 0 (using a small threshold of 2dN = 0.2N to avoid noise)
                    return force > 2;
                } else if (state === 'HARD_PRESSED') {
                    // Hard pressed: > 50dN (5N)
                    return force > 50;
                } else if (state === 'RELEASED') {
                    // Released: <= 2dN
                    return force <= 2;
                }
                return false;
            }

            // Force Sensor - pressure
            else if (blockType === 'force_sensor_pressure') {
                const port = block.getFieldValue('PORT');
                const unit = block.getFieldValue('UNIT');

                const portData = port === 'A' ? spikeHubState.portA : spikeHubState.portB;
                let force = 0; // 0-100 (decinewtons)

                if (portData && portData.type === 0x003F) {
                    force = portData.value || 0;
                }

                if (unit === 'NEWTON') {
                    return parseFloat((force / 10).toFixed(1));
                } else {
                    // Percentage (since max is 10N = 100dN, force is already 0-100%)
                    return force;
                }
            }

            // Matrix Turn ON
            else if (blockType === 'matrix_turn_on') {
                const port = block.getFieldValue('PORT');
                const patternStr = block.getFieldValue('PATTERN') || '0,0,0,0,0,0,0,0,0';
                const pixels = patternStr.split(',').map(Number);
                await setSpikeMatrix(port, pixels);
            } else if (blockType === 'matrix_turn_off') {
                const port = block.getFieldValue('PORT');
                await setSpikeMatrix(port, [0, 0, 0, 0, 0, 0, 0, 0, 0]);
            } else if (blockType === 'matrix_set_brightness') {
                const port = block.getFieldValue('PORT');
                const brightnessBlock = block.getInputTargetBlock('BRIGHTNESS');
                let brightness = 100;
                if (brightnessBlock) {
                    const val = await executeBlockPlay(brightnessBlock, flowId);
                    brightness = val !== null ? val : 100;
                }
                const bVal = Math.min(100, Math.max(0, Number(brightness)));
                await setSpikeMatrixBrightness(port, bVal);
            } else if (blockType === 'matrix_set_pixel_at') {
                const port = block.getFieldValue('PORT');
                const x = parseInt(block.getFieldValue('X'));
                const y = parseInt(block.getFieldValue('Y'));
                const color = parseInt(block.getFieldValue('COLOR'));

                const brBlock = block.getInputTargetBlock('BRIGHTNESS');
                let br = 100;
                if (brBlock) {
                    const val = await executeBlockPlay(brBlock, flowId);
                    br = val !== null ? val : 100;
                }
                const brightness = Math.round((Math.max(0, Math.min(100, Number(br))) / 100) * 10); // 0-10

                // Update specific pixel
                if (spikeHubState.matrix && spikeHubState.matrix[port]) {
                    const pixels = [...spikeHubState.matrix[port].pixels];
                    const idx = (y - 1) * 3 + (x - 1);
                    // Use Object format
                    pixels[idx] = { color: color, brightness: brightness };
                    await setSpikeMatrix(port, pixels);
                }

            } else if (blockType === 'matrix_rotate_pattern') {
                const port = block.getFieldValue('PORT');
                const dir = block.getFieldValue('DIRECTION');

                if (spikeHubState.matrix && spikeHubState.matrix[port]) {
                    const old = spikeHubState.matrix[port].pixels;
                    const newP = new Array(9);
                    // Rotations
                    if (dir === 'CW') {
                        newP[0] = old[6]; newP[1] = old[3]; newP[2] = old[0];
                        newP[3] = old[7]; newP[4] = old[4]; newP[5] = old[1];
                        newP[6] = old[8]; newP[7] = old[5]; newP[8] = old[2];
                    } else { // CCW
                        newP[0] = old[2]; newP[1] = old[5]; newP[2] = old[8];
                        newP[3] = old[1]; newP[4] = old[4]; newP[5] = old[7];
                        newP[6] = old[0]; newP[7] = old[3]; newP[8] = old[6];
                    }
                    await setSpikeMatrix(port, newP);
                }
            }

            else if (blockType === 'controls_if') {
                const conditionBlock = block.getInputTargetBlock('IF0');
                const conditionTrue = conditionBlock ? await executeBlockPlay(conditionBlock, myFlowId, depth + 1) : false;
                const doBlock = block.getInputTargetBlock('DO0');

                // Get variable based name if condition is a variable
                let conditionName = 'Condition';
                if (conditionBlock && conditionBlock.type === 'variables_get') {
                    conditionName = conditionBlock.getFieldValue('VAR');
                } else if (conditionBlock && conditionBlock.type === 'compare_values') {
                    conditionName = 'Comparison';
                }

                console.log('üî∂ If ko≈üulu kontrol ediliyor...', conditionTrue);
                if (conditionTrue) {
                    console.log('‚úÖ Ko≈üul doƒüru, then bloƒüu √ßalƒ±≈ütƒ±rƒ±lƒ±yor');
                    logExecution(currentLanguage === 'tr'
                        ? `<span style="color:#4CAF50;">‚úÖ</span> ${conditionName} <b>doƒüru</b>, √ßalƒ±≈ütƒ±rƒ±lƒ±yor`
                        : `<span style="color:#4CAF50;">‚úÖ</span> ${conditionName} is <b>true</b>, executing`, myFlowId, depth);
                    let innerBlock = doBlock;
                    while (innerBlock) {
                        if (isExecutionCancelled) break;
                        await executeBlockPlay(innerBlock, myFlowId, depth + 1);
                        innerBlock = innerBlock.getNextBlock();
                    }
                } else {
                    console.log('‚ùå Ko≈üul yanlƒ±≈ü, atlanƒ±yor');
                    logExecution(currentLanguage === 'tr'
                        ? `<span style="color:#f44336;">‚ùå</span> ${conditionName} <b>yanlƒ±≈ü</b>, atlanƒ±yor`
                        : `<span style="color:#f44336;">‚ùå</span> ${conditionName} is <b>false</b>, skipping`, myFlowId, depth);
                }
                return;
            }

            // If-then-else bloƒüu
            if (blockType === 'if_then_else') {
                const conditionBlock = block.getInputTargetBlock('CONDITION');
                const doBlock = block.getInputTargetBlock('DO');
                const elseBlock = block.getInputTargetBlock('ELSE');

                // Ko≈üulu deƒüerlendir
                let conditionTrue = false;
                let conditionName = '';
                if (conditionBlock) {
                    const result = await executeBlockPlay(conditionBlock, myFlowId);
                    conditionTrue = Boolean(result);
                    // Get human-readable condition name
                    const condType = conditionBlock.type;
                    if (condType === 'rgb_red_light_get') conditionName = currentLanguage === 'tr' ? 'Kƒ±rmƒ±zƒ± ƒ±≈üƒ±k' : 'Red light';
                    else if (condType === 'rgb_green_light_get') conditionName = currentLanguage === 'tr' ? 'Ye≈üil ƒ±≈üƒ±k' : 'Green light';
                    else if (condType === 'rgb_blue_light_get') conditionName = currentLanguage === 'tr' ? 'Mavi ƒ±≈üƒ±k' : 'Blue light';
                    else if (condType === 'rgb_red_button_get') conditionName = currentLanguage === 'tr' ? 'Kƒ±rmƒ±zƒ± buton' : 'Red button';
                    else if (condType === 'rgb_green_button_get') conditionName = currentLanguage === 'tr' ? 'Ye≈üil buton' : 'Green button';
                    else if (condType === 'rgb_blue_button_get') conditionName = currentLanguage === 'tr' ? 'Mavi buton' : 'Blue button';
                    else if (condType === 'logic_compare') conditionName = currentLanguage === 'tr' ? 'Kar≈üƒ±la≈ütƒ±rma' : 'Comparison';
                    else if (condType === 'logic_and') conditionName = currentLanguage === 'tr' ? 'VE ko≈üulu' : 'AND condition';
                    else if (condType === 'logic_or') conditionName = currentLanguage === 'tr' ? 'VEYA ko≈üulu' : 'OR condition';
                    else if (condType === 'logic_negate') conditionName = currentLanguage === 'tr' ? 'DEƒûƒ∞L ko≈üulu' : 'NOT condition';
                    else conditionName = currentLanguage === 'tr' ? 'Ko≈üul' : 'Condition';
                }

                console.log('üî∂ If-else ko≈üulu kontrol ediliyor...', conditionTrue);
                if (conditionTrue) {
                    console.log('‚úÖ Ko≈üul doƒüru, then bloƒüu √ßalƒ±≈ütƒ±rƒ±lƒ±yor');
                    logExecution(currentLanguage === 'tr'
                        ? `<span style="color:#4CAF50;">‚úÖ</span> ${conditionName} <b>doƒüru</b>, then √ßalƒ±≈ütƒ±rƒ±lƒ±yor`
                        : `<span style="color:#4CAF50;">‚úÖ</span> ${conditionName} is <b>true</b>, executing then`, myFlowId, depth);
                    let innerBlock = doBlock;
                    while (innerBlock) {
                        if (isExecutionCancelled) break;
                        await executeBlockPlay(innerBlock, myFlowId, depth + 1);
                        innerBlock = innerBlock.getNextBlock();
                    }
                } else {
                    console.log('‚ùå Ko≈üul yanlƒ±≈ü, else bloƒüu √ßalƒ±≈ütƒ±rƒ±lƒ±yor');
                    logExecution(currentLanguage === 'tr'
                        ? `<span style="color:#f44336;">‚ùå</span> ${conditionName} <b>yanlƒ±≈ü</b>, else √ßalƒ±≈ütƒ±rƒ±lƒ±yor`
                        : `<span style="color:#f44336;">‚ùå</span> ${conditionName} is <b>false</b>, executing else`, myFlowId, depth);
                    let innerBlock = elseBlock;
                    while (innerBlock) {
                        if (isExecutionCancelled) break;
                        await executeBlockPlay(innerBlock, myFlowId, depth + 1);
                        innerBlock = innerBlock.getNextBlock();
                    }
                }
                return;
            }

            // Wait until bloƒüu
            if (blockType === 'wait_until') {
                console.log('‚è≥ Wait until - ko≈üul bekleniyor...');
                // Basitle≈ütirilmi≈ü: 1 saniye bekle
                await sleep(1000);
                console.log('‚úÖ Wait until tamamlandƒ±');
                return;
            }

            // Repeat until bloƒüu - ko≈üul saƒülanana kadar tekrarla
            if (blockType === 'repeat_until') {
                const conditionBlock = block.getInputTargetBlock('CONDITION');
                const doBlock = block.getInputTargetBlock('DO');

                console.log('üîÅ Repeat until ba≈üladƒ±...');

                // Determine condition name for logging
                let conditionName = currentLanguage === 'tr' ? 'ko≈üul' : 'condition';
                if (conditionBlock) {
                    const condType = conditionBlock.type;
                    if (condType === 'rgb_red_light_get') conditionName = currentLanguage === 'tr' ? 'kƒ±rmƒ±zƒ± ƒ±≈üƒ±k yanana' : 'until red light is on';
                    else if (condType === 'rgb_green_light_get') conditionName = currentLanguage === 'tr' ? 'ye≈üil ƒ±≈üƒ±k yanana' : 'until green light is on';
                    else if (condType === 'rgb_blue_light_get') conditionName = currentLanguage === 'tr' ? 'mavi ƒ±≈üƒ±k yanana' : 'until blue light is on';
                    else if (condType === 'rgb_red_button_get') conditionName = currentLanguage === 'tr' ? 'kƒ±rmƒ±zƒ± butona basƒ±lana' : 'until red button is pressed';
                    else if (condType === 'rgb_green_button_get') conditionName = currentLanguage === 'tr' ? 'ye≈üil butona basƒ±lana' : 'until green button is pressed';
                    else if (condType === 'rgb_blue_button_get') conditionName = currentLanguage === 'tr' ? 'mavi butona basƒ±lana' : 'until blue button is pressed';
                    else conditionName = currentLanguage === 'tr' ? 'ko≈üul saƒülanana' : 'until condition is true';
                }

                // Maksimum 1000 iterasyon (sonsuz d√∂ng√º korumasƒ±)
                for (let i = 0; i < 1000; i++) {
                    // Ko≈üulu kontrol et
                    let conditionMet = false;
                    if (conditionBlock) {
                        const result = await executeBlockPlay(conditionBlock, myFlowId, depth + 1);
                        conditionMet = Boolean(result);
                    }

                    if (conditionMet) {
                        console.log('üîÅ Repeat until ko≈üul saƒülandƒ±, √ßƒ±kƒ±lƒ±yor');
                        logExecution(currentLanguage === 'tr'
                            ? `üîÅ ${conditionName} kadar tekrarla tamamlandƒ±`
                            : `üîÅ Repeat ${conditionName} finished`, myFlowId, depth);
                        break;
                    }

                    if (i === 0) {
                        logExecution(currentLanguage === 'tr'
                            ? `üîÅ ${conditionName} kadar tekrarla`
                            : `üîÅ Repeat ${conditionName}`, myFlowId, depth);
                    }

                    // ƒ∞√ß bloklarƒ± √ßalƒ±≈ütƒ±r
                    let innerBlock = doBlock;
                    while (innerBlock) {
                        if (isExecutionCancelled) break;
                        await executeBlockPlay(innerBlock, myFlowId, depth + 1);
                        innerBlock = innerBlock.getNextBlock();
                    }

                    // Her iterasyonda k√º√ß√ºk bir bekleme
                    await sleep(50);
                    if (isExecutionCancelled) break;
                }
                console.log('üîÅ Repeat until tamamlandƒ±');
                return;
            }

            // Forever bloƒüu - sonsuz d√∂ng√º (≈üimdilik 100 kez)
            if (blockType === 'forever') {
                const doBlock = block.getInputTargetBlock('DO');
                console.log('‚ôæÔ∏è S√ºrekli d√∂ng√º ba≈üladƒ± (100 iterasyon)...');
                logExecution(currentLanguage === 'tr'
                    ? `‚ôæÔ∏è S√ºrekli tekrarla`
                    : `‚ôæÔ∏è Forever loop`, myFlowId, depth);

                for (let i = 0; i < 100; i++) {
                    if (isExecutionCancelled) break;
                    let innerBlock = doBlock;
                    while (innerBlock) {
                        if (isExecutionCancelled) break;
                        await executeBlockPlay(innerBlock, myFlowId, depth + 1);
                        innerBlock = innerBlock.getNextBlock();
                    }
                    // Prevent tight loop freezing
                    await sleep(20);
                }
                return;
            }

            // RGB LED kontrolleri
            if (blockType === 'rgb_red_on') {
                rgbLedState.red = true;
                document.getElementById('rgbRedLed').classList.add('active');
                logLedValue('red', 255);
                console.log('üî¥ Kƒ±rmƒ±zƒ± LED yandƒ±');
                logExecution(currentLanguage === 'tr' ? `<span style="display:inline-block;width:12px;height:12px;background:#ff0000;border-radius:50%;vertical-align:middle;"></span> Kƒ±rmƒ±zƒ± LED Yandƒ±` : `<span style="display:inline-block;width:12px;height:12px;background:#ff0000;border-radius:50%;vertical-align:middle;"></span> Red LED On`, myFlowId, depth);
            } else if (blockType === 'rgb_green_on') {
                rgbLedState.green = true;
                document.getElementById('rgbGreenLed').classList.add('active');
                logLedValue('green', 255);
                console.log('üü¢ Ye≈üil LED yandƒ±');
                logExecution(currentLanguage === 'tr' ? `<span style="display:inline-block;width:12px;height:12px;background:#00ff00;border-radius:50%;vertical-align:middle;"></span> Ye≈üil LED Yandƒ±` : `<span style="display:inline-block;width:12px;height:12px;background:#00ff00;border-radius:50%;vertical-align:middle;"></span> Green LED On`, myFlowId, depth);
            } else if (blockType === 'rgb_blue_on') {
                rgbLedState.blue = true;
                document.getElementById('rgbBlueLed').classList.add('active');
                logLedValue('blue', 255);
                console.log('üîµ Mavi LED yandƒ±');
                logExecution(currentLanguage === 'tr' ? `<span style="display:inline-block;width:12px;height:12px;background:#0066ff;border-radius:50%;vertical-align:middle;"></span> Mavi LED Yandƒ±` : `<span style="display:inline-block;width:12px;height:12px;background:#0066ff;border-radius:50%;vertical-align:middle;"></span> Blue LED On`, myFlowId, depth);
            } else if (blockType === 'rgb_red_off') {
                rgbLedState.red = false;
                document.getElementById('rgbRedLed').classList.remove('active');
                logLedValue('red', 0);
                console.log('‚≠ï Kƒ±rmƒ±zƒ± LED s√∂nd√º');
                logExecution(currentLanguage === 'tr' ? `<span style="display:inline-block;width:12px;height:12px;border:2px solid #ff0000;border-radius:50%;vertical-align:middle;"></span> Kƒ±rmƒ±zƒ± LED S√∂nd√º` : `<span style="display:inline-block;width:12px;height:12px;border:2px solid #ff0000;border-radius:50%;vertical-align:middle;"></span> Red LED Off`, myFlowId, depth);
            } else if (blockType === 'rgb_green_off') {
                rgbLedState.green = false;
                document.getElementById('rgbGreenLed').classList.remove('active');
                logLedValue('green', 0);
                console.log('‚≠ï Ye≈üil LED s√∂nd√º');
                logExecution(currentLanguage === 'tr' ? `<span style="display:inline-block;width:12px;height:12px;border:2px solid #00ff00;border-radius:50%;vertical-align:middle;"></span> Ye≈üil LED S√∂nd√º` : `<span style="display:inline-block;width:12px;height:12px;border:2px solid #00ff00;border-radius:50%;vertical-align:middle;"></span> Green LED Off`, myFlowId, depth);
            } else if (blockType === 'rgb_blue_off') {
                rgbLedState.blue = false;
                document.getElementById('rgbBlueLed').classList.remove('active');
                logLedValue('blue', 0);
                console.log('‚≠ï Mavi LED s√∂nd√º');
                logExecution(currentLanguage === 'tr' ? `<span style="display:inline-block;width:12px;height:12px;border:2px solid #0066ff;border-radius:50%;vertical-align:middle;"></span> Mavi LED S√∂nd√º` : `<span style="display:inline-block;width:12px;height:12px;border:2px solid #0066ff;border-radius:50%;vertical-align:middle;"></span> Blue LED Off`, myFlowId, depth);
            }

            // RGB sayƒ± kontrolleri
            else if (blockType === 'rgb_red_num') {
                const numBlock = block.getInputTargetBlock('NUM');
                const numValue = numBlock ? await executeBlockPlay(numBlock, myFlowId) : 0;
                rgbNumberState.red = numValue;
                document.getElementById('rgbRedNum').textContent = numValue;
                logNumberValue('red', numValue);
                console.log('üü• Kƒ±rmƒ±zƒ± sayƒ±:', numValue);
                logExecution(`<span style="display:inline-block;width:12px;height:12px;background:#ff0000;vertical-align:middle;border-radius:2px;"></span> ${currentLanguage === 'tr' ? `Kƒ±rmƒ±zƒ± sayƒ± <b>${numValue}</b> yapƒ±ldƒ±` : `Red number set to <b>${numValue}</b>`}`, myFlowId, depth);
            } else if (blockType === 'rgb_green_num') {
                const numBlock = block.getInputTargetBlock('NUM');
                const numValue = numBlock ? await executeBlockPlay(numBlock, myFlowId) : 0;
                rgbNumberState.green = numValue;
                document.getElementById('rgbGreenNum').textContent = numValue;
                logNumberValue('green', numValue);
                console.log('üü© Ye≈üil sayƒ±:', numValue);
                logExecution(`<span style="display:inline-block;width:12px;height:12px;background:#00ff00;vertical-align:middle;border-radius:2px;"></span> ${currentLanguage === 'tr' ? `Ye≈üil sayƒ± <b>${numValue}</b> yapƒ±ldƒ±` : `Green number set to <b>${numValue}</b>`}`, myFlowId, depth);
            } else if (blockType === 'rgb_blue_num') {
                const numBlock = block.getInputTargetBlock('NUM');
                const numValue = numBlock ? await executeBlockPlay(numBlock, myFlowId) : 0;
                rgbNumberState.blue = numValue;
                document.getElementById('rgbBlueNum').textContent = numValue;
                logNumberValue('blue', numValue);
                console.log('üü¶ Mavi sayƒ±:', numValue);
                logExecution(`<span style="display:inline-block;width:12px;height:12px;background:#0066ff;vertical-align:middle;border-radius:2px;"></span> ${currentLanguage === 'tr' ? `Mavi sayƒ± <b>${numValue}</b> yapƒ±ldƒ±` : `Blue number set to <b>${numValue}</b>`}`, myFlowId, depth);
            }

            // RGB sayƒ± getir kontrolleri
            else if (blockType === 'rgb_red_get') {
                console.log('üü• Kƒ±rmƒ±zƒ± sayƒ± getir:', rgbNumberState.red);
                return rgbNumberState.red;
            } else if (blockType === 'rgb_green_get') {
                console.log('üü© Ye≈üil sayƒ± getir:', rgbNumberState.green);
                return rgbNumberState.green;
            } else if (blockType === 'rgb_blue_get') {
                console.log('üü¶ Mavi sayƒ± getir:', rgbNumberState.blue);
                return rgbNumberState.blue;
            }

            // RGB ƒ±≈üƒ±k getir kontrolleri
            else if (blockType === 'rgb_red_light_get') {
                console.log('üî¥ Kƒ±rmƒ±zƒ± ƒ±≈üƒ±k getir:', rgbLedState.red);
                return rgbLedState.red;
            } else if (blockType === 'rgb_green_light_get') {
                console.log('üü¢ Ye≈üil ƒ±≈üƒ±k getir:', rgbLedState.green);
                return rgbLedState.green;
            } else if (blockType === 'rgb_blue_light_get') {
                console.log('üîµ Mavi ƒ±≈üƒ±k getir:', rgbLedState.blue);
                return rgbLedState.blue;
            }

            // RGB tu≈ü getir kontrolleri
            else if (blockType === 'rgb_red_button_get') {
                console.log('üî∫ Kƒ±rmƒ±zƒ± tu≈ü getir:', btnStates.red);
                return btnStates.red;
            } else if (blockType === 'rgb_green_button_get') {
                console.log('üî∫ Ye≈üil tu≈ü getir:', btnStates.green);
                return btnStates.green;
            } else if (blockType === 'rgb_blue_button_get') {
                console.log('üî∫ Mavi tu≈ü getir:', btnStates.blue);
                return btnStates.blue;
            }

            // Motor kontrolleri
            else if (blockType === 'motor_run_rotation') {
                const dir = block.getFieldValue('DIRECTION');
                const rot = block.getFieldValue('ROTATIONS');
                console.log(`üîÑ Motor ${dir === 'CW' ? '‚Üª' : '‚Ü∫'} ${rot} rotasyon`);

                // Bluetooth motor kontrol√º
                const deviceId = block.data;
                console.log('DEBUG: deviceId =', deviceId);
                console.log('DEBUG: block =', block);
                console.log('DEBUG: block.data =', block.data);

                if (deviceId) {
                    console.log('‚úÖ deviceId var, runMotorRotations √ßaƒürƒ±lƒ±yor...');
                    await runMotorRotations(deviceId, parseInt(rot), dir);
                } else {
                    console.log('‚ùå deviceId yok! Motor Bluetooth komutu g√∂nderilemedi.');
                    console.log('   Motor cihazƒ±nƒ± √∂nce baƒülayƒ±n ve bloƒüu motor ikonundan s√ºr√ºkleyin.');
                }
                return; // Motor run_rotation i≈ülemi tamamlandƒ±
            } else if (blockType === 'motor_run_to_angle') {
                const dir = block.getFieldValue('DIRECTION');
                const angle = block.getFieldValue('ANGLE');
                console.log(`üéØ Motor ${dir === 'CW' ? '‚Üª' : '‚Ü∫'} ${angle}¬∞ a√ßƒ±ya git (g√∂receli)`);

                // Bluetooth motor kontrol√º
                const deviceId = block.data;
                console.log('DEBUG: deviceId =', deviceId);

                if (deviceId) {
                    console.log('‚úÖ deviceId var, runMotorToAngle √ßaƒürƒ±lƒ±yor...');
                    await runMotorToAngle(deviceId, parseInt(angle), dir);
                } else {
                    console.log('‚ùå deviceId yok! Motor Bluetooth komutu g√∂nderilemedi.');
                }
                return; // Motor run_to_angle i≈ülemi tamamlandƒ±
            } else if (blockType === 'motor_go_to_position') {
                const position = block.getFieldValue('POSITION');
                console.log(`üìç Motor ${position}¬∞ pozisyonuna git (mutlak)`);

                // Bluetooth motor kontrol√º
                const deviceId = block.data;
                if (deviceId) {
                    await goToPosition(deviceId, parseInt(position));
                } else {
                    console.log('‚ùå deviceId yok!');
                }
                return; // Motor go_to_position i≈ülemi tamamlandƒ±
            } else if (blockType === 'motor_start') {
                const dir = block.getFieldValue('DIRECTION');
                console.log(`‚ñ∂Ô∏è Motor ${dir === 'CW' ? '‚Üª' : '‚Ü∫'} ba≈ülatƒ±ldƒ±`);

                // Bluetooth motor kontrol√º
                const deviceId = block.data;
                if (deviceId) {
                    await startMotor(deviceId, dir);
                } else {
                    console.log('‚ùå deviceId yok!');
                }
                return; // Motor start i≈ülemi tamamlandƒ±
            } else if (blockType === 'motor_stop') {
                console.log('‚èπÔ∏è Motor durduruldu');

                // Bluetooth motor kontrol√º
                const deviceId = block.data;
                if (deviceId) {
                    await stopMotor(deviceId);
                } else {
                    console.log('‚ùå deviceId yok!');
                }
                return; // Motor stop i≈ülemi tamamlandƒ±
            }

            // Hub LED Color block
            else if (blockType === 'hub_led_color') {
                const colorName = block.getFieldValue('COLOR');
                console.log(`üí° Hub LED Color: ${colorName}`);

                // Map color name to LEGO color index
                const colorMap = {
                    'OFF': 0,
                    'PINK': 1,
                    'PURPLE': 2,
                    'BLUE': 3,
                    'LIGHT_BLUE': 4,
                    'CYAN': 5,
                    'GREEN': 6,
                    'YELLOW': 7,
                    'ORANGE': 8,
                    'RED': 9,
                    'WHITE': 10
                };
                const colorIndex = colorMap[colorName] ?? 3; // Default to blue

                // Use the existing setHubLedColor function
                if (spikeHubState.writeChar) {
                    await setHubLedColor(colorIndex);
                } else {
                    console.log('‚ùå Spike Hub writeChar not available');
                }
                return;
            }

            // Hub Orientation block (is face up?)
            else if (blockType === 'hub_orientation') {
                const orientation = block.getFieldValue('ORIENTATION');
                const tilt = spikeHubState.tilt || { yaw: 0, pitch: 0, roll: 0 };
                const pitch = tilt.pitch || 0;
                const roll = tilt.roll || 0;

                // Threshold for orientation detection (degrees)
                const THRESHOLD = 45;
                let isUp = false;

                switch (orientation) {
                    case 'TOP':
                        // Flat, facing up: pitch and roll close to 0
                        isUp = Math.abs(pitch) < THRESHOLD && Math.abs(roll) < THRESHOLD;
                        break;
                    case 'BOTTOM':
                        // Upside down: pitch close to ¬±180
                        isUp = Math.abs(pitch) > 135 || Math.abs(roll) > 135;
                        break;
                    case 'FRONT':
                        // Front side up: positive pitch
                        isUp = pitch > THRESHOLD && Math.abs(roll) < THRESHOLD;
                        break;
                    case 'BACK':
                        // Back side up: negative pitch
                        isUp = pitch < -THRESHOLD && Math.abs(roll) < THRESHOLD;
                        break;
                    case 'RIGHT':
                        // Right side up: positive roll
                        isUp = roll > THRESHOLD && Math.abs(pitch) < THRESHOLD;
                        break;
                    case 'LEFT':
                        // Left side up: negative roll
                        isUp = roll < -THRESHOLD && Math.abs(pitch) < THRESHOLD;
                        break;
                }

                console.log(`üìê Hub orientation: ${orientation} up? ${isUp} (pitch: ${pitch}, roll: ${roll})`);
                return isUp;
            }

            // Matematik bloklarƒ±
            else if (blockType === 'math_number') {
                const num = parseFloat(block.getFieldValue('NUM'));
                return num;
            } else if (blockType === 'math_random') {
                const fromBlock = block.getInputTargetBlock('FROM');
                const toBlock = block.getInputTargetBlock('TO');
                const from = fromBlock ? await executeBlockPlay(fromBlock, myFlowId) : 1;
                const to = toBlock ? await executeBlockPlay(toBlock, myFlowId) : 10;
                return Math.floor(Math.random() * (to - from + 1)) + from;
            } else if (blockType === 'math_arithmetic') {
                const op = block.getFieldValue('OP');
                const aBlock = block.getInputTargetBlock('A');
                const bBlock = block.getInputTargetBlock('B');
                const a = aBlock ? await executeBlockPlay(aBlock, myFlowId) : 0;
                const b = bBlock ? await executeBlockPlay(bBlock, myFlowId) : 0;

                let result = 0;
                switch (op) {
                    case 'ADD': result = a + b; break;
                    case 'MINUS': result = a - b; break;
                    case 'MULTIPLY': result = a * b; break;
                    case 'DIVIDE': result = a / b; break;
                    case 'POWER': result = Math.pow(a, b); break;
                    case 'MOD': result = a % b; break;
                }
                return result;
            }

            // Controller kontrolleri
            else if (blockType === 'lever_angle') {
                const lever = block.getFieldValue('LEVER');
                let angle = 50; // Varsayƒ±lan deƒüer (orta pozisyon)

                if (lever === 'LEFT') {
                    angle = Math.round(controllerState.leftPercent || 50);
                } else if (lever === 'RIGHT') {
                    angle = Math.round(controllerState.rightPercent || 50);
                }

                console.log(`üïπÔ∏è Lever angle ${lever}: ${angle}%`);
                return angle;
            }
            else if (blockType === 'when_lever_position') {
                const lever = block.getFieldValue('LEVER');
                const position = block.getFieldValue('POSITION');
                console.log(`üïπÔ∏è When ${lever} lever is ${position}`);
            } else if (blockType === 'lever_position') {
                const lever = block.getFieldValue('LEVER');
                const position = block.getFieldValue('POSITION');

                // Mevcut controller durumunu kontrol et
                let currentPosition;
                if (lever === 'LEFT') {
                    currentPosition = controllerState.left;
                } else if (lever === 'RIGHT') {
                    currentPosition = controllerState.right;
                } else if (lever === 'ANY') {
                    currentPosition = controllerState.left !== 'RELEASED' ? controllerState.left : controllerState.right;
                } else if (lever === 'BOTH') {
                    if (controllerState.left === controllerState.right) {
                        currentPosition = controllerState.left;
                    } else {
                        currentPosition = 'RELEASED';
                    }
                }

                const result = currentPosition === position;
                console.log(`üïπÔ∏è Checking ${lever} lever is ${position}? Current: ${currentPosition}, Result: ${result}`);
                return result;
            }

            // detecting_color bloƒüu (Color Sensor)
            if (blockType === 'detecting_color') {
                const targetColor = block.getFieldValue('COLOR');
                const currentColor = colorSensorState.detectedColor;
                const result = currentColor === targetColor;
                console.log(`üé® Renk kontrol√º: ${targetColor} algƒ±lanƒ±yor mu? Mevcut: ${currentColor}, Sonu√ß: ${result}`);
                return result;
            }

            // reflection_compare bloƒüu (Color Sensor)
            if (blockType === 'reflection_compare') {
                const op = block.getFieldValue('OP');
                const value = parseFloat(block.getFieldValue('VALUE')) || 50;
                const reflection = colorSensorState.reflection;
                let result = false;

                if (op === 'LT') result = reflection < value;
                else if (op === 'GT') result = reflection > value;
                else if (op === 'EQ') result = reflection === value;

                console.log(`üìä Yansƒ±ma kontrol√º: ${reflection} ${op} ${value}? Sonu√ß: ${result}`);
                return result;
            }

            // Non-boolean block passed to evaluator - silently return false
            return false;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Ko≈üul bloƒüunu deƒüerlendir
        function evaluateCondition(conditionBlock) {
            if (!conditionBlock) return false;

            const blockType = conditionBlock.type;

            // lever_position bloƒüu
            if (blockType === 'lever_position') {
                const lever = conditionBlock.getFieldValue('LEVER');
                const position = conditionBlock.getFieldValue('POSITION');

                // Mevcut controller durumunu kontrol et
                let currentPosition;
                if (lever === 'LEFT') {
                    currentPosition = controllerState.left;
                } else if (lever === 'RIGHT') {
                    currentPosition = controllerState.right;
                } else if (lever === 'ANY') {
                    currentPosition = controllerState.left !== 'RELEASED' ? controllerState.left : controllerState.right;
                } else if (lever === 'BOTH') {
                    // Her iki lever da aynƒ± pozisyonda mƒ±?
                    if (controllerState.left === controllerState.right) {
                        currentPosition = controllerState.left;
                    } else {
                        currentPosition = 'RELEASED';
                    }
                }

                const result = currentPosition === position;
                console.log(`üïπÔ∏è Ko≈üul kontrol√º: ${lever} lever is ${position}? Mevcut: ${currentPosition}, Sonu√ß: ${result}`);
                return result;
            }

            // detecting_color bloƒüu (Color Sensor)
            if (blockType === 'detecting_color') {
                const targetColor = conditionBlock.getFieldValue('COLOR');
                const currentColor = colorSensorState.detectedColor;
                const result = currentColor === targetColor;
                console.log(`üé® Renk kontrol√º: ${targetColor} algƒ±lanƒ±yor mu? Mevcut: ${currentColor}, Sonu√ß: ${result}`);
                return result;
            }

            // reflection_compare bloƒüu (Color Sensor)
            if (blockType === 'reflection_compare') {
                const op = conditionBlock.getFieldValue('OP');
                const value = parseFloat(conditionBlock.getFieldValue('VALUE')) || 50;
                const reflection = colorSensorState.reflection;
                let result = false;

                if (op === 'LT') result = reflection < value;
                else if (op === 'GT') result = reflection > value;
                else if (op === 'EQ') result = reflection === value;

                console.log(`üìä Yansƒ±ma kontrol√º: ${reflection} ${op} ${value}? Sonu√ß: ${result}`);
                return result;
            }

            // Non-boolean block passed to evaluator - silently return false
            return false;
        }

        // Color Sensor value reporter bloklarƒ± i√ßin executeBlockPlay'e eklenecek
        function getColorSensorValue(block) {
            const blockType = block.type;

            if (blockType === 'color_value') {
                return colorSensorState.detectedColor;
            }

            if (blockType === 'reflection_value') {
                return colorSensorState.reflection;
            }

            if (blockType === 'color_hue') {
                const mode = block.getFieldValue('MODE');
                if (mode === 'HUE') return colorSensorState.hue;
                if (mode === 'SAT') return colorSensorState.saturation;
                if (mode === 'VAL') return colorSensorState.value;
            }

            return 0;
        }

        function stopCode() {
            alert(TRANSLATIONS[currentLanguage].alert_stopped);
        }

        // --- EXPORT & IMPORT FUNCTIONS --- //
        function exportWorkspace() {
            try {
                const xml = Blockly.Xml.workspaceToDom(workspace);
                const xmlText = Blockly.Xml.domToText(xml);

                const blob = new Blob([xmlText], { type: 'text/xml' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = 'blockcode_project.xml'; // Varsayƒ±lan dosya adƒ±
                document.body.appendChild(a);
                a.click();

                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                console.log('‚úÖ Workspace exported successfully');
            } catch (e) {
                console.error('‚ùå Export error:', e);
                alert(TRANSLATIONS[currentLanguage].alert_export_error);
            }
        }

        // Bekleyen import verisi
        let pendingImportXml = null;
        let pendingImportInput = null;

        function importWorkspace(input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const xmlText = e.target.result;

                    // XML ge√ßerliliƒüini kontrol et
                    if (!xmlText.trim().startsWith('<xml')) {
                        throw new Error('Dosya ge√ßerli bir Blockly XML dosyasƒ± deƒüil.');
                    }

                    // Blockly 10+ uyumlu XML parsing
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, 'text/xml');

                    // Parse hatasƒ± kontrol√º
                    const parseError = xmlDoc.querySelector('parsererror');
                    if (parseError) {
                        throw new Error('XML parse hatasƒ±: ' + parseError.textContent);
                    }

                    const xml = xmlDoc.documentElement;

                    // Workspace'te blok var mƒ± kontrol et
                    const existingBlocks = workspace.getAllBlocks();
                    if (existingBlocks.length > 0) {
                        // Kullanƒ±cƒ±ya modal ile sor
                        pendingImportXml = xml;
                        pendingImportInput = input;
                        showImportConfirmModal();
                    } else {
                        // Direkt y√ºkle
                        Blockly.Xml.domToWorkspace(xml, workspace);
                        console.log('‚úÖ Workspace imported successfully');
                        input.value = '';
                    }
                } catch (e) {
                    console.error('‚ùå Import error:', e);
                    showImportErrorModal(
                        TRANSLATIONS[currentLanguage].alert_import_error,
                        e.message || 'Bilinmeyen hata'
                    );
                    input.value = '';
                }
            };
            reader.onerror = function () {
                showImportErrorModal(
                    TRANSLATIONS[currentLanguage].alert_import_error,
                    'Dosya okunamadƒ±.'
                );
                input.value = '';
            };
            reader.readAsText(file);
        }

        function showImportConfirmModal() {
            const modal = document.getElementById('importConfirmModal');
            const titleEl = document.getElementById('importConfirmTitle');
            const messageEl = document.getElementById('importConfirmMessage');
            const hintEl = document.getElementById('importConfirmHint');
            const cancelBtn = document.getElementById('importConfirmCancelBtn');
            const okBtn = document.getElementById('importConfirmOkBtn');

            if (currentLanguage === 'tr') {
                titleEl.textContent = 'Dosya Y√ºkleme';
                messageEl.textContent = 'Mevcut bloklarƒ± temizleyip y√ºklensin mi?';
                hintEl.textContent = '(ƒ∞ptal\'e tƒ±klayarak mevcut bloklara ekleyebilirsiniz)';
                cancelBtn.textContent = 'Ekle';
                okBtn.textContent = 'Temizle ve Y√ºkle';
            } else {
                titleEl.textContent = 'Import File';
                messageEl.textContent = 'Clear current workspace before loading?';
                hintEl.textContent = '(Click Append to add to existing blocks)';
                cancelBtn.textContent = 'Append';
                okBtn.textContent = 'Clear & Load';
            }

            modal.classList.add('active');
        }

        function confirmImport(clearWorkspace) {
            const modal = document.getElementById('importConfirmModal');
            modal.classList.remove('active');

            pendingClearWorkspace = clearWorkspace;

            if (pendingImportXml) {
                // XML'den cihaz ID'lerini √ßƒ±kar
                const deviceIds = extractDeviceIdsFromXml(pendingImportXml);
                const unmappedDevices = findUnmappedDevices(deviceIds);

                if (unmappedDevices.length > 0) {
                    // E≈üle≈ütirilmemi≈ü cihazlar var, modal g√∂ster
                    showDeviceMappingModal(unmappedDevices);
                } else {
                    // T√ºm cihazlar mevcut veya cihaz yok, direkt y√ºkle
                    finalizeImport();
                }
            }
        }

        let pendingClearWorkspace = false;
        let pendingDeviceMapping = {};

        function extractDeviceIdsFromXml(xml) {
            const deviceIds = new Set();
            const dataElements = xml.querySelectorAll('data');
            dataElements.forEach(el => {
                const deviceId = el.textContent.trim();
                if (deviceId) {
                    deviceIds.add(deviceId);
                }
            });
            return Array.from(deviceIds);
        }

        function findUnmappedDevices(deviceIds) {
            const unmapped = [];
            const connectedIds = connectedDevices.map(d => d.id);

            deviceIds.forEach(id => {
                if (!connectedIds.includes(id)) {
                    unmapped.push(id);
                }
            });

            return unmapped;
        }

        function showDeviceMappingModal(unmappedDevices) {
            const modal = document.getElementById('deviceMappingModal');
            const titleEl = document.getElementById('deviceMappingTitle');
            const messageEl = document.getElementById('deviceMappingMessage');
            const listEl = document.getElementById('deviceMappingList');
            const skipBtn = document.getElementById('deviceMappingSkipBtn');
            const applyBtn = document.getElementById('deviceMappingApplyBtn');

            // Dili ayarla
            if (currentLanguage === 'tr') {
                titleEl.textContent = 'Cihaz E≈üle≈ütirme';
                messageEl.textContent = 'ƒ∞√ße aktarƒ±lan dosyada baƒülƒ± olmayan cihazlara ait bloklar bulundu. L√ºtfen bu bloklarƒ± mevcut cihazlarla e≈üle≈ütirin:';
                skipBtn.textContent = 'E≈üle≈ütirmeden Devam Et';
                applyBtn.textContent = 'E≈üle≈ütir ve Y√ºkle';
            } else {
                titleEl.textContent = 'Device Mapping';
                messageEl.textContent = 'The imported file contains blocks from devices that are not connected. Please map them to current devices:';
                skipBtn.textContent = 'Skip Mapping';
                applyBtn.textContent = 'Apply & Load';
            }

            // Mapping listesini olu≈ütur
            listEl.innerHTML = '';
            pendingDeviceMapping = {};

            unmappedDevices.forEach((oldId, index) => {
                const row = document.createElement('div');
                row.style.cssText = 'display: flex; align-items: center; gap: 10px; padding: 10px; background: #f8f9fa; border-radius: 8px; margin-bottom: 8px;';

                // Eski cihaz ID'si (kƒ±saltƒ±lmƒ±≈ü)
                const shortId = oldId.substring(0, 8) + '...';
                const oldLabel = document.createElement('div');
                oldLabel.style.cssText = 'flex: 1; font-family: monospace; font-size: 12px; color: #888;';
                oldLabel.textContent = currentLanguage === 'tr' ? `Eski Cihaz #${index + 1}` : `Old Device #${index + 1}`;
                oldLabel.title = oldId;

                // Ok ikonu
                const arrow = document.createElement('span');
                arrow.textContent = '‚Üí';
                arrow.style.cssText = 'color: #4C97FF; font-weight: bold;';

                // Yeni cihaz se√ßimi
                const select = document.createElement('select');
                select.style.cssText = 'flex: 1; padding: 8px; border: 2px solid #ddd; border-radius: 8px; font-size: 14px;';
                select.dataset.oldId = oldId;

                // Bo≈ü se√ßenek
                const emptyOption = document.createElement('option');
                emptyOption.value = '';
                emptyOption.textContent = currentLanguage === 'tr' ? '-- Se√ßiniz --' : '-- Select --';
                select.appendChild(emptyOption);

                // Mevcut cihazlarƒ± listele
                connectedDevices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.id;
                    option.textContent = device.name;
                    option.style.color = device.color;
                    select.appendChild(option);
                });

                row.appendChild(oldLabel);
                row.appendChild(arrow);
                row.appendChild(select);
                listEl.appendChild(row);
            });

            modal.classList.add('active');
        }

        function skipDeviceMapping() {
            const modal = document.getElementById('deviceMappingModal');
            modal.classList.remove('active');
            finalizeImport();
        }

        function applyDeviceMapping() {
            const modal = document.getElementById('deviceMappingModal');
            const selects = modal.querySelectorAll('select');

            // Mapping'leri topla
            selects.forEach(select => {
                const oldId = select.dataset.oldId;
                const newId = select.value;
                if (newId) {
                    pendingDeviceMapping[oldId] = newId;
                }
            });

            // XML'deki data etiketlerini g√ºncelle
            if (Object.keys(pendingDeviceMapping).length > 0) {
                const dataElements = pendingImportXml.querySelectorAll('data');
                dataElements.forEach(el => {
                    const oldId = el.textContent.trim();
                    if (pendingDeviceMapping[oldId]) {
                        el.textContent = pendingDeviceMapping[oldId];
                    }
                });
            }

            modal.classList.remove('active');
            finalizeImport();
        }

        function finalizeImport() {
            if (pendingClearWorkspace) {
                workspace.clear();
            }

            if (pendingImportXml) {
                Blockly.Xml.domToWorkspace(pendingImportXml, workspace);
                console.log('‚úÖ Workspace imported successfully');
            }

            if (pendingImportInput) {
                pendingImportInput.value = '';
            }

            pendingImportXml = null;
            pendingImportInput = null;
            pendingClearWorkspace = false;
            pendingDeviceMapping = {};
        }

        function showImportErrorModal(title, details) {
            const modal = document.getElementById('importErrorModal');
            const titleEl = document.getElementById('importErrorTitle');
            const messageEl = document.getElementById('importErrorMessage');
            const detailsEl = document.getElementById('importErrorDetails');

            if (modal && titleEl && detailsEl) {
                titleEl.textContent = currentLanguage === 'tr' ? 'Dosya Y√ºkleme Hatasƒ±' : 'Import Error';
                messageEl.textContent = title;
                detailsEl.textContent = details;

                // Buton metnini √ßevir
                const okBtn = document.getElementById('importErrorOkBtn');
                if (okBtn) okBtn.textContent = currentLanguage === 'tr' ? 'Tamam' : 'OK';

                modal.classList.add('active');
            }
        }

        function closeImportErrorModal() {
            const modal = document.getElementById('importErrorModal');
            if (modal) modal.classList.remove('active');
        }
        // -------------------------------- //

        function resetEverything() {
            openResetModal();
        }

        function openResetModal() {
            document.getElementById('resetModal').classList.add('active');
        }

        function closeResetModal() {
            document.getElementById('resetModal').classList.remove('active');
        }

        function showRuntimeError(message) {
            const title = currentLanguage === 'tr' ? 'Hata' : 'Error';
            const okText = currentLanguage === 'tr' ? 'Tamam' : 'OK';

            document.getElementById('runtimeErrorTitle').textContent = title;
            document.getElementById('runtimeErrorMessage').textContent = message;
            document.getElementById('runtimeErrorOkBtn').textContent = okText;

            document.getElementById('runtimeErrorModal').classList.add('active');
        }

        function closeRuntimeErrorModal() {
            document.getElementById('runtimeErrorModal').classList.remove('active');
        }

        function performReset() {
            closeResetModal();

            // √áalƒ±≈üan kod varsa durdur
            isExecutionCancelled = true;

            // RGB LED'leri s√∂nd√ºr
            rgbLedState = { red: false, green: false, blue: false };
            document.getElementById('rgbRedLed').classList.remove('active');
            document.getElementById('rgbGreenLed').classList.remove('active');
            document.getElementById('rgbBlueLed').classList.remove('active');

            // RGB sayƒ±larƒ± sƒ±fƒ±rla
            rgbNumberState = { red: 0, green: 0, blue: 0 };
            document.getElementById('rgbRedNum').textContent = '0';
            document.getElementById('rgbGreenNum').textContent = '0';
            document.getElementById('rgbBlueNum').textContent = '0';

            // Motor i≈ülem kilidini sƒ±fƒ±rla
            motorOperationInProgress = false;

            // √ú√ßgen butonlarƒ±n basƒ±lƒ± tutma durumunu sƒ±fƒ±rla
            stopHold();

            // Play butonunu aktif et ve g√∂r√ºn√ºm√ºn√º d√ºzelt
            const playBtn = document.querySelector('.play-btn');
            if (playBtn) {
                playBtn.disabled = false;
                playBtn.style.opacity = '1';
                playBtn.style.cursor = 'pointer';
                playBtn.style.pointerEvents = 'auto'; // Kilitlenmeyi √∂nler
                playBtn.style.background = '#FFBF00'; // Orijinal sarƒ± renk
            }



            // G√∂rsel feedback
            const resetBtn = document.querySelector('.reset-btn');
            resetBtn.style.background = '#51cf66';
            setTimeout(() => {
                resetBtn.style.background = '#FF6680';
            }, 300);
        }


        // Global scope'a ekle
        window.resetEverything = resetEverything;

        function addDevice() {



            const modal = document.getElementById('deviceModal');


            if (modal) {
                // Hem class hem inline style ekle
                modal.classList.add('show');
                modal.style.display = 'flex';
                modal.style.zIndex = '10000';


            } else {
                console.error('deviceModal bulunamadƒ±!');
                alert('Modal element bulunamadƒ±!');
            }
        }

        // Global scope'a ekle
        window.addDevice = addDevice;

        // RGB LED kontrol fonksiyonlarƒ±
        let bluetoothDevice = null;
        let bluetoothServer = null;
        let connectedCharacteristics = {};
        let connectedDevices = [];
        let selectedDeviceId = null;
        let deviceMenuOpen = null; // A√ßƒ±k cihaz men√ºs√º

        // Button States
        let btnStates = { red: false, green: false, blue: false };
        let btnLock = { red: false, green: false, blue: false };
        let pressTimer = { red: null, green: null, blue: null };

        function handleBtnDown(color) {
            const btn = document.getElementById(`rgb${color.charAt(0).toUpperCase() + color.slice(1)}Btn`);
            if (!btn) return;

            // Eƒüer kilitliyse (basƒ±lƒ± tutularak a√ßƒ±lma kontrol√º i√ßin timer ba≈ülat)
            if (btnLock[color]) {
                // Tƒ±klama anƒ±nda kilitli olduƒüunu g√∂ster (opsiyonel)
                // 3 saniye basƒ±lƒ± tutulursa kilidi kaldƒ±r
                if (pressTimer[color]) clearTimeout(pressTimer[color]);
                pressTimer[color] = setTimeout(() => {
                    // UNLOCK
                    btnLock[color] = false;
                    btnStates[color] = false; // Bƒ±rakƒ±nca s√∂necek, ama timer bitince direkt s√∂ns√ºn m√º? 
                    // Kullanƒ±cƒ± parmaƒüƒ±nƒ± kaldƒ±rƒ±nca handleBtnUp √ßalƒ±≈üacak ve btnLock false olduƒüu i√ßin s√∂necek.
                    // Burada g√∂rsel feedback verelim:
                    btn.classList.remove('active');
                    btn.classList.add('flash');
                    setTimeout(() => btn.classList.remove('flash'), 500);
                    console.log(`${color} button UNLOCKED (3s hold)`);
                }, 3000);
                return;
            }

            // Kilitli deƒüilse: Normal basma i≈ülemi
            btnStates[color] = true;
            btn.classList.add('active');

            // 3 saniye basƒ±lƒ± tutulursa Kƒ∞Lƒ∞TLE
            if (pressTimer[color]) clearTimeout(pressTimer[color]);
            pressTimer[color] = setTimeout(() => {
                // LOCK
                btnLock[color] = true;
                btn.classList.add('flash'); // Parlama efekti
                setTimeout(() => btn.classList.remove('flash'), 500);
                console.log(`${color} button LOCKED (3s hold)`);
            }, 3000);
        }

        function handleBtnUp(color) {
            const btn = document.getElementById(`rgb${color.charAt(0).toUpperCase() + color.slice(1)}Btn`);

            if (pressTimer[color]) {
                clearTimeout(pressTimer[color]);
                pressTimer[color] = null;
            }

            // Eƒüer kilitliyse, bƒ±rakƒ±nca S√ñNMEZ (active kalƒ±r)
            // Sadece tƒ±klayƒ±p bƒ±rakƒ±nca (kƒ±sa basƒ±≈ü) kilitli state deƒüi≈ümez, ama timer iptal olduƒüu i√ßin (yukarƒ±da) bir ≈üey olmaz.

            // Eƒüer kilitli DEƒûƒ∞LSE, bƒ±rakƒ±nca s√∂ner
            if (!btnLock[color]) {
                if (btnStates[color]) {
                    btnStates[color] = false;
                    if (btn) btn.classList.remove('active');
                }
            }
        }




        // Global'e ekle
        window.handleBtnDown = handleBtnDown;
        window.handleBtnUp = handleBtnUp;

        const DEVICE_SHAPES = ['triangle', 'square', 'rectangle', 'pentagon', 'hexagon', 'octagon', 'circle'];
        const DEVICE_COLORS = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B739'];

        // ===== BLUETOOTH MOTOR KONTROL FONKSƒ∞YONLARI =====

        // Hex string'i byte array'e √ßevir
        function hexToBytes(hexString) {
            const hex = hexString.replace(/:/g, '');
            const bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i < hex.length; i += 2) {
                bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
            }
            return bytes;
        }

        // Motor komut sabitleri
        const MOTOR_COMMANDS = {
            INIT: hexToBytes("30:31:30:32:30:33:30:34:30:35:30:36:30:37:30:38"),
            CONFIG: hexToBytes("02:00"),
            CMD_START: hexToBytes("00"),
            CMD_PREPARE: hexToBytes("1a"),
            CMD_MODE: hexToBytes("28:32:00"),
            CMD_CONTROL: hexToBytes("20:00"),
            // CMD_EXECUTE rotasyon sayƒ±sƒ±na g√∂re deƒüi≈üir, a≈üaƒüƒ±da fonksiyon var
            MOTOR_INIT_1: hexToBytes("01:01:00:31:00:01:00:3e:00:01:00:00:00:f7:00:00:02"),
            MOTOR_INIT_2: hexToBytes("1b:9d:4d:ce:36:00:4b:12:00"),
            MOTOR_INIT_3: hexToBytes("29:00"),
            MOTOR_BASE: hexToBytes("3c:12:00:00:46:00:0a:01:07:56:01:00:00:00:ef:ff:ff:ff:11:01:ff"), // capturing_rotasyon_sagvesol.pcap
            MOTOR_STOP_INIT: hexToBytes("7d:01:00"),
            // Alternatif durma komutlarƒ±
            MOTOR_BRAKE: hexToBytes("00:00"),  // Fren
            MOTOR_FLOAT: hexToBytes("7d:00:00"), // Serbest bƒ±rak
        };

        // Y√∂ne g√∂re motor base komutu olu≈ütur
        function createMotorBaseCommand(direction = 'CW') {
            // capturing_rotasyon_sagvesol.pcap ANALƒ∞Zƒ∞ (ROTASYON):
            // SAƒûA (CW): 3c 12 00 00 46 00 0a 01 07 56 01 00 00 00 ef ff ff ff 11 01 ff
            // SOLA (CCW): Motor base byte 8-9 deƒüi≈ümiyor, execute komutu y√∂n√º belirliyor
            //             SOLA i√ßin motor base SAƒûA ile aynƒ±

            // Rotasyon i√ßin her iki y√∂n de aynƒ± motor base kullanƒ±yor
            return hexToBytes("3c:12:00:00:46:00:0a:01:07:56:01:00:00:00:ef:ff:ff:ff:11:01:ff");
        }

        // Rotasyon/a√ßƒ±ya g√∂re CMD_EXECUTE olu≈ütur
        function createExecuteCommand(value, isRotation = true, direction = 'CW') {
            // Eƒüer rotasyon ise dereceye √ßevir
            let degrees = isRotation ? (value * 360) : value;

            // PCAP ANALƒ∞Zƒ∞ (capturing_rotasyon_sagvesol.pcap):
            // SAƒûA: 7c 01 68 01 00 00 00 (son byte = 0x00)
            // SOLA: 7c 01 68 01 00 00 01 (son byte = 0x01)
            // Y√∂n son byte'ta kodlanƒ±yor, derece deƒüeri pozitif kalƒ±yor!

            // Derece deƒüeri her zaman pozitif (negatif YOK)
            const posDegrees = Math.abs(degrees);

            // Signed 16-bit integer olarak encode et (little endian)
            const signed16 = posDegrees & 0xFFFF;
            const lowByte = signed16 & 0xFF;
            const highByte = (signed16 >> 8) & 0xFF;

            // Son byte y√∂n√º belirliyor: 0x00 = SAƒûA, 0x01 = SOLA
            const directionByte = direction === 'CW' ? 0x00 : 0x01;

            // 7c:01:[LOW]:[HIGH]:00:00:[DIR]
            const cmd = new Uint8Array([0x7c, 0x01, lowByte, highByte, 0x00, 0x00, directionByte]);

            const unit = isRotation ? 'rotasyon' : 'derece';
            const dirSymbol = direction === 'CW' ? '‚Üª' : '‚Ü∫';
            console.log(`CMD_EXECUTE i√ßin ${value} ${unit} ${dirSymbol} = ${posDegrees}¬∞ = 0x${signed16.toString(16)} = [${lowByte.toString(16)}, ${highByte.toString(16)}, dir=${directionByte.toString(16)}]`);

            return cmd;
        }

        const MOTOR_SPEED_CHANGES = [
            hexToBytes("3c:12:00:00:64:00:0a:01:07:2e:01:00:00:00:c6:ff:ff:ff:11:01:ff"),
            hexToBytes("3c:12:00:00:64:00:0a:01:01:31:01:75:09:00:c9:ff:ff:ff:11:01:ff"),
            hexToBytes("3c:12:00:00:64:00:0a:01:01:42:01:cb:13:04:da:ff:ff:ff:11:01:ff"),
            hexToBytes("3c:12:00:00:64:00:0a:01:01:60:01:a3:1e:09:f8:ff:ff:ff:11:01:ff"),
        ];

        const MOTOR_SLOWDOWN = [
            hexToBytes("3c:12:00:00:64:00:0a:01:07:2e:01:00:00:33:fe:03:00:00:11:01:ff"),
            hexToBytes("3c:12:00:00:64:00:0a:01:07:2e:01:00:00:2d:fe:03:00:00:11:01:ff"),
            hexToBytes("3c:12:00:00:64:00:0a:01:07:2e:01:00:00:28:fe:03:00:00:11:01:ff"),
            hexToBytes("3c:12:00:00:64:00:0a:01:07:2e:01:00:00:23:fe:03:00:00:11:01:ff"),
        ];

        // Cihazƒ±n karakteristiklerini al
        async function getMotorCharacteristics(deviceId) {
            console.log('getMotorCharacteristics √ßaƒürƒ±ldƒ±, deviceId:', deviceId);
            console.log('connectedDevices:', connectedDevices);

            const deviceData = connectedDevices.find(d => d.id === deviceId);
            console.log('Bulunan deviceData:', deviceData);

            if (!deviceData) {
                console.error('‚ùå Motor cihazƒ± connectedDevices i√ßinde bulunamadƒ±!');
                return null;
            }

            if (!deviceData.server) {
                console.error('‚ùå deviceData.server yok!');
                return null;
            }

            if (!deviceData.server.connected) {
                console.error('‚ùå GATT server baƒülƒ± deƒüil!');
                return null;
            }

            // Motor UUID'leri (PCAP analizinden)
            const MOTOR_SERVICE_UUIDS = [
                '0000fd02-0000-1000-8000-00805f9b34fb', // Ana motor servisi
                '00002a05-0000-1000-8000-00805f9b34fb', // INIT
                '00002b2a-0000-1000-8000-00805f9b34fb', // CONFIG
            ];

            const MOTOR_CHAR_UUIDS = {
                INIT: '00002a05-0000-1000-8000-00805f9b34fb',
                CONFIG: '00002b2a-0000-1000-8000-00805f9b34fb',
                COMMAND: '0000fd02-0001-1000-8000-00805f9b34fb',
                MOTOR: '0000fd02-0002-1000-8000-00805f9b34fb'
            };

            try {
                console.log('‚úì Server baƒülƒ±, belirli servisleri arƒ±yoruz...');
                const chars = {};

                // Her UUID'yi deneyelim
                for (const serviceUUID of MOTOR_SERVICE_UUIDS) {
                    try {
                        console.log(`  ‚Üí Servis ${serviceUUID} deneniyor...`);
                        const service = await deviceData.server.getPrimaryService(serviceUUID);
                        console.log(`    ‚úì Servis bulundu!`);

                        const characteristics = await service.getCharacteristics();
                        console.log(`    ${characteristics.length} karakteristik bulundu`);

                        for (const char of characteristics) {
                            console.log(`      - UUID: ${char.uuid}, Write: ${char.properties.write}, WriteNoResp: ${char.properties.writeWithoutResponse}`);

                            // T√ºm write karakteristiklerini kaydet
                            if (char.properties.write || char.properties.writeWithoutResponse) {
                                chars[char.uuid] = char;
                                console.log(`        ‚úì Yazƒ±labilir karakteristik kaydedildi`);
                            }
                        }
                    } catch (e) {
                        console.log(`    ‚ö†Ô∏è Servis ${serviceUUID} bulunamadƒ±: ${e.message}`);
                    }
                }

                // Eƒüer hi√ß karakteristik bulamadƒ±ysak, belirli karakteristikleri deneyelim
                if (Object.keys(chars).length === 0) {
                    console.log('  ‚Üí Hi√ß servis bulunamadƒ±, karakteristikleri direkt deniyoruz...');

                    for (const [name, uuid] of Object.entries(MOTOR_CHAR_UUIDS)) {
                        try {
                            // Ana servisten karakteristiƒüi almayƒ± dene
                            const service = await deviceData.server.getPrimaryService('0000fd02-0000-1000-8000-00805f9b34fb');
                            const char = await service.getCharacteristic(uuid);
                            chars[uuid] = char;
                            console.log(`    ‚úì ${name} karakteristiƒüi bulundu: ${uuid}`);
                        } catch (e) {
                            console.log(`    ‚ö†Ô∏è ${name} karakteristiƒüi bulunamadƒ±`);
                        }
                    }
                }

                console.log(`‚úÖ Toplam ${Object.keys(chars).length} yazƒ±labilir karakteristik bulundu`);

                if (Object.keys(chars).length === 0) {
                    console.error('‚ùå Hi√ß karakteristik bulunamadƒ±! Motor cihazƒ± Web Bluetooth ile uyumlu olmayabilir.');
                    return null;
                }

                return chars;
            } catch (error) {
                console.error('‚ùå Karakteristikler alƒ±namadƒ±:', error);
                console.error('   Error name:', error.name);
                console.error('   Error message:', error.message);
                return null;
            }
        }

        // Karakteristiƒüe veri yaz
        async function writeMotorCommand(characteristic, data, delay = 50) {
            if (!characteristic) return;
            try {
                await characteristic.writeValue(data);
                await new Promise(resolve => setTimeout(resolve, delay));
            } catch (error) {
                console.error('Motor komut yazma hatasƒ±:', error);
            }
        }

        // Motor initialize
        async function initializeMotor(deviceId) {
            const chars = await getMotorCharacteristics(deviceId);
            if (!chars) return false;

            console.log('Motor ba≈ülatƒ±lƒ±yor...');

            // ƒ∞lk eri≈üilebilir karakteristik √ºzerinden komutlarƒ± g√∂nder
            // Ger√ßek uygulamada doƒüru UUID'leri bulup kullanmalƒ±sƒ±nƒ±z
            const writeChar = Object.values(chars)[0];

            if (writeChar) {
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.INIT);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CONFIG);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_START);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_INIT_1);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_PREPARE);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_INIT_2);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_MODE);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_INIT_3);
            }

            console.log('‚úì Motor ba≈ülatƒ±ldƒ±');
            return true;
        }

        // Helper function for unified motor control
        async function sendMotorPositionCommand(deviceId, angle) {

            // Device'ƒ± bul
            const deviceData = connectedDevices.find(d => d.id === deviceId);
            if (!deviceData || !deviceData.server) {
                console.error('‚ùå Device bulunamadƒ± veya baƒülƒ± deƒüil');
                return false;
            }

            console.log(`üìç Motor ${angle}¬∞ pozisyonuna g√∂nderiliyor...`);

            // Command characteristic - HER ZAMAN TAZE√¢ AL (cache kullanma, stale olabilir)
            let cmdChar = null;
            const charUUID = '0000fd02-0001-1000-8000-00805f9b34fb';
            const serviceUUID = '0000fd02-0000-1000-8000-00805f9b34fb';

            try {
                console.log('   üîÑ Servis ve Characteristic taze alƒ±nƒ±yor...');
                const service = await deviceData.server.getPrimaryService(serviceUUID);
                cmdChar = await service.getCharacteristic(charUUID);
                console.log('   ‚úÖ Taze characteristic alƒ±ndƒ±:', cmdChar.uuid);
            } catch (e) {
                console.error('   ‚ùå Characteristic alƒ±namadƒ±:', e);
                return false;
            }

            console.log('   üîó Kullanƒ±lan Characteristic:', cmdChar.uuid);

            // Pozisyon deƒüerini little-endian formatƒ±nda hazƒ±rla
            // A√ßƒ± negatif olabilir veya 360'tan b√ºy√ºk olabilir
            const posBytes = angle & 0xFFFF;
            const lowByte = posBytes & 0xFF;
            const highByte = (posBytes >> 8) & 0xFF;

            // 0. Notify Characteristic'i bul ve Subscribe ol
            try {
                const notifyUUID = '0000fd02-0002-1000-8000-00805f9b34fb';
                let notifyChar = null;

                if (deviceData.characteristics) {
                    notifyChar = deviceData.characteristics[notifyUUID];
                }

                // Cache'te yoksa servisten al (writeChar'ƒ±n servisini kullanabiliriz if available in obj or refetch)
                if (!notifyChar && cmdChar.service) {
                    try {
                        notifyChar = await cmdChar.service.getCharacteristic(notifyUUID);
                    } catch (e) { console.log('   ‚ö†Ô∏è Notify char servisten alƒ±namadƒ±'); }
                }

                if (notifyChar) {
                    // Start notifications safely
                    console.log('   üîî Notifications ba≈ülatƒ±lƒ±yor (Handshake i√ßin)...');
                    await notifyChar.startNotifications();
                }
            } catch (err) {
                console.log('   ‚ö†Ô∏è Notification ba≈ülatma hatasƒ± (kritik olmayabilir):', err);
            }

            try {
                // Verify connection is still active
                console.log('   üîç GATT Baƒülantƒ± durumu:', deviceData.server.connected ? '‚úÖ Baƒülƒ±' : '‚ùå Baƒülƒ± DEƒûƒ∞L');

                if (!deviceData.server.connected) {
                    console.error('   ‚ùå GATT baƒülantƒ±sƒ± kopmu≈ü! Yeniden baƒülanmayƒ± deneyin.');
                    return false;
                }

                // Log characteristic properties
                console.log('   üìã Characteristic √∂zellikleri:', {
                    uuid: cmdChar.uuid,
                    write: cmdChar.properties.write,
                    writeWithoutResponse: cmdChar.properties.writeWithoutResponse
                });

                // 1. Ba≈ülatma komutu: 20 00
                const startCmd = new Uint8Array([0x20, 0x00]);
                console.log('   üì§ CMD1 (Start) g√∂nderiliyor:', [...startCmd].map(b => b.toString(16).padStart(2, '0')).join(' '));

                try {
                    await cmdChar.writeValueWithoutResponse(startCmd);
                    console.log('   ‚úÖ CMD1 yazƒ±ldƒ± ba≈üarƒ±lƒ±');
                } catch (writeErr) {
                    console.error('   ‚ùå CMD1 yazma hatasƒ±:', writeErr);
                    return false;
                }

                await new Promise(resolve => setTimeout(resolve, 50));

                // 2. Pozisyon komutu: 80 [PORT] [LOW] [HIGH] 02
                // Port ID belirsiz olabilir (0, 1, 2 vb.), hepsini deneyelim (Shotgun approach)
                const ports = [0x00, 0x01, 0x02];
                let anySuccess = false;

                for (const port of ports) {
                    const positionCmd = new Uint8Array([0x80, port, lowByte, highByte, 0x02]);
                    console.log(`   üì§ CMD2 (Pos) g√∂nderiliyor (Port ${port}):`, [...positionCmd].map(b => b.toString(16).padStart(2, '0')).join(' '));

                    try {
                        await cmdChar.writeValueWithoutResponse(positionCmd);
                        console.log(`   ‚úÖ CMD2 (Port ${port}) yazƒ±ldƒ± ba≈üarƒ±lƒ±`);
                        anySuccess = true;
                        // Komutlar arasƒ±nda kƒ±sa bekleme
                        await new Promise(resolve => setTimeout(resolve, 30));
                    } catch (writeErr) {
                        console.error(`   ‚ùå CMD2 (Port ${port}) yazma hatasƒ±:`, writeErr);
                    }
                }

                if (!anySuccess) return false;

                // Update State
                motorState.currentAngle = angle;
                motorState.targetAngle = angle;
                updateMotorAngleDisplay(angle);

                return true;
            } catch (err) {
                console.error('‚ùå Motor komut hatasƒ±:', err);
                return false;
            }
        }

        // Motor rotasyon √ßalƒ±≈ütƒ±r
        /*
         * NOT: sendMotorPositionCommand fonksiyonu, belirli bir marka/model (√∂rn. Robot Invader) 
         * BLE motorlar i√ßin bir "Shotgun" yakla≈üƒ±mla port taramasƒ± yapar.
         * Standart port (0x01) bazen √ßalƒ±≈ümayabilir, bu y√ºzden 0x00, 0x01, 0x02 denenir.
         * Bu sayede "Go to Position" gibi komutlarƒ±n kararlƒ± √ßalƒ±≈ümasƒ± saƒülanmƒ±≈ütƒ±r.
         */

        // Motor rotasyon √ßalƒ±≈ütƒ±r (Karma≈üƒ±k 43-Komut Protokol√º - Restore Edildi)
        // Kullanƒ±cƒ± geri bildirimi: "Eskiden 0/43, 10/43 loglarƒ± vardƒ± ve tam tur atƒ±yordu."
        async function runMotorRotations(deviceId, rotations, direction = 'CW') {
            if (motorOperationInProgress) {
                console.log('‚è≥ Ba≈üka bir motor i≈ülemi devam ediyor...');
                return;
            }
            motorOperationInProgress = true;

            try {
                // 1. √ñnce eski protokol√ºn ihtiya√ß duyduƒüu ba≈ülatma sekansƒ±nƒ± g√∂nder
                await initializeMotor(deviceId);

                const chars = await getMotorCharacteristics(deviceId);
                if (!chars) {
                    console.error('‚ùå Karakteristikler alƒ±namadƒ±!');
                    return;
                }

                // Genellikle ilk karakteristik (fd02-0001) yazma i√ßin uygundur
                const writeChar = Object.values(chars)[0];
                if (!writeChar) {
                    console.error('‚ùå Yazƒ±labilir karakteristik bulunamadƒ±');
                    return;
                }

                // Number'a √ßevir ve default 1 yap
                const r = Number(rotations);
                const validRotations = isNaN(r) ? 1 : r;

                console.log(`üîÑ ${validRotations} rotasyon ba≈ülatƒ±lƒ±yor (${direction}) - 43 Komut Protokol√º...`);

                // 2. 43 adet MOTOR_BASE komutu g√∂nder (Hƒ±zlanma/Hazƒ±rlƒ±k?)
                // "GATT operation already in progress" hatasƒ±nƒ± √∂nlemek i√ßin delay ekliyoruz
                const totalCommands = 43;
                for (let i = 0; i < totalCommands; i++) {
                    // writeMotorCommand i√ßinde 50ms delay var, burada ekstra g√ºvenli yapalƒ±m (100ms total)
                    await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_BASE, 50);
                    if (i % 10 === 0) console.log(`   üì§ ${i}/${totalCommands} komut g√∂nderildi`);
                }

                // 3. Kontrol ve tekrar Base
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_CONTROL);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_BASE);

                // 4. Execute Komutu (Rotasyon sayƒ±sƒ± ve y√∂n burada)
                const executeCmd = createExecuteCommand(validRotations, true, direction);
                await writeMotorCommand(writeChar, executeCmd);

                // 5. Hƒ±z deƒüi≈üimleri
                for (const cmd of MOTOR_SPEED_CHANGES) {
                    await writeMotorCommand(writeChar, cmd);
                }

                // 6. Devam komutlarƒ± (Magic bytes from PCAP)
                const rotationCommands = [
                    hexToBytes("3c:12:00:00:64:00:0a:01:01:21:00:97:22:11:22:00:00:00:11:01:ff"),
                    hexToBytes("3c:12:00:00:64:00:0a:01:01:50:00:60:22:18:51:00:00:00:11:01:ff"),
                    hexToBytes("3c:12:00:00:64:00:0a:01:01:7e:00:ee:21:1f:7f:00:00:00:11:01:ff"),
                ];

                for (const cmd of rotationCommands) {
                    await writeMotorCommand(writeChar, cmd);
                }

                // 7. Durma sekansƒ±
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_STOP_INIT);

                for (const cmd of MOTOR_SLOWDOWN) {
                    await writeMotorCommand(writeChar, cmd);
                }

                // Final temizlik
                for (let i = 0; i < 5; i++) {
                    await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_BASE, 30);
                }

                console.log('‚úÖ Rotasyon komutlarƒ± tamamlandƒ±!');

                // State g√ºncelle (Tahmini)
                let current = motorState.currentAngle || 0;
                let delta = validRotations * 360 * (direction === 'CCW' ? -1 : 1);
                motorState.currentAngle = current + delta;
                updateMotorAngleDisplay(motorState.currentAngle);

            } catch (err) {
                console.error('‚ùå Rotasyon hatasƒ±:', err);
            } finally {
                motorOperationInProgress = false;
            }
        }


        // Motor a√ßƒ±ya git (G√∂receli hareket: Mevcut + A√ßƒ±)
        // Kullanƒ±cƒ± "Run to Angle" bloƒüunu "Turn By Angle" (G√∂receli D√∂n√º≈ü) olarak bekliyor.
        async function runMotorToAngle(deviceId, angle, direction = 'CW') {
            if (motorOperationInProgress) {
                console.log('‚è≥ Ba≈üka bir motor i≈ülemi devam ediyor...');
                return;
            }
            motorOperationInProgress = true;

            try {
                console.log(`üéØ ${angle}¬∞ a√ßƒ±ya g√∂receli gidiliyor (${direction})...`);

                let current = motorState.currentAngle || 0;
                let targetDelta = angle;

                if (direction === 'CCW') {
                    targetDelta = -targetDelta;
                }

                const targetAngle = current + targetDelta;
                console.log(`   üìç A√ßƒ± Hedef: ${current}¬∞ + ${targetDelta}¬∞ = ${targetAngle}¬∞`);

                const success = await sendMotorPositionCommand(deviceId, targetAngle);
                if (success) {
                    const waitTime = Math.max(500, Math.abs(targetDelta) * 10);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                    console.log(`‚úÖ ${angle}¬∞ deƒüi≈üimi tamamlandƒ±!`);
                }
            } finally {
                motorOperationInProgress = false;
            }
        }

        // Motor mutlak pozisyona git (Eski fonksiyonu koru ama yeni helper'ƒ± kullansƒ±n)
        // PCAP ANALƒ∞Zƒ∞ (capturing_bluetooth_67angle.pcap):
        // Frame 23: 20 00            ‚Üí Handle 0x000c (CMD char) - Ba≈ülatma komutu
        // Frame 25: 80 01 43 00 02   ‚Üí Handle 0x000c (CMD char) - 67¬∞ pozisyon komutu (0x43 = 67)
        // Frame 86: 20 01            ‚Üí Handle 0x000c (CMD char) - Tamamlama komutu (opsiyonel)
        async function goToPosition(deviceId, position) {
            if (motorOperationInProgress) {
                console.log('‚è≥ Ba≈üka bir motor i≈ülemi devam ediyor...');
                return;
            }
            motorOperationInProgress = true;
            try {
                const success = await sendMotorPositionCommand(deviceId, position);
                if (success) {
                    const waitTime = Math.max(500, Math.abs(position - (motorState.currentAngle || 0)) * 10);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                    console.log(`‚úÖ ${position}¬∞ pozisyonuna gidildi!`);
                }
            } finally {
                motorOperationInProgress = false;
            }
        }

        // Motor ba≈ülat (s√ºrekli d√∂nme)
        async function startMotor(deviceId, direction = 'CW') {
            // Motor i≈ülemi devam ediyorsa bekle
            if (motorOperationInProgress) {
                console.log('‚è≥ Ba≈üka bir motor i≈ülemi devam ediyor, bekleniyor...');
                return;
            }

            motorOperationInProgress = true;

            try {
                const chars = await getMotorCharacteristics(deviceId);

                if (!chars) {
                    console.error('‚ùå Karakteristikler alƒ±namadƒ±!');
                    return;
                }

                console.log(`‚ñ∂Ô∏è Motor ${direction === 'CW' ? 'saƒüa ‚Üª' : 'sola ‚Ü∫'} ba≈ülatƒ±lƒ±yor...`);

                const writeChar = Object.values(chars)[0];

                if (!writeChar) {
                    console.error('‚ùå Yazƒ±labilir karakteristik bulunamadƒ±');
                    return;
                }

                // Ba≈ülatma komutlarƒ±
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_START);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_INIT_1);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_PREPARE);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_INIT_2);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_MODE);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_INIT_3);

                // Y√∂ne g√∂re motor base komutu
                const motorBaseCmd = createMotorBaseCommand(direction);

                // Sabit hƒ±z komutlarƒ± (43 komut)
                for (let i = 0; i < 43; i++) {
                    await writeMotorCommand(writeChar, motorBaseCmd, 30);
                }

                // Kontrol ve execute
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_CONTROL);
                await writeMotorCommand(writeChar, motorBaseCmd);

                // S√ºrekli d√∂nme i√ßin y√ºksek rotasyon execute komutu
                const continuousRotations = 100;
                const executeCmd = createExecuteCommand(continuousRotations, true, direction);
                await writeMotorCommand(writeChar, executeCmd);

                console.log(`‚úÖ Motor ${direction === 'CW' ? 'saƒüa ‚Üª' : 'sola ‚Ü∫'} ba≈ülatƒ±ldƒ±!`);
            } finally {
                motorOperationInProgress = false;
            }
        }

        // Motor durdur
        async function stopMotor(deviceId) {
            // Stop komutu her zaman √ßalƒ±≈üabilmeli - kilidi temizle ve √ßalƒ±≈ütƒ±r
            motorOperationInProgress = false;

            try {
                const chars = await getMotorCharacteristics(deviceId);

                if (!chars) {
                    console.error('‚ùå Karakteristikler alƒ±namadƒ±!');
                    return;
                }

                console.log('‚èπÔ∏è Motor durduruluyor...');

                const writeChar = Object.values(chars)[0];

                if (!writeChar) {
                    console.error('‚ùå Yazƒ±labilir karakteristik bulunamadƒ±');
                    return;
                }

                // √áoklu durma yakla≈üƒ±mƒ±
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_STOP_INIT);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_STOP_INIT);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_STOP_INIT);

                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_CONTROL);
                const stopExecute = new Uint8Array([0x7c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00]);
                await writeMotorCommand(writeChar, stopExecute);

                for (const cmd of MOTOR_SLOWDOWN) {
                    await writeMotorCommand(writeChar, cmd, 50);
                }

                for (let i = 0; i < 30; i++) {
                    await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_BASE, 10);
                }

                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_STOP_INIT);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_BRAKE);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_FLOAT);

                console.log('‚úÖ Motor durduruldu!');
            } catch (error) {
                console.error('‚ùå stopMotor hatasƒ±:', error);
            }
        }

        // Cihaz tiplerini isimden algƒ±la
        // Cihaz tiplerini isimden algƒ±la
        function detectDeviceType(deviceName) {
            const name = deviceName.toLowerCase();
            if (name.includes('spike') || name.includes('essential')) return 'spike_essential';
            if (name.includes('hub')) return 'technic_hub';
            if (name.includes('motor')) return 'motor';
            if (name.includes('controller') || name.includes('joystick') || name.includes('gamepad') || name.includes('handset')) return 'controller';
            if (name.includes('color') && name.includes('sensor')) return 'color_sensor';
            if (name.includes('sensor')) return 'sensor';
            return 'generic';
        }



        // Cihaz tipine g√∂re √∂zel bloklar
        const DEVICE_BLOCKS = {
            'double_motor': [
                {
                    type: 'motor_run_seconds',
                    icon: 'timer',
                    label: 'run for [1] seconds',
                    color: '#4ECDC4'
                },
                {
                    type: 'motor_stop',
                    icon: 'stop',
                    label: 'stop',
                    color: '#4ECDC4'
                }
            ],
            'motor': [
                {
                    type: 'motor_run_rotation',
                    icon: 'rotate',
                    label: 'run for [1] rotations',
                    color: '#4ECDC4'
                },
                {
                    type: 'motor_run_seconds',
                    icon: 'timer',
                    label: 'run for [1] seconds',
                    color: '#4ECDC4'
                },
                {
                    type: 'motor_set_speed',
                    icon: 'speed',
                    label: 'set speed to [100]%',
                    color: '#4ECDC4'
                },
                {
                    type: 'motor_stop',
                    icon: 'stop',
                    label: 'stop',
                    color: '#4ECDC4'
                }
            ],
            'controller': [
                {
                    type: 'when_lever_up',
                    icon: 'üïπÔ∏è',
                    label: 'when left lever is up',
                    color: '#45B7D1',
                    isEvent: true
                },
                {
                    type: 'when_lever_down',
                    icon: 'üïπÔ∏è',
                    label: 'when left lever is down',
                    color: '#45B7D1',
                    isEvent: true
                },
                {
                    type: 'when_button_pressed',
                    icon: 'üîò',
                    label: 'when button A pressed',
                    color: '#45B7D1',
                    isEvent: true
                }
            ],
            'color_sensor': [
                {
                    type: 'when_color_detected',
                    icon: 'üî¥',
                    label: 'when red detected',
                    color: '#9B59B6',
                    isEvent: true
                },
                {
                    type: 'detecting_color',
                    icon: 'üü°',
                    label: 'detecting yellow?',
                    color: '#9B59B6',
                    isBoolean: true
                },
                {
                    type: 'color_value',
                    icon: 'üé®',
                    label: 'color',
                    color: '#9B59B6',
                    isReporter: true
                }
            ],
            'spike_essential': [
                {
                    type: 'hub_led_color',
                    icon: 'üí°',
                    label: 'set hub LED',
                    color: '#F5A623'
                },
                {
                    type: 'hub_orientation',
                    icon: 'üìê',
                    label: 'is front up?',
                    color: '#4FC3F7',
                    isBoolean: true
                }
            ],
            'generic': [
                {
                    type: 'device_command',
                    icon: 'üì°',
                    label: 'send command',
                    color: '#98D8C8'
                },
                {
                    type: 'force_sensor_is_pressed',
                    icon: 'üëá',
                    label: 'is pressed?',
                    color: '#4FC3F7',
                    isBoolean: true
                },
                {
                    type: 'force_sensor_pressure',
                    icon: 'üí™',
                    label: 'pressure',
                    color: '#4FC3F7',
                    isReporter: true
                }
            ],
            'generic': [
                {
                    type: 'device_command',
                    icon: 'üì°',
                    label: 'send command',
                    color: '#98D8C8'
                }
            ]
        };

        function getRandomShape() {
            return DEVICE_SHAPES[Math.floor(Math.random() * DEVICE_SHAPES.length)];
        }

        function getRandomColor() {
            return DEVICE_COLORS[Math.floor(Math.random() * DEVICE_COLORS.length)];
        }

        function addDeviceToSidebar(device, overrideColor = null, overrideType = null) {
            const deviceType = overrideType || detectDeviceType(device.name || '');

            // ƒ∞sim d√ºzeltme - cihaz adƒ± yoksa tip bazlƒ± isim kullan
            let displayName = device.name;
            if (!displayName || displayName.trim() === '') {
                if (overrideType === 'motor') displayName = 'Single Motor';
                else if (overrideType === 'double_motor') displayName = 'Double Motor';
                else if (overrideType === 'color_sensor') displayName = 'Color Sensor';
                else if (overrideType === 'controller') displayName = 'Controller';
                else displayName = 'Device';
            }
            // Tip bazlƒ± √∂zel isim ge√ßersiz kƒ±lma
            if (overrideType === 'color_sensor' && !device.name?.toLowerCase().includes('color')) {
                displayName = 'Color Sensor';
            }
            if (overrideType === 'controller' && !device.name?.toLowerCase().includes('controller')) {
                displayName = 'Controller';
            }
            if (overrideType === 'double_motor') {
                displayName = 'Double Motor';
            }
            if (overrideType === 'spike_essential') {
                displayName = 'Spike Essential Hub';
            }

            if (typeof logDeviceAction === 'function') {
                logDeviceAction('add', displayName, deviceType);
            }

            const deviceData = {
                id: device.id,
                name: displayName,
                type: deviceType,
                shape: getRandomShape(),
                color: overrideColor || getRandomColor(),
                device: device,
                server: bluetoothServer,
                characteristics: { ...connectedCharacteristics },
                connected: true
            };

            connectedDevices.push(deviceData);

            // Ana device list'e ekle
            const deviceList = document.getElementById('deviceList');
            const deviceIcon = document.createElement('div');
            deviceIcon.className = `device-icon ${deviceData.shape}`;
            deviceIcon.dataset.deviceId = deviceData.id;
            deviceIcon.title = deviceData.name;

            // Controller i√ßin √∂zel stil
            if (deviceType === 'controller') {
                deviceIcon.classList.add('controller');
                deviceIcon.style.setProperty('--device-color', deviceData.color);

                // Normal durumda beyaz arka plan, siyah yazƒ±
                deviceIcon.style.background = '#FFFFFF';
                deviceIcon.style.borderColor = deviceData.color;
                deviceIcon.style.color = 'black';

                deviceIcon.innerHTML = '<img src="img/controller.png" style="width: 28px; height: 28px; object-fit: contain;">';
                // deviceIcon.style.fontSize = '16px'; // No longer needed
            } else if (deviceType === 'color_sensor') {
                // Color Sensor i√ßin √∂zel stil
                deviceIcon.classList.add('color-sensor');
                deviceIcon.style.setProperty('--device-color', deviceData.color);

                // Normal durumda beyaz arka plan
                deviceIcon.style.background = '#FFFFFF';
                deviceIcon.style.borderColor = deviceData.color;
                deviceIcon.style.color = deviceData.color;

                deviceIcon.innerHTML = '<img src="img/color-sensor.png" style="width: 28px; height: 28px; object-fit: contain;">';
            } else if (deviceType === 'spike_essential') {
                // Spike Essential Hub i√ßin √∂zel stil
                deviceIcon.classList.add('spike-essential');
                deviceIcon.style.setProperty('--device-color', deviceData.color);
                deviceIcon.style.background = '#FFFFFF';
                deviceIcon.style.borderColor = deviceData.color;
                deviceIcon.style.color = deviceData.color;
                deviceIcon.innerHTML = '<img src="img/essential-hub.png" style="width: 28px; height: 28px; object-fit: contain;">';
            } else {
                deviceIcon.style.borderColor = deviceData.color;
                deviceIcon.style.color = deviceData.color;

                // Single/Double Motor i√ßin √∂zel kontrol
                const name = (deviceData.name || '').toLowerCase();
                if (name.includes('single motor')) {
                    deviceIcon.innerHTML = '<img src="img/single-motor.png" style="width: 28px; height: 28px; object-fit: contain;">';
                } else if (name.includes('double motor')) {
                    deviceIcon.innerHTML = '<img src="img/double-motor.png" style="width: 28px; height: 28px; object-fit: contain;">';
                } else {
                    // Diƒüer cihazlar i√ßin ID'nin son 4 karakteri
                    const shortId = deviceData.id.split('-').pop().substring(0, 4).toUpperCase();
                    deviceIcon.innerHTML = `${shortId}`;
                }
            }

            deviceIcon.onclick = (e) => {
                e.stopPropagation();

                // T√ºm ikonlardan se√ßili durumunu kaldƒ±r
                document.querySelectorAll('.device-icon').forEach(icon => icon.classList.remove('selected'));

                // Eƒüer aynƒ± cihaza tekrar tƒ±klandƒ±ysa toolbox'ƒ± kapat
                if (currentToolboxDevice === deviceData.id && currentToolboxMode === 'device') {
                    hideAllToolboxes();
                    currentToolboxDevice = null;
                } else {
                    // Farklƒ± cihaz - cihaz bloklarƒ±nƒ± toolbox'ta g√∂ster
                    currentToolboxDevice = deviceData.id;
                    showDeviceToolbox(deviceData);
                    deviceIcon.classList.add('selected');
                }
            };

            deviceList.appendChild(deviceIcon);

            // Tabloyu g√ºncelle
            updateDevicesTable();

            console.log('Cihaz eklendi:', deviceData);
        }

        function toggleDeviceMenu(deviceData) {
            const sidebar = document.getElementById('sidebar');
            const panelTitle = document.getElementById('panelTitle');
            const panelContent = document.getElementById('panelContent');
            const icon = document.querySelector(`[data-device-id="${deviceData.id}"]`);

            // Aynƒ± cihaza tekrar tƒ±klanƒ±rsa kapat
            if (deviceMenuOpen === deviceData.id) {
                sidebar.classList.remove('expanded');
                icon.classList.remove('active');
                deviceMenuOpen = null;
                return;
            }

            // √ñnceki aktif ikonu temizle
            document.querySelectorAll('.device-icon').forEach(i => i.classList.remove('active'));
            icon.classList.add('active');

            // Panel i√ßeriƒüini olu≈ütur
            const blocks = DEVICE_BLOCKS[deviceData.type] || DEVICE_BLOCKS['generic'];
            panelTitle.textContent = `${deviceData.name} Bloklarƒ±`;
            panelContent.innerHTML = '';

            blocks.forEach(blockDef => {
                const blockDiv = document.createElement('div');
                blockDiv.className = 'device-menu-block';

                // Ge√ßici bir Blockly bloƒüu olu≈ütur
                const tempBlockType = `temp_${deviceData.id}_${blockDef.type}`;

                // Blok tipini tanƒ±mla
                if (!Blockly.Blocks[tempBlockType]) {
                    createDeviceBlock(tempBlockType, blockDef, deviceData);
                }

                try {
                    // Workspace'de ge√ßici blok olu≈ütur
                    const tempBlock = workspace.newBlock(tempBlockType);
                    tempBlock.initSvg();
                    tempBlock.render();

                    // Bloƒüun SVG'sini al
                    const blockSvg = tempBlock.getSvgRoot();
                    const bbox = blockSvg.getBBox();

                    // SVG wrapper olu≈ütur
                    const svgWrapper = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svgWrapper.setAttribute('width', bbox.width + 10);
                    svgWrapper.setAttribute('height', bbox.height + 10);
                    svgWrapper.setAttribute('viewBox', `${bbox.x - 5} ${bbox.y - 5} ${bbox.width + 10} ${bbox.height + 10}`);

                    // ƒ∞√ßeriƒüi clone'la
                    const clonedContent = blockSvg.cloneNode(true);
                    svgWrapper.appendChild(clonedContent);

                    blockDiv.appendChild(svgWrapper);

                    // Ge√ßici bloƒüu sil
                    tempBlock.dispose(false);

                } catch (error) {
                    console.error('Blok √∂nizleme hatasƒ±:', error);
                    // Hata durumunda basit g√∂sterim
                    blockDiv.innerHTML = `
                        <div style="background: ${blockDef.color}; color: white; padding: 10px 15px; border-radius: 8px; font-size: 13px; font-weight: 600;">
                            ${blockDef.icon} ${blockDef.label}
                        </div>
                    `;
                }

                // Drag and drop
                blockDiv.draggable = true;

                blockDiv.ondragstart = (e) => {
                    e.dataTransfer.effectAllowed = 'copy';
                    e.dataTransfer.setData('blockType', blockDef.type);
                    e.dataTransfer.setData('deviceId', deviceData.id);
                    blockDiv.style.opacity = '0.5';
                };

                blockDiv.ondragend = (e) => {
                    blockDiv.style.opacity = '1';
                };

                panelContent.appendChild(blockDiv);
            });

            // Sidebar'ƒ± geni≈ület
            sidebar.classList.add('expanded');
            deviceMenuOpen = deviceData.id;
        }

        function adjustColor(color, amount) {
            const num = parseInt(color.replace("#", ""), 16);
            const r = Math.max(0, Math.min(255, (num >> 16) + amount));
            const g = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amount));
            const b = Math.max(0, Math.min(255, (num & 0x0000FF) + amount));
            return "#" + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
        }

        // Workspace'e drop handler ekle
        function setupWorkspaceDrop() {
            const workspaceDiv = document.getElementById('blocklyDiv');

            workspaceDiv.ondragover = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            };

            workspaceDiv.ondrop = (e) => {
                e.preventDefault();
                const blockType = e.dataTransfer.getData('blockType');
                const deviceId = e.dataTransfer.getData('deviceId');

                if (blockType && deviceId) {
                    const deviceData = connectedDevices.find(d => d.id === deviceId);
                    const blockDef = Object.values(DEVICE_BLOCKS).flat()
                        .find(b => b.type === blockType);

                    if (deviceData && blockDef) {
                        // Mouse pozisyonunu Blockly koordinatlarƒ±na √ßevir
                        const metrics = workspace.getMetrics();
                        const scale = workspace.scale;

                        // Blockly canvas'ƒ±nƒ±n pozisyonunu al
                        const blocklyRect = workspaceDiv.getBoundingClientRect();

                        // Mouse pozisyonunu workspace koordinatlarƒ±na √ßevir
                        const x = (e.clientX - blocklyRect.left) / scale - metrics.viewLeft;
                        const y = (e.clientY - blocklyRect.top) / scale - metrics.viewTop;

                        addDeviceBlockToWorkspace(blockDef, deviceData, x, y);
                    }
                }
            };
        }

        function addDeviceBlockToWorkspace(blockDef, deviceData, x, y) {
            // Dinamik blok olu≈ütur
            const blockType = `${deviceData.id}_${blockDef.type}`;

            // Blok zaten tanƒ±mlƒ± deƒüilse olu≈ütur
            if (!Blockly.Blocks[blockType]) {
                createDeviceBlock(blockType, blockDef, deviceData);
            }

            // Workspace'e ekle
            const newBlock = workspace.newBlock(blockType);
            newBlock.initSvg();
            newBlock.render();

            // Pozisyon belirtilmi≈üse kullan, yoksa varsayƒ±lan
            if (x !== undefined && y !== undefined) {
                newBlock.moveBy(x, y);
            } else {
                newBlock.moveBy(200, 100);
            }

            console.log('Cihaz bloƒüu eklendi:', blockType, 'at', x, y);
        }

        function createDeviceBlock(blockType, blockDef, deviceData) {
            Blockly.Blocks[blockType] = {
                init: function () {
                    const input = this.appendDummyInput();

                    if (DEVICE_ICONS[blockDef.icon]) {
                        input.appendField(new Blockly.FieldImage(DEVICE_ICONS[blockDef.icon], 16, 16, "*"));
                    } else {
                        input.appendField(blockDef.icon);
                    }

                    // Label'ƒ± par√ßala ve number field'larƒ± ekle
                    const parts = blockDef.label.split(/\[|\]/);
                    parts.forEach((part, index) => {
                        if (index % 2 === 0) {
                            // Normal text
                            if (part.trim()) input.appendField(part.trim());
                        } else {
                            // Number field
                            const value = parseInt(part) || 1;
                            input.appendField(new CustomNumberField(value, 1, 100), `VAL${index}`);
                        }
                    });

                    if (blockDef.isEvent) {
                        this.setNextStatement(true, null);
                    } else {
                        this.setPreviousStatement(true, null);
                        this.setNextStatement(true, null);
                    }

                    this.setColour(blockDef.color);
                    this.data = deviceData.id;
                }
            };

            // Kod √ºretici
            Blockly.Python[blockType] = function (block) {
                return `# ${deviceData.name}: ${blockDef.label}\n`;
            };
        }

        function updateDevicesTable() {
            const tbody = document.getElementById('devicesTableBody');
            const t = TRANSLATIONS[currentLanguage];

            if (connectedDevices.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="4" style="padding: 30px; text-align: center; color: #999;">
                            ${t.no_device}
                        </td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = '';

            connectedDevices.forEach((device, index) => {
                const row = document.createElement('tr');
                row.style.borderBottom = '1px solid #e0e0e0';
                row.style.background = index % 2 === 0 ? 'white' : '#f9f9f9';

                const statusIcon = device.connected ? 'üü¢' : 'üî¥';
                const statusText = device.connected ? t.status_connected : t.status_disconnected;
                const statusColor = device.connected ? '#0FBD8C' : '#FF6680';

                row.innerHTML = `
                    <td style="padding: 12px; font-size: 14px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div style="width: 20px; height: 20px; border-radius: 50%; background: ${device.color}; border: 2px solid ${device.color};"></div>
                            <strong>${device.name}</strong>
                        </div>
                    </td>
                    <td style="padding: 12px; font-size: 12px; color: #666; font-family: monospace;">
                        ${device.id}
                    </td>
                    <td style="padding: 12px; text-align: center;">
                        <span style="background: ${statusColor}20; color: ${statusColor}; padding: 4px 12px; border-radius: 12px; font-size: 12px; font-weight: bold;">
                            ${statusIcon} ${statusText}
                        </span>
                    </td>
                    <td style="padding: 12px; text-align: center;">
                        <div style="display: flex; gap: 8px; justify-content: center;">
                            ${device.type === 'spike_essential' ? `
                                <button onclick="openDeviceSettings('${device.id}')" style="background: #4C97FF; color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: bold; display: flex; align-items: center; gap: 6px;">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="white"><path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.64-.06.94s.02.63.06.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
                                    Settings
                                </button>
                            ` : ''}
                            <button onclick="removeDeviceFromTable('${device.id}')" style="background: #FF6680; color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: bold; display: flex; align-items: center; gap: 6px;">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="white"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
                                ${t.btn_remove}
                            </button>
                        </div>
                    </td>
                `;

                tbody.appendChild(row);
            });
        }

        let pendingRemoveDeviceId = null;

        function removeDeviceFromTable(deviceId) {
            pendingRemoveDeviceId = deviceId;
            const modal = document.getElementById('removeDeviceModal');
            if (modal) {
                modal.classList.add('active');
            }
        }

        function closeRemoveDeviceModal() {
            const modal = document.getElementById('removeDeviceModal');
            if (modal) {
                modal.classList.remove('active');
            }
            pendingRemoveDeviceId = null;
        }

        function confirmRemoveDevice() {
            if (pendingRemoveDeviceId) {
                removeDevice(pendingRemoveDeviceId);
            }
            closeRemoveDeviceModal();
        }

        // Device Settings Modal
        let currentSettingsDeviceId = null;

        function openDeviceSettings(deviceId) {
            currentSettingsDeviceId = deviceId;
            const device = connectedDevices.find(d => d.id === deviceId);
            if (!device) return;

            // Update title
            const title = document.getElementById('deviceSettingsTitle');
            if (title) title.textContent = `Settings: ${device.name}`;

            // Set current nickname
            const nicknameInput = document.getElementById('deviceNicknameInput');
            if (nicknameInput) nicknameInput.value = device.name || '';

            // Generate LED color picker
            const colorPicker = document.getElementById('ledColorPicker');
            if (colorPicker) {
                colorPicker.innerHTML = '';
                Object.entries(LEGO_COLORS).forEach(([index, colorData]) => {
                    const btn = document.createElement('button');
                    btn.style.cssText = `
                        width: 36px; height: 36px; border-radius: 50%; border: 3px solid #e0e0e0;
                        background: ${colorData.hex}; cursor: pointer; transition: all 0.2s;
                        ${colorData.name === 'Off' ? 'background: linear-gradient(45deg, #333 25%, #666 25%, #666 50%, #333 50%, #333 75%, #666 75%);' : ''}
                    `;
                    btn.title = colorData.name;
                    btn.onclick = () => setHubLedColor(parseInt(index));

                    // Highlight current color
                    if (spikeHubState.hubColor === parseInt(index)) {
                        btn.style.borderColor = '#4C97FF';
                        btn.style.transform = 'scale(1.1)';
                    }

                    colorPicker.appendChild(btn);
                });
            }

            // Show modal
            const modal = document.getElementById('deviceSettingsModal');
            if (modal) modal.classList.add('active');
        }

        function closeDeviceSettings() {
            const modal = document.getElementById('deviceSettingsModal');
            if (modal) modal.classList.remove('active');
            currentSettingsDeviceId = null;
        }

        async function saveDeviceNickname() {
            if (!currentSettingsDeviceId) return;
            const device = connectedDevices.find(d => d.id === currentSettingsDeviceId);
            if (!device || !spikeHubState.writeChar) {
                console.error('‚ùå Cannot save nickname: device or writeChar not available');
                return;
            }

            const nicknameInput = document.getElementById('deviceNicknameInput');
            const newName = nicknameInput.value.trim().substring(0, 14);
            if (!newName) return;

            try {
                // LWP3 Hub Properties - Set Advertising Name
                // Format: [Length] [0x00] [0x01] [0x01] [0x01] [name bytes...]
                // 0x01 = Hub Properties, 0x01 = Advertising Name, 0x01 = Set operation
                const nameBytes = new TextEncoder().encode(newName);
                const data = new Uint8Array(5 + nameBytes.length);
                data[0] = 5 + nameBytes.length; // Length
                data[1] = 0x00; // Hub ID
                data[2] = 0x01; // Hub Properties
                data[3] = 0x01; // Property: Advertising Name
                data[4] = 0x01; // Operation: Set
                data.set(nameBytes, 5);

                await spikeHubState.writeChar.writeValueWithoutResponse(data);
                console.log('‚úÖ Hub nickname saved:', newName);

                // Update local device name
                device.name = newName;
                updateDevicesTable();

                // Update panel header
                const header = document.getElementById('spikeEssentialHeader');
                if (header) {
                    // Keep the color dot, update text
                    const colorDot = document.getElementById('spikeHubColorDot');
                    header.textContent = newName;
                    if (colorDot) header.appendChild(colorDot);
                }

                // Visual feedback
                nicknameInput.style.borderColor = '#37b24d';
                setTimeout(() => { nicknameInput.style.borderColor = '#e0e0e0'; }, 1500);

            } catch (e) {
                console.error('‚ùå Failed to save nickname:', e);
                nicknameInput.style.borderColor = '#e03131';
                setTimeout(() => { nicknameInput.style.borderColor = '#e0e0e0'; }, 1500);
            }
        }

        async function setHubLedColor(colorIndex) {
            if (!spikeHubState.writeChar) {
                console.error('‚ùå Cannot set LED color: writeChar not available');
                return;
            }

            try {
                // LWP3 Port Output Command - Set LED Color
                // Format: [0x08] [0x00] [0x81] [0x31] [0x11] [0x51] [0x00] [ColorIndex]
                // 0x81 = Port Output Command
                // 0x31 = RGB Light port
                // 0x11 = Execute immediately, no feedback
                // 0x51 = Write Direct Mode Data
                // 0x00 = Mode (Color Index)
                const data = new Uint8Array([0x08, 0x00, 0x81, 0x31, 0x11, 0x51, 0x00, colorIndex]);
                await spikeHubState.writeChar.writeValueWithoutResponse(data);

                console.log('‚úÖ Hub LED color set to:', LEGO_COLORS[colorIndex]?.name || colorIndex);

                // Update state and UI
                spikeHubState.hubColor = colorIndex;
                updateSpikeHubColor(colorIndex);

                // Update picker highlight
                const colorPicker = document.getElementById('ledColorPicker');
                if (colorPicker) {
                    colorPicker.querySelectorAll('button').forEach((btn, i) => {
                        if (i === colorIndex) {
                            btn.style.borderColor = '#4C97FF';
                            btn.style.transform = 'scale(1.1)';
                        } else {
                            btn.style.borderColor = '#e0e0e0';
                            btn.style.transform = 'scale(1)';
                        }
                    });
                }

            } catch (e) {
                console.error('‚ùå Failed to set LED color:', e);
            }
        }

        async function setSpikeMatrix(portLetter, pixels) {
            if (!spikeHubState.writeChar) {
                console.log('‚ö†Ô∏è Matrix update skipped: writeChar not ready');
                return;
            }

            try {
                const portId = portLetter === 'A' ? 0x00 : 0x01;

                // Update State (Pixels)
                if (spikeHubState.matrix && spikeHubState.matrix[portLetter]) {
                    spikeHubState.matrix[portLetter].pixels = pixels;
                }

                // Get Global Brightness (Default 10)
                let globalBr = 10;
                if (spikeHubState.matrix && spikeHubState.matrix[portLetter]) {
                    globalBr = spikeHubState.matrix[portLetter].brightness;
                }

                // 1. FORCE MODE 2 (9 values)
                const setupData = new Uint8Array([
                    0x0A, 0x00, 0x41, portId, 0x02, 0x01, 0x00, 0x00, 0x00, 0x01
                ]);
                await spikeHubState.writeChar.writeValueWithoutResponse(setupData);

                await new Promise(r => setTimeout(r, 50));

                // 2. SEND MODE 2 DATA (Format: Br << 4 | Color)
                // Support both Number (ColorIndex) and Object {color, brightness}
                const packedPixels = pixels.map(p => {
                    let c = 0;
                    let b = globalBr;

                    if (typeof p === 'object' && p !== null) {
                        c = p.color || 0;
                        if (p.brightness !== undefined) b = p.brightness;
                    } else {
                        c = Number(p);
                    }

                    c = Math.min(10, Math.max(0, c));
                    b = Math.min(10, Math.max(0, b));

                    // If Color is 0 (Black), Output 0 (Off)
                    if (c === 0) return 0x00;

                    // Pack: (Brightness << 4) | Color
                    return ((b & 0xF) << 4) | (c & 0xF);
                });

                const data = new Uint8Array([
                    0x10, 0x00, 0x81, portId, 0x11, 0x51, 0x02,
                    ...packedPixels
                ]);

                // console.log(`üì§ Sending Matrix CMD (Br=${brVal}):`, packedPixels);
                await spikeHubState.writeChar.writeValueWithoutResponse(data);

            } catch (err) {
                console.error('‚ùå Matrix Update Error:', err);
            }
        }

        async function setSpikeMatrixBrightness(portLetter, percent) {
            if (spikeHubState.matrix && spikeHubState.matrix[portLetter]) {
                const b = Math.round((percent / 100) * 10);
                spikeHubState.matrix[portLetter].brightness = Math.min(10, Math.max(0, b));
                console.log(`üîÜ Matrix ${portLetter} brightness set to ${b} (${percent}%)`);
                // Resend current pixels with new brightness
                await setSpikeMatrix(portLetter, spikeHubState.matrix[portLetter].pixels);
            }
        }


        let selectedBlock = null;

        function handleBlockSelection(event) {
            const deleteOverlay = document.getElementById('deleteBlockOverlay');

            if (event.newElementId) {
                // Bir blok se√ßildi
                selectedBlock = workspace.getBlockById(event.newElementId);
                if (selectedBlock) {
                    deleteOverlay.classList.add('show');
                }
            } else {
                // Se√ßim kaldƒ±rƒ±ldƒ±
                selectedBlock = null;
                deleteOverlay.classList.remove('show');
            }
        }

        function deleteSelectedBlock() {
            if (selectedBlock) {
                selectedBlock.dispose(true);
                selectedBlock = null;
                document.getElementById('deleteBlockOverlay').classList.remove('show');
            }
        }

        function duplicateSelectedBlock() {
            if (selectedBlock && workspace) {
                // Blok XML'ini al
                const xml = Blockly.Xml.blockToDom(selectedBlock);
                // Yeni blok olu≈ütur
                const newBlock = Blockly.Xml.domToBlock(xml, workspace);
                // Yeni bloƒüu biraz kaydƒ±r
                const oldPos = selectedBlock.getRelativeToSurfaceXY();
                newBlock.moveBy(oldPos.x + 30, oldPos.y + 30);
                console.log('üìã Blok kopyalandƒ±');
            }
        }

        // --- Block Documentation & Help ---
        const BLOCK_DOCS = {
            'start': {
                en: `
# Start Block
When clicking the "Play" button, the code connected to this block runs.

### How to use
Connect this block to the beginning of your program.
`,
                tr: `
# Ba≈ülangƒ±√ß Bloƒüu
"Oynat" butonuna tƒ±klandƒ±ƒüƒ±nda, bu bloƒüa baƒülƒ± olan kodlar √ßalƒ±≈üƒ±r.

### Nasƒ±l Kullanƒ±lƒ±r
Bu bloƒüu programƒ±nƒ±zƒ±n en ba≈üƒ±na yerle≈ütirin.
`
            },
            'when_condition': {
                en: `
# When Condition
Continuously checks a condition. When it becomes **True**, the connected blocks run.

### Example
When detecting a red color, stop the motor.
`,
                tr: `
# Bir Durum Olduƒüunda
S√ºrekli olarak bir ko≈üulu kontrol eder. Ko≈üul **Doƒüru** olduƒüunda, altƒ±ndaki bloklarƒ± √ßalƒ±≈ütƒ±rƒ±r.

### √ñrnek
Kƒ±rmƒ±zƒ± renk algƒ±landƒ±ƒüƒ±nda motoru durdur.
`
            },
            'wait': {
                en: `
# Wait
Pauses the program for a specific amount of time.

### Parameters
- **Seconds**: How long to wait (e.g., 1, 0.5).
`,
                tr: `
# Bekle
Programƒ± belirli bir s√ºre duraklatƒ±r.

### Parametreler
- **Saniye**: Ne kadar bekleneceƒüi (√∂rn. 1, 0.5).
`
            },
            'wait_until': {
                en: `
# Wait Until
Pauses the program execution until a specific condition becomes true.
`,
                tr: `
# Olana Kadar Bekle
Belirli bir ko≈üul ger√ßekle≈üene kadar programƒ± bekletir.
`
            },
            'repeat_forever': {
                en: `
# Repeat Forever
Runs the blocks inside it continuously in a loop, forever.
`,
                tr: `
# S√ºrekli Tekrarla
ƒ∞√ßindeki bloklarƒ± sonsuza kadar s√ºrekli tekrar eder.
`
            },
            'repeat': {
                en: '# Repeat\nRuns the blocks inside a specific number of times.',
                tr: '# Tekrarla\nƒ∞√ßindeki bloklarƒ± belirli bir sayƒ±da tekrar eder.'
            },
            'forever': {
                en: '# Forever\nRuns the blocks inside continuously forever.',
                tr: '# S√ºrekli √áalƒ±≈ütƒ±r\nƒ∞√ßindeki bloklarƒ± sonsuza kadar s√ºrekli √ßalƒ±≈ütƒ±rƒ±r.'
            },
            'if_then': {
                en: '# If Then\nIf the condition check is **TRUE**, the blocks inside will run.',
                tr: '# Eƒüer ƒ∞se\nEƒüer ko≈üul **DOƒûRU** ise, i√ßindeki bloklar √ßalƒ±≈üƒ±r.'
            },
            'if_then_else': {
                en: '# If / Else\nIf the condition is **TRUE**, runs the first blocks. If **FALSE**, runs the "Else" blocks.',
                tr: '# Eƒüer / Deƒüilse\nKo≈üul **DOƒûRU** ise ilk bloklarƒ± √ßalƒ±≈ütƒ±rƒ±r. **YANLI≈û** ise "Deƒüilse" kƒ±smƒ±ndaki bloklarƒ± √ßalƒ±≈ütƒ±rƒ±r.'
            },
            'repeat_until': {
                en: '# Repeat Until\nRepeats the blocks inside until the condition becomes true.',
                tr: '# Olana Kadar Tekrarla\nKo≈üul doƒüru olana kadar i√ßindeki bloklarƒ± tekrar eder.'
            },

            // --- Operators & Math ---
            'math_arithmetic': {
                en: '# Arithmetic\nPerforms mathematical operations (+, -, x, √∑) on two numbers.',
                tr: '# Aritmetik\nƒ∞ki sayƒ± √ºzerinde matematiksel i≈ülemler (+, -, x, √∑) yapar.'
            },
            'logic_compare': {
                en: '# Comparison\nCompares two values (Equal, Greater Than, Less Than). Returns True or False.',
                tr: '# Kar≈üƒ±la≈ütƒ±rma\nƒ∞ki deƒüeri kar≈üƒ±la≈ütƒ±rƒ±r (E≈üittir, B√ºy√ºkt√ºr, K√º√ß√ºkt√ºr). Doƒüru veya Yanlƒ±≈ü d√∂nd√ºr√ºr.'
            },
            'logic_and': {
                en: '# And\nReturns True only if **BOTH** conditions are True.',
                tr: '# Ve (And)\nSadece **ƒ∞Kƒ∞** ko≈üul da Doƒüru ise Doƒüru d√∂nd√ºr√ºr.'
            },
            'logic_or': {
                en: '# Or\nReturns True if **AT LEAST ONE** condition is True.',
                tr: '# Veya (Or)\nKo≈üullardan **EN AZ Bƒ∞Rƒ∞** Doƒüru ise Doƒüru d√∂nd√ºr√ºr.'
            },
            'logic_negate': {
                en: '# Not\nInverts a condition. True becomes False, False becomes True.',
                tr: '# Deƒüil\nBir ko≈üulu tersine √ßevirir. Doƒüru Yanlƒ±≈ü olur, Yanlƒ±≈ü Doƒüru olur.'
            },
            'math_random': {
                en: '# Pick Random\nPicks a random integer between two numbers.',
                tr: '# Rastgele Sayƒ±\nƒ∞ki sayƒ± arasƒ±nda rastgele bir tam sayƒ± se√ßer.'
            },
            'math_number': {
                en: '# Number\nA generic number block used to set values.',
                tr: '# Sayƒ±\nDeƒüer ayarlamak i√ßin kullanƒ±lan genel sayƒ± bloƒüu.'
            },
            'math_round': {
                en: '# Round\nRounds a number to the nearest integer, up, or down.',
                tr: '# Yuvarla\nBir sayƒ±yƒ± en yakƒ±n tam sayƒ±ya, yukarƒ±ya veya a≈üaƒüƒ±ya yuvarlar.'
            },
            'math_modulo': {
                en: '# Remainder\nReturns the remainder after division.',
                tr: '# Kalan\nB√∂lme i≈üleminden kalanƒ± verir.'
            },

            // --- Events ---
            'when_message_received': {
                en: `
# When Message Received
Triggers when a specific message is broadcasted.
`,
                tr: `
# Mesaj Alƒ±ndƒ±ƒüƒ±nda
Belirli bir mesaj yayƒ±nlandƒ±ƒüƒ±nda √ßalƒ±≈üƒ±r.
`
            },
            'send_message': {
                en: `
# Send Message
Broadcasts a message to trigger other scripts.
`,
                tr: `
# Mesaj G√∂nder
Diƒüer komut dizilerini tetiklemek i√ßin bir mesaj yayƒ±nlar.
`
            },

            // --- Motor Blocks ---
            'motor_run_rotation': {
                en: `
# Motor Run (Rotations)
Runs the motor for a specific number of rotations.

### Parameters
- **Rotations**: Number of full turns (e.g., 1, 0.5).
- **Direction**: Clockwise or Counter-Clockwise.
`,
                tr: `
# Motoru √áevir (Tur)
Motoru belirli bir tur sayƒ±sƒ± kadar d√∂nd√ºr√ºr.

### Parametreler
- **Tur**: Tam tur sayƒ±sƒ± (√∂rn. 1, 0.5).
- **Y√∂n**: Saat y√∂n√º veya tersi.
`
            },
            'motor_run_seconds': {
                en: `
# Motor Run (Seconds)
Runs the motor for a specific amount of time.

### Parameters
- **Seconds**: Time in seconds.
`,
                tr: `
# Motoru √áalƒ±≈ütƒ±r (Saniye)
Motoru belirli bir s√ºre √ßalƒ±≈ütƒ±rƒ±r.

### Parametreler
- **Saniye**: S√ºre (saniye cinsinden).
`
            },
            'motor_start': {
                en: `
# Start Motor
Starts the motor running continuously until stopped.
`,
                tr: `
# Motoru Ba≈ülat
Motoru durdurulana kadar s√ºrekli √ßalƒ±≈ütƒ±rƒ±r.
`
            },
            'motor_stop': {
                en: `
# Stop Motor
Stops the specific motor immediately.
`,
                tr: `
# Motoru Durdur
Se√ßilen motoru anƒ±nda durdurur.
`
            },
            'motor_speed': {
                en: `
# Set Motor Speed
Sets the speed (0-100%) for subsequent motor commands.
`,
                tr: `
# Motor Hƒ±zƒ±nƒ± Ayarla
Sonraki motor komutlarƒ± i√ßin hƒ±zƒ± (0-100%) ayarlar.
`
            },

            // --- Color Sensor ---
            'when_color_detected': {
                en: `
# When Color Detected
Triggers an event when the Color Sensor detects a specific color.

### Parameters
- **Color**: Select the color (Red, Green, Blue, etc.).
`,
                tr: `
# Renk Algƒ±landƒ±ƒüƒ±nda
Renk Sens√∂r√º belirli bir rengi algƒ±ladƒ±ƒüƒ±nda √ßalƒ±≈üƒ±r.

### Parametreler
- **Renk**: Algƒ±lanacak rengi se√ßin (Kƒ±rmƒ±zƒ±, Ye≈üil, Mavi vb.).
`
            },
            'detecting_color': {
                en: `
# Detecting Color?
Checks if the Color Sensor is currently seeing a specific color. (True/False)
`,
                tr: `
# Renk Algƒ±lanƒ±yor mu?
Renk Sens√∂r√ºn√ºn ≈üu anda belirli bir rengi g√∂r√ºp g√∂rmediƒüini kontrol eder. (Doƒüru/Yanlƒ±≈ü)
`
            },
            'color_value': {
                en: `
# Color Name
Returns the name of the color currently seen by the sensor.
`,
                tr: `
# Renk Deƒüi≈ükeni
Sens√∂r√ºn ≈üu anda g√∂rd√ºƒü√º rengin ismini verir.
`
            },
            'reflection_value': {
                en: `
# Reflection %
Returns the light reflection percentage (0-100). useful for line following.
`,
                tr: `
# Yansƒ±ma %
I≈üƒ±k yansƒ±ma y√ºzdesini (0-100) verir. √áizgi izlemek i√ßin kullanƒ±≈ülƒ±dƒ±r.
`
            },

            // --- Controller ---
            'when_controller_button': {
                en: `
# When Button Pressed
Runs code when a specific button on the controller is pressed or released.
`,
                tr: `
# D√ºƒümeye Basƒ±ldƒ±ƒüƒ±nda
Kumandadaki belirli bir d√ºƒümeye basƒ±ldƒ±ƒüƒ±nda veya bƒ±rakƒ±ldƒ±ƒüƒ±nda √ßalƒ±≈üƒ±r.
`
            },
            'controller_axis': {
                en: `
# Controller Axis
Returns the numeric value (-100 to 100) of a joystick axis.
`,
                tr: `
# Kumanda Ekseni
Joystick ekseninin sayƒ±sal deƒüerini (-100 ile 100 arasƒ±) verir.
`
            },

            // --- LED ---
            'rgb_red_on': { en: '# Red LED On\nTurns on the Red LED.', tr: '# Kƒ±rmƒ±zƒ± LED A√ß\nKƒ±rmƒ±zƒ± LED\'i yakar.' },
            'rgb_green_on': { en: '# Green LED On\nTurns on the Green LED.', tr: '# Ye≈üil LED A√ß\nYe≈üil LED\'i yakar.' },
            'rgb_blue_on': { en: '# Blue LED On\nTurns on the Blue LED.', tr: '# Mavi LED A√ß\nMavi LED\'i yakar.' },
            'rgb_red_off': { en: '# Red LED Off\nTurns off the Red LED.', tr: '# Kƒ±rmƒ±zƒ± LED Kapat\nKƒ±rmƒ±zƒ± LED\'i s√∂nd√ºr√ºr.' },

            // --- LED Getters ---
            'rgb_red_light_get': { en: '# Get Red Status\nReturns TRUE if Red LED is On.', tr: '# Kƒ±rmƒ±zƒ± Durumu\nKƒ±rmƒ±zƒ± LED A√ßƒ±k ise DOƒûRU d√∂nd√ºr√ºr.' },
            'rgb_green_light_get': { en: '# Get Green Status\nReturns TRUE if Green LED is On.', tr: '# Ye≈üil Durumu\nYe≈üil LED A√ßƒ±k ise DOƒûRU d√∂nd√ºr√ºr.' },
            'rgb_blue_light_get': { en: '# Get Blue Status\nReturns TRUE if Blue LED is On.', tr: '# Mavi Durumu\nMavi LED A√ßƒ±k ise DOƒûRU d√∂nd√ºr√ºr.' },

            'rgb_red_get': { en: '# Get Red Value\nReturns current brightness (0-255).', tr: '# Kƒ±rmƒ±zƒ± Deƒüeri\nMevcut parlaklƒ±ƒüƒ± verir (0-255).' },
            'rgb_green_get': { en: '# Get Green Value\nReturns current brightness (0-255).', tr: '# Ye≈üil Deƒüeri\nMevcut parlaklƒ±ƒüƒ± verir (0-255).' },
            'rgb_blue_get': { en: '# Get Blue Value\nReturns current brightness (0-255).', tr: '# Mavi Deƒüeri\nMevcut parlaklƒ±ƒüƒ± verir (0-255).' },

            // --- Action Buttons ---
            'rgb_red_button_get': { en: '# Red Button Pressed?\nReturns true if the Red button is pressed.', tr: '# Kƒ±rmƒ±zƒ± D√ºƒümeye Basƒ±ldƒ± mƒ±?\nKƒ±rmƒ±zƒ± d√ºƒümeye basƒ±lƒ±yorsa Doƒüru deƒüerini verir.' },
            'rgb_green_button_get': { en: '# Green Button Pressed?\nReturns true if the Green button is pressed.', tr: '# Ye≈üil D√ºƒümeye Basƒ±ldƒ± mƒ±?\nYe≈üil d√ºƒümeye basƒ±lƒ±yorsa Doƒüru deƒüerini verir.' },
            'rgb_blue_button_get': { en: '# Blue Button Pressed?\nReturns true if the Blue button is pressed.', tr: '# Mavi D√ºƒümeye Basƒ±ldƒ± mƒ±?\nMavi d√ºƒümeye basƒ±lƒ±yorsa Doƒüru deƒüerini verir.' },

            // --- Action Numbers (Set) ---
            'rgb_red_num': { en: '# Set Red LED\nSets the Red LED brightness (0-255).', tr: '# Kƒ±rmƒ±zƒ± LED Ayarla\nKƒ±rmƒ±zƒ± LED parlaklƒ±ƒüƒ±nƒ± ayarlar (0-255).' },
            'rgb_green_num': { en: '# Set Green LED\nSets the Green LED brightness (0-255).', tr: '# Ye≈üil LED Ayarla\nYe≈üil LED parlaklƒ±ƒüƒ±nƒ± ayarlar (0-255).' },
            'rgb_blue_num': { en: '# Set Blue LED\nSets the Blue LED brightness (0-255).', tr: '# Mavi LED Ayarla\nMavi LED parlaklƒ±ƒüƒ±nƒ± ayarlar (0-255).' },

            // --- Math/Logic ---
            'math_number': { en: '# Number\nA numeric value.', tr: '# Sayƒ±\nSayƒ±sal bir deƒüer.' },
            'logic_compare': { en: '# Compare\nCompares two values (e.g. A > B).', tr: '# Kar≈üƒ±la≈ütƒ±r\nƒ∞ki deƒüeri kar≈üƒ±la≈ütƒ±rƒ±r (√∂rn. A > B).' },
            'math_arithmetic': { en: '# Arithmetic\nPerforms math operations (+, -, *, /).', tr: '# Matematik\nMatematiksel i≈ülem yapar (+, -, *, /).' },
            'math_random_int': { en: '# Pick Random\nPicks a random integer between two numbers.', tr: '# Rastgele Sayƒ±\nƒ∞ki sayƒ± arasƒ±nda rastgele bir tam sayƒ± se√ßer.' },
            'logic_operation': { en: '# Logic Operation\nConnects two conditions (AND / OR).', tr: '# Mantƒ±ksal ƒ∞≈ülem\nƒ∞ki ko≈üulu baƒülar (VE / VEYA).' },
            'logic_negate': { en: '# Not\nInverts a condition (True becomes False).', tr: '# Deƒüil\nBir ko≈üulun tersini alƒ±r (Doƒüru ise Yanlƒ±≈ü olur).' },

            // --- Spike Essential Hub ---
            'hub_led_color': {
                en: `
# Hub LED Color
Changes the color of the LED light on the Spike Essential Hub.

### Parameters
- **Color**: Choose from predefined colors (Black, Pink, Violet, Blue, Cyan, Green, Yellow, Orange, Red, White).

### Example
Set the hub light to Green when connected.
`,
                tr: `
# Hub LED Rengi
Spike Essential Hub √ºzerindeki LED ƒ±≈üƒ±ƒüƒ±nƒ±n rengini deƒüi≈ütirir.

### Parametreler
- **Renk**: √ñnceden tanƒ±mlƒ± renklerden birini se√ßin (Siyah, Pembe, Mor, Mavi, Camg√∂beƒüi, Ye≈üil, Sarƒ±, Turuncu, Kƒ±rmƒ±zƒ±, Beyaz).

### √ñrnek
Baƒülandƒ±ƒüƒ±nda hub ƒ±≈üƒ±ƒüƒ±nƒ± Ye≈üil yapƒ±n.
`
            },
            'hub_orientation': {
                en: `
# Hub Orientation
Detects the orientation/position of the Spike Essential Hub.

### Return Values
- **Front, Back, Left, Right, Top, Bottom**: Current orientation.

### Example
When the hub is tilted left, play a sound.
`,
                tr: `
# Hub Y√∂nelimi
Spike Essential Hub'ƒ±n y√∂n√ºn√º/pozisyonunu algƒ±lar.

### D√∂n√º≈ü Deƒüerleri
- **√ñn, Arka, Sol, Saƒü, √úst, Alt**: Mevcut y√∂nelim.

### √ñrnek
Hub sola eƒüildiƒüinde ses √ßal.
`
            },

            // --- Color Light Matrix (3x3) ---
            'matrix_turn_on': {
                en: `
# Matrix Turn On
Displays a custom pattern on the 3x3 Color Light Matrix.

### Parameters
- **Port**: A or B
- **Pattern**: Click pixels to set colors.

### Colors Available
Black (off), Pink, Violet, Blue, Cyan, Teal, Green, Yellow, Orange, Red, White.
`,
                tr: `
# Matris A√ß
3x3 Renkli I≈üƒ±k Matrisinde √∂zel bir desen g√∂r√ºnt√ºler.

### Parametreler
- **Port**: A veya B
- **Desen**: Renk ayarlamak i√ßin piksellere tƒ±klayƒ±n.

### Mevcut Renkler
Siyah (kapalƒ±), Pembe, Mor, Mavi, Camg√∂beƒüi, Turkuaz, Ye≈üil, Sarƒ±, Turuncu, Kƒ±rmƒ±zƒ±, Beyaz.
`
            },
            'matrix_turn_off': {
                en: `
# Matrix Turn Off
Turns off all pixels on the 3x3 Color Light Matrix.

### Parameters
- **Port**: A or B
`,
                tr: `
# Matris Kapat
3x3 Renkli I≈üƒ±k Matrisindeki t√ºm pikselleri kapatƒ±r.

### Parametreler
- **Port**: A veya B
`
            },
            'matrix_set_brightness': {
                en: `
# Set Pixel Brightness
Sets the brightness level for all pixels on the matrix.

### Parameters
- **Port**: A or B
- **Brightness**: 0-100%

### Note
This affects all pixels. Use the pattern block to set which pixels are lit.
`,
                tr: `
# Piksel Parlaklƒ±ƒüƒ±nƒ± Ayarla
Matristeki t√ºm piksellerin parlaklƒ±k seviyesini ayarlar.

### Parametreler
- **Port**: A veya B
- **Parlaklƒ±k**: 0-100%

### Not
Bu t√ºm pikselleri etkiler. Hangi piksellerin yanacaƒüƒ±nƒ± desen bloƒüuyla ayarlayƒ±n.
`
            },
            'matrix_set_pixel_at': {
                en: `
# Set Pixel At Position
Sets a specific pixel's color and brightness on the 3x3 matrix.

### Parameters
- **Port**: A or B
- **X**: Column (1-3)
- **Y**: Row (1-3)
- **Color**: Pink, Red, Blue, etc.
- **Brightness**: 0-100%

### Coordinate System
\`\`\`
(1,1) (2,1) (3,1)
(1,2) (2,2) (3,2)
(1,3) (2,3) (3,3)
\`\`\`
`,
                tr: `
# Belirli Pikseli Ayarla
3x3 matristeki belirli bir pikselin rengini ve parlaklƒ±ƒüƒ±nƒ± ayarlar.

### Parametreler
- **Port**: A veya B
- **X**: S√ºtun (1-3)
- **Y**: Satƒ±r (1-3)
- **Renk**: Pembe, Kƒ±rmƒ±zƒ±, Mavi vb.
- **Parlaklƒ±k**: 0-100%

### Koordinat Sistemi
\`\`\`
(1,1) (2,1) (3,1)
(1,2) (2,2) (3,2)
(1,3) (2,3) (3,3)
\`\`\`
`
            },
            'matrix_rotate_pattern': {
                en: `
# Rotate Pattern
Rotates the current pattern on the matrix 90 degrees.

### Parameters
- **Port**: A or B
- **Direction**: ‚Ü∑ Clockwise or ‚Ü∂ Counter-Clockwise

### Example
Create an animation by rotating a pattern in a loop.
`,
                tr: `
# Deseni D√∂nd√ºr
Matristeki mevcut deseni 90 derece d√∂nd√ºr√ºr.

### Parametreler
- **Port**: A veya B
- **Y√∂n**: ‚Ü∑ Saat y√∂n√ºnde veya ‚Ü∂ Saat y√∂n√ºn√ºn tersi

### √ñrnek
Bir d√∂ng√ºde deseni d√∂nd√ºrerek animasyon olu≈üturun.
`
            },

            // --- Force Sensor ---
            'force_sensor_is_pressed': {
                en: `
# Force Sensor Pressed?
Checks if the Force Sensor is pressed, hard-pressed, or released.

### Parameters
- **Port**: A or B
- **State**: 
  - **Pressed**: Lightly touched
  - **Hard-Pressed**: Firmly pressed
  - **Released**: Not touched

### Returns
True or False
`,
                tr: `
# Kuvvet Sens√∂r√º Basƒ±lƒ± mƒ±?
Kuvvet Sens√∂r√ºn√ºn basƒ±lƒ±, sert basƒ±lƒ± veya bƒ±rakƒ±lmƒ±≈ü olup olmadƒ±ƒüƒ±nƒ± kontrol eder.

### Parametreler
- **Port**: A veya B
- **Durum**: 
  - **Basƒ±lƒ±**: Hafif√ße dokunulmu≈ü
  - **Sert Basƒ±lƒ±**: Sƒ±kƒ±ca basƒ±lmƒ±≈ü
  - **Bƒ±rakƒ±lmƒ±≈ü**: Dokunulmamƒ±≈ü

### D√∂nd√ºr√ºr
Doƒüru veya Yanlƒ±≈ü
`
            },
            'force_sensor_pressure': {
                en: `
# Force Sensor Pressure
Returns the current pressure value from the Force Sensor.

### Parameters
- **Port**: A or B
- **Unit**: 
  - **Newton**: Force in Newtons (0-10N)
  - **%**: Percentage (0-100%)

### Example
Move motor faster when more pressure is applied.
`,
                tr: `
# Kuvvet Sens√∂r√º Basƒ±ncƒ±
Kuvvet Sens√∂r√ºnden mevcut basƒ±n√ß deƒüerini d√∂nd√ºr√ºr.

### Parametreler
- **Port**: A veya B
- **Birim**: 
  - **Newton**: Newton cinsinden kuvvet (0-10N)
  - **%**: Y√ºzde (0-100%)

### √ñrnek
Daha fazla basƒ±n√ß uygulandƒ±ƒüƒ±nda motoru daha hƒ±zlƒ± hareket ettirin.
`
            },

            // --- Additional Motor Blocks ---
            'motor_run_to_angle': {
                en: `
# Motor Run to Angle
Rotates the motor to a specific angle position.

### Parameters
- **Angle**: Target angle in degrees (0-360).
- **Direction**: Shortest path, Clockwise, or Counter-Clockwise.
`,
                tr: `
# Motoru A√ßƒ±ya D√∂nd√ºr
Motoru belirli bir a√ßƒ± konumuna d√∂nd√ºr√ºr.

### Parametreler
- **A√ßƒ±**: Hedef a√ßƒ± (derece cinsinden, 0-360).
- **Y√∂n**: En kƒ±sa yol, Saat y√∂n√º veya Saat y√∂n√ºn√ºn tersi.
`
            },
            'motor_go_to_position': {
                en: `
# Motor Go to Position
Moves the motor to an absolute position.

### Parameters
- **Position**: Target position in degrees.
`,
                tr: `
# Motoru Pozisyona G√∂t√ºr
Motoru mutlak bir pozisyona hareket ettirir.

### Parametreler
- **Pozisyon**: Hedef pozisyon (derece cinsinden).
`
            },

            // --- Lever/Encoder Blocks ---
            'when_lever_position': {
                en: `
# When Lever Position
Triggers when the motor/lever reaches a specific position.

### Parameters
- **Position**: Up, Middle, or Down.
`,
                tr: `
# Kol Pozisyonunda
Motor/kol belirli bir pozisyona ula≈ütƒ±ƒüƒ±nda tetiklenir.

### Parametreler
- **Pozisyon**: Yukarƒ±, Orta veya A≈üaƒüƒ±.
`
            },
            'lever_position': {
                en: `
# Lever Position
Returns the current lever position.

### Returns
- **Up**: Lever is pushed up
- **Middle**: Lever is centered
- **Down**: Lever is pushed down
`,
                tr: `
# Kol Pozisyonu
Mevcut kol pozisyonunu d√∂nd√ºr√ºr.

### D√∂nd√ºr√ºr
- **Yukarƒ±**: Kol yukarƒ± itilmi≈ü
- **Orta**: Kol merkezde
- **A≈üaƒüƒ±**: Kol a≈üaƒüƒ± itilmi≈ü
`
            },
            'lever_angle': {
                en: `
# Lever Angle
Returns the current rotation angle of the lever/motor.

### Returns
Angle in degrees (-180 to 180).
`,
                tr: `
# Kol A√ßƒ±sƒ±
Kol/motorun mevcut d√∂n√º≈ü a√ßƒ±sƒ±nƒ± d√∂nd√ºr√ºr.

### D√∂nd√ºr√ºr
Derece cinsinden a√ßƒ± (-180 ile 180 arasƒ±).
`
            },

            // --- Color Sensor Extended ---
            'reflection_compare': {
                en: `
# Reflection Compare
Compares the reflection value with a threshold.

### Parameters
- **Comparison**: Greater than, Less than, Equal to.
- **Value**: Threshold percentage (0-100).

### Example
If reflection < 30%, we are on a dark line.
`,
                tr: `
# Yansƒ±ma Kar≈üƒ±la≈ütƒ±r
Yansƒ±ma deƒüerini bir e≈üik deƒüeriyle kar≈üƒ±la≈ütƒ±rƒ±r.

### Parametreler
- **Kar≈üƒ±la≈ütƒ±rma**: B√ºy√ºkt√ºr, K√º√ß√ºkt√ºr, E≈üittir.
- **Deƒüer**: E≈üik y√ºzdesi (0-100).

### √ñrnek
Yansƒ±ma < %30 ise, koyu bir √ßizgi √ºzerindeyiz.
`
            },

            // --- Controller Extended ---
            'controller_button': {
                en: `
# Controller Button
Checks if a specific button on the game controller is pressed.

### Parameters
- **Button**: A, B, X, Y, L1, R1, etc.

### Returns
True if pressed, False otherwise.
`,
                tr: `
# Kumanda D√ºƒümesi
Oyun kumandasƒ±ndaki belirli bir d√ºƒümenin basƒ±lƒ± olup olmadƒ±ƒüƒ±nƒ± kontrol eder.

### Parametreler
- **D√ºƒüme**: A, B, X, Y, L1, R1, vb.

### D√∂nd√ºr√ºr
Basƒ±lƒ±ysa Doƒüru, deƒüilse Yanlƒ±≈ü.
`
            }
        };

        function showBlockHelp() {
            if (!selectedBlock) return;

            const sidebar = document.getElementById('helpSidebar');
            const content = document.getElementById('helpContent');
            const title = document.getElementById('helpTitle');

            sidebar.classList.add('open');

            const blockType = selectedBlock.type;
            const docData = BLOCK_DOCS[blockType];

            // Set Title
            title.textContent = (currentLanguage === 'tr' ? 'Blok Yardƒ±mƒ±: ' : 'Block Help: ') + blockType;

            // --- Block Visual Creation ---
            let blockVisualHtml = '';
            try {
                const svgRoot = selectedBlock.getSvgRoot();
                if (svgRoot) {
                    const clone = svgRoot.cloneNode(true);

                    // Remove connected blocks (nested .blocklyDraggable elements)
                    clone.querySelectorAll('g.blocklyDraggable').forEach(el => el.remove());

                    // Reset positioning for the preview
                    clone.setAttribute('transform', 'translate(10, 10)');
                    clone.classList.remove('blocklySelected');
                    clone.removeAttribute('data-id');

                    // Cleanup any nested selected classes
                    const selectedChildren = clone.querySelectorAll('.blocklySelected');
                    selectedChildren.forEach(child => child.classList.remove('blocklySelected'));

                    // Calculate dimensions from the block's path (first path is usually the block shape)
                    const blockPath = clone.querySelector('.blocklyPath');
                    let width = 200, height = 60; // Default fallback
                    if (blockPath) {
                        // Try to get approximate dimensions from the block itself
                        const hw = selectedBlock.getHeightWidth();
                        // Use block's own height only (not including connected blocks)
                        // Blockly doesn't have a direct method, but typically the block itself is smaller
                        width = hw.width;
                        // Height estimation: use a reasonable fraction or fixed height for single block
                        height = Math.min(hw.height, 80); // Most single blocks are under 80px tall
                    }

                    // Create container
                    blockVisualHtml = `
                        <div style="display: flex; justify-content: center; margin-bottom: 20px; padding: 20px; background: #fff; border: 1px solid #eee; border-radius: 8px; box-shadow: inset 0 0 10px rgba(0,0,0,0.02);">
                            <svg xmlns="http://www.w3.org/2000/svg" width="${width + 20}" height="${height + 20}" style="display: block; overflow: visible;">
                                ${clone.outerHTML}
                            </svg>
                        </div>
                    `;
                }
            } catch (e) {
                console.warn('Block visual creation failed:', e);
            }

            if (docData) {
                const lang = currentLanguage === 'tr' ? 'tr' : 'en';
                const doc = docData[lang] || docData['en'] || docData;
                const text = typeof doc === 'string' ? doc : JSON.stringify(doc);
                content.innerHTML = blockVisualHtml + parseMarkdown(text.trim());
            } else {
                const msg = currentLanguage === 'tr'
                    ? '<div style="color: #666; font-style: italic; padding: 20px; text-align: center;">Bu blok i√ßin hen√ºz yardƒ±m dok√ºmanƒ± eklenmemi≈ütir.<br><br>üöß</div>'
                    : '<div style="color: #666; font-style: italic; padding: 20px; text-align: center;">Help documentation has not been added for this block yet.<br><br>üöß</div>';
                content.innerHTML = blockVisualHtml + msg;
            }
        }

        function closeBlockHelp() {
            document.getElementById('helpSidebar').classList.remove('open');
        }

        function parseMarkdown(md) {
            // Simple Markdown Parser
            let html = md
                .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                .replace(/\*\*(.*)\*\*/gim, '<b>$1</b>')
                .replace(/`(.*)`/gim, '<code>$1</code>')
                .replace(/^\- (.*$)/gim, '<li>$1</li>');

            // Wrap lists
            html = html.replace(/(<li>.*<\/li>)/gim, '<ul>$1</ul>').replace(/<\/ul>\s*<ul>/g, '');

            // Newlines to br (except around tags)
            html = html.replace(/\n/g, '<br>');

            return html;
        }

        // Close help sidebar when clicking outside
        function handleGlobalClick(e) {
            const sidebar = document.getElementById('helpSidebar');
            const helpBtn = document.getElementById('helpBlockBtn');

            // Should exist and be open
            if (sidebar && sidebar.classList.contains('open')) {
                // Check if click is outside sidebar and outside the help button
                // SVG elementlerinde .contains bazen sorun olabilir, bu y√ºzden closest kontrol√º de ekleyelim
                const target = e.target;
                const clickedInsideSidebar = sidebar.contains(target) || !!target.closest('#helpSidebar');
                const clickedOnButton = (helpBtn && (helpBtn.contains(target) || !!target.closest('#helpBlockBtn')));

                if (!clickedInsideSidebar && !clickedOnButton) {
                    closeBlockHelp();
                }
            }
        }

        // Use capture phase on window for maximum priority
        window.addEventListener('mousedown', handleGlobalClick, true);
        window.addEventListener('pointerdown', handleGlobalClick, true);
        window.addEventListener('touchstart', handleGlobalClick, true);

        function selectDevice(deviceId) {
            const icon = document.querySelector(`[data-device-id="${deviceId}"]`);

            // Toggle se√ßimi
            if (selectedDeviceId === deviceId) {
                // Aynƒ± cihaza basƒ±ldƒ± - se√ßimi kaldƒ±r
                if (icon) icon.classList.remove('selected');
                selectedDeviceId = null;
                document.getElementById('disconnectOverlay').classList.remove('show');
                console.log('Se√ßim iptal edildi');
            } else {
                // Farklƒ± cihaz se√ßildi
                document.querySelectorAll('.device-icon').forEach(i => {
                    i.classList.remove('selected');
                });

                if (icon) {
                    icon.classList.add('selected');
                    selectedDeviceId = deviceId;
                    document.getElementById('disconnectOverlay').classList.add('show');
                    console.log('Se√ßili cihaz:', deviceId);
                }
            }
        }

        function disconnectSelectedDevice() {
            if (selectedDeviceId) {
                removeDevice(selectedDeviceId);
            }
        }

        function removeDevice(deviceId, event) {
            if (event) event.stopPropagation();

            const device = connectedDevices.find(d => d.id === deviceId);
            if (device) {
                // Hide the corresponding display panel based on device type
                if (device.type === 'motor' || device.type === 'double_motor') {
                    hideMotorDisplay();
                } else if (device.type === 'color_sensor') {
                    hideColorSensorDisplay();
                } else if (device.type === 'spike_essential') {
                    hideSpikeEssentialDisplay();
                }

                // Disconnect GATT if connected
                if (device.device && device.device.gatt.connected) {
                    device.device.gatt.disconnect();
                }
            }

            connectedDevices = connectedDevices.filter(d => d.id !== deviceId);

            const icon = document.querySelector(`[data-device-id="${deviceId}"]`);
            if (icon) {
                icon.remove();
            }

            if (selectedDeviceId === deviceId) {
                selectedDeviceId = null;
                document.getElementById('disconnectOverlay').classList.remove('show');

                if (connectedDevices.length > 0) {
                    selectDevice(connectedDevices[0].id);
                }
            }

            // Tabloyu g√ºncelle
            updateDevicesTable();

            console.log('Cihaz kaldƒ±rƒ±ldƒ±:', deviceId);
        }

        function getSelectedDevice() {
            return connectedDevices.find(d => d.id === selectedDeviceId);
        }

        function getDeviceIcon(deviceId) {
            const device = connectedDevices.find(d => d.id === deviceId);
            if (!device) return '';

            // SVG shape generator - daha k√º√ß√ºk
            let shape = '';
            const size = 14;
            const color = device.color;

            switch (device.shape) {
                case 'triangle':
                    shape = `<svg width="${size}" height="${size}"><polygon points="${size / 2},0 0,${size} ${size},${size}" fill="${color}"/></svg>`;
                    break;
                case 'square':
                    shape = `<svg width="${size}" height="${size}"><rect width="${size}" height="${size}" rx="2" fill="${color}"/></svg>`;
                    break;
                case 'rectangle':
                    shape = `<svg width="${size}" height="${size * 0.7}"><rect width="${size}" height="${size * 0.7}" rx="2" fill="${color}"/></svg>`;
                    break;
                case 'pentagon':
                    shape = `<svg width="${size}" height="${size}"><polygon points="${size / 2},0 ${size},${size * 0.38} ${size * 0.82},${size} ${size * 0.18},${size} 0,${size * 0.38}" fill="${color}"/></svg>`;
                    break;
                case 'hexagon':
                    shape = `<svg width="${size}" height="${size}"><polygon points="${size / 2},0 ${size},${size * 0.25} ${size},${size * 0.75} ${size / 2},${size} 0,${size * 0.75} 0,${size * 0.25}" fill="${color}"/></svg>`;
                    break;
                case 'octagon':
                    shape = `<svg width="${size}" height="${size}"><polygon points="${size * 0.3},0 ${size * 0.7},0 ${size},${size * 0.3} ${size},${size * 0.7} ${size * 0.7},${size} ${size * 0.3},${size} 0,${size * 0.7} 0,${size * 0.3}" fill="${color}"/></svg>`;
                    break;
                case 'circle':
                    shape = `<svg width="${size}" height="${size}"><circle cx="${size / 2}" cy="${size / 2}" r="${size / 2}" fill="${color}"/></svg>`;
                    break;
            }

            return shape;
        }

        const OPTIONAL_SERVICES = [
            'generic_access', 'generic_attribute', 'device_information', 'battery_service',
            '00002a05-0000-1000-8000-00805f9b34fb', '00002b2a-0000-1000-8000-00805f9b34fb',
            '0000fd02-0000-1000-8000-00805f9b34fb', '0000fd02-0001-1000-8000-00805f9b34fb', '0000fd02-0002-1000-8000-00805f9b34fb',
            0x1800, 0x1801, 0x180a, 0x180f, 0x2a05, 0x2b2a, 0xfd02,
            0xffe0, 0xffe1, 0xffe2, 0xffe3, 0xffe4, 0xffe5, 0xffe6, 0xffe7, 0xffe8, 0xffe9,
            0x1623, 0x1624, 0x1625, 0x1626,
            '00001623-1212-efde-1623-785feabcd123', '00001624-1212-efde-1623-785feabcd123', '00001625-1212-efde-1623-785feabcd123',
            '0000ffe0-0000-1000-8000-00805f9b34fb', '0000ffe1-0000-1000-8000-00805f9b34fb'
        ];

        function openSpecificDeviceModal() {
            document.getElementById('specificDeviceModal').classList.add('show');
        }

        function closeSpecificDeviceModal() {
            document.getElementById('specificDeviceModal').classList.remove('show');
        }

        function showNotSupportedAlert(deviceName) {
            const message = currentLanguage === 'tr'
                ? `${deviceName} hen√ºz desteklenmiyor. Yakƒ±nda eklenecek!`
                : `${deviceName} is not yet supported. Coming soon!`;

            showImportErrorModal(
                currentLanguage === 'tr' ? 'Hen√ºz Desteklenmiyor' : 'Not Yet Supported',
                message
            );
        }

        async function scanSpecificDevice(type) {
            closeSpecificDeviceModal();
            let options = { filters: [] };

            // LEGO ortak BLE tanƒ±mlayƒ±cƒ±larƒ±
            // Company ID: 0x0397 (919)
            // Service UUID: 0xFD02 (64770)
            // Device Type Byte: Motor=0x00, Color Sensor=0x02, Controller=0x03

            if (type === 'controller') {
                // Controller: Device Type Byte = 0x03
                options.filters.push({ services: [0xFD02] });
                options.filters.push({
                    manufacturerData: [{
                        companyIdentifier: 0x0397,
                        dataPrefix: new Uint8Array([0x03])
                    }]
                });
                options.inputType = 'controller';
            } else if (type === 'single_motor') {
                // Single Motor: Device Type Byte = 0x00
                options.filters.push({ services: [0xFD02] });
                options.filters.push({
                    manufacturerData: [{
                        companyIdentifier: 0x0397,
                        dataPrefix: new Uint8Array([0x00])
                    }]
                });
                options.inputType = 'motor';
            } else if (type === 'double_motor') {
                // Double Motor: Device Type Byte = 0x01
                options.filters.push({ services: [0xFD02] });
                options.filters.push({
                    manufacturerData: [{
                        companyIdentifier: 0x0397,
                        dataPrefix: new Uint8Array([0x01])
                    }]
                });
                options.inputType = 'double_motor';
            } else if (type === 'color_sensor') {
                // Color Sensor: Device Type Byte = 0x02
                options.filters.push({ services: [0xFD02] });
                options.filters.push({
                    manufacturerData: [{
                        companyIdentifier: 0x0397,
                        dataPrefix: new Uint8Array([0x02])
                    }]
                });
                options.inputType = 'color_sensor';
            } else if (type === 'spike_essential') {
                // Spike Essential Hub: Device Type Byte = 0x83
                // Service UUID: 00001623-1212-efde-1623-785feabcd123
                options.filters.push({ services: ['00001623-1212-efde-1623-785feabcd123'] });
                options.filters.push({
                    manufacturerData: [{
                        companyIdentifier: 0x0397,
                        dataPrefix: new Uint8Array([0x83])
                    }]
                });
                options.inputType = 'spike_essential';
            }
            await scanDeviceInternal(options);
        }

        async function scanAndConnect() {
            await scanDeviceInternal({ acceptAllDevices: true });
        }

        async function scanDeviceInternal(customOptions) {
            // Bluetooth kontrol√º
            if (!navigator.bluetooth) {
                alert('‚ùå Tarayƒ±cƒ±nƒ±z Web Bluetooth desteklemiyor!\n\nChrome, Edge veya Opera kullanƒ±n.');
                return;
            }

            try {
                const scanStatus = document.getElementById('scanStatus');
                const t = TRANSLATIONS[currentLanguage];
                scanStatus.style.display = 'block';
                scanStatus.textContent = t.device_list_opening;

                // Motor/cihaz tarama
                const forcedType = customOptions.inputType;
                const deviceRequestOptions = { ...customOptions };
                delete deviceRequestOptions.inputType;

                const requestOptions = {
                    optionalServices: OPTIONAL_SERVICES,
                    ...deviceRequestOptions
                };
                bluetoothDevice = await navigator.bluetooth.requestDevice(requestOptions);

                // Determine friendly name based on forcedType if device has no name
                let friendlyName = bluetoothDevice.name;
                if (!friendlyName && forcedType) {
                    if (forcedType === 'motor') friendlyName = 'Single Motor';
                    else if (forcedType === 'double_motor') friendlyName = 'Double Motor';
                    else if (forcedType === 'color_sensor') friendlyName = 'Color Sensor';
                    else if (forcedType === 'controller') friendlyName = 'Controller';
                    else if (forcedType === 'spike_essential') friendlyName = 'Spike Essential Hub';
                    else friendlyName = t.unknown_device;
                } else if (!friendlyName) {
                    friendlyName = t.unknown_device;
                }

                scanStatus.textContent = `${t.connecting_to} ${friendlyName}...`;
                console.log('Se√ßilen cihaz:', bluetoothDevice.name || friendlyName, bluetoothDevice.id);

                // GATT sunucusuna baƒülan
                bluetoothServer = await bluetoothDevice.gatt.connect();

                // Rengi √∂nceden belirle, b√∂ylece hem sidebar hem panel aynƒ± rengi kullanƒ±r
                const assignedColor = getRandomColor();

                scanStatus.textContent = `${t.connected_to} ${friendlyName}`;

                console.log('GATT server connected');
                console.log('Server:', bluetoothServer);
                console.log('Server.connected:', bluetoothServer.connected);

                // Servisleri al ve logla
                try {
                    console.log('‚Üí getPrimaryServices() √ßaƒürƒ±lƒ±yor...');
                    const services = await bluetoothServer.getPrimaryServices();
                    console.log(`‚úì ${services.length} servis bulundu!`);

                    for (const service of services) {
                        console.log(`  Servis UUID: ${service.uuid}`);
                        try {
                            const chars = await service.getCharacteristics();
                            console.log(`    ${chars.length} karakteristik bulundu`);

                            let writeChar = null;
                            let notifyChar = null;

                            for (const char of chars) {
                                console.log(`      - ${char.uuid} (write: ${char.properties.write}, writeNoResp: ${char.properties.writeWithoutResponse}, notify: ${char.properties.notify})`);

                                // Write karakteristiƒüi sakla
                                if (char.properties.writeWithoutResponse) {
                                    writeChar = char;
                                }

                                // Notify karakteristiƒüi tespit et
                                // Her cihaz kendi notify char'ƒ±nƒ± kullanabilsin
                                if (char.properties.notify) {
                                    notifyChar = char;
                                }
                            }

                            // Eƒüer controller ise, √∂nce write ile ba≈ülat, sonra notify dinle
                            // Eƒüer controller ise, sadece notify dinle (write YOK)
                            // Sadece "Controller" tipindeyse display'i a√ß (Single Motor vs a√ßmasƒ±n)
                            const deviceType = forcedType || detectDeviceType(bluetoothDevice.name || '');
                            if (notifyChar && deviceType === 'controller') {
                                console.log('      üéÆ Controller tespit edildi!');
                                console.log('      DEBUG: writeChar var mƒ±?', !!writeChar);
                                console.log('      DEBUG: writeChar UUID:', writeChar ? writeChar.uuid : 'YOK');

                                // Characteristic'leri kaydet
                                connectedCharacteristics[notifyChar.uuid] = notifyChar;
                                if (writeChar) {
                                    connectedCharacteristics[writeChar.uuid] = writeChar;

                                    // DENEME: Controller'a "wake up" ping g√∂nder
                                    try {
                                        console.log('      üì§ Controller wake-up ping g√∂nderiliyor...');
                                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x00]));
                                        console.log('      ‚úì Ping g√∂nderildi!');
                                        await new Promise(resolve => setTimeout(resolve, 100));
                                    } catch (e) {
                                        console.log('      ‚ö†Ô∏è Ping hatasƒ±:', e.message);
                                    }
                                }

                                // Monitoring ba≈ülat (periyodik ping ile)
                                console.log('      üéÆ Monitoring ba≈ülatƒ±lƒ±yor...');
                                await startControllerMonitoring(bluetoothDevice, notifyChar, writeChar, assignedColor);
                            }

                            // Motor i√ßin notification monitoring ba≈ülat
                            // Motor a√ßƒ±sƒ±nƒ± Bluetooth'tan ger√ßek zamanlƒ± almak i√ßin
                            if (notifyChar && deviceType === 'motor' && !motorMonitoringActive) {
                                console.log('      ‚öôÔ∏è Motor tespit edildi!');
                                console.log('      DEBUG: notifyChar UUID:', notifyChar.uuid);

                                // Characteristic'leri kaydet
                                connectedCharacteristics[notifyChar.uuid] = notifyChar;
                                if (writeChar) {
                                    connectedCharacteristics[writeChar.uuid] = writeChar;
                                }

                                // Motor a√ßƒ± monitoring ba≈ülat
                                console.log('      ‚öôÔ∏è Motor a√ßƒ± monitoring ba≈ülatƒ±lƒ±yor...');

                                // Motor'a sensor stream ba≈ülatma komutu g√∂nder (PCAP'tan: 0x28 0x32 0x00)


                                if (writeChar) {
                                    try {
                                        console.log('      üì§ Motor sensor stream ba≈ülatƒ±lƒ±yor...');

                                        // Adƒ±m 1: Reset/Init
                                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x00]));
                                        await new Promise(resolve => setTimeout(resolve, 100));

                                        // Adƒ±m 2: Handshake
                                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x1a]));
                                        await new Promise(resolve => setTimeout(resolve, 100));

                                        // Adƒ±m 3: Sensor data stream ba≈ülat
                                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x28, 0x32, 0x00]));
                                        console.log('      ‚úì Sensor stream ba≈ülatƒ±ldƒ±!');

                                    } catch (e) {
                                        console.log('      ‚ö†Ô∏è Motor ba≈ülatma hatasƒ±:', e.message);
                                    }
                                }

                                // Monitoring ba≈ülat
                                await startMotorAngleMonitoring(bluetoothDevice, notifyChar, bluetoothDevice.id, assignedColor);
                            }

                            // Color Sensor i√ßin notification monitoring ba≈ülat
                            if (notifyChar && deviceType === 'color_sensor') {
                                console.log('      üé® Color Sensor tespit edildi!');
                                console.log('      DEBUG: notifyChar UUID:', notifyChar.uuid);

                                // Characteristic'leri kaydet
                                connectedCharacteristics[notifyChar.uuid] = notifyChar;
                                if (writeChar) {
                                    connectedCharacteristics[writeChar.uuid] = writeChar;
                                }

                                // Color Sensor'a sensor stream ba≈ülatma komutu g√∂nder
                                if (writeChar) {
                                    try {
                                        console.log('      üì§ Color Sensor stream ba≈ülatƒ±lƒ±yor...');

                                        // Adƒ±m 1: Reset/Init
                                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x00]));
                                        await new Promise(resolve => setTimeout(resolve, 100));

                                        // Adƒ±m 2: Handshake
                                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x1a]));
                                        await new Promise(resolve => setTimeout(resolve, 100));

                                        // Adƒ±m 3: Sensor data stream ba≈ülat (PCAP'tan analiz edilebilir)
                                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x28, 0x32, 0x00]));
                                        console.log('      ‚úì Color Sensor stream ba≈ülatƒ±ldƒ±!');

                                    } catch (e) {
                                        console.log('      ‚ö†Ô∏è Color Sensor ba≈ülatma hatasƒ±:', e.message);
                                    }
                                }

                                // Monitoring ba≈ülat
                                await startColorSensorMonitoring(bluetoothDevice, notifyChar, bluetoothDevice.id, assignedColor);
                            }

                            // Spike Essential Hub i√ßin monitoring ba≈ülat
                            if (notifyChar && deviceType === 'spike_essential') {
                                console.log('      üîå Spike Essential Hub tespit edildi!');
                                console.log('      DEBUG: notifyChar UUID:', notifyChar.uuid);
                                console.log('      DEBUG: writeChar UUID:', writeChar ? writeChar.uuid : 'YOK');

                                // Characteristic'leri kaydet
                                connectedCharacteristics[notifyChar.uuid] = notifyChar;
                                if (writeChar) {
                                    connectedCharacteristics[writeChar.uuid] = writeChar;
                                }

                                // Monitoring ba≈ülat
                                await startSpikeHubMonitoring(bluetoothDevice, notifyChar, writeChar, assignedColor, friendlyName);
                            }

                        } catch (e) {
                            console.log(`    Karakteristik hatasƒ±: ${e.message}`);
                        }
                    }

                    // connectedCharacteristics = {}; // KALDIRDIM - characteristic'leri silme!
                } catch (err) {
                    console.error('‚ùå Servis hatasƒ±:', err);
                    console.error('   Bu motor cihazƒ±nƒ±n servisleri Web Bluetooth izin listesinde olmayabilir.');
                    console.error('   Motor √ßalƒ±≈ümayabilir ama cihaz listeye eklendi.');
                }

                // Baƒülantƒ± kesilince
                bluetoothDevice.addEventListener('gattserverdisconnected', onDisconnected);

                // Cihazƒ± sidebar'a ekle (aynƒ± rengi kullanarak)
                addDeviceToSidebar(bluetoothDevice, assignedColor, forcedType);

                // Eƒüer Motor ise Display'i g√∂ster
                const connectedType = forcedType || detectDeviceType(bluetoothDevice.name || '');
                if (connectedType === 'motor' || connectedType === 'double_motor') {
                    showMotorDisplay(bluetoothDevice, assignedColor, friendlyName);
                }
                // Eƒüer Color Sensor ise Display'i g√∂ster
                else if (connectedType === 'color_sensor') {
                    showColorSensorDisplay(bluetoothDevice, assignedColor);
                }

                scanStatus.textContent = t.device_added;

                // Scan status'u gizle
                setTimeout(() => {
                    scanStatus.style.display = 'none';
                }, 2000);

            } catch (error) {
                console.error('Bluetooth hatasƒ±:', error);
                const scanStatus = document.getElementById('scanStatus');
                scanStatus.style.display = 'block';
                scanStatus.style.background = '#FFE5E5';
                scanStatus.textContent = `‚ùå Hata: ${error.message}`;

                let errorMsg = `Bluetooth baƒülantƒ± hatasƒ±:\n${error.message}\n\n`;

                if (error.message.includes('User cancelled')) {
                    scanStatus.style.display = 'none';
                    return; // ƒ∞ptal - hata g√∂sterme
                } else if (error.message.includes('Bluetooth adapter not available')) {
                    errorMsg = '‚ùå Bluetooth a√ßƒ±k deƒüil!\n\nL√ºtfen Bluetooth\'u a√ßƒ±n ve tekrar deneyin.';
                } else {
                    errorMsg += 'Kontrol edin:\n‚úì Bluetooth a√ßƒ±k mƒ±?\n‚úì Cihaz a√ßƒ±k mƒ±?\n‚úì Cihaz menzilde mi?';
                }

                alert(errorMsg);

                setTimeout(() => {
                    scanStatus.style.display = 'none';
                    scanStatus.style.background = '#f0f0f0';
                }, 5000);
            }
        }

        function onDisconnected(event) {
            // Find the device in connectedDevices first for accurate name/type
            const device = connectedDevices.find(d => d.device === bluetoothDevice);
            const deviceName = device ? device.name : (event && event.target ? (event.target.name || 'Unknown') : 'Device');
            const deviceType = device ? device.type : 'unknown';
            console.log('Bluetooth cihaz baƒülantƒ±sƒ± kesildi', deviceName);

            if (typeof logDeviceAction === 'function') {
                logDeviceAction('remove', deviceName, deviceType);
            }

            // Controller monitoring'i durdur
            if (controllerMonitoring) {
                clearInterval(controllerMonitoring);
                controllerMonitoring = null;
            }

            // Controller ping'i durdur
            if (controllerPingInterval) {
                clearInterval(controllerPingInterval);
                controllerPingInterval = null;
            }

            activeControllerDevice = null;
            activeControllerCharacteristic = null;

            // Motor monitoring'i durdur
            if (motorMonitoringActive) {
                stopMotorAngleMonitoring();
            }

            // Controller display'i gizle
            hideControllerDisplay();
            hideMotorDisplay();
            hideColorSensorDisplay();
            hideSpikeEssentialDisplay();

            // Baƒülantƒ±sƒ± kesilen cihazƒ± bul ve durumunu g√ºncelle (device already found above)
            if (device) {
                device.connected = false;
                updateDevicesTable();
            }

            bluetoothDevice = null;
            bluetoothServer = null;
            connectedCharacteristics = {};
        }

        // Controller'dan veri oku ve state g√ºncelle
        async function startControllerMonitoring(device, notifyChar, writeChar, deviceColor = null) {
            console.log('üéÆ Controller monitoring ba≈ülatƒ±lƒ±yor...');
            activeControllerDevice = device;
            activeControllerCharacteristic = notifyChar; // Global'e kaydet

            console.log('   DEBUG: Notify characteristic:', notifyChar.uuid);
            console.log('   DEBUG: Write characteristic:', writeChar ? writeChar.uuid : 'YOK');

            // Controller display'i g√∂ster - cihaz bilgilerini bul
            // Eƒüer renk parametre olarak geldiyse kullan, yoksa listeden bulmaya √ßalƒ±≈ü
            let colorToUse = deviceColor;
            let nameToUse = device.name || 'Controller';

            if (!colorToUse) {
                const deviceData = connectedDevices.find(d => d.device === device || d.id === device.id);
                if (deviceData) {
                    nameToUse = deviceData.name;
                    colorToUse = deviceData.color;
                } else {
                    colorToUse = '#4C97FF';
                }
            }

            showControllerDisplay(nameToUse, colorToUse);

            // Notification'larƒ± dinle
            try {
                await notifyChar.startNotifications();
                console.log('‚úÖ Notifications ba≈ülatƒ±ldƒ± - kollarƒ± hareket ettirin');
                console.log('   Characteristic UUID:', notifyChar.uuid);
                console.log('   Is notifying:', notifyChar.properties.notify);

                // Event listener ekle - notification'dan SONRA
                notifyChar.addEventListener('characteristicvaluechanged', (event) => {
                    const value = event.target.value;

                    // RAW HEX DUMP (Debug i√ßin devre dƒ±≈üƒ±)
                    // if (!event.target._logCount) event.target._logCount = 0;
                    // if (event.target._logCount < 10) {
                    //     const bytes = new Uint8Array(value.buffer);
                    //     const hexDump = [...bytes].map(b => b.toString(16).padStart(2, '0')).join(' ');
                    //     console.log(`üéÆ Controller RAW [${value.byteLength} bytes]: ${hexDump}`);
                    //     event.target._logCount++;
                    // }

                    // Format: 60, 10, 0, 0, 50, 0, 15, 1, 0, 50, 0, 248, 255
                    // Index:   0   1  2  3   4  5   6  7  8   9 10   11  12
                    // Index 7 = Sol lever byte
                    // Index 8 = Saƒü lever byte
                    // Deƒüerler: 0-1 = normal, 2-104 = up, 152-255 = down

                    if (value.byteLength >= 9) {
                        const leftByte = value.getUint8(7);   // Index 7 = Sol lever
                        const rightByte = value.getUint8(8);  // Index 8 = Saƒü lever

                        // Sadece deƒüer deƒüi≈ütiyse g√ºncelle
                        if (leftByte !== controllerState.leftValue || rightByte !== controllerState.rightValue) {
                            updateControllerState(leftByte, rightByte);
                        }

                        // Pil y√ºzdesini al (index 4 olabilir - motor ile aynƒ± gibi deneyelim)
                        if (value.byteLength >= 5) {
                            let batteryPercent = value.getUint8(4);
                            // 0-100 arasƒ±na normalize et
                            if (batteryPercent > 100) {
                                batteryPercent = Math.round((batteryPercent / 255) * 100);
                            }

                            // Pil g√∂stergesini g√ºncelle
                            const batteryEl = document.getElementById('controllerBatteryPercent');
                            const batteryFill = document.getElementById('controllerBatteryFill');
                            if (batteryEl) {
                                batteryEl.textContent = `${batteryPercent}%`;

                                // Pil doluluk g√∂stergesini g√ºncelle
                                if (batteryFill) {
                                    const fillWidth = Math.round((batteryPercent / 100) * 14);
                                    batteryFill.setAttribute('width', fillWidth);
                                }

                                // Renk ayarla
                                if (batteryPercent < 20) {
                                    batteryEl.parentElement.style.color = '#e03131';
                                } else if (batteryPercent < 50) {
                                    batteryEl.parentElement.style.color = '#fab005';
                                } else {
                                    batteryEl.parentElement.style.color = '#37b24d';
                                }
                            }
                        }
                    }
                });

                console.log('‚úì Event listener eklendi');

                // Controller'ƒ± ba≈ülat ve sensor stream'i a√ß
                if (writeChar) {
                    console.log('üîÑ Controller sensor stream ba≈ülatƒ±lƒ±yor...');

                    try {
                        // PCAP analizinden: Ba≈ülatma sƒ±rasƒ±
                        // Paket 403: 0x00 (reset/init)
                        // 0. Notify Characteristic'i bul ve Subscribe ol (Gerekli olabilir)
                        try {
                            const notifyUUID = '0000fd02-0002-1000-8000-00805f9b34fb';
                            let notifyChar = null;

                            // deviceData'yƒ± bul
                            const deviceData = connectedDevices.find(d => d.device === device || d.id === device.id);

                            if (deviceData && deviceData.characteristics) {
                                notifyChar = deviceData.characteristics[notifyUUID];
                            }

                            // Cache'te yoksa servisten al (writeChar'ƒ±n servisini kullanabiliriz)
                            if (!notifyChar && writeChar && writeChar.service) {
                                try {
                                    notifyChar = await writeChar.service.getCharacteristic(notifyUUID);
                                } catch (e) { console.log('   ‚ö†Ô∏è Notify char servisten alƒ±namadƒ±:', e.message); }
                            }

                            if (notifyChar) {
                                // Start notifications if we haven't tracked it yet or just to be safe
                                // Web Bluetooth automatically handles duplicate startNotifications calls usually, or checks properties
                                console.log('   üîî Notifications ba≈ülatƒ±lƒ±yor (Handshake i√ßin gerekli olabilir)...');
                                await notifyChar.startNotifications();
                                // Listener eklemeye gerek yok, sadece aktif olmasƒ± yetebilir
                            } else {
                                console.log('   ‚ö†Ô∏è Notify char bulunamadƒ±, bu adƒ±m atlanƒ±yor.');
                            }
                        } catch (err) {
                            console.log('   ‚ö†Ô∏è Notification ba≈ülatma uyarƒ±sƒ±:', err);
                            // Notification hatasƒ± motoru durdurmamalƒ±, devam et
                        }

                        // 1. Wake UP / Init / Handshake)
                        // Paket 409: 0x28 0x32 0x00 (sensor data stream ba≈ülat)

                        // Adƒ±m 1: Reset/Init
                        console.log('   üì§ Adƒ±m 1: Reset komutu (0x00)...');
                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x00]));
                        await new Promise(resolve => setTimeout(resolve, 100));

                        // Adƒ±m 2: Handshake
                        console.log('   üì§ Adƒ±m 2: Handshake komutu (0x1a)...');
                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x1a]));
                        await new Promise(resolve => setTimeout(resolve, 100));

                        // Adƒ±m 3: Sensor data stream ba≈ülat (PCAP Paket 409)
                        // Bu komut g√∂nderildikten sonra cihaz S√úREKLƒ∞ notification g√∂nderir
                        const sensorStreamCmd = new Uint8Array([0x28, 0x32, 0x00]);
                        console.log('   üì§ Adƒ±m 3: Sensor stream ba≈ülat (0x28 0x32 0x00)...');
                        await writeChar.writeValueWithoutResponse(sensorStreamCmd);

                        console.log('   ‚úÖ Sensor stream ba≈ülatƒ±ldƒ±! Cihaz artƒ±k s√ºrekli veri g√∂nderecek.');

                    } catch (e) {
                        console.error('   ‚ùå Ba≈ülatma hatasƒ±:', e.message);
                    }

                    // NOT: Periyodik ping GEREKMEYOR - cihaz tek komutla s√ºrekli stream yapƒ±yor
                    // Eski periyodik ping kaldƒ±rƒ±ldƒ±
                }

                // TEST: Event listener ger√ßekten √ßalƒ±≈üƒ±yor mu?
                console.log('üß™ TEST: Event listener count:',
                    notifyChar.getAttributeNames ? 'Modern API' : 'Eski API');

                // Manuel bir test eventi tetikle
                setTimeout(() => {
                    console.log('üß™ 5 saniye ge√ßti, manuel test...');
                    console.log('   Characteristic hala var mƒ±?', !!activeControllerCharacteristic);
                    console.log('   Event listener sayƒ±sƒ± kontrol edilemiyor (Web Bluetooth API sƒ±nƒ±rlamasƒ±)');
                }, 5000);

                // ƒ∞lk deƒüeri okumayƒ± dene
                if (notifyChar.properties.read) {
                    try {
                        console.log('   üìñ ƒ∞lk deƒüer okunuyor...');
                        const initialValue = await notifyChar.readValue();
                        console.log('   üìñ ƒ∞lk deƒüer:', initialValue.byteLength, 'bytes');

                        // ƒ∞lk deƒüeri manuel olarak i≈üle
                        if (initialValue.byteLength >= 9) {
                            const leftByte = initialValue.getUint8(7);   // Index 7 = Sol
                            const rightByte = initialValue.getUint8(8);  // Index 8 = Saƒü
                            console.log(`   üìñ ƒ∞lk deƒüerler: Left=${leftByte}, Right=${rightByte}`);
                        }
                    } catch (e) {
                        console.log('   ‚ö†Ô∏è Read desteklenmiyor:', e.message);
                    }
                }

                // Test: 5 saniye sonra hala veri gelmediyse uyar
                setTimeout(() => {
                    console.log('‚è∞ 5 saniye ge√ßti - Eƒüer hala veri gelmediyse:');
                    console.log('   1. Kollarƒ± hareket ettirmeyi deneyin');
                    console.log('   2. Controller\'ƒ± yeniden baƒülayƒ±n');
                    console.log('   3. Controller\'ƒ±n pilini kontrol edin');
                }, 5000);

            } catch (err) {
                console.error('‚ùå Notification ba≈ülatma hatasƒ±:', err.message);
            }
        }

        function updateControllerState(leftByte, rightByte) {
            // √ñnceki state'i kaydet
            const prevLeft = controllerState.left;
            const prevRight = controllerState.right;

            // Y√ºzdeleri hesapla - her iki lever i√ßin aynƒ± mantƒ±k
            const leftPercent = calculateLeverPercent(leftByte);
            const rightPercent = calculateLeverPercent(rightByte);

            // State'i y√ºzdeye g√∂re belirle
            // >55%: UP, <45%: DOWN, 45-55%: RELEASED
            const newLeft = leftPercent > 55 ? 'UP' : (leftPercent < 45 ? 'DOWN' : 'RELEASED');
            const newRight = rightPercent > 55 ? 'UP' : (rightPercent < 45 ? 'DOWN' : 'RELEASED');

            controllerState.left = newLeft;
            controllerState.right = newRight;
            controllerState.leftValue = leftByte;
            controllerState.rightValue = rightByte;

            // G√∂rseli throttle ile g√ºncelle (100ms'de bir)
            const now = Date.now();
            if (now - lastVisualUpdate >= VISUAL_UPDATE_INTERVAL) {
                lastVisualUpdate = now;
                updateControllerVisualThrottled(leftPercent, rightPercent);
            }

            // State deƒüi≈üikliklerinde when bloklarƒ±nƒ± tetikle
            if (newLeft !== prevLeft) {
                triggerLeverEvents('LEFT', newLeft);
            }
            if (newRight !== prevRight) {
                triggerLeverEvents('RIGHT', newRight);
            }

            // Both ve Any kontrol√º
            if (newLeft !== prevLeft || newRight !== prevRight) {
                triggerLeverEvents('BOTH', newLeft === newRight ? newLeft : null);
                triggerLeverEvents('ANY', newLeft !== 'RELEASED' || newRight !== 'RELEASED' ?
                    (newLeft !== 'RELEASED' ? newLeft : newRight) : null);
            }
        }

        // Throttled g√∂rsel g√ºncelleme - dikey bar i√ßin height kullan
        function updateControllerVisualThrottled(leftPercent, rightPercent) {
            // Sol kol
            const leftFill = document.getElementById('leftLeverFill');
            const leftValue = document.getElementById('leftLeverValue');

            if (leftFill && leftValue) {
                const leftHeight = Math.round(leftPercent);
                leftFill.style.height = leftHeight + '%';
                leftValue.textContent = leftHeight + '%';
            }

            // Saƒü kol
            const rightFill = document.getElementById('rightLeverFill');
            const rightValueEl = document.getElementById('rightLeverValue');

            if (rightFill && rightValueEl) {
                const rightHeight = Math.round(rightPercent);
                rightFill.style.height = rightHeight + '%';
                rightValueEl.textContent = rightHeight + '%';
            }
        }

        // Lever y√ºzde hesaplama
        // 0-1 = normal (ortada) = %50
        // 2-104 = up (yukarƒ±) = %50-%100 (2‚Üí%50, 104‚Üí%100)
        // 152-255 = down (a≈üaƒüƒ±) = %0-%50 (255‚Üí%50, 152‚Üí%0)
        function calculateLeverPercent(byteValue) {
            let percent;

            if (byteValue <= 1) {
                // NORMAL - ortada
                percent = 50;
            } else if (byteValue >= 2 && byteValue <= 104) {
                // UP - yukarƒ±
                // 2 ‚Üí %50, 104 ‚Üí %100
                percent = 50 + ((byteValue - 2) / (104 - 2)) * 50;
            } else if (byteValue >= 152 && byteValue <= 255) {
                // DOWN - a≈üaƒüƒ±
                // 255 ‚Üí %50'ye yakƒ±n, 152 ‚Üí %0
                // 255'ten 152'ye gittik√ße a≈üaƒüƒ± iniyor
                percent = ((byteValue - 152) / (255 - 152)) * 50;
            } else {
                // Ara deƒüerler (105-151) - ge√ßi≈ü b√∂lgesi, ortada say
                percent = 50;
            }

            return Math.max(0, Math.min(100, percent));
        }

        // Lever angle deƒüerini d√∂nd√ºr (bloklar i√ßin)
        function getLeverAngle(lever) {
            if (lever === 'LEFT') {
                return Math.round(calculateLeverPercent(controllerState.leftValue));
            } else if (lever === 'RIGHT') {
                return Math.round(calculateLeverPercent(controllerState.rightValue));
            }
            return 50;
        }

        function triggerLeverEvents(lever, position) {
            if (!position) return;

            // Motor i≈ülemi devam ediyorsa yeni i≈ülem ba≈ülatma
            if (motorOperationInProgress) {
                return;
            }

            // Workspace'teki t√ºm when_lever_position bloklarƒ±nƒ± bul
            const allBlocks = workspace.getAllBlocks();
            allBlocks.forEach(block => {
                if (block.type === 'when_lever_position') {
                    const blockLever = block.getFieldValue('LEVER');
                    const blockPosition = block.getFieldValue('POSITION');

                    // Eƒüer blok parametreleri mevcut durumla e≈üle≈üiyorsa
                    if (blockLever === lever && blockPosition === position) {
                        // Bloƒüu vurgula
                        highlightBlock(block);

                        // Bloktan sonraki komutlarƒ± √ßalƒ±≈ütƒ±r
                        executeBlockChain(block);
                    }
                }
            });
        }

        // Color Sensor event trigger - when_color_detected bloklarƒ± i√ßin
        function triggerColorEvents(detectedColor) {
            if (!detectedColor || detectedColor === 'NONE') return;

            // Motor i≈ülemi devam ediyorsa yeni i≈ülem ba≈ülatma
            if (motorOperationInProgress) {
                return;
            }

            // Workspace'teki t√ºm when_color_detected bloklarƒ±nƒ± bul
            const allBlocks = workspace.getAllBlocks();
            allBlocks.forEach(block => {
                if (block.type === 'when_color_detected') {
                    const blockColor = block.getFieldValue('COLOR');

                    // Eƒüer blok parametresi mevcut renkle e≈üle≈üiyorsa
                    if (blockColor === detectedColor) {
                        console.log(`üé® Color event triggered: ${detectedColor}`);

                        // Bloƒüu vurgula
                        highlightBlock(block);

                        // Bloktan sonraki komutlarƒ± √ßalƒ±≈ütƒ±r
                        executeBlockChain(block);
                    }
                }
            });
        }

        function highlightBlock(block) {
            // Bloƒüu kƒ±sa s√ºreliƒüine vurgula
            const blockSvg = block.getSvgRoot();
            if (blockSvg) {
                blockSvg.style.filter = 'brightness(1.3)';
                setTimeout(() => {
                    blockSvg.style.filter = '';
                }, 300);
            }
        }

        async function executeBlockChain(startBlock) {
            // Bloƒüun altƒ±ndaki komut zincirini √ßalƒ±≈ütƒ±r
            let nextBlock = startBlock.getNextBlock();

            while (nextBlock) {
                await executeBlock(nextBlock);
                nextBlock = nextBlock.getNextBlock();
            }
        }

        async function executeBlock(block) {
            const blockType = block.type;
            console.log('  ‚Üí Executing block:', blockType);

            if (typeof logExecution === 'function') {
                logExecution(blockType);
            }

            // RGB LED bloklarƒ±
            if (blockType === 'rgb_red_on') {
                rgbLedState.red = true;
                updateRGBDisplay();
            } else if (blockType === 'rgb_red_off') {
                rgbLedState.red = false;
                updateRGBDisplay();
            } else if (blockType === 'rgb_green_on') {
                rgbLedState.green = true;
                updateRGBDisplay();
            } else if (blockType === 'rgb_green_off') {
                rgbLedState.green = false;
                updateRGBDisplay();
            } else if (blockType === 'rgb_blue_on') {
                rgbLedState.blue = true;
                updateRGBDisplay();
            } else if (blockType === 'rgb_blue_off') {
                rgbLedState.blue = false;
                updateRGBDisplay();
            }
            // RGB sayƒ± g√∂nder bloklarƒ±
            else if (blockType === 'rgb_red_num') {
                const value = block.getFieldValue('NUM') || 1;
                rgbNumberState.red = parseInt(value);
                updateRGBNumberDisplay();
            } else if (blockType === 'rgb_green_num') {
                const value = block.getFieldValue('NUM') || 1;
                rgbNumberState.green = parseInt(value);
                updateRGBNumberDisplay();
            } else if (blockType === 'rgb_blue_num') {
                const value = block.getFieldValue('NUM') || 1;
                rgbNumberState.blue = parseInt(value);
                updateRGBNumberDisplay();
            }
            // Motor bloklarƒ± - Ger√ßek Bluetooth kontrol√º
            else if (blockType === 'motor_run_rotation') {
                const direction = block.getFieldValue('DIRECTION');
                const rotations = block.getFieldValue('ROTATIONS');
                console.log(`  ‚öôÔ∏è Motor: ${rotations} rotation ${direction}`);

                const deviceId = block.data;
                if (deviceId) {
                    await runMotorRotations(deviceId, parseInt(rotations), direction);
                } else {
                    console.log('  ‚ùå deviceId yok - motor √ßalƒ±≈ütƒ±rƒ±lamadƒ±');
                }
            } else if (blockType === 'motor_run_to_angle') {
                const direction = block.getFieldValue('DIRECTION');
                const angle = block.getFieldValue('ANGLE');
                console.log(`  ‚öôÔ∏è Motor: Go to ${angle}¬∞ ${direction}`);

                const deviceId = block.data;
                if (deviceId) {
                    await runMotorToAngle(deviceId, parseInt(angle), direction);
                } else {
                    console.log('  ‚ùå deviceId yok');
                }
            } else if (blockType === 'motor_go_to_position') {
                const position = block.getFieldValue('POSITION');
                console.log(`  ‚öôÔ∏è Motor: Go to position ${position}`);

                const deviceId = block.data;
                if (deviceId) {
                    await goToPosition(deviceId, parseInt(position));
                } else {
                    console.log('  ‚ùå deviceId yok');
                }
            } else if (blockType === 'motor_start') {
                const direction = block.getFieldValue('DIRECTION');
                console.log(`  ‚öôÔ∏è Motor: Start ${direction}`);

                const deviceId = block.data;
                if (deviceId) {
                    await startMotor(deviceId, direction);
                } else {
                    console.log('  ‚ùå deviceId yok');
                }
            } else if (blockType === 'motor_stop') {
                console.log(`  ‚öôÔ∏è Motor: Stop`);

                const deviceId = block.data;
                if (deviceId) {
                    await stopMotor(deviceId);
                } else {
                    console.log('  ‚ùå deviceId yok');
                }
            }
            // Wait bloƒüu
            else if (blockType === 'wait') {
                const seconds = block.getFieldValue('SECONDS') || 1;
                console.log(`  ‚Üí Waiting ${seconds} seconds...`);
                await new Promise(resolve => setTimeout(resolve, seconds * 1000));
            }
        }

        function showDeviceModal() {
            document.getElementById('deviceModal').classList.add('show');
        }

        function closeDeviceModal() {
            const modal = document.getElementById('deviceModal');
            if (modal) {
                modal.classList.remove('show');
                modal.style.display = 'none';
            }
        }

        function zoomIn() {
            workspace.zoomCenter(1.2);
        }

        function zoomOut() {
            workspace.zoomCenter(-1.2);
        }

        function resetView() {
            workspace.setScale(1);
            workspace.scrollCenter();
        }

        function clearWorkspace() {
            if (workspace.getAllBlocks().length > 0 && confirm('T√ºm bloklarƒ± sil?')) {
                workspace.clear();
            }
        }

        function toggleStartBlocks() {


            if (!workspace) {
                console.error('Workspace hen√ºz y√ºklenmedi!');
                return;
            }

            if (currentToolboxMode === 'start') {
                hideAllToolboxes();
            } else {
                showStartToolbox();
            }
        }

        function toggleControlBlocks() {


            if (!workspace) {
                console.error('Workspace hen√ºz y√ºklenmedi!');
                return;
            }

            if (currentToolboxMode === 'control') {
                hideAllToolboxes();
            } else {
                showControlToolbox();
            }
        }

        function toggleActionLedBlocks() {


            if (!workspace) {
                console.error('Workspace hen√ºz y√ºklenmedi!');
                return;
            }

            if (currentToolboxMode === 'action_led') {
                hideAllToolboxes();
            } else {
                showActionLedToolbox();
            }
        }

        function toggleActionNumBlocks() {


            if (!workspace) {
                console.error('Workspace hen√ºz y√ºklenmedi!');
                return;
            }

            if (currentToolboxMode === 'action_num') {
                hideAllToolboxes();
            } else {
                showActionNumToolbox();
            }
        }

        function toggleOperatorBlocks() {


            if (!workspace) {
                console.error('Workspace hen√ºz y√ºklenmedi!');
                return;
            }

            // Eƒüer zaten operator mode aktifse kapat, deƒüilse operator mode a√ß
            if (currentToolboxMode === 'operator') {
                hideAllToolboxes();
            } else {
                showOperatorToolbox();
            }
        }

        function toggleMotorControl() {
            console.log('toggleMotorControl √ßaƒürƒ±ldƒ±, currentMode:', currentToolboxMode);

            if (!workspace) {
                console.error('Workspace hen√ºz y√ºklenmedi!');
                return;
            }

            // Eƒüer zaten motor mode aktifse kapat, deƒüilse motor mode a√ß
            if (currentToolboxMode === 'motor') {
                hideAllToolboxes();
            } else {
                // Full veya kapalƒ± olabilir - her durumda motor a√ß
                showMotorToolbox();
            }
        }

        let currentToolboxMode = null;

        // Toolbox deƒüi≈ütiƒüinde bloklarƒ±n kaymasƒ±nƒ± √∂nlemek i√ßin bloklarƒ± fiziksel olarak geri ta≈üƒ±
        function updateToolboxPreservingScroll(toolboxXml) {
            // T√ºm √ºst seviye bloklarƒ±n pozisyonlarƒ±nƒ± kaydet
            const allBlocks = workspace.getTopBlocks(false);
            const originalPositions = [];

            allBlocks.forEach(block => {
                const pos = block.getRelativeToSurfaceXY();
                originalPositions.push({
                    block: block,
                    x: pos.x,
                    y: pos.y
                });
            });

            // Toolbox'ƒ± g√ºncelle
            workspace.updateToolbox(toolboxXml);

            // Bloklarƒ±n yeni pozisyonlarƒ±nƒ± kontrol et ve delta varsa geri ta≈üƒ±
            originalPositions.forEach(item => {
                const newPos = item.block.getRelativeToSurfaceXY();
                const deltaX = newPos.x - item.x;
                const deltaY = newPos.y - item.y;

                // Eƒüer blok kaydƒ±ysa, ters y√∂nde geri ta≈üƒ±
                if (deltaX !== 0 || deltaY !== 0) {
                    item.block.moveBy(-deltaX, -deltaY);
                }
            });
        }

        function showStartToolbox() {
            const startToolbox = `
                <xml xmlns="https://developers.google.com/blockly/xml">
                    <block type="start"></block>
                    <block type="when_condition"></block>
                    <block type="when_message_received">
                        <field name="MESSAGE">message1</field>
                    </block>
                    <sep gap="32"></sep>
                    <block type="send_message">
                        <field name="MESSAGE">message1</field>
                    </block>
                    <sep gap="32"></sep>
                    <block type="wait">
                        <value name="SECONDS">
                            <shadow type="math_number">
                                <field name="NUM">1</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="wait_until"></block>
                </xml>
            `;

            updateToolboxPreservingScroll(startToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'start';
            currentToolboxDevice = null;
            selectedDeviceId = null;

            updateToolboxButtons('startToggle');
            resetDeviceIcons();

        }

        function showControlToolbox() {
            const controlToolbox = `
                <xml xmlns="https://developers.google.com/blockly/xml">
                    <block type="repeat">
                        <value name="TIMES">
                            <shadow type="math_number">
                                <field name="NUM">10</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="forever"></block>
                    <block type="if_then"></block>
                    <block type="if_then_else"></block>
                    <block type="repeat_until"></block>
                </xml>
            `;

            updateToolboxPreservingScroll(controlToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'control';
            currentToolboxDevice = null;
            selectedDeviceId = null;

            updateToolboxButtons('controlToggle');
            resetDeviceIcons();

        }

        function showActionLedToolbox() {
            const actionLedToolbox = `
                <xml xmlns="https://developers.google.com/blockly/xml">
                    <block type="rgb_red_on"></block>
                    <block type="rgb_green_on"></block>
                    <block type="rgb_blue_on"></block>
                    <sep gap="32"></sep>
                    <block type="rgb_red_off"></block>
                    <block type="rgb_green_off"></block>
                    <block type="rgb_blue_off"></block>
                    <sep gap="32"></sep>
                    <block type="rgb_red_light_get"></block>
                    <block type="rgb_green_light_get"></block>
                    <block type="rgb_blue_light_get"></block>
                </xml>
            `;

            updateToolboxPreservingScroll(actionLedToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'action_led';
            selectedDeviceId = null;
            currentToolboxDevice = null;

            updateToolboxButtons('actionLedToggle');
            resetDeviceIcons();

        }

        function showActionNumToolbox() {
            const actionNumToolbox = `
                <xml xmlns="https://developers.google.com/blockly/xml">
                    <block type="rgb_red_num">
                        <value name="NUM">
                            <shadow type="math_number">
                                <field name="NUM">1</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="rgb_green_num">
                        <value name="NUM">
                            <shadow type="math_number">
                                <field name="NUM">1</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="rgb_blue_num">
                        <value name="NUM">
                            <shadow type="math_number">
                                <field name="NUM">1</field>
                            </shadow>
                        </value>
                    </block>
                    <sep gap="32"></sep>
                    <block type="rgb_red_get"></block>
                    <block type="rgb_green_get"></block>
                    <block type="rgb_blue_get"></block>
                </xml>
            `;

            updateToolboxPreservingScroll(actionNumToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'action_num';
            selectedDeviceId = null;
            currentToolboxDevice = null;

            updateToolboxButtons('actionNumToggle');
            resetDeviceIcons();

        }

        function showDeviceToolbox(deviceData) {
            // selectedDeviceId'yi set et - √ñNEMLI!
            selectedDeviceId = deviceData.id;
            console.log('selectedDeviceId set edildi:', selectedDeviceId);

            // Cihaz tipine g√∂re bloklarƒ± al
            const blocks = DEVICE_BLOCKS[deviceData.type] || DEVICE_BLOCKS['generic'];

            // Toolbox XML'i olu≈ütur
            let deviceToolboxXml = '<xml xmlns="https://developers.google.com/blockly/xml">';

            // Motor bloklarƒ± ekle
            if (deviceData.type === 'motor') {
                deviceToolboxXml += `
                    <block type="motor_run_rotation">
                        <field name="DIRECTION">CW</field>
                        <field name="ROTATIONS">1</field>
                    </block>
                    <block type="motor_run_to_angle">
                        <field name="DIRECTION">CW</field>
                        <field name="ANGLE">90</field>
                    </block>
                    <block type="motor_go_to_position">
                        <field name="POSITION">270</field>
                    </block>
                    <block type="motor_start">
                        <field name="DIRECTION">CW</field>
                    </block>
                    <block type="motor_stop"></block>
                `;
            }
            // Controller bloklarƒ± ekle
            else if (deviceData.type === 'controller') {
                deviceToolboxXml += `
                    <block type="when_lever_position">
                        <field name="LEVER">LEFT</field>
                        <field name="POSITION">UP</field>
                    </block>
                    <block type="lever_position">
                        <field name="LEVER">LEFT</field>
                        <field name="POSITION">UP</field>
                    </block>
                    <block type="lever_angle">
                        <field name="LEVER">LEFT</field>
                    </block>
                `;
            }
            // Color Sensor bloklarƒ± ekle
            else if (deviceData.type === 'color_sensor') {
                deviceToolboxXml += `
                    <block type="when_color_detected">
                        <field name="COLOR">RED</field>
                    </block>
                    <block type="detecting_color">
                        <field name="COLOR">YELLOW</field>
                    </block>
                    <block type="color_value"></block>
                    <block type="reflection_compare">
                        <field name="OP">LT</field>
                        <field name="VALUE">50</field>
                    </block>
                    <block type="reflection_value"></block>
                    <block type="color_hue">
                        <field name="MODE">HUE</field>
                    </block>
                `;
            }
            // Spike Essential bloklarƒ± ekle
            else if (deviceData.type === 'spike_essential') {
                deviceToolboxXml += `
                    <block type="hub_led_color">
                        <field name="COLOR">RED</field>
                    </block>
                    <block type="hub_orientation">
                        <field name="ORIENTATION">FRONT</field>
                    </block>
                    <block type="matrix_turn_on">
                        <field name="PORT">A</field>
                    </block>
                    <block type="matrix_turn_off">
                        <field name="PORT">A</field>
                    </block>
                    <block type="matrix_set_brightness">
                        <field name="PORT">A</field>
                        <value name="BRIGHTNESS">
                            <shadow type="math_number">
                                <field name="NUM">100</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="matrix_set_pixel_at">
                        <field name="PORT">A</field>
                        <field name="X">1</field>
                        <field name="Y">1</field>
                        <field name="COLOR">9</field>
                        <value name="BRIGHTNESS">
                            <shadow type="math_number">
                                <field name="NUM">100</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="matrix_rotate_pattern">
                        <field name="PORT">A</field>
                        <field name="DIRECTION">CW</field>
                    </block>
                    <block type="force_sensor_is_pressed">
                        <field name="PORT">B</field>
                        <field name="STATE">PRESSED</field>
                    </block>
                    <block type="force_sensor_pressure">
                        <field name="PORT">B</field>
                        <field name="UNIT">NEWTON</field>
                    </block>
                `;
            }
            // Generic bloklar
            else {
                deviceToolboxXml += '<block type="led_on"><field name="VAL">90</field></block>';
            }

            deviceToolboxXml += '</xml>';

            updateToolboxPreservingScroll(deviceToolboxXml);
            isToolboxVisible = true;
            currentToolboxMode = 'device';
            currentToolboxDevice = deviceData.id; // Bu da ekleyelim

            // T√ºm butonlarƒ± pasif yap, cihaz ikonu aktif
            updateToolboxButtons(null);

            // Cihaz ikonunu aktif g√∂ster
            document.querySelectorAll('.device-icon').forEach(icon => {
                icon.style.background = 'white';
            });
            const activeIcon = document.querySelector(`[data-device-id="${deviceData.id}"]`);
            if (activeIcon) {
                activeIcon.style.background = '#0FBD8C';
            }

            console.log('Device toolbox g√∂sterildi:', deviceData.name);
            console.log('currentToolboxDevice:', currentToolboxDevice);
        }

        function showOperatorToolbox() {
            const operatorToolbox = `
                    < xml xmlns = "https://developers.google.com/blockly/xml" >
                    <block type="math_number">
                        <field name="NUM">0</field>
                    </block>
                    <block type="math_arithmetic">
                        <field name="OP">ADD</field>
                        <value name="A">
                            <shadow type="math_number">
                                <field name="NUM">2</field>
                            </shadow>
                        </value>
                        <value name="B">
                            <shadow type="math_number">
                                <field name="NUM">1</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="math_random">
                        <value name="FROM">
                            <shadow type="math_number">
                                <field name="NUM">1</field>
                            </shadow>
                        </value>
                        <value name="TO">
                            <shadow type="math_number">
                                <field name="NUM">10</field>
                            </shadow>
                        </value>
                    </block>
                    <sep gap="32"></sep>
                    <block type="logic_compare">
                        <field name="OP">GT</field>
                        <value name="A">
                            <shadow type="math_number">
                                <field name="NUM">3</field>
                            </shadow>
                        </value>
                        <value name="B">
                            <shadow type="math_number">
                                <field name="NUM">2</field>
                            </shadow>
                        </value>
                    </block>
                    <sep gap="32"></sep>
                    <block type="logic_and"></block>
                    <block type="logic_or"></block>
                    <block type="logic_negate"></block>
                </xml >
                    `;

            updateToolboxPreservingScroll(operatorToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'operator';
            selectedDeviceId = null;
            currentToolboxDevice = null;

            updateToolboxButtons('operatorToggle');
            resetDeviceIcons();

        }

        function showMotorToolbox() {
            const motorToolbox = `
                    < xml xmlns = "https://developers.google.com/blockly/xml" >
                        <block type="led_on"><field name="VAL">90</field></block>
                </xml >
                    `;

            updateToolboxPreservingScroll(motorToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'motor';
            selectedDeviceId = null;
            currentToolboxDevice = null;

            updateToolboxButtons('motorToggle');
            resetDeviceIcons();
            console.log('Motor toolbox g√∂sterildi');
        }

        function resetDeviceIcons() {
            document.querySelectorAll('.device-icon').forEach(icon => {
                icon.style.background = '';
            });
        }

        function toggleActionButtonBlocks() {


            if (!workspace) {
                console.error('Workspace hen√ºz y√ºklenmedi!');
                return;
            }

            if (currentToolboxMode === 'action_button') {
                hideAllToolboxes();
            } else {
                showActionButtonToolbox();
            }
        }

        function showActionButtonToolbox() {
            const actionButtonToolbox = `
                    < xml xmlns = "https://developers.google.com/blockly/xml" >
                    <block type="rgb_red_button_get"></block>
                    <block type="rgb_green_button_get"></block>
                    <block type="rgb_blue_button_get"></block>
                </xml >
                    `;

            updateToolboxPreservingScroll(actionButtonToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'action_button';
            selectedDeviceId = null;
            currentToolboxDevice = null;

            updateToolboxButtons('actionButtonToggle');
            resetDeviceIcons();

        }

        function updateToolboxButtons(activeButtonId) {
            const buttons = ['startToggle', 'controlToggle', 'actionLedToggle', 'actionNumToggle', 'actionButtonToggle', 'operatorToggle'];

            buttons.forEach(buttonId => {
                const btn = document.getElementById(buttonId);
                if (btn) {
                    if (buttonId === activeButtonId) {
                        btn.style.background = '#0FBD8C';
                        btn.style.color = 'white';
                    } else {
                        btn.style.background = 'white';
                        btn.style.color = '#666';
                    }
                }
            });
        }

        function hideAllToolboxes() {
            const emptyToolbox = '<xml xmlns="https://developers.google.com/blockly/xml"></xml>';
            updateToolboxPreservingScroll(emptyToolbox);
            isToolboxVisible = false;
            currentToolboxMode = null;
            currentToolboxDevice = null;

            updateToolboxButtons(null);
            resetDeviceIcons();


        }

        function showToolbox() {
            showStartToolbox();
        }

        function hideToolbox() {
            hideAllToolboxes();
        }

        document.getElementById('codeModal').addEventListener('click', (e) => {
            if (e.target.id === 'codeModal') closeModal();
        });

        document.getElementById('deviceModal').addEventListener('click', (e) => {
            if (e.target.id === 'deviceModal') closeDeviceModal();
        });

        // Cihaz ekle butonu event listener
        window.addEventListener('load', () => {
            const addDeviceBtn = document.getElementById('addDeviceBtn');
            if (addDeviceBtn) {
                addDeviceBtn.addEventListener('click', addDevice);

            } else {
                console.error('‚ùå addDeviceBtn bulunamadƒ±!');
            }
        });

        // --- Info Modal Logic ---

        let executionSessions = []; // Array of { startTime, logs[], ended, endTime }
        let deviceLogs = [];
        const MAX_LOGS = 100;

        function openInfoModal() {
            document.getElementById('infoModal').classList.add('show');
            updateInfoModalTexts();
            updateStartersTab();
            switchInfoTab('starters'); // Reset to first tab
        }

        function closeInfoModal() {
            document.getElementById('infoModal').classList.remove('show');
        }

        // Close on background click
        document.getElementById('infoModal').addEventListener('click', (e) => {
            if (e.target.id === 'infoModal') closeInfoModal();
        });

        function updateInfoModalTexts() {
            const isTr = currentLanguage === 'tr';
            const title = document.getElementById('infoModalTitle');
            if (title) title.textContent = isTr ? '‚ÑπÔ∏è Sistem Bilgisi' : '‚ÑπÔ∏è System Info';

            const tab1 = document.getElementById('tab-btn-starters');
            if (tab1) tab1.textContent = isTr ? 'Ba≈ülangƒ±√ßlar' : 'Starters';

            const tab2 = document.getElementById('tab-btn-executions');
            if (tab2) tab2.textContent = isTr ? '√áalƒ±≈ütƒ±rmalar' : 'Executions';

            const tab3 = document.getElementById('tab-btn-devices');
            if (tab3) tab3.textContent = isTr ? 'Cihazlar' : 'Devices';
        }

        function switchInfoTab(tabId) {
            // Update Headers
            ['starters', 'executions', 'devices', 'graphs'].forEach(id => {
                const btn = document.getElementById(`tab-btn-${id}`);
                const content = document.getElementById(`tab-${id}`);

                if (id === tabId) {
                    btn.style.borderBottom = '3px solid #4C97FF';
                    btn.style.color = '#4C97FF';
                    if (tabId === 'graphs') {
                        btn.style.background = '#4C97FF';
                        btn.style.color = 'white';
                    }
                    content.style.display = 'block';
                } else {
                    btn.style.borderBottom = 'none';
                    btn.style.color = '#888';
                    btn.style.background = '';
                    content.style.display = 'none';
                }
            });

            if (tabId === 'executions') renderExecutionLogs();
            if (tabId === 'devices') renderDeviceLogs();
            if (tabId === 'graphs') renderLedGraph();
        }

        function updateStartersTab() {
            if (!workspace) return;
            const topBlocks = workspace.getTopBlocks(false);
            const list = document.getElementById('startersList');
            list.innerHTML = '';

            const starterTypes = ['start', 'when_condition', 'when_message_received', 'when_color_detected', 'when_controller_button'];
            let count = 0;
            const isTr = currentLanguage === 'tr';

            topBlocks.forEach(block => {
                // Filter strict: Only explicitly defined starter types
                if (starterTypes.includes(block.type)) {
                    count++;
                    const childCount = block.getDescendants().length - 1; // Exclude self

                    const li = document.createElement('li');
                    li.style.padding = '15px';
                    li.style.borderBottom = '1px solid #eee';
                    li.style.display = 'flex';
                    li.style.alignItems = 'center';
                    li.style.gap = '15px';

                    const subText = isTr ? `Altƒ±nda ${childCount} blok var` : `${childCount} blocks below`;

                    li.innerHTML = `
                    <div style="background: #FFBF00; border-radius: 12px; padding: 8px; width: 44px; height: 44px; display: flex; align-items: center; justify-content: center;">
                        ${getIconForBlock(block.type)}
                    </div>
                    <div>
                        <div style="font-weight: bold; color: #333; font-size: 16px;">${getBlockName(block.type)}</div>
                        <div style="color: #666; font-size: 14px; margin-top: 4px;">${subText}</div>
                    </div>
                `;
                    list.appendChild(li);
                }
            });

            if (count === 0) {
                list.innerHTML = `<div style="padding: 30px; text-align: center; color: #999;">${isTr ? 'Hen√ºz ba≈ülangƒ±√ß bloƒüu eklenmemi≈ü.' : 'No starter blocks added yet.'}</div>`;
            }
        }

        function getIconForBlock(type) {
            // Return SVG icons matching the actual block icons
            if (type.includes('start')) return `<img src="${ICON_START}" width="24" height="24" style="display:block;">`;
            if (type.includes('color')) return `<img src="${ICON_RHOMBUS}" width="24" height="24" style="display:block; filter: hue-rotate(180deg);">`;
            if (type.includes('controller')) return `<img src="${ICON_RHOMBUS}" width="24" height="24" style="display:block;">`;
            if (type.includes('message')) return `<img src="${ICON_MSG_IN}" width="24" height="24" style="display:block;">`;
            if (type.includes('condition')) return `<img src="${ICON_BOLT}" width="24" height="24" style="display:block;">`;
            return 'üß©';
        }

        function getBlockName(type) {
            const names = {
                'start': { tr: 'Ba≈üla Bloƒüu', en: 'Start Block' },
                'when_condition': { tr: 'Ko≈üul Bloƒüu', en: 'Condition Block' },
                'when_message_received': { tr: 'Mesaj Alƒ±ndƒ±', en: 'Msg Received' },
                'when_color_detected': { tr: 'Renk Algƒ±landƒ±', en: 'Color Detected' },
            };

            if (names[type]) {
                return currentLanguage === 'tr' ? names[type].tr : names[type].en;
            }
            return type;
        }

        // Current active flow ID for logging (set by each parallel start block)
        let currentFlowId = null;
        let flowCounter = 0;



        // Updated logExecution signature to support depth
        function logExecution(message, flowId = null, depth = 0) {
            // Find the correct session for this flowId
            const targetFlowId = flowId !== null ? flowId : currentFlowId;
            let sessionIndex = -1;

            if (targetFlowId !== null && flowIdToSessionIndex.has(targetFlowId)) {
                sessionIndex = flowIdToSessionIndex.get(targetFlowId);
            } else if (executionSessions.length > 0) {
                // Fall back to most recent session
                sessionIndex = executionSessions.length - 1;
            }

            if (sessionIndex >= 0 && sessionIndex < executionSessions.length) {
                const session = executionSessions[sessionIndex];
                if (!session.ended) {
                    const time = new Date().toLocaleTimeString();
                    session.logs.push({ time, message, depth });
                    if (session.logs.length > MAX_LOGS) session.logs.shift();
                }
            }

            const modal = document.getElementById('infoModal');
            if (modal.classList.contains('show') && document.getElementById('tab-executions').style.display !== 'none') {
                renderExecutionLogs();
            }
        }

        // Log to a specific session by index
        function logExecutionToSession(sessionIndex, message, depth = 0) {
            if (sessionIndex >= 0 && sessionIndex < executionSessions.length) {
                const session = executionSessions[sessionIndex];
                if (!session.ended) {
                    const time = new Date().toLocaleTimeString();
                    session.logs.push({ time, message, depth });
                    if (session.logs.length > MAX_LOGS) session.logs.shift();
                }
            }

            const modal = document.getElementById('infoModal');
            if (modal.classList.contains('show') && document.getElementById('tab-executions').style.display !== 'none') {
                renderExecutionLogs();
            }
        }

        // Log to all active sessions (for shared events like stop, event listening)
        function logToAllActiveSessions(message, depth = 0) {
            if (window.activeFlowSessions) {
                window.activeFlowSessions.forEach((sessionIndex) => {
                    logExecutionToSession(sessionIndex, message, depth);
                });
            }
        }

        // flowIdToSessionIndex maps flowId to session index
        const flowIdToSessionIndex = new Map();

        function startExecutionSession(flowId = null, blockId = null, title = null) {
            // Snapshot the block appearance at the start of execution
            const blockPreviewData = blockId ? getBlockSvg(blockId) : null;

            const session = {
                startTime: new Date(),
                logs: [],
                flowId: flowId, // Track which flow this session belongs to
                blockId: blockId, // Store block ID reference
                blockPreviewData: blockPreviewData, // Store the static snapshot
                title: title, // Custom session title
                ended: false,
                expanded: true // Most recent is expanded by default
            };
            // Collapse previous sessions
            executionSessions.forEach(s => s.expanded = false);
            executionSessions.push(session);

            const sessionIndex = executionSessions.length - 1;

            // Map flowId to session index
            if (flowId !== null) {
                flowIdToSessionIndex.set(flowId, sessionIndex);
            }

            // Limit total sessions
            if (executionSessions.length > 20) {
                executionSessions.shift();
                // Adjust indices in map
                flowIdToSessionIndex.forEach((idx, fid) => {
                    flowIdToSessionIndex.set(fid, idx - 1);
                });
            }

            renderExecutionLogs();
            return sessionIndex;
        }

        function endExecutionSession(reason) {
            if (executionSessions.length > 0) {
                const currentSession = executionSessions[executionSessions.length - 1];
                if (!currentSession.ended) {
                    currentSession.ended = true;
                    currentSession.endTime = new Date();
                    currentSession.endReason = reason || 'Completed';
                }
            }
            renderExecutionLogs();
        }

        function endExecutionSessionByIndex(sessionIndex, reason) {
            if (sessionIndex >= 0 && sessionIndex < executionSessions.length) {
                const session = executionSessions[sessionIndex];
                if (!session.ended) {
                    session.ended = true;
                    session.endTime = new Date();
                    session.endReason = reason || 'Completed';
                }
            }
            renderExecutionLogs();
        }

        function toggleSessionExpand(index) {
            if (executionSessions[index]) {
                executionSessions[index].expanded = !executionSessions[index].expanded;
                renderExecutionLogs();
            }
        }

        // Export a block and its children as SVG data URI
        function getBlockSvg(blockId) {
            try {
                const block = workspace.getBlockById(blockId);
                if (!block) return null;

                // Get the block's SVG element
                const blockSvg = block.getSvgRoot();
                if (!blockSvg) return null;

                // Get block bounds including all children
                const bbox = blockSvg.getBBox();
                if (bbox.width === 0 || bbox.height === 0) return null;

                // Add padding
                const padding = 10;
                const width = bbox.width + padding * 2;
                const height = bbox.height + padding * 2;

                // Create a new SVG
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                svg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
                svg.setAttribute('width', width);
                svg.setAttribute('height', height);
                svg.setAttribute('viewBox', `${bbox.x - padding} ${bbox.y - padding} ${width} ${height} `);

                // Copy defs from the workspace SVG (contains gradients, patterns, etc.)
                const workspaceSvg = workspace.getParentSvg();
                const originalDefs = workspaceSvg.querySelector('defs');
                if (originalDefs) {
                    const defsClone = originalDefs.cloneNode(true);
                    svg.appendChild(defsClone);
                }

                // Add necessary styles
                const style = document.createElementNS('http://www.w3.org/2000/svg', 'style');
                style.textContent = `
                    .blocklyText { font - family: "Helvetica Neue", Helvetica, sans - serif; font - size: 11pt; fill: #fff; }
                    /* Input fields have white background, so text should be black */
                    .blocklyNonEditableText > text { fill: #000!important; }
                    .blocklyEditableText > text { fill: #000!important; }
                    .blocklyDropdownText { fill: #fff!important; }
                `;
                svg.appendChild(style);

                // Clone the block SVG with deep clone
                const clone = blockSvg.cloneNode(true);

                // Remove any transforms (position on workspace) so it starts at 0,0
                clone.removeAttribute('transform');
                // Also remove selection highlighting class if present
                clone.classList.remove('blocklySelected');

                // Wrap in a group to ensure cleanliness
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.appendChild(clone);
                svg.appendChild(g);

                // Serialize to string
                const serializer = new XMLSerializer();
                const svgString = serializer.serializeToString(svg);

                // Convert to data URI
                return 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgString)));
            } catch (e) {
                console.error('Error exporting block SVG:', e);
                return null;
            }
        }

        function renderExecutionLogs() {
            const container = document.getElementById('executionLogs');
            const isTr = currentLanguage === 'tr';

            if (executionSessions.length === 0) {
                container.innerHTML = `< div style = "padding: 30px; text-align: center; color: #999;" > ${isTr ? 'Hen√ºz √ßalƒ±≈ütƒ±rma kaydƒ± yok.' : 'No execution logs yet.'}</div > `;
                return;
            }

            // Flow colors for visual distinction
            const flowColors = ['#e3f2fd', '#e8f5e9', '#fff3e0', '#fce4ec', '#e1f5fe', '#f3e5f5'];

            let html = '';
            // Show sessions in reverse order (newest first)
            [...executionSessions].reverse().forEach((session, revIndex) => {
                const index = executionSessions.length - 1 - revIndex;
                const startTimeStr = session.startTime.toLocaleTimeString();
                const dateStr = session.startTime.toLocaleDateString();
                const logCount = session.logs.length;
                const statusIcon = session.ended ? '‚èπÔ∏è' : '‚ñ∂Ô∏è';
                const expandIcon = session.expanded ? '‚ñº' : '‚ñ∂';

                // Get flow label if this session has an associated flowId
                const flowLabel = session.flowId ? ` (${isTr ? 'Akƒ±≈ü' : 'Flow'} ${session.flowId})` : '';
                const bgColor = session.flowId ? flowColors[(session.flowId - 1) % flowColors.length] : '#f8f9fa';

                // Get block SVG for preview (use stored snapshot)
                // Get block SVG for preview (use stored snapshot)
                const blockSvg = session.blockPreviewData;

                html += `
                    <div style="margin-bottom: 8px; border: 1px solid #e0e0e0; border-radius: 10px; overflow: hidden; background: #fff;">
                        <div onclick="toggleSessionExpand(${index})" style="background: ${bgColor}; padding: 12px; cursor: pointer; display: flex; align-items: center; gap: 12px; border-bottom: ${session.expanded ? '1px solid #e0e0e0' : 'none'};">
                            <span style="color: #666; font-size: 12px;">${expandIcon}</span>
                            <div style="background: #FFBF00; border-radius: 10px; padding: 8px; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center;">
                                <img src="${session.title && (session.title.includes('Condition') || session.title.includes('Ko≈üul')) ? ICON_BOLT : ICON_START}" width="24" height="24" style="display:block;">
                            </div>
                            <div style="flex: 1;">
                                <div style="font-weight: bold; color: #333; font-size: 16px;">${session.title ? session.title : (isTr ? 'Kod √áalƒ±≈ütƒ±rƒ±ldƒ±' : 'Code Executed') + flowLabel}</div>
                                <div style="font-size: 13px; color: #666; margin-top: 2px;">${dateStr} ${startTimeStr} ‚Ä¢ ${logCount} ${isTr ? 'i≈ülem' : 'actions'}</div>
                            </div>
                            <div style="font-size: 20px;">${statusIcon}</div>
                        </div>
                        ${session.expanded ? `
                            <div style="display: flex; gap: 8px; padding: 8px; background: #fafafa;">
                                <!-- Left: Logs -->
                                <div style="flex: 1; max-height: 400px; overflow-y: auto; min-width: 0;">
                                    ${session.logs.length === 0 ? `<div style="color: #999; text-align: center; padding: 10px;">${isTr ? 'Log yok' : 'No logs'}</div>` : ''}
                                    ${session.logs.map(log => `
                                        <div style="margin-bottom: 4px; padding: 6px 10px; margin-left: ${log.depth ? log.depth * 20 : 0}px; background: #fff; border: 1px solid #eee; border-left: ${log.depth ? '3px solid #ddd' : '1px solid #eee'}; border-radius: 6px; font-size: 12px; display: flex; align-items: center; gap: 6px;">
                                            <span style="color: #999; font-size: 10px; white-space: nowrap;">[${log.time}]</span>
                                            <span style="color: #333;">${log.message}</span>
                                        </div>
                                    `).join('')}
                                </div>
                                <!-- Right: Block Preview -->
                                ${blockSvg ? `
                                    <div style="flex: 0 0 auto; width: 220px; max-height: 400px; overflow: auto; background: #f5f5f5; border-radius: 8px; padding: 10px; border: 1px solid #e0e0e0;">
                                        <img src="${blockSvg}" style="display: block; width: 100%; height: auto;" alt="Block Preview">
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''
                    }
                    </div>
                    `;
            });

            container.innerHTML = html;
        }

        function logDeviceAction(action, deviceName, deviceType) {
            const date = new Date().toLocaleString();
            const logEntry = { date, action, deviceName, deviceType };
            deviceLogs.push(logEntry);

            const modal = document.getElementById('infoModal');
            if (modal.classList.contains('show') && document.getElementById('tab-devices').style.display !== 'none') {
                renderDeviceLogs();
            }
        }

        function getDeviceIcon(type) {
            // Return appropriate icon based on device type
            if (type === 'motor') return '‚öôÔ∏è';
            if (type === 'color_sensor') return 'üé®';
            if (type === 'controller') return 'üéÆ';
            return 'üì±';
        }

        function getDeviceTypeName(type, isTr) {
            const names = {
                'motor': { tr: 'Motor', en: 'Motor' },
                'color_sensor': { tr: 'Renk Sens√∂r√º', en: 'Color Sensor' },
                'controller': { tr: 'Kumanda', en: 'Controller' }
            };
            if (names[type]) {
                return isTr ? names[type].tr : names[type].en;
            }
            return type || 'Device';
        }

        function renderDeviceLogs() {
            const list = document.getElementById('deviceLogsList');
            const isTr = currentLanguage === 'tr';
            if (deviceLogs.length === 0) {
                list.innerHTML = `<div style="padding: 30px; color: #999; text-align: center;">${isTr ? 'Hen√ºz cihaz i≈ülemi yok' : 'No device actions yet'}</div>`;
                return;
            }

            list.innerHTML = deviceLogs.map(log => {
                const icon = getDeviceIcon(log.deviceType);
                const typeName = getDeviceTypeName(log.deviceType, isTr);
                const isAdd = log.action === 'add';
                const actionText = isAdd
                    ? (isTr ? '+ Eklendi' : '+ Added')
                    : (isTr ? '- Kaldƒ±rƒ±ldƒ±' : '- Removed');
                const actionColor = isAdd ? '#2e7d32' : '#c62828';
                const bgColor = isAdd ? '#e8f5e9' : '#ffebee';

                return `
                    <li style="padding: 12px 15px; border-bottom: 1px solid #eee; display: flex; align-items: center; gap: 12px;">
                        <div style="background: #FFBF00; border-radius: 10px; padding: 8px; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-size: 20px;">
                            ${icon}
                        </div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; color: #333; font-size: 15px;">${log.deviceName || typeName}</div>
                            <div style="font-size: 12px; color: #666; margin-top: 2px;">${log.date}</div>
                        </div>
                        <div style="background: ${bgColor}; color: ${actionColor}; padding: 4px 10px; border-radius: 12px; font-size: 12px; font-weight: 600;">
                            ${actionText}
                        </div>
                    </li>
                    `;
            }).reverse().join('');
        }

        // ========== LED GRAPH FUNCTIONALITY ==========
        // Store LED data points with timestamps (max 1 hour = 3600 seconds)
        const ledGraphData = {
            red: [],    // { timestamp: Date, value: number }
            green: [],
            blue: []
        };
        const MAX_GRAPH_DATA_AGE = 3600 * 1000; // 1 hour in ms
        const APP_START_TIME = Date.now(); // Track when app was opened

        // Numbers graph data (RGB numeric values)
        const numbersGraphData = {
            red: [],    // { timestamp: Date, value: number }
            green: [],
            blue: []
        };

        // Zoom state (shared between both graphs)
        let graphViewStart = null; // null = auto (app start or 1 hour ago, whichever is later)
        let graphViewEnd = null;   // null = auto (now)
        let isGraphZoomed = false;

        // Drag selection state
        let isDragging = false;
        let dragStartX = 0;
        let dragEndX = 0;

        // Initialize all colors with starting values (so all appear on graph even at 0/Off)
        ['red', 'green', 'blue'].forEach(color => {
            ledGraphData[color].push({ timestamp: APP_START_TIME, value: 0 });
            numbersGraphData[color].push({ timestamp: APP_START_TIME, value: 0 });
        });

        function logLedValue(color, value) {
            const now = Date.now();
            ledGraphData[color].push({ timestamp: now, value: value });

            // Cleanup old data (older than 1 hour)
            const cutoff = now - MAX_GRAPH_DATA_AGE;
            ledGraphData[color] = ledGraphData[color].filter(d => d.timestamp > cutoff);
        }

        function logNumberValue(color, value) {
            const now = Date.now();
            numbersGraphData[color].push({ timestamp: now, value: value });

            // Cleanup old data (older than 1 hour)
            const cutoff = now - MAX_GRAPH_DATA_AGE;
            numbersGraphData[color] = numbersGraphData[color].filter(d => d.timestamp > cutoff);
        }

        function refreshLedGraph() {
            // Reset to default 1 hour view
            graphViewStart = null;
            graphViewEnd = null;
            isGraphZoomed = false;
            document.getElementById('cancelZoomBtn').style.display = 'none';
            renderLedGraph();
            renderNumbersGraph();
        }

        function cancelGraphZoom() {
            refreshLedGraph();
        }

        function formatTime(timestamp) {
            const d = new Date(timestamp);
            // 24-hour format: HH:MM:SS
            return d.toLocaleTimeString('tr-TR', { hour12: false });
        }

        function renderLedGraph() {
            const canvas = document.getElementById('ledGraphCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.fillStyle = '#fafafa';
            ctx.fillRect(0, 0, width, height);

            // Graph area (with padding for labels) - adjusted for smaller height
            const padding = { left: 30, right: 10, top: 8, bottom: 18 };
            const graphWidth = width - padding.left - padding.right;
            const graphHeight = height - padding.top - padding.bottom;

            const now = Date.now();
            const viewEnd = graphViewEnd || now;
            // Use app start time as minimum - don't show time before app was opened
            const defaultStart = Math.max(APP_START_TIME, now - MAX_GRAPH_DATA_AGE);
            const viewStart = graphViewStart || defaultStart;
            const rangeMs = viewEnd - viewStart;

            // Update time labels
            const startLabel = document.getElementById('graphTimeStart');
            const endLabel = document.getElementById('graphTimeEnd');
            if (startLabel) startLabel.textContent = formatTime(viewStart);
            if (endLabel) endLabel.textContent = formatTime(viewEnd);

            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;

            // Only 2 horizontal lines: On and Off
            const isTr = currentLanguage === 'tr';
            const onLabel = isTr ? 'A√ßƒ±k' : 'On';
            const offLabel = isTr ? 'Kapalƒ±' : 'Off';

            // On line (top)
            const yOn = padding.top;
            ctx.beginPath();
            ctx.moveTo(padding.left, yOn);
            ctx.lineTo(padding.left + graphWidth, yOn);
            ctx.stroke();
            ctx.fillStyle = '#888';
            ctx.font = '9px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText(onLabel, padding.left - 3, yOn + 3);

            // Off line (bottom)
            const yOff = padding.top + graphHeight;
            ctx.beginPath();
            ctx.moveTo(padding.left, yOff);
            ctx.lineTo(padding.left + graphWidth, yOff);
            ctx.stroke();
            ctx.fillText(offLabel, padding.left - 3, yOff + 3);

            // Draw border
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.strokeRect(padding.left, padding.top, graphWidth, graphHeight);

            // Draw LED lines
            const colors = {
                red: '#ff4444',
                green: '#44bb44',
                blue: '#4488ff'
            };

            let hasData = false;
            const transitionPoints = []; // Collect transition points for labels

            ['red', 'green', 'blue'].forEach(color => {
                const data = ledGraphData[color].filter(d => d.timestamp >= viewStart && d.timestamp <= viewEnd);
                if (data.length === 0) return;

                hasData = true;
                ctx.strokeStyle = colors[color];
                ctx.lineWidth = 2;
                ctx.beginPath();

                // Binary: value > 0 = On (top), value = 0 = Off (bottom)
                let lastValue = data[0].value > 0 ? 1 : 0;
                data.forEach((point, index) => {
                    const x = padding.left + ((point.timestamp - viewStart) / rangeMs) * graphWidth;
                    const isOn = point.value > 0 ? 1 : 0;
                    const y = padding.top + graphHeight - isOn * graphHeight;

                    if (index === 0) {
                        const startX = padding.left;
                        ctx.moveTo(startX, y);
                        ctx.lineTo(x, y);
                    } else {
                        const prevY = padding.top + graphHeight - lastValue * graphHeight;
                        ctx.lineTo(x, prevY);
                        ctx.lineTo(x, y);

                        // Record transition point (when value changes)
                        if (isOn !== lastValue) {
                            transitionPoints.push({
                                x: x,
                                timestamp: point.timestamp,
                                color: colors[color]
                            });
                        }
                    }
                    lastValue = isOn;
                });

                // Extend to current time
                const endX = padding.left + graphWidth;
                const endY = padding.top + graphHeight - lastValue * graphHeight;
                ctx.lineTo(endX, endY);

                ctx.stroke();
            });

            // Draw transition time labels (avoid overlap by spacing)
            ctx.font = '8px sans-serif';
            ctx.textAlign = 'center';
            let lastLabelX = -50; // Track last label position to avoid overlap

            transitionPoints
                .sort((a, b) => a.timestamp - b.timestamp)
                .forEach(point => {
                    // Only draw label if far enough from last one (30px minimum)
                    if (point.x - lastLabelX > 30) {
                        // Draw small tick mark
                        ctx.strokeStyle = point.color;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(point.x, padding.top + graphHeight);
                        ctx.lineTo(point.x, padding.top + graphHeight + 4);
                        ctx.stroke();

                        // Draw time label
                        ctx.fillStyle = '#666';
                        const timeStr = formatTime(point.timestamp);
                        // Show only HH:MM:SS (already in 24h format)
                        ctx.fillText(timeStr, point.x, padding.top + graphHeight + 12);

                        lastLabelX = point.x;
                    }
                });

            // Update status
            const status = document.getElementById('graphStatus');
            if (status) {
                const totalPoints = ledGraphData.red.length + ledGraphData.green.length + ledGraphData.blue.length;
                if (isGraphZoomed) {
                    const durationSec = Math.round(rangeMs / 1000);
                    status.textContent = isTr
                        ? `Zoom: ${durationSec} saniye g√∂steriliyor`
                        : `Zoom: Showing ${durationSec} seconds`;
                } else if (hasData) {
                    status.textContent = isTr
                        ? `${totalPoints} veri noktasƒ± ‚Ä¢ Son 1 saat g√∂steriliyor`
                        : `${totalPoints} data points ‚Ä¢ Showing last 1 hour`;
                } else {
                    status.textContent = isTr ? 'Hen√ºz LED verisi yok' : 'No LED data yet';
                }
            }

            // Also render numbers graph
            renderNumbersGraph();
        }

        function renderNumbersGraph() {
            const canvas = document.getElementById('numbersGraphCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.fillStyle = '#fafafa';
            ctx.fillRect(0, 0, width, height);

            // Graph area
            const padding = { left: 30, right: 10, top: 10, bottom: 20 };
            const graphWidth = width - padding.left - padding.right;
            const graphHeight = height - padding.top - padding.bottom;

            const now = Date.now();
            const viewEnd = graphViewEnd || now;
            const defaultStart = Math.max(APP_START_TIME, now - MAX_GRAPH_DATA_AGE);
            const viewStart = graphViewStart || defaultStart;
            const rangeMs = viewEnd - viewStart;

            // Y-axis range: 0-10
            const maxValue = 10;

            // Draw horizontal grid lines
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            ctx.font = '9px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillStyle = '#888';

            for (let v = 0; v <= maxValue; v += 2) {
                const y = padding.top + graphHeight - (v / maxValue) * graphHeight;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + graphWidth, y);
                ctx.stroke();
                ctx.fillText(v.toString(), padding.left - 3, y + 3);
            }

            // Draw border
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.strokeRect(padding.left, padding.top, graphWidth, graphHeight);

            // Draw number lines
            const colors = {
                red: '#ff4444',
                green: '#44bb44',
                blue: '#4488ff'
            };

            const transitionPoints = []; // Collect transition points for labels

            ['red', 'green', 'blue'].forEach(color => {
                const data = numbersGraphData[color].filter(d => d.timestamp >= viewStart && d.timestamp <= viewEnd);
                if (data.length === 0) return;

                ctx.strokeStyle = colors[color];
                ctx.lineWidth = 2;
                ctx.beginPath();

                let lastValue = Math.min(data[0].value, maxValue);
                data.forEach((point, index) => {
                    const x = padding.left + ((point.timestamp - viewStart) / rangeMs) * graphWidth;
                    const clampedValue = Math.min(point.value, maxValue);
                    const y = padding.top + graphHeight - (clampedValue / maxValue) * graphHeight;

                    if (index === 0) {
                        const startX = padding.left;
                        ctx.moveTo(startX, y);
                        ctx.lineTo(x, y);
                    } else {
                        // Step graph for discrete values
                        const prevY = padding.top + graphHeight - (lastValue / maxValue) * graphHeight;
                        ctx.lineTo(x, prevY);
                        ctx.lineTo(x, y);

                        // Record transition point (when value changes)
                        if (clampedValue !== lastValue) {
                            transitionPoints.push({
                                x: x,
                                timestamp: point.timestamp,
                                color: colors[color],
                                value: clampedValue
                            });
                        }
                    }
                    lastValue = clampedValue;
                });

                // Extend to current time
                const endX = padding.left + graphWidth;
                const endY = padding.top + graphHeight - (lastValue / maxValue) * graphHeight;
                ctx.lineTo(endX, endY);

                ctx.stroke();
            });

            // Draw transition time labels (avoid overlap by spacing)
            ctx.font = '8px sans-serif';
            ctx.textAlign = 'center';
            let lastLabelX = -50;

            transitionPoints
                .sort((a, b) => a.timestamp - b.timestamp)
                .forEach(point => {
                    // Only draw label if far enough from last one (30px minimum)
                    if (point.x - lastLabelX > 30) {
                        // Draw small tick mark
                        ctx.strokeStyle = point.color;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(point.x, padding.top + graphHeight);
                        ctx.lineTo(point.x, padding.top + graphHeight + 4);
                        ctx.stroke();

                        // Draw time label
                        ctx.fillStyle = '#666';
                        const timeStr = formatTime(point.timestamp);
                        ctx.fillText(timeStr, point.x, padding.top + graphHeight + 12);

                        lastLabelX = point.x;
                    }
                });
        }



        function initGraphZoom() {
            // Setup zoom for both LED and Numbers graphs
            setupCanvasZoom('ledGraphCanvas', 'graphSelectionOverlay');
            setupCanvasZoom('numbersGraphCanvas', 'numbersSelectionOverlay');
        }

        function setupCanvasZoom(canvasId, overlayId) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const overlay = document.getElementById(overlayId);
            const padding = { left: 30, right: 10 };
            const graphWidth = canvas.width - padding.left - padding.right;

            function getCanvasX(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                return (e.clientX - rect.left) * scaleX;
            }

            function clampToGraph(x) {
                return Math.max(padding.left, Math.min(x, padding.left + graphWidth));
            }

            function updateOverlay() {
                if (!overlay) return;
                const rect = canvas.getBoundingClientRect();
                const containerPadding = 10;

                const left = Math.min(dragStartX, dragEndX);
                const right = Math.max(dragStartX, dragEndX);
                const width = right - left;

                const screenLeft = (left / canvas.width) * rect.width + containerPadding;
                const screenWidth = (width / canvas.width) * rect.width;

                overlay.style.left = `${screenLeft} px`;
                overlay.style.width = `${screenWidth} px`;
            }

            canvas.addEventListener('mousedown', (e) => {
                const x = clampToGraph(getCanvasX(e));

                isDragging = true;
                dragStartX = x;
                dragEndX = x;
                if (overlay) {
                    overlay.style.display = 'block';
                    updateOverlay();
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                dragEndX = clampToGraph(getCanvasX(e));
                updateOverlay();
            });

            function finishSelection() {
                if (!isDragging) return;
                isDragging = false;
                if (overlay) overlay.style.display = 'none';

                const minDrag = 10;
                if (Math.abs(dragEndX - dragStartX) < minDrag) return;

                const now = Date.now();
                const defaultStart = Math.max(APP_START_TIME, now - MAX_GRAPH_DATA_AGE);
                const currentStart = graphViewStart || defaultStart;
                const currentEnd = graphViewEnd || now;
                const rangeMs = currentEnd - currentStart;

                const left = Math.min(dragStartX, dragEndX);
                const right = Math.max(dragStartX, dragEndX);

                const leftRatio = (left - padding.left) / graphWidth;
                const rightRatio = (right - padding.left) / graphWidth;

                const newStart = currentStart + leftRatio * rangeMs;
                const newEnd = currentStart + rightRatio * rangeMs;
                const newRange = newEnd - newStart;

                const MIN_ZOOM_RANGE = 5000;
                if (newRange < MIN_ZOOM_RANGE) {
                    return;
                }

                graphViewStart = newStart;
                graphViewEnd = newEnd;
                isGraphZoomed = true;

                document.getElementById('cancelZoomBtn').style.display = 'inline-block';
                renderLedGraph(); // This also calls renderNumbersGraph
            }

            canvas.addEventListener('mouseup', finishSelection);

            document.addEventListener('mouseup', (e) => {
                if (isDragging && e.target !== canvas) {
                    const x = getCanvasX(e);
                    dragEndX = clampToGraph(x);
                    finishSelection();
                }
            });

            canvas.addEventListener('mouseleave', (e) => {
                if (isDragging) {
                    dragEndX = clampToGraph(getCanvasX(e));
                    updateOverlay();
                }
            });
        }

        // Initialize zoom on load
        setTimeout(initGraphZoom, 500);

        // Make functions globally available
        window.refreshLedGraph = refreshLedGraph;
        window.cancelGraphZoom = cancelGraphZoom;
        window.renderLedGraph = renderLedGraph;
        // ========== END LED GRAPH FUNCTIONALITY ==========

        window.addEventListener('load', initBlockly);
        window.addEventListener('resize', () => Blockly.svgResize(workspace));
    </script>
</body>

</html>
