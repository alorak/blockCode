<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blok Kodlama</title>
    <script src="https://unpkg.com/blockly@10.4.3/blockly.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background: #4C97FF;
            overflow: hidden;
        }

        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }

        .top-bar {
            height: 60px;
            background: #4C97FF;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            gap: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 100;
        }

        .logo {
            color: white;
            font-size: 24px;
            font-weight: bold;
        }

        .play-btn {
            width: 48px;
            height: 48px;
            background: #FFBF00;
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        }

        .play-btn:hover {
            background: #FFA500;
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.3);
        }

        .play-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .play-btn svg {
            margin-left: 2px;
        }

        .reset-btn {
            width: 48px;
            height: 48px;
            background: #FF6680;
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        }

        .reset-btn:hover {
            background: #FF4466;
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.3);
        }

        .reset-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .top-btn {
            padding: 10px 24px;
            border: none;
            border-radius: 20px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .run-btn {
            background: #0FBD8C;
            color: white;
        }

        .run-btn:hover {
            background: #0DA574;
            transform: translateY(-2px);
        }

        .stop-btn {
            background: #FF6680;
            color: white;
        }

        .code-btn {
            background: white;
            color: #4C97FF;
            margin-left: auto;
        }

        .tool-btn-small {
            width: 48px;
            height: 48px;
            border: none;
            background: #E9ECEF;
            border-radius: 8px;
            color: #495057;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .tool-btn-small:hover {
            background: #DEE2E6;
            transform: translateY(-2px);
        }

        .sidebar {
            width: 70px;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            padding: 0;
            box-shadow: 4px 0 15px rgba(0, 0, 0, 0.08);
            border-right: 1px solid #e0e0e0;
            position: fixed;
            left: 0;
            top: 60px;
            bottom: 0;
            z-index: 50;
            transition: width 0.3s ease;
        }

        .sidebar.expanded {
            width: 280px;
        }

        .sidebar-content {
            width: 70px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
            padding: 15px 0;
            flex-shrink: 0;
            height: 100%;
        }

        .sidebar-divider {
            width: 40px;
            height: 2px;
            background: linear-gradient(90deg, transparent, #ccc, transparent);
            margin: 8px 0;
            flex-shrink: 0;
        }

        /* RGB Control Panel */
        .rgb-control-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 15px 25px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 100;
        }

        .rgb-panel-separator {
            width: 1px;
            height: 40px;
            background: linear-gradient(to bottom, transparent, #ccc, transparent);
            margin: 0 5px;
        }

        .rgb-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .rgb-group-items {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .rgb-group-label {
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        .rgb-led {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 3px solid #ddd;
            transition: all 0.2s;
            position: relative;
        }

        .rgb-led.red {
            background: #fff;
            border-color: #ff6b6b;
        }

        .rgb-led.red.active {
            background: #ff6b6b;
            box-shadow: 0 0 15px #ff6b6b;
        }

        .rgb-led.green {
            background: #fff;
            border-color: #51cf66;
        }

        .rgb-led.green.active {
            background: #51cf66;
            box-shadow: 0 0 15px #51cf66;
        }

        .rgb-led.blue {
            background: #fff;
            border-color: #4dabf7;
        }

        .rgb-led.blue.active {
            background: #4dabf7;
            box-shadow: 0 0 15px #4dabf7;
        }

        .rgb-number-box {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            font-weight: bold;
            transition: all 0.2s;
            border: 3px solid #ddd;
        }

        .rgb-number-box.red {
            background: #ffb3b3;
            border-color: #ff6b6b;
            color: #c92a2a;
        }

        .rgb-number-box.green {
            background: #b3e0b3;
            border-color: #51cf66;
            color: #2b8a3e;
        }

        .rgb-number-box.blue {
            background: #b3d9ff;
            border-color: #4dabf7;
            color: #1971c2;
        }

        .rgb-triangle-btn {
            width: 44px;
            height: 44px;
            background: none;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            margin: 0 4px;
            overflow: visible;
            outline: none;
            /* Kare olu≈ümasƒ±nƒ± engelle */
            -webkit-tap-highlight-color: transparent;
            /* Mobil se√ßimi engelle */
        }

        .rgb-triangle-btn polygon {
            transition: all 0.2s;
            stroke-width: 4px;
            stroke-linejoin: round;
        }

        .rgb-triangle-btn:hover {
            transform: scale(1.1);
        }

        .rgb-triangle-btn:active {
            transform: scale(0.95);
        }

        /* Red Button */
        .rgb-triangle-btn.red polygon {
            fill: #ffb3b3;
            stroke: #ff6b6b;
        }

        .rgb-triangle-btn.red:hover polygon {
            fill: #ff9999;
        }

        .rgb-triangle-btn.red.active polygon {
            fill: #ff6b6b;
            /* Active: Fill matches stroke (Solid Vivid) */
        }

        /* Green Button */
        .rgb-triangle-btn.green polygon {
            fill: #b3e0b3;
            stroke: #51cf66;
        }

        .rgb-triangle-btn.green:hover polygon {
            fill: #99d999;
        }

        .rgb-triangle-btn.green.active polygon {
            fill: #51cf66;
        }

        /* Blue Button */
        .rgb-triangle-btn.blue polygon {
            fill: #b3d9ff;
            stroke: #4dabf7;
        }

        .rgb-triangle-btn.blue:hover polygon {
            fill: #99cfff;
        }

        .rgb-triangle-btn.blue.active polygon {
            fill: #4dabf7;
        }

        /* Flash Animation */
        @keyframes flash-glow {
            0% {
                filter: brightness(1) drop-shadow(0 0 0 rgba(255, 255, 255, 0));
                transform: scale(1);
            }

            50% {
                filter: brightness(1.5) drop-shadow(0 0 10px currentColor);
                transform: scale(1.2);
            }

            100% {
                filter: brightness(1) drop-shadow(0 0 0 rgba(255, 255, 255, 0));
                transform: scale(1);
            }
        }

        .rgb-triangle-btn.flash {
            animation: flash-glow 0.5s ease-out;
        }



        .sidebar-bottom-tools {
            margin-top: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
            padding-bottom: 15px;
        }

        /* Blockly toolbox gizle/g√∂ster */
        .blocklyToolboxDiv.hidden {
            display: none !important;
        }

        .blocklyMainBackground {
            transition: transform 0.3s ease;
        }

        .sidebar-panel {
            width: 210px;
            background: white;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.05) inset;
            overflow-y: auto;
            padding: 20px 15px;
            display: none;
            flex-shrink: 0;
        }

        .sidebar.expanded .sidebar-panel {
            display: block;
        }

        .sidebar-panel h3 {
            margin: 0 0 15px 0;
            font-size: 14px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tool-btn {
            width: 45px;
            height: 45px;
            border: none;
            background: white;
            border-radius: 50%;
            font-size: 22px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            flex-shrink: 0;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tool-btn:hover {
            transform: scale(1.15);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        #deviceList {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 10px 0;
            padding: 5px 0;
            width: 100%;
            align-items: center;
        }

        .device-icon {
            width: 40px;
            height: 40px;
            border: 3px solid;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 7px;
            font-weight: bold;
            flex-shrink: 0;
        }

        .device-icon:hover {
            transform: scale(1.15);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .device-icon.active {
            box-shadow: 0 0 0 4px rgba(76, 151, 255, 0.3);
            transform: scale(1.1);
        }

        .device-icon.controller.active,
        .device-icon.selected {
            background-color: #e0e0e0 !important;
            color: black !important;
        }

        .device-icon svg {
            width: 16px;
            height: 16px;
        }

        .device-menu {
            display: none;
        }

        .device-menu-block {
            margin: 12px 0;
            cursor: grab;
            user-select: none;
            display: inline-block;
            transition: all 0.2s;
        }

        .device-menu-block svg {
            display: block;
        }

        .device-menu-block:hover {
            transform: translateY(-2px);
        }

        .device-menu-block:active {
            transform: translateY(1px);
            cursor: grabbing;
        }

        .device-menu-icon {
            font-size: 18px;
            flex-shrink: 0;
        }

        .disconnect-overlay {
            display: none;
            position: fixed;
            top: 70px;
            right: 10px;
            z-index: 1000;
        }

        .disconnect-overlay.show {
            display: block;
        }

        .disconnect-btn-overlay {
            padding: 12px 20px;
            background: #FF6680;
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 102, 128, 0.4);
            transition: all 0.2s;
        }

        .disconnect-btn-overlay:hover {
            background: #FF4466;
            transform: translateY(-2px);
        }

        .delete-block-overlay {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            flex-direction: row;
            gap: 10px;
        }

        .delete-block-overlay.show {
            display: flex;
        }

        .block-action-btn {
            background: #4C97FF;
            color: white;
            border: none;
            padding: 14px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(76, 151, 255, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            width: 50px;
            height: 50px;
        }

        .block-action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 151, 255, 0.5);
        }

        .block-action-btn.delete {
            background: #FF4466;
            box-shadow: 0 4px 15px rgba(255, 68, 102, 0.4);
        }

        .block-action-btn.delete:hover {
            box-shadow: 0 6px 20px rgba(255, 68, 102, 0.5);
        }

        .delete-block-btn {
            background: #FF4466;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 68, 102, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .delete-block-btn:hover {
            background: #FF4466;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 102, 128, 0.5);
        }

        /* Displays Container */
        .displays-container {
            position: fixed;
            top: 70px;
            right: 20px;
            display: flex;
            gap: 15px;
            z-index: 1000;
            align-items: flex-start;
            pointer-events: none;
            /* Container clicks pass through */
        }

        /* Controller Display Panel ve Motor Display */
        .controller-display,
        .motor-display {
            display: none;
            /* width/height controlled by content */
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.15);
            min-width: 140px;
            pointer-events: auto;
            /* Enable clicks on panels */
        }

        .controller-header {
            padding: 10px 15px;
            color: white;
            font-weight: bold;
            font-size: 14px;
            border-radius: 12px 12px 0 0;
        }

        .controller-display.active,
        .motor-display.active {
            display: block;
        }

        .controller-levers {
            display: flex;
            gap: 15px;
            align-items: center;
            padding: 12px 15px;
            justify-content: center;
        }

        .lever-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .lever-label-mini {
            font-size: 10px;
            font-weight: bold;
            color: #666;
        }

        .lever-bar {
            width: 8px;
            height: 60px;
            background: #e0e0e0;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .lever-bar-fill {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 4px;
            transition: height 0.1s ease-out;
        }

        .lever-bar-fill.left {
            background: linear-gradient(to top, #ff6b6b, #ff8787);
        }

        .lever-bar-fill.right {
            background: linear-gradient(to top, #4C97FF, #7BB3FF);
        }

        .lever-value-mini {
            font-size: 11px;
            font-weight: bold;
            color: #333;
        }

        .workspace-container {
            flex: 1;
            margin-left: 70px;
            position: relative;
            background: white;
            /* Sidebar panel artƒ±k workspace'in √ºst√ºne overlay oluyor, itmiyor */
            /* transition: margin-left 0.3s ease; */
        }

        /* Sidebar a√ßƒ±ldƒ±ƒüƒ±nda workspace'i itme - KALDIRILDI
           Bunun yerine sidebar panel overlay olarak √ßalƒ±≈üƒ±yor */
        /*
        .sidebar.expanded~.workspace-container {
            margin-left: 280px;
        }
        */

        /* Blockly toolbox'ƒ± sola ta≈üƒ±mak i√ßin ek margin */
        #blocklyDiv {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        /* Blockly toolbox stilini √∂zelle≈ütir */
        /* Flyout'un workspace'i itmemesi i√ßin absolute positioning */
        .blocklyToolboxDiv {
            background-color: rgba(255, 255, 255, 0.95) !important;
            border-right: 2px solid #E8E8E8 !important;
            position: absolute !important;
            z-index: 40 !important;
        }

        .blocklyFlyout {
            fill: #EFEFEF !important;
        }

        /* Workspace her zaman flyout geni≈üliƒüi kadar sola doƒüru offset'lensin
           Bu sayede flyout a√ßƒ±lƒ±p kapanƒ±nca bloklar kaymaz */
        .blocklyWorkspace {
            /* Flyout geni≈üliƒüi + biraz bo≈üluk i√ßin sabit margin */
            margin-left: 210px !important;
        }

        /* Flyout background'ƒ± da overlay yap */
        .blocklyFlyoutBackground {
            fill: rgba(239, 239, 239, 0.98) !important;
        }

        /* Blockly flyout SVG'sini workspace'in √ºst√ºne overlay yap */
        .blocklySvg>g.blocklyFlyout {
            z-index: 35;
        }

        /* Number Panel Popup */
        .number-panel {
            display: none;
            position: fixed;
            background: #4C97FF;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
            z-index: 10000;
            min-width: 200px;
        }

        .number-panel.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .number-display {
            background: white;
            border: 4px solid #4C97FF;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            font-weight: bold;
            color: #4C97FF;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .number-controls {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .num-btn {
            width: 60px;
            height: 60px;
            border: 3px solid white;
            background: transparent;
            border-radius: 50%;
            color: white;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .num-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .num-btn:active {
            transform: scale(0.95);
        }

        /* Angle Panel Popup */
        .angle-panel {
            display: none;
            position: fixed;
            background: #4C97FF;
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            z-index: 10000;
        }

        .angle-panel.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .angle-display-container {
            position: relative;
            width: 200px;
            height: 200px;
        }

        .angle-circle {
            width: 100%;
            height: 100%;
            background: white;
            border-radius: 50%;
            position: relative;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .angle-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 90px;
            background: #667eea;
            transform-origin: bottom center;
            transform: translate(-50%, -100%) rotate(0deg);
            border-radius: 2px 2px 0 0;
            transition: transform 0.1s ease-out;
            pointer-events: none;
        }

        .angle-center-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 16px;
            height: 16px;
            background: #667eea;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            pointer-events: none;
        }

        .angle-degrees {
            font-size: 32px;
            font-weight: bold;
            color: white;
            min-width: 80px;
            text-align: center;
        }

        /* Fix Number Field Alignment - Targeted via JS Class */
        .number-field-styled>rect {
            fill: white !important;
            stroke: none !important;
            rx: 12px;
            ry: 12px;
        }

        .number-field-styled>text {
            fill: #4C97FF !important;
            font-weight: bold !important;
            dominant-baseline: central !important;
        }

        .angle-markers {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .angle-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 12px;
            background: #ddd;
            transform-origin: bottom center;
        }

        .angle-marker.major {
            height: 18px;
            width: 3px;
            background: #999;
        }

        .angle-marker-label {
            position: absolute;
            font-size: 11px;
            font-weight: bold;
            color: white;
        }

        .angle-controls {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .angle-btn {
            width: 60px;
            height: 60px;
            border: 3px solid white;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            color: white;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .angle-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .angle-btn:active {
            transform: scale(0.95);
        }

        .code-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .code-modal.show {
            display: flex;
        }

        .code-content {
            background: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .code-header h2 {
            color: #4C97FF;
        }

        .close-btn {
            background: #FF6680;
            color: white;
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .close-btn:hover {
            background: #FF4466;
        }

        .code-display {
            background: #F9F9F9;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            white-space: pre-wrap;
            max-height: 400px;
            overflow: auto;
            border: 2px solid #E0E0E0;
        }

        .copy-btn {
            margin-top: 15px;
            padding: 12px 24px;
            background: #4C97FF;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .copy-btn:hover {
            background: #3A7FDF;
        }

        .copy-btn:hover {
            background: #3A7FDF;
        }

        /* Reset Modal Styling */
        .reset-modal {
            display: none;
            position: fixed;
            z-index: 10001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(2px);
            align-items: center;
            justify-content: center;
        }

        .reset-modal.active {
            display: flex;
        }

        .reset-modal-content {
            background-color: #ffffff;
            margin: auto;
            padding: 30px;
            border-radius: 20px;
            width: 420px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            text-align: left;
            color: #333333;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            border: 1px solid #e0e0e0;
        }

        .reset-modal-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 25px;
            font-size: 18px;
            font-weight: 600;
            color: #333333;
        }

        .reset-modal-header svg {
            stroke: #4C97FF;
        }

        .reset-modal-body ul {
            list-style-type: none;
            padding-left: 0;
            margin-bottom: 30px;
            color: #555555;
            font-size: 15px;
            line-height: 2;
        }

        .reset-modal-body ul li {
            position: relative;
            padding-left: 20px;
        }

        .reset-modal-body ul li::before {
            content: "‚Ä¢";
            position: absolute;
            left: 0;
            color: #4C97FF;
            font-weight: bold;
        }

        .reset-modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .reset-modal-btn {
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            outline: none;
            transition: all 0.2s;
        }

        .reset-modal-btn.cancel {
            background-color: #f5f5f5;
            color: #666666;
            border: 2px solid #e0e0e0;
        }

        .reset-modal-btn.cancel:hover {
            background-color: #eeeeee;
            border-color: #cccccc;
        }

        .reset-modal-btn.confirm {
            background-color: #4C97FF;
            color: #ffffff;
        }

        .reset-modal-btn.confirm:hover {
            background-color: #3A7FDF;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(76, 151, 255, 0.3);
        }

        .blocklyMainBackground {
            stroke: none !important;
            fill: #FAFAFA !important;
        }

        .blocklyToolboxDiv {
            background: #F9F9F9 !important;
            border-top: 3px solid #CCCCCC !important;
        }

        .blocklyFlyoutBackground {
            fill: #EFEFEF !important;
            fill-opacity: 0.98 !important;
            stroke: #e0e0e0 !important;
            stroke-width: 1 !important;
            filter: drop-shadow(4px 0 8px rgba(0, 0, 0, 0.08)) !important;
        }

        .blocklyPath {
            stroke-width: 1.5px !important;
        }

        .blocklyText {
            font-size: 18px !important;
            font-weight: 500 !important;
        }

        .blocklyEditableText .blocklyText {
            font-size: 20px !important;
            font-weight: bold !important;
        }

        /* Field kutularƒ±na padding ekle */
        .blocklyEditableText>rect {
            rx: 4 !important;
            ry: 4 !important;
        }

        /* Dropdown i√ßindeki metinleri dikey ortala */
        .blocklyDropdownText {
            dominant-baseline: middle !important;
            alignment-baseline: middle !important;
        }

        /* T√ºm field text'leri ortala */
        .blocklyText {
            dominant-baseline: middle !important;
        }
    </style>
</head>

<body>
    <div class="app">
        <div class="top-bar">
            <div class="logo">BlockCode</div>
            <div style="display: flex; gap: 10px;">
                <button class="tool-btn-small" onclick="toggleLanguage()" id="langBtn" title="Dil / Language"
                    style="font-weight: bold; font-size: 14px;">TR</button>
                <div style="width: 1px; background: #e0e0e0; margin: 0 5px;"></div>
                <input type="file" id="importInput" style="display: none;" onchange="importWorkspace(this)"
                    accept=".xml">
                <button class="tool-btn-small" onclick="document.getElementById('importInput').click()"
                    title="ƒ∞√ße Aktar (Import)">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                </button>
                <button class="tool-btn-small" onclick="exportWorkspace()" title="Dƒ±≈üa Aktar (Export)">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                </button>
                <div style="width: 1px; background: #e0e0e0; margin: 0 5px;"></div>
                <button class="reset-btn" onclick="resetEverything()" title="Sƒ±fƒ±rla">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
                        <path d="M21 3v5h-5" />
                        <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" />
                        <path d="M3 21v-5h5" />
                    </svg>
                </button>
                <button class="play-btn" onclick="runCode()" title="Kodu √áalƒ±≈ütƒ±r">
                    <svg width="24" height="24" viewBox="0 0 24 24">
                        <path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z" fill="#4CC970" stroke="#FFFFFF"
                            stroke-width="1.5" />
                    </svg>
                </button>
            </div>
        </div>

        <div class="sidebar" id="sidebar">
            <div class="sidebar-content">
                <button class="tool-btn device-add" id="addDeviceBtn" title="Cihaz Ekle">‚ûï</button>
                <div id="deviceList"></div>
                <div class="sidebar-divider"></div>
                <button class="tool-btn" id="startToggle" onclick="toggleStartBlocks()" title="Ba≈ülangƒ±√ß">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="5 3 19 12 5 21 5 3"></polygon>
                    </svg>
                </button>
                <button class="tool-btn" id="controlToggle" onclick="toggleControlBlocks()" title="Kontrol">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <path
                            d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z">
                        </path>
                    </svg>
                </button>
                <button class="tool-btn" id="actionLedToggle" onclick="toggleActionLedBlocks()" title="LED Kontrol">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <circle cx="12" cy="12" r="3"></circle>
                    </svg>
                </button>
                <button class="tool-btn" id="actionNumToggle" onclick="toggleActionNumBlocks()" title="Sayƒ± Kontrol">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                        <line x1="9" y1="9" x2="15" y2="15"></line>
                        <line x1="15" y1="9" x2="9" y2="15"></line>
                    </svg>
                </button>
                <button class="tool-btn" id="actionButtonToggle" onclick="toggleActionButtonBlocks()"
                    title="Tu≈ü Kontrol">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <!-- √ú√ßgen ikonu -->
                        <path d="M12 3L20 20H4L12 3Z"></path>
                    </svg>
                </button>
                <button class="tool-btn" id="operatorToggle" onclick="toggleOperatorBlocks()" title="Operat√∂rler">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <path d="M4 7V4h16v3"></path>
                        <path d="M9 20h6"></path>
                        <path d="M12 4v16"></path>
                    </svg>
                </button>
                <div class="sidebar-divider"></div>
                <div class="sidebar-bottom-tools">
                    <button class="tool-btn" onclick="zoomIn()" title="Yakƒ±nla≈ütƒ±r">üîç+</button>
                    <button class="tool-btn" onclick="zoomOut()" title="Uzakla≈ütƒ±r">üîç‚àí</button>
                    <button class="tool-btn" onclick="resetView()" title="G√∂r√ºn√ºm√º Ortala">‚äô</button>
                </div>
            </div>
            <div class="sidebar-panel" id="sidebarPanel">
                <h3 id="panelTitle">Cihaz Bloklarƒ±</h3>
                <div id="panelContent"></div>
            </div>
        </div>

        <div class="workspace-container">
            <div id="blocklyDiv"></div>

            <!-- RGB Control Panel -->
            <div class="rgb-control-panel">
                <div class="rgb-group">
                    <div class="rgb-group-items">
                        <div class="rgb-led red" id="rgbRedLed" title="Kƒ±rmƒ±zƒ± LED"></div>
                        <div class="rgb-led green" id="rgbGreenLed" title="Ye≈üil LED"></div>
                        <div class="rgb-led blue" id="rgbBlueLed" title="Mavi LED"></div>
                    </div>
                    <span class="rgb-group-label" id="panelLedsLabel">LEDs</span>
                </div>

                <div class="rgb-panel-separator"></div>

                <div class="rgb-group">
                    <div class="rgb-group-items">
                        <div class="rgb-number-box red" id="rgbRedNum">0</div>
                        <div class="rgb-number-box green" id="rgbGreenNum">0</div>
                        <div class="rgb-number-box blue" id="rgbBlueNum">0</div>
                    </div>
                    <span class="rgb-group-label" id="panelNumbersLabel">Numbers</span>
                </div>

                <div class="rgb-panel-separator"></div>

                <div class="rgb-group">
                    <div class="rgb-group-items">
                        <svg id="rgbRedBtn" class="rgb-triangle-btn red" viewBox="0 0 44 44"
                            onmousedown="handleBtnDown('red')" onmouseup="handleBtnUp('red')"
                            onmouseleave="handleBtnUp('red')" ontouchstart="handleBtnDown('red')"
                            ontouchend="handleBtnUp('red')">
                            <polygon points="22,4 4,40 40,40"></polygon>
                        </svg>
                        <svg id="rgbGreenBtn" class="rgb-triangle-btn green" viewBox="0 0 44 44"
                            onmousedown="handleBtnDown('green')" onmouseup="handleBtnUp('green')"
                            onmouseleave="handleBtnUp('green')" ontouchstart="handleBtnDown('green')"
                            ontouchend="handleBtnUp('green')">
                            <polygon points="22,4 4,40 40,40"></polygon>
                        </svg>
                        <svg id="rgbBlueBtn" class="rgb-triangle-btn blue" viewBox="0 0 44 44"
                            onmousedown="handleBtnDown('blue')" onmouseup="handleBtnUp('blue')"
                            onmouseleave="handleBtnUp('blue')" ontouchstart="handleBtnDown('blue')"
                            ontouchend="handleBtnUp('blue')">
                            <polygon points="22,4 4,40 40,40"></polygon>
                        </svg>
                    </div>
                    <span class="rgb-group-label" id="panelButtonsLabel">Buttons</span>
                </div>
            </div>
        </div>

        <!-- Disconnect Button Overlay -->
        <div class="disconnect-overlay" id="disconnectOverlay">
            <button class="disconnect-btn-overlay" onclick="disconnectSelectedDevice()">
                üîå Baƒülantƒ±yƒ± Kes
            </button>
        </div>

        <!-- Blok i≈ülem butonlarƒ± (saƒü alt) -->
        <div class="delete-block-overlay" id="deleteBlockOverlay">
            <button class="block-action-btn" id="duplicateBlockBtn" onclick="duplicateSelectedBlock()" title="Kopyala">
                <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="#FFFFFF">
                    <path
                        d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" />
                </svg>
            </button>
            <button class="block-action-btn delete" id="deleteBlockBtn" onclick="deleteSelectedBlock()" title="Sil">
                <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="#FFFFFF">
                    <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z" />
                </svg>
            </button>
        </div>

        <!-- Controller Display Panel - Kompakt -->
        <div class="displays-container">
            <div class="controller-display" id="controllerDisplay">
                <div class="controller-header" id="controllerHeader">Controller</div>
                <!-- Pil g√∂stergesi -->
                <div id="controllerBatteryInfo"
                    style="position: absolute; top: 38px; right: 10px; font-size: 11px; color: #37b24d; font-family: monospace; display: flex; align-items: center; gap: 3px;">
                    <svg width="18" height="12" viewBox="0 0 24 14" fill="none" stroke="currentColor"
                        stroke-width="1.5">
                        <rect x="1" y="1" width="18" height="12" rx="2" ry="2"></rect>
                        <rect x="19" y="4" width="3" height="6" rx="1" ry="1" fill="currentColor"></rect>
                        <rect id="controllerBatteryFill" x="3" y="3" width="14" height="8" rx="1" ry="1"
                            fill="currentColor" opacity="0.7"></rect>
                    </svg>
                    <span id="controllerBatteryPercent">--%</span>
                </div>
                <div class="controller-levers">
                    <!-- Sol Kol -->
                    <div class="lever-container">
                        <div class="lever-label-mini">L</div>
                        <div class="lever-bar">
                            <div class="lever-bar-fill left" id="leftLeverFill"></div>
                        </div>
                        <div class="lever-value-mini" id="leftLeverValue">50%</div>
                    </div>
                    <!-- Saƒü Kol -->
                    <div class="lever-container">
                        <div class="lever-label-mini">R</div>
                        <div class="lever-bar">
                            <div class="lever-bar-fill right" id="rightLeverFill"></div>
                        </div>
                        <div class="lever-value-mini" id="rightLeverValue">50%</div>
                    </div>
                </div>
            </div>

            <div class="motor-display" id="motorDisplay">
                <div class="controller-header" id="motorHeader">Single Motor</div>
                <!-- Pil g√∂stergesi -->
                <div id="motorBatteryInfo"
                    style="position: absolute; top: 38px; right: 10px; font-size: 11px; color: #37b24d; font-family: monospace; display: flex; align-items: center; gap: 3px;">
                    <svg width="18" height="12" viewBox="0 0 24 14" fill="none" stroke="currentColor"
                        stroke-width="1.5">
                        <!-- Pil g√∂vdesi -->
                        <rect x="1" y="1" width="18" height="12" rx="2" ry="2"></rect>
                        <!-- Pil ba≈üƒ± -->
                        <rect x="19" y="4" width="3" height="6" rx="1" ry="1" fill="currentColor"></rect>
                        <!-- Doluluk g√∂stergesi (JavaScript ile geni≈üliƒüi ayarlanacak) -->
                        <rect id="motorBatteryFill" x="3" y="3" width="14" height="8" rx="1" ry="1" fill="currentColor"
                            opacity="0.7"></rect>
                    </svg>
                    <span id="motorBatteryPercent">--%</span>
                </div>
                <div style="position: relative; width: 100px; height: 104px; margin: 15px auto;">
                    <img src="single-motor-body.png" style="width: 100%; height: 100%; object-fit: contain;">
                    <img id="motorShaft" src="single-motor-shaft.png"
                        style="position: absolute; top: 12px; left: 0; width: 100%; height: 80%; object-fit: contain; transition: transform 0.1s linear;">
                </div>
                <div id="motorAngleInfo"
                    style="text-align: center; color: #666; font-size: 12px; margin-bottom: 10px; font-weight: bold; font-family: monospace;">
                    0¬∞</div>
            </div>
        </div>

        <!-- Custom Reset Modal -->
        <div id="resetModal" class="reset-modal">
            <div class="reset-modal-content">
                <div class="reset-modal-header">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
                        <path d="M21 3v5h-5" />
                        <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" />
                        <path d="M3 21v-5h5" />
                    </svg>
                    <span id="resetModalTitle">Her ≈üeyi sƒ±fƒ±rlamak istediƒüinize emin misiniz?</span>
                </div>
                <div class="reset-modal-body">
                    <ul id="resetModalList">
                        <!-- List items will be populated by JS -->
                    </ul>
                </div>
                <div class="reset-modal-footer">
                    <button class="reset-modal-btn cancel" id="resetModalCancelBtn"
                        onclick="closeResetModal()">ƒ∞ptal</button>
                    <button class="reset-modal-btn confirm" id="resetModalConfirmBtn"
                        onclick="performReset()">Sƒ±fƒ±rla</button>
                </div>
            </div>
        </div>

        <!-- Device Remove Confirmation Modal -->
        <div id="removeDeviceModal" class="reset-modal">
            <div class="reset-modal-content" style="width: 380px;">
                <div class="reset-modal-header">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 6h18" />
                        <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" />
                        <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" />
                        <line x1="10" y1="11" x2="10" y2="17" />
                        <line x1="14" y1="11" x2="14" y2="17" />
                    </svg>
                    <span id="removeDeviceModalTitle">Bu cihazƒ± kaldƒ±rmak istediƒüinize emin misiniz?</span>
                </div>
                <div class="reset-modal-footer">
                    <button class="reset-modal-btn cancel" id="removeDeviceCancelBtn"
                        onclick="closeRemoveDeviceModal()">ƒ∞ptal</button>
                    <button class="reset-modal-btn confirm" id="removeDeviceConfirmBtn"
                        style="background-color: #FF4466;" onclick="confirmRemoveDevice()">Kaldƒ±r</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Number Panel Popup -->
    <div class="number-panel" id="numberPanel">
        <div class="number-display" id="numberDisplay">1</div>
        <div class="number-controls">
            <button class="num-btn" id="decrementBtn">‚àí</button>
            <button class="num-btn" id="incrementBtn">+</button>
        </div>
    </div>

    <!-- Angle Panel Popup -->
    <div class="angle-panel" id="anglePanel">
        <div class="angle-display-container">
            <div class="angle-circle" id="angleCircle">
                <div class="angle-markers" id="angleMarkers"></div>
                <div class="angle-indicator" id="angleIndicator"></div>
                <div class="angle-center-dot"></div>
            </div>
        </div>
        <div class="angle-controls">
            <button class="angle-btn" id="angleDecrementBtn">‚àí</button>
            <div class="angle-degrees" id="angleDegrees">0¬∞</div>
            <button class="angle-btn" id="angleIncrementBtn">+</button>
        </div>
    </div>

    <!-- Message Input Panel -->
    <div class="number-panel" id="messagePanel" style="width: 300px;">
        <div
            style="background: white; border: 4px solid #4C97FF; border-radius: 15px; padding: 20px; box-shadow: 0 4px 10px rgba(0,0,0,0.2);">
            <input type="text" id="messageInput" placeholder="Mesaj adƒ±..."
                style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #4C97FF; border-radius: 8px; outline: none; font-weight: bold;">
            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button onclick="saveMessage()"
                    style="flex: 1; padding: 10px; background: #0FBD8C; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer;">
                    ‚úì Kaydet
                </button>
                <button onclick="closeMessagePanel()"
                    style="flex: 1; padding: 10px; background: #FF6680; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer;">
                    √ó ƒ∞ptal
                </button>
            </div>
        </div>
    </div>

    <div class="code-modal" id="codeModal">
        <div class="code-content">
            <div class="code-header">
                <h2>üìù MicroPython</h2>
                <button class="close-btn" onclick="closeModal()">√ó</button>
            </div>
            <div class="code-display" id="codeDisplay"></div>
            <button class="copy-btn" onclick="copyCode()">üìã Kopyala</button>
        </div>
    </div>

    <!-- Device Connection Modal -->
    <div class="code-modal" id="deviceModal">
        <div class="code-content" style="max-width: 800px;">
            <div class="code-header">
                <h2 id="deviceModalTitle">üì± Bluetooth Cihaz Y√∂netimi</h2>
                <button class="close-btn" onclick="closeDeviceModal()">√ó</button>
            </div>

            <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                <button class="copy-btn" id="scanDeviceBtn" onclick="scanAndConnect()" style="flex: 1.3; margin: 0;">
                    üîç Yeni Cihaz Ara & Baƒülan
                </button>
                <button class="copy-btn" id="addSpecificBtn" onclick="openSpecificDeviceModal()"
                    style="flex: 1; margin: 0; background-color: #6C5CE7; color: white;">
                    ‚ûï √ñzel Cihaz Ekle
                </button>
            </div>

            <div
                style="background: white; border-radius: 8px; border: 2px solid #e0e0e0; overflow: hidden; margin-bottom: 20px;">
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: #4C97FF; color: white;">
                            <th id="thDeviceName" style="padding: 12px; text-align: left; font-size: 14px;">Cihaz Adƒ±
                            </th>
                            <th id="thDeviceId" style="padding: 12px; text-align: left; font-size: 14px;">Cihaz ID</th>
                            <th id="thDeviceStatus" style="padding: 12px; text-align: center; font-size: 14px;">Durum
                            </th>
                            <th id="thDeviceAction" style="padding: 12px; text-align: center; font-size: 14px;">ƒ∞≈ülem
                            </th>
                        </tr>
                    </thead>
                    <tbody id="devicesTableBody">
                        <tr>
                            <td id="noDeviceMsg" colspan="4" style="padding: 30px; text-align: center; color: #999;">
                                Hen√ºz baƒülƒ± cihaz yok. "Yeni Cihaz Ara & Baƒülan" butonuna tƒ±klayƒ±n.
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div id="scanStatus"
                style="display: none; background: #f0f0f0; padding: 15px; border-radius: 8px; margin-bottom: 20px; text-align: center; font-size: 14px;">
                üîç Tarama yapƒ±lƒ±yor...
            </div>
        </div>
    </div>

    <!-- Specific Device Selection Modal -->
    <div class="code-modal" id="specificDeviceModal" style="z-index: 10000;">
        <div class="code-content" style="max-width: 500px; z-index: 10001;">
            <div class="code-header">
                <h2 id="specificModalTitle">Cihaz Tipi Se√ßin</h2>
                <button class="close-btn" onclick="closeSpecificDeviceModal()">√ó</button>
            </div>
            <div style="display: flex; gap: 20px; padding: 20px; justify-content: center;">
                <div onclick="scanSpecificDevice('controller')"
                    style="cursor: pointer; padding: 20px; border: 2px solid #ddd; border-radius: 12px; text-align: center; flex: 1; transition: all 0.2s; background: white;"
                    onmouseover="this.style.background='#f5f5f5'; this.style.borderColor='#4C97FF'"
                    onmouseout="this.style.background='white'; this.style.borderColor='#ddd'">
                    <img src="controller.png" alt="Controller"
                        style="width: 80px; height: 80px; object-fit: contain; margin-bottom: 10px;">
                    <div id="specificLabelController" style="font-weight: bold; font-size: 16px;">Controller</div>
                </div>
                <div onclick="scanSpecificDevice('single_motor')"
                    style="cursor: pointer; padding: 20px; border: 2px solid #ddd; border-radius: 12px; text-align: center; flex: 1; transition: all 0.2s; background: white;"
                    onmouseover="this.style.background='#f5f5f5'; this.style.borderColor='#4C97FF'"
                    onmouseout="this.style.background='white'; this.style.borderColor='#ddd'">
                    <img src="single-motor.png" alt="Single Motor"
                        style="width: 80px; height: 80px; object-fit: contain; margin-bottom: 10px;">
                    <div id="specificLabelSingleMotor" style="font-weight: bold; font-size: 16px;">Single Motor</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let workspace;
        let currentNumberField = null;
        let currentValue = 1;
        let minValue = 1;
        let maxValue = 100;
        let messages = ['message1', 'message2']; // Varsayƒ±lan mesajlar
        let currentMessageField = null;
        let currentMessageBlock = null;
        let isToolboxVisible = false;
        let currentToolboxDevice = null;

        // RGB kontrol deƒüi≈ükenleri
        let rgbLedState = { red: false, green: false, blue: false };
        let rgbNumberState = { red: 0, green: 0, blue: 0 };

        // A√ßƒ± se√ßici deƒüi≈ükenleri
        let currentAngleField = null;
        let currentAngle = 0;

        // Motor i≈ülem kilidi - aynƒ± anda sadece bir motor i≈ülemi yapƒ±labilir
        let motorOperationInProgress = false;

        // G√∂rsel g√ºncelleme throttle - 100ms'de bir g√ºncelle
        let lastVisualUpdate = 0;
        const VISUAL_UPDATE_INTERVAL = 100;

        // Controller state tracking
        let controllerState = {
            left: 'RELEASED',  // UP, DOWN, RELEASED
            right: 'RELEASED',
            leftValue: 0,
            rightValue: 0,
            leftPercent: 50,   // 0-100 arasƒ± y√ºzdelik deƒüer
            rightPercent: 50   // 0-100 arasƒ± y√ºzdelik deƒüer
        };

        // Motor state tracking (PCAP analizinden: Index 8-9 = anlƒ±k a√ßƒ±, Index 13-14 = hedef a√ßƒ±)
        let motorState = {
            currentAngle: 0,      // Anlƒ±k motor a√ßƒ±sƒ± (derece)
            targetAngle: 0,       // Hedef a√ßƒ±
            mode: 0,              // Mode byte (0x00=idle, 0x01=moving, 0x07=holding)
            isMoving: false,      // Motor hareket halinde mi
            deviceId: null        // Hangi cihaza ait
        };

        // Motor monitoring deƒüi≈ükenleri
        let motorMonitoringActive = false;
        let activeMotorDevice = null;
        let activeMotorCharacteristic = null;
        let motorLastVisualUpdate = 0;
        const MOTOR_VISUAL_UPDATE_INTERVAL = 50; // 50ms'de bir g√ºncelle (daha akƒ±cƒ± animasyon)

        // --- ICONS (Simple White SVGs) ---
        const ICON_START = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMTQuNCA2TDE0IDRINXYxN2gydi03aDUuNmwuNCAyaDdWNnoiIGZpbGw9IiM0Q0M5NzAiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIxLjUiLz48L3N2Zz4='; // Green Flag with white outline
        const ICON_BOLT = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNNyAydjExaDN2OWw3LTEyaC00bDQtOHoiLz48L3N2Zz4=';
        const ICON_MSG_IN = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNMjAgNEg0Yy0xLjEgMC0xLjk5LjktMS45OSAyTDIgMThjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY2YzAtMS4xLS45LTItMi0yem0wIDRsLTggNS04LTVWNmw4IDUgOC01djJ6Ii8+PC9zdmc+';
        const ICON_MSG_OUT = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNOSAxNmg2di02aDRsLTctNy03IDdoNHptLTQgMmgxNHYySDV6Ii8+PC9zdmc+';
        const ICON_CLOCK = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNMTIgMkM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptMCAxOGMtNC40MSAwLTgtMy41OS04LThzMy41OS04IDgtOHw4IDMuNTkgOCA4LTMuNTkgOC04IDh6bS41LTExSDExdjZsNS4yIDMuMi44LTEuMy00LjUtMi41ek03IDEyYzAgMi43NiAyLjI0IDUgNSA1czUtMi4yNCA1LTVIN3oiLz48L3N2Zz4='; // Hand/Stop-like icon (using a simplified pause/stop metaphor or just keeping clock but trying to make it look like "duration" or "stop"). Actually user asked for "durma veya stop", so let's use a Hand (Pause/Stop) icon.
        // Better "Stop"/"Hand" icon for Wait:
        const ICON_STOP_HAND = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNMTIgMkM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptLTEgMTRoLTJ2LTZoMnY2em00IDBoLTJ2LTZoMnY2eiIvPjwvc3ZnPg=='; // Pause/Stop circle

        const ICON_LOOP = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNNy41IDE4QTMuNSAzLjUgMCAwIDEgNCAxNC41VjUuNWw0LjIgMi44YTMuNSAzLjUgMCAwIDEgNC4yIDIuOGw2LTUuNkEzLjUgMy41IDAgMCAwIDIwIDUuNUgxNlYyaC0ydjZIMjJ2LTJtLTIgMTMuMkEzLjUgMy41IDAgMCAwIDE2IDE4LjVIMjJWMjJoLTJ2LTZIMTZ2MiIvPjwvc3ZnPg=='; // Trying to find a visually simpler "refresh" or "repeat" icon. Let's use standard Material refresh.
        const ICON_REFRESH = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNMTcuNjUgNi4zNUMxNi4yIDQuOSAxNC4yMSA0IDEyIDRjLTQuNDIgMC03Ljk5IDMuNTgtNy45OSA4czMuNTcgOCA3Ljk5IDhjMy43MyAwIDYuODQtMi41NSA3LjczLTYtMmgtMi4wOGMtLjgyIDIuMzMtMy4wNCA0LTUuNjUgNC0zLjMxIDAtNi0yLjY5LTYtNnMvbS42OS02IDYtNmMgMS42NiAwIDMuMTQuNjkgNC4yMiAxLjc4TDEzIDExaDdWNWwtMi4zNSAyLjM1eiIvPjwvc3ZnPg==';

        const ICON_INFINITY = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNMTguNiA2LjYyYy0xLjQ0IDAtMi44LjU2LTMuNzcgMS41M0wxMiAxMC42NiA5LjE3IDguMTVjLS45Ny0uOTctMi4zMy0xLjUzLTMuNzctMS41My0yLjk0IDAtNS4zMyAyLjM4LTUuMzMyIDUuMzE1UzIuNCAxNy4yNSA1LjQgMTcuMjVjMS40NCAwIDIuOC0uNTYgMy43Ny0xLjUzTDEyIDEzLjM0bDguMDMgOC4wM2MuOTcuOTcgMi41MyAxLjUzIDMuNzcgMS41MyAyLjk0IDAgNS4zMy0yLjM5IDUuMzMtNS4zMyAwLTIuOTMtMi4zOS01LjMzLTUuMzMtNS4zM3ptMCA4LjU1Yy0uNTEgMC0xLjAxLS4yLTEuMzktLjU5TDEyIDEwLjAybDguNDEgOC40MWMtLjM4LjM5LS44OC41OS0xLjQxLjU5em0tOS45Ni05LjgyYy41MSAwIDEuMDEuMiAxLjM5LjU5TDEyIDEwLjM0bC0yLjI5IDIuMjlMOC42NCA5LjY1Yy0uMzgtLjM5LS44OS0uNTktMS40MS0uNTktMS45NiAwLTMuNTUgMS41OS0zLjU1IDMuNTUgMCAxLjk2IDEuNTkgMy41NSAzLjU1IDMuNTUuNTEgMCAxLjAxLS4yIDEuMzktLjU5bDMuMTItMy4xMi01LjEzLTUuMTNjLjM4LS40Mi44OS0uNjMgMS40MS0uNjN6Ii8+PC9zdmc+';
        const ICON_DIAMOND = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNOS4xNyA2bDItMmMyIC44MiAyLjgyIDEuNjQgNC44MyAzLjY0bDMuNjQgNC44M2MtLjgyIDItMS42NCAyLjgyLTMuNjQgNC44M2wtMiAyLTIgLTIgLTMuNjMtNC44M2MuODItMiAxLjY0LTIuODIgMy42My00Ljgzek0xMiAyTDQgMTJsOCAxMCA4LTEwTDExIDJ6Ii8+PHBhdGggZD0iTTE5IDNsLTUgNWgydi00bDQtNGg2eSgiIHRyYW5zZm9ybT0icm90YXRlKDQ1IDEyIDEyKSIvPjwvc3ZnPg=='; // Generic Diamond for Logic, replaced with a filled rhombus or similar if needed. Using a simple rhombus here:
        const ICON_COND_TRUE = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNMTkgM0g1Yy0xLjEgMC0yIC45LTIgMnYxNGMwIDEuMS45IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6bTAgMTZINVY1aDE0djE0em0tNy0yaC0ydi01aDVsLTEgMWg0bC02LTZ6Ii8+PC9zdmc+'; // Placeholder if needed, but let's use a simple diamond shape for logic conditions.
        const ICON_RHOMBUS = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNMTIgMkwyIDEybDEwIDEwIDEwLTEwTDExIDJ6Ii8+PC9zdmc+';
        const ICON_HOURGLASS = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNNiAydjZoLjAxTCA2IDguMDFWMTBsNiA2IDYgNnYybC4wMSAySDZ2NmgxMnYtNmgtLjAxTDE4IDE2di0ybC02LTYgNi02VjZMNT44di02aC0uMDFMNiAyeiIvPjwvc3ZnPg==';

        // Colored Square Icons for RGB blocks (Red, Green, Blue) - No gradients, solid colors.
        // Using slight shadow/bevel effect for "button" look if desired, or flat. User said "kare ≈üeklinde ikonlar".
        const ICON_SQUARE_RED = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IjBmaWxsPSIjRkYwMDAwIj48cmVjdCB4PSI0IiB5PSI0IiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHJ4PSIyIiByeT0iMiIgLz48L3N2Zz4='; // #FF0000 Rounded Rect
        const ICON_SQUARE_GREEN = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IjBmaWxsPSIjMDBGRjAwIj48cmVjdCB4PSI0IiB5PSI0IiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHJ4PSIyIiByeT0iMiIgLz48L3N2Zz4='; // #00FF00
        const ICON_SQUARE_BLUE = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IjBmaWxsPSIjMDAwMEZGIj48cmVjdCB4PSI0IiB5PSI0IiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHJ4PSIyIiByeT0iMiIgLz48L3N2Zz4='; // #0000FF

        // Updating with specific colors requested normally found in blocks (e.g. Red #FF3333, etc) or just pure RGB.
        // Let's use darker shades to stand out on pastel blocks if necessary, or vivid standard colors.
        // Red: #D32F2F, Green: #388E3C, Blue: #1976D2
        const ICON_SQ_RED = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRDMyRjJGIj48cmVjdCB4PSI0IiB5PSI0IiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHJ4PSI0IiByeT0iNCIgLz48L3N2Zz4=';
        const ICON_SQ_GREEN = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjMzg4RTNDIj48cmVjdCB4PSI0IiB5PSI0IiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHJ4PSI0IiByeT0iNCIgLz48L3N2Zz4=';
        const ICON_SQ_BLUE = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjMTk3NkQyIj48cmVjdCB4PSI0IiB5PSI0IiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHJ4PSI0IiByeT0iNCIgLz48L3N2Zz4=';

        // Solid Colored Circle Icons (Red, Green, Blue) - No gradient
        const ICON_CIRCLE_RED = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkYwMDAwIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI4IiAvPjwvc3ZnPg==';
        const ICON_CIRCLE_GREEN = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjMDBGRjAwIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI4IiAvPjwvc3ZnPg==';
        const ICON_CIRCLE_BLUE = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjMDAwMEZGIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI4IiAvPjwvc3ZnPg==';

        // Using specific darker shades if preferred for better contrast on blocks
        const ICON_CIRC_RED = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRDMyRjJGIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI3IiAvPjwvc3ZnPg==';
        const ICON_CIRC_GREEN = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjMzg4RTNDIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI3IiAvPjwvc3ZnPg==';
        const ICON_CIRC_BLUE = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjMTk3NkQyIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI3IiAvPjwvc3ZnPg==';
        // White circle for "Off" state (same size as On state)
        const ICON_CIRC_WHITE = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI3IiAvPjwvc3ZnPg==';


        let controllerMonitoring = null;  // Interval ID for monitoring
        let activeControllerDevice = null; // Aktif controller cihazƒ±
        let activeControllerCharacteristic = null; // DEBUG i√ßin
        let controllerPingInterval = null; // Periyodik ping i√ßin

        // DEBUG: Manuel test fonksiyonu
        window.testControllerCharacteristic = async function () {
            console.log('üß™ Controller characteristic test ba≈ülatƒ±lƒ±yor...');

            if (!activeControllerCharacteristic) {
                console.log('‚ùå activeControllerCharacteristic yok!');
                return;
            }
        };

        // --- VISUAL FIXES ---
        // Safely style Number Fields without breaking Dropdowns
        if (typeof Blockly !== 'undefined') {
            // 1. Add a specific class to Number Fields during initialization
            const originalInitView = Blockly.FieldNumber.prototype.initView;
            Blockly.FieldNumber.prototype.initView = function () {
                originalInitView.call(this);
                if (this.fieldGroup_) {
                    Blockly.utils.dom.addClass(this.fieldGroup_, 'number-field-styled');
                }
            };

            // 2. Add padding to single digits to make them look like circles/pills
            const originalGetText = Blockly.FieldNumber.prototype.getText;
            Blockly.FieldNumber.prototype.getText = function () {
                const text = originalGetText.call(this);
                if (text && text.length === 1) {
                    return ' ' + text + ' '; // Add spaces for visual centering
                }
                return text;
            };
        }

        // --- LANGUAGE SUPPORT ---
        let currentLanguage = 'tr';

        const TRANSLATIONS = {
            tr: {
                lang: "TR",
                import: "ƒ∞√ße Aktar (Import)",
                export: "Dƒ±≈üa Aktar (Export)",
                reset: "Sƒ±fƒ±rla",
                run: "Kodu √áalƒ±≈ütƒ±r",
                add_device: "Cihaz Ekle",

                start_tooltip: "Ba≈ülangƒ±√ß",
                control_tooltip: "Kontrol",
                led_tooltip: "LED Kontrol",
                num_tooltip: "Sayƒ± Kontrol",
                btn_tooltip: "Tu≈ü Kontrol",
                op_tooltip: "Operat√∂rler",
                zoom_in: "Yakƒ±nla≈ütƒ±r",
                zoom_out: "Uzakla≈ütƒ±r",
                reset_view: "G√∂r√ºn√ºm√º Ortala",

                block_random_pre: " rastgele sayƒ±  ",
                block_random_mid: " ile ",
                delete_block: "Bloƒüu Sil",

                modal_reset_title: "Her ≈üeyi sƒ±fƒ±rlamak istediƒüinize emin misiniz?",
                modal_reset_list: "RGB paneli sƒ±fƒ±rlanacak|T√ºm LED'ler s√∂necek|Sayƒ± deƒüerleri 0 olacak|Cihazlar baƒülƒ± kalacak",
                btn_cancel: "ƒ∞ptal",
                btn_reset: "Sƒ±fƒ±rla",

                block_wait_pre: "‚è±Ô∏è ",
                block_wait_post: " saniye bekle  ",
                block_repeat_pre: "üîÑ ",
                block_repeat_post: " kez tekrarla  ",
                block_forever: "‚ôæÔ∏è s√ºrekli tekrarla  ",
                block_if: "üî∂ eƒüer",
                block_then: "ise  ",
                block_then: "ise  ",
                block_else: "deƒüilse  ",
                block_wait_until_pre: "‚è≥ ",
                block_start: "play tƒ±klandƒ±ƒüƒ±nda  ",

                block_wait_pre: " ",
                block_wait_post: " saniye bekle  ",
                block_repeat_pre: " ",
                block_repeat_post: " kez tekrarla  ",
                block_forever: " s√ºrekli tekrarla  ",
                block_if: " eƒüer",
                block_then: "ise  ",
                block_then: "ise  ",
                block_else: "deƒüilse  ",
                block_wait_until_pre: " ",
                block_wait_until_post: " olana kadar bekle  ",
                block_repeat_until_pre: " ",
                block_repeat_until_post: " olana kadar tekrarla  ",

                block_when_pre: "olduƒüunda  ",
                block_when_post: "  ",
                block_message_pre: "alƒ±ndƒ±ƒüƒ±nda  ",
                block_message_post: "  ",
                block_send_mobile_pre: "g√∂nder  ",
                block_send_mobile_post: "  ",

                block_light_get_pre: " ",
                block_light_get_post: " ƒ±≈üƒ±k getir  ",

                block_red_light_on: "  kƒ±rmƒ±zƒ± ƒ±≈üƒ±k yak    ",
                block_red_light_off: "  kƒ±rmƒ±zƒ± ƒ±≈üƒ±k s√∂nd√ºr    ",
                block_green_light_on: "  ye≈üil ƒ±≈üƒ±k yak    ",
                block_green_light_off: "  ye≈üil ƒ±≈üƒ±k s√∂nd√ºr    ",
                block_blue_light_on: "  mavi ƒ±≈üƒ±k yak    ",
                block_blue_light_off: "  mavi ƒ±≈üƒ±k s√∂nd√ºr    ",

                block_red_num: "  kƒ±rmƒ±zƒ± sayƒ± yap  ",
                block_green_num: "  ye≈üil sayƒ± yap  ",
                block_blue_num: "  mavi sayƒ± yap  ",
                block_red_get: "  kƒ±rmƒ±zƒ± sayƒ± √∂ƒüren  ",
                block_green_get: "  ye≈üil sayƒ± √∂ƒüren  ",
                block_blue_get: "  mavi sayƒ± √∂ƒüren  ",

                block_rgb_red_btn_get: " tu≈ü getir  ",
                block_rgb_green_btn_get: " tu≈ü getir  ",
                block_rgb_blue_btn_get: " tu≈ü getir  ",

                block_logic_and: " ve ",
                block_logic_or: " veya ",
                block_logic_not: "deƒüil ",

                panel_leds: "LEDler",
                panel_numbers: "Sayƒ±lar",
                panel_buttons: "Butonlar",

                confirm_reset: "Her ≈üeyi sƒ±fƒ±rlamak istediƒüinize emin misiniz?", // Deprecated but kept for safety
                alert_no_play: "‚ùå Play bloƒüu bulunamadƒ±!\n\n\"üö© play tƒ±klandƒ±ƒüƒ±nda\" bloƒüunu ekleyin.",
                alert_stopped: "‚èπÔ∏è Durduruldu!",
                alert_import_error: "Dosya y√ºklenirken bir hata olu≈ütu! Ge√ßerli bir XML dosyasƒ± se√ßtiƒüinizden emin olun.",
                alert_export_error: "Dƒ±≈üa aktarma sƒ±rasƒ±nda bir hata olu≈ütu!",
                confirm_import: "Mevcut √ßalƒ±≈üma alanƒ± temizlenip, dosya y√ºklensin mi?\n(ƒ∞ptal derseniz mevcut bloklarƒ±n √ºzerine eklenir)",

                scan_btn: "üîç Yeni Cihaz Ara & Baƒülan",
                tbl_name: "Cihaz Adƒ±",
                tbl_id: "Cihaz ID",
                tbl_status: "Durum",
                tbl_action: "ƒ∞≈ülem",
                no_device: "Hen√ºz baƒülƒ± cihaz yok. \"Yeni Cihaz Ara & Baƒülan\" butonuna tƒ±klayƒ±n.",
                scan_status: "üîç Tarama yapƒ±lƒ±yor...",
                status_connected: "Baƒülƒ±",
                status_disconnected: "Kesildi",
                btn_remove: "Kaldƒ±r",
                confirm_remove_device: "Bu cihazƒ± kaldƒ±rmak istediƒüinize emin misiniz?",
                connecting_to: "üì± Baƒülanƒ±yor:",
                connected_to: "‚úÖ Baƒülandƒ±:",
                device_added: "‚úÖ Cihaz eklendi!",
                unknown_device: "Bilinmeyen",
                device_list_opening: "üîç Cihaz listesi a√ßƒ±lƒ±yor...",
                modal_title: "üì± Bluetooth Cihaz Y√∂netimi",
                add_specific_btn: "‚ûï √ñzel Cihaz Ekle",
                specific_modal_title: "Cihaz Tipi Se√ßin",
                specific_type_controller: "Controller",
                specific_type_single_motor: "Single Motor"
            },
            en: {
                lang: "EN",
                import: "Import",
                export: "Export",
                reset: "Reset",
                run: "Run Code",
                add_device: "Add Device",

                start_tooltip: "Start",
                control_tooltip: "Control",
                led_tooltip: "LED Control",
                num_tooltip: "Number Control",
                btn_tooltip: "Button Control",
                op_tooltip: "Operators",
                zoom_in: "Zoom In",
                zoom_out: "Zoom Out",
                reset_view: "Reset View",

                block_random_pre: " pick random  ",
                block_random_mid: " to ",
                delete_block: "Delete Block",

                modal_reset_title: "Are you sure you want to reset everything?",
                modal_reset_list: "RGB panel will be reset|All LEDs will turn off|Number values will be 0|Devices will stay connected",
                btn_cancel: "Cancel",
                btn_reset: "Reset",

                block_start: "when play clicked  ",

                block_wait_pre: " wait ",
                block_wait_post: " seconds  ",
                block_repeat_pre: " repeat ",
                block_repeat_post: " times  ",
                block_forever: " repeat forever  ",
                block_if: " if",
                block_then: "then  ",
                block_then: "then  ",
                block_else: "else  ",
                block_wait_until_pre: " wait until ",
                block_wait_until_post: "  ",
                block_repeat_until_pre: " repeat until ",
                block_repeat_until_post: "  ",

                block_when_pre: "when ",
                block_when_post: "  ",
                block_message_pre: "when ",
                block_message_post: " received  ",
                block_send_mobile_pre: "send ",
                block_send_mobile_post: "  ",

                block_light_get_pre: " ",
                block_light_get_post: " get light  ",

                block_red_light_on: "  turn red light on    ",
                block_red_light_off: "  turn red light off    ",
                block_green_light_on: "  turn green light on    ",
                block_green_light_off: "  turn green light off    ",
                block_blue_light_on: "  turn blue light on    ",
                block_blue_light_off: "  turn blue light off    ",

                block_red_num: "  set red number to  ",
                block_green_num: "  set green number to  ",
                block_blue_num: "  set blue number to  ",
                block_red_get: "  get red number  ",
                block_green_get: "  get green number  ",
                block_blue_get: "  get blue number  ",

                block_rgb_red_btn_get: " get button  ",
                block_rgb_green_btn_get: " get button  ",
                block_rgb_blue_btn_get: " get button  ",

                block_logic_and: " and ",
                block_logic_or: " or ",
                block_logic_not: "not ",

                panel_leds: "LEDs",
                panel_numbers: "Numbers",
                panel_buttons: "Buttons",

                confirm_reset: "üîÑ Are you sure you want to reset everything?\n\n‚Ä¢ RGB panel will be reset\n‚Ä¢ All LEDs will turn off\n‚Ä¢ Number values will be 0\n‚Ä¢ Devices will stay connected",
                alert_no_play: "‚ùå Play block not found!\n\nAdd \"üö© when play clicked\" block.",
                alert_stopped: "‚èπÔ∏è Stopped!",
                alert_import_error: "Error loading file! Make sure you selected a valid XML file.",
                alert_export_error: "Error exporting workspace!",
                confirm_import: "Clear current workspace before loading?\n(Cancel to append to existing blocks)",

                scan_btn: "üîç Scan & Connect New Device",
                tbl_name: "Device Name",
                tbl_id: "Device ID",
                tbl_status: "Status",
                tbl_action: "Action",
                no_device: "No connected devices. Click \"Scan & Connect New Device\".",
                scan_status: "üîç Scanning...",
                status_connected: "Online",
                status_disconnected: "Offline",
                btn_remove: "Remove",
                confirm_remove_device: "Are you sure you want to remove this device?",
                connecting_to: "üì± Connecting:",
                connected_to: "‚úÖ Connected:",
                device_added: "‚úÖ Device added!",
                unknown_device: "Unknown",
                device_list_opening: "üîç Opening device list...",
                modal_title: "üì± Bluetooth Device Management",
                add_specific_btn: "‚ûï Add Specific Device",
                specific_modal_title: "Select Device Type",
                specific_type_controller: "Controller",
                specific_type_single_motor: "Single Motor"
            }
        };

        function toggleLanguage() {
            setLanguage(currentLanguage === 'tr' ? 'en' : 'tr');
        }

        function setLanguage(lang) {
            if (!TRANSLATIONS[lang]) return;
            currentLanguage = lang;
            const t = TRANSLATIONS[lang];

            const langBtn = document.getElementById('langBtn');
            if (langBtn) langBtn.textContent = t.lang;

            const addDeviceBtn = document.getElementById('addDeviceBtn');
            if (addDeviceBtn) addDeviceBtn.title = t.add_device;

            const startToggle = document.getElementById('startToggle');
            if (startToggle) startToggle.title = t.start_tooltip;

            const controlToggle = document.getElementById('controlToggle');
            if (controlToggle) controlToggle.title = t.control_tooltip;

            const actionLedToggle = document.getElementById('actionLedToggle');
            if (actionLedToggle) actionLedToggle.title = t.led_tooltip;

            const actionNumToggle = document.getElementById('actionNumToggle');
            if (actionNumToggle) actionNumToggle.title = t.num_tooltip;

            const actionButtonToggle = document.getElementById('actionButtonToggle');
            if (actionButtonToggle) actionButtonToggle.title = t.btn_tooltip;

            const operatorToggle = document.getElementById('operatorToggle');
            if (operatorToggle) operatorToggle.title = t.op_tooltip;

            const resetBtn = document.querySelector('.reset-btn');
            if (resetBtn) resetBtn.title = t.reset;

            const playBtn = document.querySelector('.play-btn');
            if (playBtn) playBtn.title = t.run;

            const importBtn = document.querySelector('button[onclick*="importInput"]');
            if (importBtn) importBtn.title = t.import;

            const exportBtn = document.querySelector('button[onclick="exportWorkspace()"]');
            if (exportBtn) exportBtn.title = t.export;

            const zoomInBtn = document.querySelector('button[onclick="zoomIn()"]');
            if (zoomInBtn) zoomInBtn.title = t.zoom_in;

            const zoomOutBtn = document.querySelector('button[onclick="zoomOut()"]');
            if (zoomOutBtn) zoomOutBtn.title = t.zoom_out;

            const resetViewBtn = document.querySelector('button[onclick="resetView()"]');
            if (resetViewBtn) resetViewBtn.title = t.reset_view;

            // Update Device Modal Texts
            const modalTitle = document.getElementById('deviceModalTitle');
            if (modalTitle) modalTitle.textContent = t.modal_title;

            const scanBtn = document.getElementById('scanDeviceBtn');
            if (scanBtn) scanBtn.textContent = t.scan_btn;

            const thName = document.getElementById('thDeviceName');
            if (thName) thName.textContent = t.tbl_name;

            const thId = document.getElementById('thDeviceId');
            if (thId) thId.textContent = t.tbl_id;

            const thStatus = document.getElementById('thDeviceStatus');
            if (thStatus) thStatus.textContent = t.tbl_status;

            const thAction = document.getElementById('thDeviceAction');
            if (thAction) thAction.textContent = t.tbl_action;

            const noDeviceMsg = document.getElementById('noDeviceMsg');
            if (noDeviceMsg) noDeviceMsg.textContent = t.no_device;

            const scanStatus = document.getElementById('scanStatus');
            if (scanStatus) scanStatus.textContent = t.scan_status;

            // Update Remove Device Modal Translations
            const removeDeviceTitle = document.getElementById('removeDeviceModalTitle');
            if (removeDeviceTitle) removeDeviceTitle.textContent = t.confirm_remove_device;

            const removeDeviceCancelBtn = document.getElementById('removeDeviceCancelBtn');
            if (removeDeviceCancelBtn) removeDeviceCancelBtn.textContent = t.btn_cancel;

            const removeDeviceConfirmBtn = document.getElementById('removeDeviceConfirmBtn');
            if (removeDeviceConfirmBtn) removeDeviceConfirmBtn.textContent = t.btn_remove;

            // Refresh devices table if open to update translations
            updateDevicesTable();

            // Update Reset Modal Translations
            const resetTitle = document.getElementById('resetModalTitle');
            if (resetTitle) resetTitle.textContent = t.modal_reset_title;

            // Populate list from split string
            const resetList = document.getElementById('resetModalList');
            if (resetList && t.modal_reset_list) {
                resetList.innerHTML = t.modal_reset_list.split('|').map(item => `<li>${item}</li>`).join('');
            }

            const resetCancel = document.getElementById('resetModalCancelBtn');
            if (resetCancel) resetCancel.textContent = t.btn_cancel;

            const resetConfirm = document.getElementById('resetModalConfirmBtn');
            if (resetConfirm) resetConfirm.textContent = t.btn_reset;

            const deleteBlockBtn = document.getElementById('deleteBlockBtn');
            if (deleteBlockBtn) {
                deleteBlockBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="#FFFFFF"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>`;
            }

            // Update RGB panel labels
            const panelLedsLabel = document.getElementById('panelLedsLabel');
            if (panelLedsLabel) panelLedsLabel.textContent = t.panel_leds;

            const panelNumbersLabel = document.getElementById('panelNumbersLabel');
            if (panelNumbersLabel) panelNumbersLabel.textContent = t.panel_numbers;

            const panelButtonsLabel = document.getElementById('panelButtonsLabel');
            if (panelButtonsLabel) panelButtonsLabel.textContent = t.panel_buttons;

            // Specific Device Modal Translations
            const addSpecificBtn = document.getElementById('addSpecificBtn');
            if (addSpecificBtn) addSpecificBtn.textContent = t.add_specific_btn;

            const specificModalTitle = document.getElementById('specificModalTitle');
            if (specificModalTitle) specificModalTitle.textContent = t.specific_modal_title;

            const specificLabelController = document.getElementById('specificLabelController');
            if (specificLabelController) specificLabelController.textContent = t.specific_type_controller;

            const specificLabelSingleMotor = document.getElementById('specificLabelSingleMotor');
            if (specificLabelSingleMotor) specificLabelSingleMotor.textContent = t.specific_type_single_motor;

            // Update Blockly Messages
            if (typeof Blockly !== 'undefined') {
                Blockly.Msg.BLOCK_START = t.block_start;

                Blockly.Msg.BLOCK_WAIT_PRE = t.block_wait_pre;
                Blockly.Msg.BLOCK_WAIT_POST = t.block_wait_post;

                Blockly.Msg.BLOCK_REPEAT_PRE = t.block_repeat_pre;
                Blockly.Msg.BLOCK_REPEAT_PRE = t.block_repeat_pre;
                Blockly.Msg.BLOCK_REPEAT_POST = t.block_repeat_post;

                Blockly.Msg.BLOCK_RANDOM_PRE = t.block_random_pre;
                Blockly.Msg.BLOCK_RANDOM_MID = t.block_random_mid;

                Blockly.Msg.BLOCK_FOREVER = t.block_forever;
                Blockly.Msg.BLOCK_IF = t.block_if;
                Blockly.Msg.BLOCK_THEN = t.block_then;
                Blockly.Msg.BLOCK_ELSE = t.block_else;

                Blockly.Msg.BLOCK_WAIT_UNTIL_PRE = t.block_wait_until_pre;
                Blockly.Msg.BLOCK_WAIT_UNTIL_POST = t.block_wait_until_post;

                Blockly.Msg.BLOCK_REPEAT_UNTIL_PRE = t.block_repeat_until_pre;
                Blockly.Msg.BLOCK_REPEAT_UNTIL_POST = t.block_repeat_until_post;

                Blockly.Msg.BLOCK_WHEN_PRE = t.block_when_pre;
                Blockly.Msg.BLOCK_WHEN_POST = t.block_when_post;
                Blockly.Msg.BLOCK_MESSAGE_PRE = t.block_message_pre;
                Blockly.Msg.BLOCK_MESSAGE_POST = t.block_message_post;
                Blockly.Msg.BLOCK_SEND_MOBILE_PRE = t.block_send_mobile_pre;
                Blockly.Msg.BLOCK_SEND_MOBILE_POST = t.block_send_mobile_post;

                Blockly.Msg.BLOCK_LIGHT_GET_PRE = t.block_light_get_pre;
                Blockly.Msg.BLOCK_LIGHT_GET_POST = t.block_light_get_post;

                Blockly.Msg.BLOCK_RED_ON = t.block_red_light_on;
                Blockly.Msg.BLOCK_RED_OFF = t.block_red_light_off;
                Blockly.Msg.BLOCK_GREEN_ON = t.block_green_light_on;
                Blockly.Msg.BLOCK_GREEN_OFF = t.block_green_light_off;
                Blockly.Msg.BLOCK_BLUE_ON = t.block_blue_light_on;
                Blockly.Msg.BLOCK_BLUE_OFF = t.block_blue_light_off;

                Blockly.Msg.BLOCK_RED_NUM = t.block_red_num;
                Blockly.Msg.BLOCK_GREEN_NUM = t.block_green_num;
                Blockly.Msg.BLOCK_BLUE_NUM = t.block_blue_num;
                Blockly.Msg.BLOCK_RED_GET = t.block_red_get;
                Blockly.Msg.BLOCK_GREEN_GET = t.block_green_get;
                Blockly.Msg.BLOCK_BLUE_GET = t.block_blue_get;

                Blockly.Msg.BLOCK_RED_BTN_GET = t.block_rgb_red_btn_get;
                Blockly.Msg.BLOCK_GREEN_BTN_GET = t.block_rgb_green_btn_get;
                Blockly.Msg.BLOCK_BLUE_BTN_GET = t.block_rgb_blue_btn_get;

                Blockly.Msg.BLOCK_LOGIC_AND = t.block_logic_and;
                Blockly.Msg.BLOCK_LOGIC_OR = t.block_logic_or;
                Blockly.Msg.BLOCK_LOGIC_NOT = t.block_logic_not;
            }

            // Refresh Toolboxes if active
            if (typeof showStartToolbox !== 'undefined') {
                if (currentToolboxMode === 'start') showStartToolbox();
                else if (currentToolboxMode === 'control') showControlToolbox();
                else if (currentToolboxMode === 'action_led') showActionLedToolbox();
                else if (currentToolboxMode === 'action_num') showActionNumToolbox();
                else if (currentToolboxMode === 'action_button') showActionButtonToolbox();
                else if (currentToolboxMode === 'operator') showOperatorToolbox();

                if (workspace) {
                    const xml = Blockly.Xml.workspaceToDom(workspace);
                    workspace.clear();
                    Blockly.Xml.domToWorkspace(xml, workspace);
                }
            }
        }

        function updateControllerVisual() {
            const leftValue = controllerState.leftValue;
            const rightValue = controllerState.rightValue;

            const leftPercent = calculateLeverPercent(leftValue);
            const rightPercent = calculateLeverPercent(rightValue);

            // controllerState'e y√ºzdelikleri kaydet
            controllerState.leftPercent = Math.round(leftPercent);
            controllerState.rightPercent = Math.round(rightPercent);

            // Sol kol
            const leftFill = document.getElementById('leftLeverFill');
            const leftValueEl = document.getElementById('leftLeverValue');
            if (leftFill && leftValueEl) {
                leftFill.style.height = Math.round(leftPercent) + '%';
                leftValueEl.textContent = Math.round(leftPercent) + '%';
            }

            // Saƒü kol
            const rightFill = document.getElementById('rightLeverFill');
            const rightValueEl = document.getElementById('rightLeverValue');
            if (rightFill && rightValueEl) {
                rightFill.style.height = Math.round(rightPercent) + '%';
                rightValueEl.textContent = Math.round(rightPercent) + '%';
            }
        }

        function showControllerDisplay(deviceName, deviceColor) {
            // hideMotorDisplay(); // ARTIK Gƒ∞ZLEMƒ∞YORUZ - Side by side
            const display = document.getElementById('controllerDisplay');
            const header = document.getElementById('controllerHeader');

            if (display) {
                display.classList.add('active');
            }

            if (header) {
                header.textContent = deviceName || 'Controller';
                header.style.background = deviceColor || '#4C97FF';
            }
        }

        function hideControllerDisplay() {
            const display = document.getElementById('controllerDisplay');
            if (display) {
                display.classList.remove('active');
            }
        }

        function showMotorDisplay(device, color) {
            // hideControllerDisplay(); // ARTIK Gƒ∞ZLEMƒ∞YORUZ - Side by side
            const display = document.getElementById('motorDisplay');
            const header = document.getElementById('motorHeader');
            const info = document.getElementById('motorAngleInfo');
            const shaft = document.getElementById('motorShaft');

            if (display && header) {
                header.style.background = color || '#4ecca3';
                header.textContent = device.name || 'Single Motor';
                display.classList.add('active');

                // Reset visual
                if (shaft) shaft.style.transform = `rotate(0deg)`;
                if (info) info.innerText = "0¬∞";
            }
        }

        function hideMotorDisplay() {
            const display = document.getElementById('motorDisplay');
            if (display) display.classList.remove('active');
        }

        // ===== MOTOR ANGLE MONITORING (PCAP Analizi Tabanlƒ±) =====
        // Motor notification verisi formatƒ±:
        // Payload[7] = mode byte (0x00=idle, 0x01=moving, 0x07=holding)
        // Payload[8-9] = Anlƒ±k a√ßƒ± (little-endian signed 16-bit)
        // Payload[13-14] = Hedef a√ßƒ± (little-endian signed 16-bit)

        async function startMotorAngleMonitoring(device, notifyChar, deviceId, deviceColor) {
            console.log('‚öôÔ∏è Motor a√ßƒ± monitoring ba≈ülatƒ±lƒ±yor...');

            activeMotorDevice = device;
            activeMotorCharacteristic = notifyChar;
            motorState.deviceId = deviceId;
            motorMonitoringActive = true;

            try {
                // Notification'larƒ± ba≈ülat
                await notifyChar.startNotifications();
                console.log('‚úÖ Motor notifications ba≈ülatƒ±ldƒ±');

                // Event listener ekle
                notifyChar.addEventListener('characteristicvaluechanged', handleMotorNotification);

                console.log('‚úÖ Motor angle monitoring aktif!');

            } catch (err) {
                console.error('‚ùå Motor notification ba≈ülatma hatasƒ±:', err);
                motorMonitoringActive = false;
            }
        }

        function handleMotorNotification(event) {
            const value = event.target.value;

            // Minimum byte gereksinimi
            if (value.byteLength < 4) {
                return;
            }

            // RAW HEX DUMP (Debugging i√ßin)
            const bytes = new Uint8Array(value.buffer);
            const hexDump = [...bytes].map(b => b.toString(16).padStart(2, '0')).join(' ');

            // ƒ∞lk birka√ß paketi logla
            if (!handleMotorNotification.logCount) handleMotorNotification.logCount = 0;
            if (handleMotorNotification.logCount < 20) {
                console.log(`üì¶ Motor RAW [${value.byteLength} bytes]: ${hexDump}`);
                handleMotorNotification.logCount++;
            }

            let currentAngle = 0;
            let targetAngle = 0;
            let mode = 0;

            // PCAP ANALƒ∞Zƒ∞ sonucu (21 byte paket):
            // 90¬∞:  3c 12 00 00 5a 00 0a 01 07 [5a] 00 00 00 00 5a 00 00 00 11 01 ff
            // 240¬∞: 3c 12 00 00 5a 00 0a 01 07 [f0] 00 00 00 00 ef 00 00 00 11 01 ff
            // Index 9 = Mevcut a√ßƒ± (0x5a=90, 0xf0=240)
            // Index 14 = Hedef a√ßƒ± (yakla≈üƒ±k)
            // Index 8 = Mode byte (0x07 = holding)

            if (value.byteLength >= 15) {
                // Mode byte at index 8
                mode = value.getUint8(8);

                // A√ßƒ± index 9-10'da (little-endian int16 olarak deneyelim √∂nce)
                // Eƒüer 360'tan b√ºy√ºk deƒüerler varsa int16 kullan
                const angleInt16 = value.getInt16(9, true);
                const angleUint8 = value.getUint8(9);

                // 360'tan k√º√ß√ºkse uint8, b√ºy√ºkse int16 kullan
                if (Math.abs(angleInt16) > 360 && angleUint8 <= 255) {
                    // Muhtemelen tek byte
                    currentAngle = angleUint8;
                } else {
                    // int16 olarak dene
                    currentAngle = angleInt16;
                }

                // Hedef a√ßƒ± index 14-15
                if (value.byteLength >= 16) {
                    targetAngle = value.getInt16(14, true);
                    // Aynƒ± mantƒ±k
                    if (Math.abs(targetAngle) > 360) {
                        targetAngle = value.getUint8(14);
                    }
                }
            }
            // Daha kƒ±sa paketler i√ßin fallback
            else if (value.byteLength >= 10) {
                currentAngle = value.getUint8(9);
            }

            // State g√ºncelle
            const prevAngle = motorState.currentAngle;
            motorState.currentAngle = currentAngle;
            motorState.targetAngle = targetAngle;
            motorState.mode = mode;
            motorState.isMoving = (mode === 0x01);

            // Pil y√ºzdesini al (index 4)
            let batteryPercent = 0;
            if (value.byteLength >= 5) {
                batteryPercent = value.getUint8(4);
                // 0-100 arasƒ±na normalize et (bazƒ± cihazlar farklƒ± aralƒ±k kullanabilir)
                if (batteryPercent > 100) {
                    // Belki 0-255 aralƒ±ƒüƒ±nda, y√ºzdeye √ßevir
                    batteryPercent = Math.round((batteryPercent / 255) * 100);
                }
                motorState.battery = batteryPercent;
            }

            // G√∂rsel g√ºncelleme (throttled)
            const now = Date.now();
            if (now - motorLastVisualUpdate >= MOTOR_VISUAL_UPDATE_INTERVAL) {
                motorLastVisualUpdate = now;
                updateMotorAngleDisplay(currentAngle);

                // Pil g√∂stergesini g√ºncelle
                const batteryEl = document.getElementById('motorBatteryPercent');
                const batteryFill = document.getElementById('motorBatteryFill');
                if (batteryEl) {
                    batteryEl.textContent = `${batteryPercent}%`;

                    // Pil doluluk g√∂stergesini g√ºncelle (max geni≈ülik: 14px)
                    if (batteryFill) {
                        const fillWidth = Math.round((batteryPercent / 100) * 14);
                        batteryFill.setAttribute('width', fillWidth);
                    }

                    // Pil d√º≈ü√ºkse rengi deƒüi≈ütir
                    if (batteryPercent < 20) {
                        batteryEl.parentElement.style.color = '#e03131';
                    } else if (batteryPercent < 50) {
                        batteryEl.parentElement.style.color = '#fab005';
                    } else {
                        batteryEl.parentElement.style.color = '#37b24d';
                    }
                }
            }

            // Debug log (sadece deƒüi≈üiklik varsa)
            if (Math.abs(prevAngle - currentAngle) > 1) {
                console.log(`‚öôÔ∏è Motor: ${currentAngle}¬∞ (hedef: ${targetAngle}¬∞, mode: 0x${mode.toString(16)})`);
            }
        }

        function updateMotorAngleDisplay(angle) {
            const shaft = document.getElementById('motorShaft');
            const info = document.getElementById('motorAngleInfo');

            if (shaft) {
                // G√∂rsel d√∂n√º≈ü i√ßin tam a√ßƒ±yƒ± kullanabiliriz (animasyon varsa d√ºzg√ºn d√∂ner)
                shaft.style.transform = `rotate(${angle}deg)`;
            }

            if (info) {
                // Metin g√∂sterimi i√ßin 0-359 arasƒ±na normalize et
                // ((angle % 360) + 360) % 360 form√ºl√º negatif sayƒ±larƒ± da doƒüru i≈üler
                const normalizedAngle = Math.round(((angle % 360) + 360) % 360);
                info.textContent = `${normalizedAngle}¬∞`;
            }
        }

        function stopMotorAngleMonitoring() {
            if (activeMotorCharacteristic) {
                try {
                    activeMotorCharacteristic.removeEventListener('characteristicvaluechanged', handleMotorNotification);
                    activeMotorCharacteristic.stopNotifications();
                } catch (e) {
                    console.log('Motor notification durdurma hatasƒ±:', e);
                }
            }

            motorMonitoringActive = false;
            activeMotorDevice = null;
            activeMotorCharacteristic = null;
            motorState.deviceId = null;

            console.log('‚öôÔ∏è Motor angle monitoring durduruldu');
        }

        // Motor a√ßƒ±sƒ±nƒ± al (bloklar i√ßin)
        function getMotorAngle(deviceId) {
            if (motorState.deviceId === deviceId) {
                return motorState.currentAngle;
            }
            return 0;
        }

        // Global'e ekle
        window.getMotorAngle = getMotorAngle;
        window.motorState = motorState;

        // RGB Display g√ºncelleme fonksiyonlarƒ±
        function updateRGBDisplay() {
            const redLed = document.getElementById('rgbRedLed');
            const greenLed = document.getElementById('rgbGreenLed');
            const blueLed = document.getElementById('rgbBlueLed');

            if (redLed) {
                redLed.classList.toggle('active', rgbLedState.red);
            }
            if (greenLed) {
                greenLed.classList.toggle('active', rgbLedState.green);
            }
            if (blueLed) {
                blueLed.classList.toggle('active', rgbLedState.blue);
            }
        }

        function updateRGBNumberDisplay() {
            const redNum = document.getElementById('rgbRedNum');
            const greenNum = document.getElementById('rgbGreenNum');
            const blueNum = document.getElementById('rgbBlueNum');

            if (redNum) redNum.textContent = rgbNumberState.red;
            if (greenNum) greenNum.textContent = rgbNumberState.green;
            if (blueNum) blueNum.textContent = rgbNumberState.blue;
        }

        // T√ºm a√ßƒ±k pop-up panelleri kapatƒ±r
        function closeAllPopups() {
            closeNumberPanel();
            closeAnglePanel();
            closeMessagePanel();
        }

        // Custom Angle Field (A√ßƒ± se√ßici)
        class CustomAngleField extends Blockly.FieldNumber {
            showEditor_() {
                closeAllPopups(); // √ñnce diƒüerlerini kapat
                const fieldRect = this.getScaledBBox();
                const panel = document.getElementById('anglePanel');

                currentAngle = parseInt(this.getValue()) || 0;
                currentAngleField = this;

                updateAngleDisplay();

                panel.style.left = (fieldRect.right + 10) + 'px';
                panel.style.top = fieldRect.top + 'px';
                panel.classList.add('active');

                // A√ßƒ± dairesi interaksiyonunu kur
                setTimeout(() => {
                    setupAngleCircleInteraction();
                }, 50);

                document.addEventListener('click', closeAnglePanelOnClickOutside);
            }
        }

        // Custom Message Field with Dropdown
        class CustomMessageField extends Blockly.FieldDropdown {
            constructor(value) {
                // Etiketin sonuna bo≈üluk ekle ki ok i≈üareti √ºst√ºne binmesin
                const options = messages.map(m => [m + '   ', m]);
                options.push(['‚ûï Yeni mesaj...', 'NEW']);
                super(options);
                this.setValue(value || messages[0]);
            }

            doValueUpdate_(newValue) {
                super.doValueUpdate_(newValue);

                // NEW se√ßilirse panel a√ß
                if (newValue === 'NEW') {
                    setTimeout(() => {
                        showMessagePanel(this);
                    }, 50);
                    return;
                }
            }

            updateOptions() {
                const currentValue = this.getValue();
                // Etiketin sonuna bo≈üluk ekle ki ok i≈üareti √ºst√ºne binmesin
                const options = messages.map(m => [m + '   ', m]);
                options.push(['‚ûï Yeni mesaj...', 'NEW']);
                this.menuGenerator_ = options;

                // Eƒüer mevcut deƒüer listede yoksa, ilk mesajƒ± se√ß
                if (currentValue === 'NEW' || !messages.includes(currentValue)) {
                    this.setValue(messages[0]);
                }
            }
        }

        function showMessagePanel(field) {
            closeAllPopups(); // √ñnce diƒüerlerini kapat
            currentMessageField = field;
            const panel = document.getElementById('messagePanel');
            const input = document.getElementById('messageInput');

            // Bloƒüun pozisyonunu al
            const block = field.getSourceBlock();
            const blockSvg = block.getSvgRoot();
            const rect = blockSvg.getBoundingClientRect();

            panel.style.left = (rect.right + 20) + 'px';
            panel.style.top = rect.top + 'px';
            panel.classList.add('active');

            input.value = '';
            input.focus();

            // Enter tu≈üu ile kaydet
            input.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    saveMessage();
                } else if (e.key === 'Escape') {
                    closeMessagePanel();
                }
            };

            document.addEventListener('click', closeMessagePanelOnClickOutside);
        }

        function closeMessagePanelOnClickOutside(e) {
            const panel = document.getElementById('messagePanel');
            if (!panel.contains(e.target) && !e.target.closest('.blocklyDropDownDiv')) {
                closeMessagePanel();
            }
        }

        function saveMessage() {
            const input = document.getElementById('messageInput');
            const newMessage = input.value.trim();

            if (newMessage && newMessage !== 'NEW') {
                if (!messages.includes(newMessage)) {
                    messages.push(newMessage);
                    console.log('Yeni mesaj eklendi:', newMessage);
                }

                if (currentMessageField) {
                    // T√ºm mesaj field'larƒ±nƒ± g√ºncelle
                    workspace.getAllBlocks().forEach(block => {
                        ['MESSAGE'].forEach(fieldName => {
                            const field = block.getField(fieldName);
                            if (field && field instanceof CustomMessageField) {
                                field.updateOptions();
                            }
                        });
                    });

                    currentMessageField.setValue(newMessage);
                    currentMessageField = null;
                }
            }

            closeMessagePanel();
        }

        function closeMessagePanel() {
            const panel = document.getElementById('messagePanel');
            panel.classList.remove('active');
            document.removeEventListener('click', closeMessagePanelOnClickOutside);

            // Eƒüer yeni mesaj se√ßilmediyse, ilk mesaja d√∂n
            if (currentMessageField && currentMessageField.getValue() === 'NEW') {
                currentMessageField.setValue(messages[0]);
            }

            currentMessageField = null;
        }

        // Custom Number Field with Popup
        class CustomNumberField extends Blockly.FieldNumber {
            showEditor_() {
                closeAllPopups(); // √ñnce diƒüerlerini kapat
                const fieldRect = this.getScaledBBox();
                const panel = document.getElementById('numberPanel');
                const display = document.getElementById('numberDisplay');

                currentValue = parseInt(this.getValue()) || 1;
                currentNumberField = this;
                minValue = this.min_ || 1;
                maxValue = this.max_ || 100;

                display.textContent = currentValue;

                panel.style.left = (fieldRect.right + 10) + 'px';
                panel.style.top = fieldRect.top + 'px';
                panel.classList.add('active');

                document.addEventListener('click', closeNumberPanelOnClickOutside);
            }
        }

        function closeNumberPanelOnClickOutside(e) {
            const panel = document.getElementById('numberPanel');
            if (!panel.contains(e.target) && !e.target.closest('.blocklyEditableText')) {
                closeNumberPanel();
            }
        }

        function closeNumberPanel() {
            const panel = document.getElementById('numberPanel');
            panel.classList.remove('active');
            document.removeEventListener('click', closeNumberPanelOnClickOutside);

            if (currentNumberField) {
                currentNumberField.setValue(currentValue);
                currentNumberField = null;
            }
        }

        function incrementNumber() {
            if (currentValue < maxValue) {
                currentValue++;
                updateDisplay();
            }
        }

        function decrementNumber() {
            if (currentValue > minValue) {
                currentValue--;
                updateDisplay();
            }
        }

        // Basƒ±lƒ± tutma i√ßin deƒüi≈ükenler
        let holdTimer = null;
        let holdInterval = null;
        let isHolding = false;

        // Basƒ±lƒ± tutma fonksiyonlarƒ±
        function startHold(incrementFunc) {
            isHolding = false;

            // ƒ∞lk tƒ±klama - hemen √ßalƒ±≈ütƒ±r
            incrementFunc();

            // 500ms basƒ±lƒ± tutulursa hƒ±zlƒ± mod ba≈ülat
            holdTimer = setTimeout(() => {
                isHolding = true;
                holdInterval = setInterval(() => {
                    incrementFunc();
                }, 100); // Her 100ms'de bir deƒüi≈üir
            }, 500);
        }

        function stopHold() {
            if (holdTimer) {
                clearTimeout(holdTimer);
                holdTimer = null;
            }
            if (holdInterval) {
                clearInterval(holdInterval);
                holdInterval = null;
            }
            isHolding = false;
        }

        function updateDisplay() {
            document.getElementById('numberDisplay').textContent = currentValue;
        }

        // Event listener'larƒ± sayfa y√ºklendiƒüinde ekle
        window.addEventListener('load', () => {
            const incrementBtn = document.getElementById('incrementBtn');
            const decrementBtn = document.getElementById('decrementBtn');

            if (incrementBtn && decrementBtn) {
                // Artƒ± butonu
                incrementBtn.addEventListener('mousedown', () => startHold(incrementNumber));
                incrementBtn.addEventListener('mouseup', stopHold);
                incrementBtn.addEventListener('mouseleave', stopHold);
                incrementBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startHold(incrementNumber);
                });
                incrementBtn.addEventListener('touchend', stopHold);
                incrementBtn.addEventListener('touchcancel', stopHold);

                // Eksi butonu
                decrementBtn.addEventListener('mousedown', () => startHold(decrementNumber));
                decrementBtn.addEventListener('mouseup', stopHold);
                decrementBtn.addEventListener('mouseleave', stopHold);
                decrementBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startHold(decrementNumber);
                });
                decrementBtn.addEventListener('touchend', stopHold);
                decrementBtn.addEventListener('touchcancel', stopHold);
            }

            // A√ßƒ± se√ßici butonlarƒ±
            const angleIncrementBtn = document.getElementById('angleIncrementBtn');
            const angleDecrementBtn = document.getElementById('angleDecrementBtn');

            if (angleIncrementBtn && angleDecrementBtn) {
                // Artƒ± butonu
                angleIncrementBtn.addEventListener('mousedown', () => startHold(incrementAngle));
                angleIncrementBtn.addEventListener('mouseup', stopHold);
                angleIncrementBtn.addEventListener('mouseleave', stopHold);
                angleIncrementBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startHold(incrementAngle);
                });
                angleIncrementBtn.addEventListener('touchend', stopHold);
                angleIncrementBtn.addEventListener('touchcancel', stopHold);

                // Eksi butonu
                angleDecrementBtn.addEventListener('mousedown', () => startHold(decrementAngle));
                angleDecrementBtn.addEventListener('mouseup', stopHold);
                angleDecrementBtn.addEventListener('mouseleave', stopHold);
                angleDecrementBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startHold(decrementAngle);
                });
                angleDecrementBtn.addEventListener('touchend', stopHold);
                angleDecrementBtn.addEventListener('touchcancel', stopHold);
            }

            // A√ßƒ± i≈üaret√ßilerini olu≈ütur
            createAngleMarkers();

            // A√ßƒ± dairesine tƒ±klama/s√ºr√ºkleme √∂zelliƒüi ekle
            setupAngleCircleInteraction();
        });

        // A√ßƒ± dairesi etkile≈üimi
        let isDraggingAngle = false;

        function setupAngleCircleInteraction() {
            const circle = document.getElementById('angleCircle');
            if (!circle) {
                // Circle hen√ºz yok, daha sonra eklenecek
                return;
            }

            // Mouse olaylarƒ±
            circle.addEventListener('mousedown', (e) => {
                isDraggingAngle = true;
                updateAngleFromMouse(e);
            });

            document.addEventListener('mousemove', (e) => {
                if (isDraggingAngle) {
                    updateAngleFromMouse(e);
                }
            });

            document.addEventListener('mouseup', () => {
                isDraggingAngle = false;
            });

            // Touch olaylarƒ±
            circle.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isDraggingAngle = true;
                updateAngleFromTouch(e);
            });

            document.addEventListener('touchmove', (e) => {
                if (isDraggingAngle) {
                    e.preventDefault();
                    updateAngleFromTouch(e);
                }
            });

            document.addEventListener('touchend', () => {
                isDraggingAngle = false;
            });
        }

        function updateAngleFromMouse(e) {
            const circle = document.getElementById('angleCircle');
            if (!circle) return;

            const rect = circle.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const dx = e.clientX - centerX;
            const dy = e.clientY - centerY;

            calculateAngleFromCoordinates(dx, dy);
        }

        function updateAngleFromTouch(e) {
            const circle = document.getElementById('angleCircle');
            if (!circle || e.touches.length === 0) return;

            const rect = circle.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const touch = e.touches[0];
            const dx = touch.clientX - centerX;
            const dy = touch.clientY - centerY;

            calculateAngleFromCoordinates(dx, dy);
        }

        function calculateAngleFromCoordinates(dx, dy) {
            // A√ßƒ±yƒ± hesapla (radyan cinsinden)
            let angleRad = Math.atan2(dy, dx);

            // Radyandan dereceye √ßevir
            let angleDeg = angleRad * 180 / Math.PI;

            // 0-360 aralƒ±ƒüƒ±na √ßevir (saat 3'ten ba≈ülayarak saat y√∂n√ºnde)
            // atan2 saat 3'ten ba≈ülar, biz saat 12'den ba≈ülatmak istiyoruz
            angleDeg = (angleDeg + 90) % 360;
            if (angleDeg < 0) angleDeg += 360;

            // 1'in katƒ±na yuvarla
            currentAngle = Math.round(angleDeg);
            if (currentAngle === 360) currentAngle = 0;

            updateAngleDisplay();
        }

        // A√ßƒ± se√ßici fonksiyonlarƒ±
        function incrementAngle() {
            currentAngle = (currentAngle + 1) % 360;
            updateAngleDisplay();
        }

        function decrementAngle() {
            currentAngle = (currentAngle - 1 + 360) % 360;
            updateAngleDisplay();
        }

        function updateAngleDisplay() {
            const indicator = document.getElementById('angleIndicator');
            const degrees = document.getElementById('angleDegrees');

            indicator.style.transform = `translate(-50%, -100%) rotate(${currentAngle}deg)`;
            degrees.textContent = `${currentAngle}¬∞`;
        }

        function createAngleMarkers() {
            const markersContainer = document.getElementById('angleMarkers');
            if (!markersContainer) return;

            markersContainer.innerHTML = '';

            // Her 30 derece i√ßin i≈üaret (0, 30, 60, 90, ...)
            for (let angle = 0; angle < 360; angle += 30) {
                const marker = document.createElement('div');
                marker.className = 'angle-marker major';
                marker.style.transform = `translate(-50%, -100%) rotate(${angle}deg)`;
                markersContainer.appendChild(marker);

                // Sadece ana a√ßƒ±larda (0, 90, 180, 270) etiket ekle
                if (angle % 90 === 0) {
                    const label = document.createElement('div');
                    label.className = 'angle-marker-label';
                    label.textContent = angle + '¬∞';

                    // Etiketin pozisyonunu hesapla - daha da i√ße alƒ±ndƒ±
                    const radius = 60; // 72'den 60'a d√º≈ü√ºrd√ºk
                    const rad = (angle - 90) * Math.PI / 180;
                    const x = 50 + radius * Math.cos(rad);
                    const y = 50 + radius * Math.sin(rad);

                    label.style.left = x + '%';
                    label.style.top = y + '%';
                    label.style.transform = 'translate(-50%, -50%)';

                    markersContainer.appendChild(label);
                }
            }

            // Her 15 derece i√ßin k√º√ß√ºk i≈üaret (15, 45, 75, ...)
            for (let angle = 15; angle < 360; angle += 30) {
                const marker = document.createElement('div');
                marker.className = 'angle-marker';
                marker.style.transform = `translate(-50%, -100%) rotate(${angle}deg)`;
                markersContainer.appendChild(marker);
            }
        }

        function closeAnglePanelOnClickOutside(e) {
            const panel = document.getElementById('anglePanel');
            if (!panel.contains(e.target) && !e.target.closest('.blocklyEditableText')) {
                closeAnglePanel();
            }
        }

        function closeAnglePanel() {
            const panel = document.getElementById('anglePanel');
            panel.classList.remove('active');
            document.removeEventListener('click', closeAnglePanelOnClickOutside);

            if (currentAngleField) {
                currentAngleField.setValue(currentAngle);
                currentAngleField = null;
            }
        }

        // Event bloklarƒ±
        Blockly.Blocks['start'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_START, 20, 20, "*"))
                    .appendField(Blockly.Msg.BLOCK_START);
                this.setNextStatement(true, null);
                this.setColour("#FFBF00");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['when_condition'] = {
            init: function () {
                this.appendValueInput("CONDITION")
                    .setCheck("Boolean")
                    .appendField(new Blockly.FieldImage(ICON_BOLT, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_WHEN_PRE);
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_WHEN_POST);
                this.setInputsInline(true);
                this.setNextStatement(true, null);
                this.setColour("#FFBF00");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['when_message_received'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_MSG_IN, 20, 20, "*"))
                    .appendField(Blockly.Msg.BLOCK_MESSAGE_PRE)
                    .appendField(new CustomMessageField('message1'), "MESSAGE")
                    .appendField(Blockly.Msg.BLOCK_MESSAGE_POST);
                this.setNextStatement(true, null);
                this.setColour("#FFBF00");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['send_message'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_MSG_OUT, 20, 20, "*"))
                    .appendField(Blockly.Msg.BLOCK_SEND_MOBILE_PRE)
                    .appendField(new CustomMessageField('message1'), "MESSAGE")
                    .appendField(Blockly.Msg.BLOCK_SEND_MOBILE_POST);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['forward'] = {
            init: function () {
                this.appendValueInput('STEPS')
                    .setCheck('Number')
                    .appendField("‚¨ÜÔ∏è");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FF8C1A");
                this.setInputsInline(true);
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['turn_right'] = {
            init: function () {
                this.appendValueInput('DEG')
                    .setCheck('Number')
                    .appendField("‚Üª");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FF8C1A");
                this.setInputsInline(true);
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['turn_left'] = {
            init: function () {
                this.appendValueInput('DEG')
                    .setCheck('Number')
                    .appendField("‚Ü∫");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FF8C1A");
                this.setInputsInline(true);
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['repeat'] = {
            init: function () {
                this.appendValueInput('TIMES')
                    .setCheck('Number')
                    .appendField(new Blockly.FieldImage(ICON_REFRESH, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_REPEAT_PRE);
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_REPEAT_POST);
                this.appendStatementInput('DO');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setInputsInline(true);
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['wait'] = {
            init: function () {
                this.appendValueInput('SECONDS')
                    .setCheck('Number')
                    .appendField(new Blockly.FieldImage(ICON_STOP_HAND, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_WAIT_PRE);
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_WAIT_POST);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setInputsInline(true);
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['forever'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_INFINITY, 20, 20, "*"))
                    .appendField(Blockly.Msg.BLOCK_FOREVER);
                this.appendStatementInput('DO');
                this.setPreviousStatement(true, null);
                this.setColour("#FFAB19");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['if_then'] = {
            init: function () {
                this.appendValueInput('CONDITION')
                    .setCheck('Boolean')
                    .appendField(new Blockly.FieldImage(ICON_RHOMBUS, 16, 16, "*"))
                    .appendField(Blockly.Msg.BLOCK_IF);
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_THEN);
                this.appendStatementInput('DO');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['if_then_else'] = {
            init: function () {
                this.appendValueInput('CONDITION')
                    .setCheck('Boolean')
                    .appendField(new Blockly.FieldImage(ICON_RHOMBUS, 16, 16, "*"))
                    .appendField(Blockly.Msg.BLOCK_IF);
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_THEN);
                this.appendStatementInput('DO');
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_ELSE);
                this.appendStatementInput('ELSE');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['wait_until'] = {
            init: function () {
                this.appendValueInput('CONDITION')
                    .setCheck('Boolean')
                    .appendField(new Blockly.FieldImage(ICON_HOURGLASS, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_WAIT_UNTIL_PRE);
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_WAIT_UNTIL_POST);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['repeat_until'] = {
            init: function () {
                this.appendValueInput('CONDITION')
                    .setCheck('Boolean')
                    .appendField(new Blockly.FieldImage(ICON_REFRESH, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_REPEAT_UNTIL_PRE);
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_REPEAT_UNTIL_POST);
                this.appendStatementInput('DO');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['alarm'] = {
            init: function () {
                this.appendDummyInput().appendField("üîî");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#CF63CF");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['sound'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üîä")
                    .appendField(new CustomNumberField(300, 100, 1000), 'FREQ');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#CF63CF");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['light'] = {
            init: function () {
                this.appendDummyInput().appendField("üí°");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#0FBD8C");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['led_on'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üü¶")
                    .appendField(new CustomNumberField(90, 0, 255), 'VAL');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5CB1D6");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['led_off'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("‚¨õ")
                    .appendField(new CustomNumberField(90, 0, 255), 'VAL');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5CB1D6");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['smile'] = {
            init: function () {
                this.appendDummyInput().appendField("üòä");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FF6680");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // RGB LED Bloklarƒ±
        Blockly.Blocks['rgb_red_on'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_RED, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_RED_ON);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#ff6b6b");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_green_on'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_GREEN, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_GREEN_ON);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#51cf66");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_blue_on'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_BLUE, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_BLUE_ON);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4dabf7");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // RGB LED S√∂nd√ºr Bloklarƒ±
        Blockly.Blocks['rgb_red_off'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_WHITE, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_RED_OFF);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#ffb3b3");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_green_off'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_WHITE, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_GREEN_OFF);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#b3e0b3");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_blue_off'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_WHITE, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_BLUE_OFF);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#b3d9ff");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_red_num'] = {
            init: function () {
                this.appendValueInput('NUM')
                    .setCheck('Number')
                    .appendField(new Blockly.FieldImage(ICON_SQ_RED, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_RED_NUM);
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#ff6b6b");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_green_num'] = {
            init: function () {
                this.appendValueInput('NUM')
                    .setCheck('Number')
                    .appendField(new Blockly.FieldImage(ICON_SQ_GREEN, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_GREEN_NUM);
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#51cf66");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_blue_num'] = {
            init: function () {
                this.appendValueInput('NUM')
                    .setCheck('Number')
                    .appendField(new Blockly.FieldImage(ICON_SQ_BLUE, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_BLUE_NUM);
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4dabf7");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // RGB Sayƒ± Getir Bloklarƒ± (Yuvarlak ≈üekilli - Number output)
        Blockly.Blocks['rgb_red_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_SQ_RED, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_RED_GET);
                this.setOutput(true, "Number");
                this.setColour("#ff6b6b");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_green_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_SQ_GREEN, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_GREEN_GET);
                this.setOutput(true, "Number");
                this.setColour("#51cf66");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_blue_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_SQ_BLUE, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_BLUE_GET);
                this.setOutput(true, "Number");
                this.setColour("#4dabf7");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // RGB I≈üƒ±k Getir Bloklarƒ± (Altƒ±gen ≈üekilli - Boolean output)
        Blockly.Blocks['rgb_red_light_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_RED, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_LIGHT_GET_POST);
                this.setOutput(true, "Boolean");
                this.setColour("#ff6b6b");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_green_light_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_GREEN, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_LIGHT_GET_POST);
                this.setOutput(true, "Boolean");
                this.setColour("#51cf66");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_blue_light_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_BLUE, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_LIGHT_GET_POST);
                this.setOutput(true, "Boolean");
                this.setColour("#4dabf7");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // RGB Tu≈ü Getir Bloklarƒ± (Altƒ±gen ≈üekilli - Boolean output - √ú√ßgen ikonlu)
        Blockly.Blocks['rgb_red_button_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTEyIDJMMiAyMmgyMEwxMiAyeiIgZmlsbD0iI2NmMTMyMiIvPjwvc3ZnPg==", 24, 24, "*"))
                    .appendField(Blockly.Msg.BLOCK_RED_BTN_GET);
                this.setOutput(true, "Boolean");
                this.setColour("#ff6b6b");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_green_button_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTEyIDJMMiAyMmgyMEwxMiAyeiIgZmlsbD0iIzFhOTAzZSIvPjwvc3ZnPg==", 24, 24, "*"))
                    .appendField(Blockly.Msg.BLOCK_GREEN_BTN_GET);
                this.setOutput(true, "Boolean");
                this.setColour("#51cf66");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_blue_button_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTEyIDJMMiAyMmgyMEwxMiAyeiIgZmlsbD0iIzE5NzFjMiIvPjwvc3ZnPg==", 24, 24, "*"))
                    .appendField(Blockly.Msg.BLOCK_BLUE_BTN_GET);
                this.setOutput(true, "Boolean");
                this.setColour("#4dabf7");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Motor Bloklarƒ±
        // SVG Ikonlar (Base64 encoded)
        const DEVICE_ICONS = {
            'rotate': 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0id2hpdGUiPjxwYXRoIGQ9Ik0xMiA0VjFMNCA1bDQgNFY2YzMuMzEgMCA2IDIuNjkgNiA2IDAgMS4wMS0uMjUgMS45Ny0uNyAyLjhsMS40NiAxLjQ2QzE5LjU0IDE1LjAzIDIwIDEzLjU3IDIwIDEyYzAtNC40Mi0zLjU4LTgtOC04em0wIDE0Yy0zLjMxIDAtNi0yLjY5LTYtNiAwLTEuMDEuMjUtMS45Ny43LTIuOEw1LjI0IDcuNzRDNC40NiA4Ljk3IDQgMTAuNDMgNCAxMmMwIDQuNDIgMy41OCA4IDggOHYzbDQtNC00LTR2M3oiLz48L3N2Zz4=',
            'timer': 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0id2hpdGUiPjxwYXRoIGQ9Ik0xMS45OSAyQzYuNDcgMiAyIDYuNDggMiAxMnM0LjQ3IDEwIDkuOTkgMTBDMTcuNTIgMjIgMjIgMTcuNTIgMjIgMTJTMTcuNTIgMiAxMS45OSAyem0uMDEgMThjLTQuNDIgMC04LTMuNTgtOC04czMuNTgtOCA4LTggOCAzLjU4IDggOC0zLjU4IDgtOCA4em0uNS0xM0gxMXY2bDUuMjUgMy4xNS43NS0xLjIzLTQuNS0yLjY3eiIvPjwvc3ZnPg==',
            'speed': 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0id2hpdGUiPjxwYXRoIGQ9Ik03IDJ2MTFoM3Y5bDctMTJoLTRsNC04eiIvPjwvc3ZnPg==',
            'stop': 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0id2hpdGUiPjxwYXRoIGQ9Ik02IDZoMTJ2MTJINnoiLz48L3N2Zz4=',
            'target': 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0id2hpdGUiPjxwYXRoIGQ9Ik0xMiAyQzYuNDggMiAyIDYuNDggMiAxMnM0LjQ4IDEwIDEwIDEwIDEwLTQuNDggMTAtMTBTMTcuNTIgMiAxMiAyem0wIDE4Yy00LjQxIDAtOC0zLjU5LTgtOHMzLjU5LTggOC04IDggMy41OSA4IDgtMy41OSA4LTggOHptLTUtOGMwIDIuNzYgMi4yNCA1IDUgNXM1LTIuMjQgNS01LTIuMjQtNS01LTUgMi4yNC01IDUgNXoiLz48L3N2Zz4=',
            'play': 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0id2hpdGUiPjxwYXRoIGQ9Ik04IDV2MTRsMTEtN3oiLz48L3N2Zz4=',
            'pin': 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0id2hpdGUiPjxwYXRoIGQ9Ik0xMiAyQzguMSAyIDUgNS4xIDUgOWMwIDUuMiA3IDEzIDcgMTNzNy03LjggNy0xM2MwLTMuOS0zLjEtNy03LTd6bTAgOS41Yy0xLjQgMC0yLjUtMS4xLTIuNS0yLjVzMS4xLTIuNSAyLjUtMi41IDIuNSAxLjEgMi41IDIuNS0xLjEgMi41LTIuNSAyLjV6Ii8+PC9zdmc+'
        };
        Blockly.Blocks['motor_run_rotation'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(DEVICE_ICONS['rotate'], 16, 16, "*"))
                    .appendField("run")
                    .appendField(new Blockly.FieldDropdown([["‚Üª", "CW"], ["‚Ü∫", "CCW"]]), "DIRECTION")
                    .appendField("for")
                    .appendField(new CustomNumberField(1, 1, 100), 'ROTATIONS')
                    .appendField("rotations");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4ECDC4");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['motor_run_to_angle'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(DEVICE_ICONS['target'], 16, 16, "*"))
                    .appendField("run")
                    .appendField(new Blockly.FieldDropdown([["‚Üª", "CW"], ["‚Ü∫", "CCW"]]), "DIRECTION")
                    .appendField("to")
                    .appendField(new CustomAngleField(0, 0, 360), 'ANGLE')
                    .appendField("angle");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4ECDC4");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // YENƒ∞ BLOK: Mutlak pozisyon (0¬∞ referansƒ±na g√∂re)
        Blockly.Blocks['motor_go_to_position'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(DEVICE_ICONS['pin'], 16, 16, "*"))
                    .appendField("go to position ")
                    .appendField(new CustomAngleField(0, 0, 360), 'POSITION')
                    .appendField("¬∞");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4ECDC4");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['motor_start'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(DEVICE_ICONS['play'], 16, 16, "*"))
                    .appendField("start motor ")
                    .appendField(new Blockly.FieldDropdown([["‚Üª", "CW"], ["‚Ü∫", "CCW"]]), "DIRECTION");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4ECDC4");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['motor_stop'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(DEVICE_ICONS['stop'], 16, 16, "*"))
                    .appendField("stop motor");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4ECDC4");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Controller Bloklarƒ±
        Blockly.Blocks['when_lever_position'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üïπÔ∏è when")
                    .appendField(new Blockly.FieldDropdown([
                        ["left", "LEFT"],
                        ["right", "RIGHT"],
                        ["both", "BOTH"],
                        ["any", "ANY"]
                    ]), "LEVER")
                    .appendField("lever is")
                    .appendField(new Blockly.FieldDropdown([
                        ["released", "RELEASED"],
                        ["up", "UP"],
                        ["down", "DOWN"]
                    ]), "POSITION");
                this.setNextStatement(true, null);
                this.setColour("#45B7D1");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['lever_position'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üïπÔ∏è")
                    .appendField(new Blockly.FieldDropdown([
                        ["left", "LEFT"],
                        ["right", "RIGHT"],
                        ["both", "BOTH"],
                        ["any", "ANY"]
                    ]), "LEVER")
                    .appendField("lever is")
                    .appendField(new Blockly.FieldDropdown([
                        ["released", "RELEASED"],
                        ["up", "UP"],
                        ["down", "DOWN"]
                    ]), "POSITION");
                this.setOutput(true, "Boolean");
                this.setColour("#45B7D1");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Yeni: Lever angle/percent bloƒüu (0-100 arasƒ± deƒüer d√∂ner)
        Blockly.Blocks['lever_angle'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üïπÔ∏è")
                    .appendField(new Blockly.FieldDropdown([
                        ["left", "LEFT"],
                        ["right", "RIGHT"]
                    ]), "LEVER")
                    .appendField("lever angle");
                this.setOutput(true, "Number");
                this.setColour("#45B7D1");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Operat√∂r Bloklarƒ±
        Blockly.Blocks['math_arithmetic'] = {
            init: function () {
                this.appendValueInput('A')
                    .setCheck('Number');
                this.appendDummyInput()
                    .appendField(new Blockly.FieldDropdown([
                        ["+", "ADD"],
                        ["-", "MINUS"],
                        ["√ó", "MULTIPLY"],
                        ["√∑", "DIVIDE"],
                        ["^", "POWER"],
                        ["mod", "MOD"]
                    ]), "OP");
                this.appendValueInput('B')
                    .setCheck('Number');
                this.setOutput(true, 'Number');
                this.setInputsInline(true);
                this.setColour("#59C059");
            }
        };

        Blockly.Blocks['math_random'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_RANDOM_PRE);
                this.appendValueInput('FROM')
                    .setCheck('Number');
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_RANDOM_MID);
                this.appendValueInput('TO')
                    .setCheck('Number');
                this.setOutput(true, 'Number');
                this.setInputsInline(true);
                this.setColour("#59C059");
            }
        };

        Blockly.Blocks['logic_compare'] = {
            init: function () {
                this.appendValueInput('A')
                    .setCheck('Number');
                this.appendDummyInput()
                    .appendField(new Blockly.FieldDropdown([
                        [">", "GT"],
                        ["<", "LT"],
                        ["=", "EQ"],
                        ["‚â•", "GTE"],
                        ["‚â§", "LTE"]
                    ]), "OP");
                this.appendValueInput('B')
                    .setCheck('Number');
                this.setOutput(true, 'Boolean');
                this.setInputsInline(true);
                this.setColour("#5CB15C");
            }
        };

        Blockly.Blocks['logic_and'] = {
            init: function () {
                this.appendValueInput('A')
                    .setCheck('Boolean');
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_LOGIC_AND);
                this.appendValueInput('B')
                    .setCheck('Boolean');
                this.setOutput(true, 'Boolean');
                this.setInputsInline(true);
                this.setColour("#5CB15C");
            }
        };

        Blockly.Blocks['logic_or'] = {
            init: function () {
                this.appendValueInput('A')
                    .setCheck('Boolean');
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_LOGIC_OR);
                this.appendValueInput('B')
                    .setCheck('Boolean');
                this.setOutput(true, 'Boolean');
                this.setInputsInline(true);
                this.setColour("#5CB15C");
            }
        };

        Blockly.Blocks['logic_negate'] = {
            init: function () {
                this.appendValueInput('BOOL')
                    .setCheck('Boolean')
                    .appendField(Blockly.Msg.BLOCK_LOGIC_NOT);
                this.setOutput(true, 'Boolean');
                this.setColour("#5CB15C");
            }
        };

        // Sayƒ± bloƒüu (shadow bloklar i√ßin)
        Blockly.Blocks['math_number'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new CustomNumberField(0, -999, 999), 'NUM');
                this.setOutput(true, 'Number');
                this.setColour("#59C059");
            }
        };

        // Kod √ºretici
        Blockly.Python = new Blockly.Generator('Python');

        Blockly.Python['start'] = () => '# When play clicked\n';
        Blockly.Python['when_condition'] = (b) => {
            const condition = Blockly.Python.valueToCode(b, 'CONDITION', Blockly.Python.ORDER_NONE) || 'True';
            return `# When ${condition}\n`;
        };
        Blockly.Python['when_message_received'] = (b) => {
            const message = b.getFieldValue('MESSAGE');
            return `# When ${message} received\n`;
        };
        Blockly.Python['send_message'] = (b) => {
            const message = b.getFieldValue('MESSAGE');
            return `send_message("${message}")\n`;
        };
        Blockly.Python['forward'] = (b) => `forward(${b.getFieldValue('STEPS')})\n`;
        Blockly.Python['turn_right'] = (b) => `turn_right(${b.getFieldValue('DEG')})\n`;
        Blockly.Python['turn_left'] = (b) => `turn_left(${b.getFieldValue('DEG')})\n`;
        Blockly.Python['repeat'] = (b) => {
            const times = b.getFieldValue('TIMES');
            const branch = Blockly.Python.statementToCode(b, 'DO');
            return `for i in range(${times}):\n${branch}\n`;
        };
        Blockly.Python['wait'] = (b) => `time.sleep(${b.getFieldValue('SECONDS')})\n`;
        Blockly.Python['forever'] = (b) => {
            const branch = Blockly.Python.statementToCode(b, 'DO');
            return `while True:\n${branch}\n`;
        };
        Blockly.Python['if_then'] = (b) => {
            const condition = Blockly.Python.valueToCode(b, 'CONDITION', Blockly.Python.ORDER_NONE) || 'False';
            const branch = Blockly.Python.statementToCode(b, 'DO');
            return `if ${condition}:\n${branch}\n`;
        };
        Blockly.Python['if_then_else'] = (b) => {
            const condition = Blockly.Python.valueToCode(b, 'CONDITION', Blockly.Python.ORDER_NONE) || 'False';
            const branchDo = Blockly.Python.statementToCode(b, 'DO');
            const branchElse = Blockly.Python.statementToCode(b, 'ELSE');
            return `if ${condition}:\n${branchDo}else:\n${branchElse}\n`;
        };
        Blockly.Python['wait_until'] = (b) => {
            const condition = Blockly.Python.valueToCode(b, 'CONDITION', Blockly.Python.ORDER_NONE) || 'False';
            return `while not (${condition}):\n    time.sleep(0.1)\n`;
        };
        Blockly.Python['repeat_until'] = (b) => {
            const condition = Blockly.Python.valueToCode(b, 'CONDITION', Blockly.Python.ORDER_NONE) || 'False';
            const branch = Blockly.Python.statementToCode(b, 'DO');
            return `while not (${condition}):\n${branch}\n`;
        };
        Blockly.Python['alarm'] = () => 'alarm()\n';
        Blockly.Python['sound'] = (b) => `play_tone(${b.getFieldValue('FREQ')})\n`;
        Blockly.Python['light'] = () => 'light_on()\n';
        Blockly.Python['led_on'] = (b) => `led_on(${b.getFieldValue('VAL')})\n`;
        Blockly.Python['led_off'] = (b) => `led_off(${b.getFieldValue('VAL')})\n`;
        Blockly.Python['smile'] = () => 'show_smile()\n';
        Blockly.Python['rgb_red_on'] = () => 'rgb_red_on()\n';
        Blockly.Python['rgb_green_on'] = () => 'rgb_green_on()\n';
        Blockly.Python['rgb_blue_on'] = () => 'rgb_blue_on()\n';
        Blockly.Python['rgb_red_off'] = () => 'rgb_red_off()\n';
        Blockly.Python['rgb_green_off'] = () => 'rgb_green_off()\n';
        Blockly.Python['rgb_blue_off'] = () => 'rgb_blue_off()\n';
        Blockly.Python['rgb_red_num'] = (b) => {
            const num = Blockly.Python.valueToCode(b, 'NUM', Blockly.Python.ORDER_ATOMIC) || '0';
            return `rgb_red_num(${num})\n`;
        };
        Blockly.Python['rgb_green_num'] = (b) => {
            const num = Blockly.Python.valueToCode(b, 'NUM', Blockly.Python.ORDER_ATOMIC) || '0';
            return `rgb_green_num(${num})\n`;
        };
        Blockly.Python['rgb_blue_num'] = (b) => {
            const num = Blockly.Python.valueToCode(b, 'NUM', Blockly.Python.ORDER_ATOMIC) || '0';
            return `rgb_blue_num(${num})\n`;
        };
        Blockly.Python['rgb_red_get'] = () => ['rgb_red_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_green_get'] = () => ['rgb_green_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_blue_get'] = () => ['rgb_blue_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_red_light_get'] = () => ['rgb_red_light_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_green_light_get'] = () => ['rgb_green_light_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_blue_light_get'] = () => ['rgb_blue_light_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_red_button_get'] = () => ['rgb_red_button_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_green_button_get'] = () => ['rgb_green_button_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_blue_button_get'] = () => ['rgb_blue_button_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['motor_run_rotation'] = (b) => {
            const dir = b.getFieldValue('DIRECTION');
            const rot = b.getFieldValue('ROTATIONS');
            return `motor.run_for_rotations(${rot}, ${dir === 'CW' ? '1' : '-1'})\n`;
        };
        Blockly.Python['motor_run_to_angle'] = (b) => {
            const dir = b.getFieldValue('DIRECTION');
            const angle = b.getFieldValue('ANGLE');
            return `motor.run_to_angle(${angle}, ${dir === 'CW' ? '1' : '-1'})\n`;
        };
        Blockly.Python['motor_go_to_position'] = (b) => {
            const position = b.getFieldValue('POSITION');
            return `motor.go_to_position(${position})\n`;
        };
        Blockly.Python['motor_start'] = (b) => {
            const dir = b.getFieldValue('DIRECTION');
            return `motor.start(${dir === 'CW' ? '1' : '-1'})\n`;
        };
        Blockly.Python['motor_stop'] = () => 'motor.stop()\n';
        Blockly.Python['when_lever_position'] = (b) => {
            const lever = b.getFieldValue('LEVER');
            const position = b.getFieldValue('POSITION');
            return `# When ${lever} lever is ${position}\n`;
        };
        Blockly.Python['lever_position'] = (b) => {
            const lever = b.getFieldValue('LEVER');
            const position = b.getFieldValue('POSITION');
            return [`controller.${lever.toLowerCase()}_lever_is_${position.toLowerCase()}()`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['lever_angle'] = (b) => {
            const lever = b.getFieldValue('LEVER');
            return [`controller.${lever.toLowerCase()}_lever_angle()`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['math_arithmetic'] = (b) => {
            const ops = {
                'ADD': '+', 'MINUS': '-', 'MULTIPLY': '*',
                'DIVIDE': '/', 'POWER': '**', 'MOD': '%'
            };
            const op = ops[b.getFieldValue('OP')];
            const a = Blockly.Python.valueToCode(b, 'A', Blockly.Python.ORDER_ATOMIC) || '0';
            const bVal = Blockly.Python.valueToCode(b, 'B', Blockly.Python.ORDER_ATOMIC) || '0';
            return [`(${a} ${op} ${bVal})`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['math_random'] = (b) => {
            const from = Blockly.Python.valueToCode(b, 'FROM', Blockly.Python.ORDER_ATOMIC) || '1';
            const to = Blockly.Python.valueToCode(b, 'TO', Blockly.Python.ORDER_ATOMIC) || '10';
            return [`random.randint(${from}, ${to})`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['logic_compare'] = (b) => {
            const ops = { 'GT': '>', 'LT': '<', 'EQ': '==', 'GTE': '>=', 'LTE': '<=' };
            const op = ops[b.getFieldValue('OP')];
            const a = Blockly.Python.valueToCode(b, 'A', Blockly.Python.ORDER_ATOMIC) || '0';
            const bVal = Blockly.Python.valueToCode(b, 'B', Blockly.Python.ORDER_ATOMIC) || '0';
            return [`(${a} ${op} ${bVal})`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['logic_and'] = (b) => {
            const a = Blockly.Python.valueToCode(b, 'A', Blockly.Python.ORDER_ATOMIC) || 'False';
            const bVal = Blockly.Python.valueToCode(b, 'B', Blockly.Python.ORDER_ATOMIC) || 'False';
            return [`(${a} and ${bVal})`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['logic_or'] = (b) => {
            const a = Blockly.Python.valueToCode(b, 'A', Blockly.Python.ORDER_ATOMIC) || 'False';
            const bVal = Blockly.Python.valueToCode(b, 'B', Blockly.Python.ORDER_ATOMIC) || 'False';
            return [`(${a} or ${bVal})`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['logic_negate'] = (b) => {
            const bool = Blockly.Python.valueToCode(b, 'BOOL', Blockly.Python.ORDER_ATOMIC) || 'False';
            return [`not ${bool}`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['math_number'] = (b) => {
            const num = b.getFieldValue('NUM');
            return [num, Blockly.Python.ORDER_ATOMIC];
        };

        function initBlockly() {
            workspace = Blockly.inject('blocklyDiv', {
                toolbox: `
                    <xml xmlns="https://developers.google.com/blockly/xml">
                        <block type="start"></block>
                        <block type="when_condition"></block>
                        <block type="when_message_received">
                            <field name="MESSAGE">message1</field>
                        </block>
                        <block type="send_message">
                            <field name="MESSAGE">message1</field>
                        </block>
                        <block type="forward">
                            <value name="STEPS">
                                <shadow type="math_number">
                                    <field name="NUM">4</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="turn_right">
                            <value name="DEG">
                                <shadow type="math_number">
                                    <field name="NUM">4</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="turn_left">
                            <value name="DEG">
                                <shadow type="math_number">
                                    <field name="NUM">4</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="repeat">
                            <value name="TIMES">
                                <shadow type="math_number">
                                    <field name="NUM">10</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="alarm"></block>
                        <block type="sound"><field name="FREQ">300</field></block>
                        <block type="light"></block>
                        <block type="led_on"><field name="VAL">90</field></block>
                        <block type="led_off"><field name="VAL">90</field></block>
                        <block type="rgb_red_button_get"></block>
                        <block type="rgb_green_button_get"></block>
                        <block type="rgb_blue_button_get"></block>
                        <block type="smile"></block>
                    </xml>
                `,
                horizontalLayout: false,
                toolboxPosition: 'start',
                renderer: 'zelos',
                zoom: {
                    controls: false,
                    wheel: true,
                    startScale: 1.0,
                    maxScale: 2.0,
                    minScale: 0.5,
                    scaleSpeed: 1.15
                },
                grid: {
                    spacing: 20,
                    length: 2,
                    colour: '#E8E8E8',
                    snap: true
                },
                move: {
                    scrollbars: {
                        horizontal: true,
                        vertical: true
                    },
                    drag: true,
                    wheel: true
                },
                trashcan: false
            });

            // Blok eklendiƒüinde cihaz ikonu ekle
            workspace.addChangeListener(function (event) {
                // Blok se√ßildiƒüinde silme butonunu g√∂ster
                if (event.type === Blockly.Events.SELECTED) {
                    handleBlockSelection(event);
                }

                if (event.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                    const block = workspace.getBlockById(event.blockId);
                    if (block && block.data === selectedDeviceId) {
                        // Bloƒüun SVG'sine cihaz ikonu ekle
                        setTimeout(() => {
                            const blockSvg = block.getSvgRoot();
                            if (blockSvg && !blockSvg.querySelector('.device-badge')) {
                                const deviceIcon = getDeviceIcon(selectedDeviceId);
                                if (deviceIcon) {
                                    const foreignObject = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
                                    foreignObject.setAttribute('x', '2');
                                    foreignObject.setAttribute('y', block.height - 18);
                                    foreignObject.setAttribute('width', '14');
                                    foreignObject.setAttribute('height', '14');
                                    foreignObject.classList.add('device-badge');

                                    const div = document.createElement('div');
                                    div.innerHTML = deviceIcon;
                                    div.style.width = '14px';
                                    div.style.height = '14px';

                                    foreignObject.appendChild(div);
                                    blockSvg.appendChild(foreignObject);
                                }
                            }
                        }, 100);
                    }
                }
            });

            // Workspace drop handler
            setupWorkspaceDrop();

            // Toolbox'ƒ± ba≈ülangƒ±√ßta gizle
            setTimeout(() => {
                hideAllToolboxes();
                console.log('Toolbox ba≈ülangƒ±√ßta gizlendi');

                // Varsayƒ±lan dili ƒ∞ngilizce yap
                setTimeout(() => {
                    setLanguage('en');
                }, 200);
            }, 100);
        }

        function showCode() {
            const code = Blockly.Python.workspaceToCode(workspace);
            if (!code.trim()) {
                alert('√ñnce blok ekle! üé®');
                return;
            }
            document.getElementById('codeDisplay').textContent = '# MicroPython\n\n' + code;
            document.getElementById('codeModal').classList.add('show');
        }

        function closeModal() {
            document.getElementById('codeModal').classList.remove('show');
        }

        function copyCode() {
            const code = document.getElementById('codeDisplay').textContent;
            navigator.clipboard.writeText(code).then(() => alert('‚úÖ Kopyalandƒ±!'));
        }

        // Global execution control flags
        var isExecutionCancelled = false;
        var isExecutionRunning = false;
        var eventCheckInterval = null;

        async function runCode() {
            const playBtn = document.querySelector('.play-btn');

            // Eƒüer zaten √ßalƒ±≈üƒ±yorsa, durdur
            if (isExecutionRunning) {
                stopExecution();
                return;
            }

            // Yeni √ßalƒ±≈ütƒ±rma ba≈ülat
            isExecutionCancelled = false;
            isExecutionRunning = true;

            // Play butonunu "√ßalƒ±≈üƒ±yor" g√∂r√ºn√ºm√ºne getir
            playBtn.style.background = '#51cf66';
            playBtn.style.boxShadow = 'inset 0 2px 8px rgba(0,0,0,0.3)';
            playBtn.title = 'Durdur / Stop';

            // Workspace'teki t√ºm bloklarƒ± al
            const allBlocks = workspace.getAllBlocks();

            // "start" bloklarƒ±nƒ± bul ve √ßalƒ±≈ütƒ±r
            const startBlocks = allBlocks.filter(block => block.type === 'start');

            if (startBlocks.length === 0) {
                alert(TRANSLATIONS[currentLanguage].alert_no_play);
                stopExecution();
                return;
            }

            console.log('‚ñ∂Ô∏è Kod √ßalƒ±≈ütƒ±rƒ±lƒ±yor...');

            // Start bloklarƒ±nƒ± √ßalƒ±≈ütƒ±r
            for (const startBlock of startBlocks) {
                if (isExecutionCancelled) break;

                let nextBlock = startBlock.getNextBlock();
                while (nextBlock) {
                    if (isExecutionCancelled) {
                        console.log('üõë Kod y√ºr√ºtme iptal edildi.');
                        break;
                    }

                    await executeBlockPlay(nextBlock);
                    nextBlock = nextBlock.getNextBlock();
                }
            }

            // Start bloklarƒ± bitti, event dinlemeye ba≈üla
            if (!isExecutionCancelled) {
                startEventListening();
            }
        }

        function stopExecution() {
            console.log('‚èπÔ∏è √áalƒ±≈üma durduruluyor...');
            isExecutionCancelled = true;
            isExecutionRunning = false;

            // Event dinlemeyi durdur
            if (eventCheckInterval) {
                clearInterval(eventCheckInterval);
                eventCheckInterval = null;
            }

            // Play butonunu normal haline getir
            const playBtn = document.querySelector('.play-btn');
            playBtn.style.background = '#FFBF00';
            playBtn.style.boxShadow = '0 3px 8px rgba(0, 0, 0, 0.2)';
            playBtn.title = 'Kodu √áalƒ±≈ütƒ±r / Run Code';
        }

        function startEventListening() {
            console.log('üëÇ Event dinleme ba≈üladƒ±...');

            // Play butonunu "dinliyor" (daha koyu ye≈üil) g√∂r√ºn√ºm√ºne getir
            const playBtn = document.querySelector('.play-btn');
            if (playBtn) {
                // √áalƒ±≈üƒ±yor state'inden (#51cf66) daha koyu bir ye≈üil yap
                playBtn.style.background = '#2b8a3e';
                playBtn.title = 'Dinleniyor... (Durdurmak i√ßin tƒ±kla)';
            }

            // Her 100ms'de event bloklarƒ±nƒ± kontrol et
            eventCheckInterval = setInterval(async () => {
                if (isExecutionCancelled || !isExecutionRunning) {
                    clearInterval(eventCheckInterval);
                    eventCheckInterval = null;
                    return;
                }

                const allBlocks = workspace.getAllBlocks();

                // when_condition bloklarƒ± (when [condition] true olduƒüunda)
                const conditionBlocks = allBlocks.filter(b => b.type === 'when_condition');
                for (const block of conditionBlocks) {
                    if (isExecutionCancelled) break;
                    const conditionBlock = block.getInputTargetBlock('CONDITION');
                    if (conditionBlock) {
                        const result = await executeBlockPlay(conditionBlock);
                        if (result === true) {
                            // Ko≈üul saƒülandƒ±, altƒ±ndaki bloklarƒ± √ßalƒ±≈ütƒ±r
                            let nextBlock = block.getNextBlock();
                            while (nextBlock && !isExecutionCancelled) {
                                await executeBlockPlay(nextBlock);
                                nextBlock = nextBlock.getNextBlock();
                            }
                        }
                    }
                }

                // when_message_received bloklarƒ±
                // (Bu bloklar message g√∂nderildiƒüinde tetiklenir, ayrƒ±ca y√∂netilir)

            }, 100);
        }

        // Global scope'a ekle
        window.runCode = runCode;
        window.stopExecution = stopExecution;

        async function executeBlockPlay(block) {
            if (!block || isExecutionCancelled) return;

            const blockType = block.type;
            console.log('üéØ executeBlockPlay √ßalƒ±≈ütƒ±rƒ±lƒ±yor:', blockType);

            // Wait bloƒüu - ger√ßek bekleme
            if (blockType === 'wait') {
                // ValueInput'tan baƒülƒ± bloƒüun deƒüerini al
                const secondsBlock = block.getInputTargetBlock('SECONDS');
                let seconds = 1; // varsayƒ±lan
                if (secondsBlock) {
                    // math_number veya benzeri bloktan deƒüer al
                    if (secondsBlock.type === 'math_number') {
                        seconds = parseFloat(secondsBlock.getFieldValue('NUM')) || 1;
                    } else {
                        // Diƒüer sayƒ± bloklarƒ± i√ßin
                        seconds = parseFloat(secondsBlock.getFieldValue('NUM') || secondsBlock.getFieldValue('VALUE')) || 1;
                    }
                }
                console.log(`‚è±Ô∏è ${seconds} saniye bekleniyor...`);
                // Wait sƒ±rasƒ±nda da iptal kontrol√º i√ßin d√∂ng√ºl√º bekleme
                const steps = seconds * 10;
                for (let i = 0; i < steps; i++) {
                    if (isExecutionCancelled) return;
                    await sleep(100);
                }
                console.log(`‚è±Ô∏è ${seconds} saniye bekleme tamamlandƒ±`);
                return;
            }

            // Repeat bloƒüu - d√∂ng√º
            if (blockType === 'repeat') {
                const timesBlock = block.getInputTargetBlock('TIMES');
                let times = 10; // varsayƒ±lan
                if (timesBlock) {
                    times = await executeBlockPlay(timesBlock);
                }
                const doBlock = block.getInputTargetBlock('DO');

                console.log(`üîÑ ${times} kez tekrarlanƒ±yor...`);
                for (let i = 0; i < times; i++) {
                    if (isExecutionCancelled) break;
                    let innerBlock = doBlock;
                    while (innerBlock) {
                        if (isExecutionCancelled) break;
                        await executeBlockPlay(innerBlock);
                        innerBlock = innerBlock.getNextBlock();
                    }
                }
                return;
            }

            // If-then bloƒüu
            if (blockType === 'if_then') {
                const conditionBlock = block.getInputTargetBlock('CONDITION');
                const doBlock = block.getInputTargetBlock('DO');

                // Ko≈üulu deƒüerlendir
                let conditionTrue = false;
                if (conditionBlock) {
                    const result = await executeBlockPlay(conditionBlock);
                    conditionTrue = Boolean(result);
                }

                console.log('üî∂ If ko≈üulu kontrol ediliyor...', conditionTrue);
                if (conditionTrue) {
                    console.log('‚úÖ Ko≈üul doƒüru, then bloƒüu √ßalƒ±≈ütƒ±rƒ±lƒ±yor');
                    let innerBlock = doBlock;
                    while (innerBlock) {
                        if (isExecutionCancelled) break;
                        await executeBlockPlay(innerBlock);
                        innerBlock = innerBlock.getNextBlock();
                    }
                } else {
                    console.log('‚ùå Ko≈üul yanlƒ±≈ü, atlanƒ±yor');
                }
                return;
            }

            // If-then-else bloƒüu
            if (blockType === 'if_then_else') {
                const conditionBlock = block.getInputTargetBlock('CONDITION');
                const doBlock = block.getInputTargetBlock('DO');
                const elseBlock = block.getInputTargetBlock('ELSE');

                // Ko≈üulu deƒüerlendir
                let conditionTrue = false;
                if (conditionBlock) {
                    const result = await executeBlockPlay(conditionBlock);
                    conditionTrue = Boolean(result);
                }

                console.log('üî∂ If-else ko≈üulu kontrol ediliyor...', conditionTrue);
                if (conditionTrue) {
                    console.log('‚úÖ Ko≈üul doƒüru, then bloƒüu √ßalƒ±≈ütƒ±rƒ±lƒ±yor');
                    let innerBlock = doBlock;
                    while (innerBlock) {
                        if (isExecutionCancelled) break;
                        await executeBlockPlay(innerBlock);
                        innerBlock = innerBlock.getNextBlock();
                    }
                } else {
                    console.log('‚ùå Ko≈üul yanlƒ±≈ü, else bloƒüu √ßalƒ±≈ütƒ±rƒ±lƒ±yor');
                    let innerBlock = elseBlock;
                    while (innerBlock) {
                        if (isExecutionCancelled) break;
                        await executeBlockPlay(innerBlock);
                        innerBlock = innerBlock.getNextBlock();
                    }
                }
                return;
            }

            // Wait until bloƒüu
            if (blockType === 'wait_until') {
                console.log('‚è≥ Wait until - ko≈üul bekleniyor...');
                // Basitle≈ütirilmi≈ü: 1 saniye bekle
                await sleep(1000);
                console.log('‚úÖ Wait until tamamlandƒ±');
                return;
            }

            // Repeat until bloƒüu - ko≈üul saƒülanana kadar tekrarla
            if (blockType === 'repeat_until') {
                const conditionBlock = block.getInputTargetBlock('CONDITION');
                const doBlock = block.getInputTargetBlock('DO');

                console.log('üîÅ Repeat until ba≈üladƒ±...');

                // Maksimum 1000 iterasyon (sonsuz d√∂ng√º korumasƒ±)
                for (let i = 0; i < 1000; i++) {
                    // Ko≈üulu kontrol et
                    let conditionMet = false;
                    if (conditionBlock) {
                        const result = await executeBlockPlay(conditionBlock);
                        conditionMet = Boolean(result);
                    }

                    if (conditionMet) {
                        console.log('üîÅ Repeat until ko≈üul saƒülandƒ±, √ßƒ±kƒ±lƒ±yor');
                        break;
                    }

                    // ƒ∞√ß bloklarƒ± √ßalƒ±≈ütƒ±r
                    let innerBlock = doBlock;
                    while (innerBlock) {
                        if (isExecutionCancelled) break;
                        await executeBlockPlay(innerBlock);
                        innerBlock = innerBlock.getNextBlock();
                    }

                    // Her iterasyonda k√º√ß√ºk bir bekleme
                    await sleep(50);
                    if (isExecutionCancelled) break;
                }
                console.log('üîÅ Repeat until tamamlandƒ±');
                return;
            }

            // Forever bloƒüu - sonsuz d√∂ng√º (≈üimdilik 100 kez)
            if (blockType === 'forever') {
                const doBlock = block.getInputTargetBlock('DO');
                console.log('‚ôæÔ∏è S√ºrekli d√∂ng√º ba≈üladƒ± (100 iterasyon)...');

                for (let i = 0; i < 100; i++) {
                    if (isExecutionCancelled) break;
                    let innerBlock = doBlock;
                    while (innerBlock) {
                        if (isExecutionCancelled) break;
                        await executeBlockPlay(innerBlock);
                        innerBlock = innerBlock.getNextBlock();
                    }
                }
                return;
            }

            // RGB LED kontrolleri
            if (blockType === 'rgb_red_on') {
                rgbLedState.red = true;
                document.getElementById('rgbRedLed').classList.add('active');
                console.log('üî¥ Kƒ±rmƒ±zƒ± LED yakƒ±ldƒ±');
            } else if (blockType === 'rgb_green_on') {
                rgbLedState.green = true;
                document.getElementById('rgbGreenLed').classList.add('active');
                console.log('üü¢ Ye≈üil LED yakƒ±ldƒ±');
            } else if (blockType === 'rgb_blue_on') {
                rgbLedState.blue = true;
                document.getElementById('rgbBlueLed').classList.add('active');
                console.log('üîµ Mavi LED yakƒ±ldƒ±');
            }

            // RGB LED s√∂nd√ºr kontrolleri
            else if (blockType === 'rgb_red_off') {
                rgbLedState.red = false;
                document.getElementById('rgbRedLed').classList.remove('active');
                console.log('‚óØ Kƒ±rmƒ±zƒ± LED s√∂nd√ºr√ºld√º');
            } else if (blockType === 'rgb_green_off') {
                rgbLedState.green = false;
                document.getElementById('rgbGreenLed').classList.remove('active');
                console.log('‚óØ Ye≈üil LED s√∂nd√ºr√ºld√º');
            } else if (blockType === 'rgb_blue_off') {
                rgbLedState.blue = false;
                document.getElementById('rgbBlueLed').classList.remove('active');
                console.log('‚óØ Mavi LED s√∂nd√ºr√ºld√º');
            }

            // RGB sayƒ± kontrolleri
            else if (blockType === 'rgb_red_num') {
                const numBlock = block.getInputTargetBlock('NUM');
                const numValue = numBlock ? await executeBlockPlay(numBlock) : 0;
                rgbNumberState.red = numValue;
                document.getElementById('rgbRedNum').textContent = numValue;
                console.log('üü• Kƒ±rmƒ±zƒ± sayƒ±:', numValue);
            } else if (blockType === 'rgb_green_num') {
                const numBlock = block.getInputTargetBlock('NUM');
                const numValue = numBlock ? await executeBlockPlay(numBlock) : 0;
                rgbNumberState.green = numValue;
                document.getElementById('rgbGreenNum').textContent = numValue;
                console.log('üü© Ye≈üil sayƒ±:', numValue);
            } else if (blockType === 'rgb_blue_num') {
                const numBlock = block.getInputTargetBlock('NUM');
                const numValue = numBlock ? await executeBlockPlay(numBlock) : 0;
                rgbNumberState.blue = numValue;
                document.getElementById('rgbBlueNum').textContent = numValue;
                console.log('üü¶ Mavi sayƒ±:', numValue);
            }

            // RGB sayƒ± getir kontrolleri
            else if (blockType === 'rgb_red_get') {
                console.log('üü• Kƒ±rmƒ±zƒ± sayƒ± getir:', rgbNumberState.red);
                return rgbNumberState.red;
            } else if (blockType === 'rgb_green_get') {
                console.log('üü© Ye≈üil sayƒ± getir:', rgbNumberState.green);
                return rgbNumberState.green;
            } else if (blockType === 'rgb_blue_get') {
                console.log('üü¶ Mavi sayƒ± getir:', rgbNumberState.blue);
                return rgbNumberState.blue;
            }

            // RGB ƒ±≈üƒ±k getir kontrolleri
            else if (blockType === 'rgb_red_light_get') {
                console.log('üî¥ Kƒ±rmƒ±zƒ± ƒ±≈üƒ±k getir:', rgbLedState.red);
                return rgbLedState.red;
            } else if (blockType === 'rgb_green_light_get') {
                console.log('üü¢ Ye≈üil ƒ±≈üƒ±k getir:', rgbLedState.green);
                return rgbLedState.green;
            } else if (blockType === 'rgb_blue_light_get') {
                console.log('üîµ Mavi ƒ±≈üƒ±k getir:', rgbLedState.blue);
                return rgbLedState.blue;
            }

            // RGB tu≈ü getir kontrolleri
            else if (blockType === 'rgb_red_button_get') {
                console.log('üî∫ Kƒ±rmƒ±zƒ± tu≈ü getir:', btnStates.red);
                return btnStates.red;
            } else if (blockType === 'rgb_green_button_get') {
                console.log('üî∫ Ye≈üil tu≈ü getir:', btnStates.green);
                return btnStates.green;
            } else if (blockType === 'rgb_blue_button_get') {
                console.log('üî∫ Mavi tu≈ü getir:', btnStates.blue);
                return btnStates.blue;
            }

            // Motor kontrolleri
            else if (blockType === 'motor_run_rotation') {
                const dir = block.getFieldValue('DIRECTION');
                const rot = block.getFieldValue('ROTATIONS');
                console.log(`üîÑ Motor ${dir === 'CW' ? '‚Üª' : '‚Ü∫'} ${rot} rotasyon`);

                // Bluetooth motor kontrol√º
                const deviceId = block.data;
                console.log('DEBUG: deviceId =', deviceId);
                console.log('DEBUG: block =', block);
                console.log('DEBUG: block.data =', block.data);

                if (deviceId) {
                    console.log('‚úÖ deviceId var, runMotorRotations √ßaƒürƒ±lƒ±yor...');
                    await runMotorRotations(deviceId, parseInt(rot), dir);
                } else {
                    console.log('‚ùå deviceId yok! Motor Bluetooth komutu g√∂nderilemedi.');
                    console.log('   Motor cihazƒ±nƒ± √∂nce baƒülayƒ±n ve bloƒüu motor ikonundan s√ºr√ºkleyin.');
                }
                return; // Motor run_rotation i≈ülemi tamamlandƒ±
            } else if (blockType === 'motor_run_to_angle') {
                const dir = block.getFieldValue('DIRECTION');
                const angle = block.getFieldValue('ANGLE');
                console.log(`üéØ Motor ${dir === 'CW' ? '‚Üª' : '‚Ü∫'} ${angle}¬∞ a√ßƒ±ya git (g√∂receli)`);

                // Bluetooth motor kontrol√º
                const deviceId = block.data;
                console.log('DEBUG: deviceId =', deviceId);

                if (deviceId) {
                    console.log('‚úÖ deviceId var, runMotorToAngle √ßaƒürƒ±lƒ±yor...');
                    await runMotorToAngle(deviceId, parseInt(angle), dir);
                } else {
                    console.log('‚ùå deviceId yok! Motor Bluetooth komutu g√∂nderilemedi.');
                }
                return; // Motor run_to_angle i≈ülemi tamamlandƒ±
            } else if (blockType === 'motor_go_to_position') {
                const position = block.getFieldValue('POSITION');
                console.log(`üìç Motor ${position}¬∞ pozisyonuna git (mutlak)`);

                // Bluetooth motor kontrol√º
                const deviceId = block.data;
                if (deviceId) {
                    await goToPosition(deviceId, parseInt(position));
                } else {
                    console.log('‚ùå deviceId yok!');
                }
                return; // Motor go_to_position i≈ülemi tamamlandƒ±
            } else if (blockType === 'motor_start') {
                const dir = block.getFieldValue('DIRECTION');
                console.log(`‚ñ∂Ô∏è Motor ${dir === 'CW' ? '‚Üª' : '‚Ü∫'} ba≈ülatƒ±ldƒ±`);

                // Bluetooth motor kontrol√º
                const deviceId = block.data;
                if (deviceId) {
                    await startMotor(deviceId, dir);
                } else {
                    console.log('‚ùå deviceId yok!');
                }
                return; // Motor start i≈ülemi tamamlandƒ±
            } else if (blockType === 'motor_stop') {
                console.log('‚èπÔ∏è Motor durduruldu');

                // Bluetooth motor kontrol√º
                const deviceId = block.data;
                if (deviceId) {
                    await stopMotor(deviceId);
                } else {
                    console.log('‚ùå deviceId yok!');
                }
                return; // Motor stop i≈ülemi tamamlandƒ±
            }

            // Matematik bloklarƒ±
            else if (blockType === 'math_number') {
                const num = parseFloat(block.getFieldValue('NUM'));
                return num;
            } else if (blockType === 'math_random') {
                const fromBlock = block.getInputTargetBlock('FROM');
                const toBlock = block.getInputTargetBlock('TO');
                const from = fromBlock ? await executeBlockPlay(fromBlock) : 1;
                const to = toBlock ? await executeBlockPlay(toBlock) : 10;
                return Math.floor(Math.random() * (to - from + 1)) + from;
            } else if (blockType === 'math_arithmetic') {
                const op = block.getFieldValue('OP');
                const aBlock = block.getInputTargetBlock('A');
                const bBlock = block.getInputTargetBlock('B');
                const a = aBlock ? await executeBlockPlay(aBlock) : 0;
                const b = bBlock ? await executeBlockPlay(bBlock) : 0;

                let result = 0;
                switch (op) {
                    case 'ADD': result = a + b; break;
                    case 'MINUS': result = a - b; break;
                    case 'MULTIPLY': result = a * b; break;
                    case 'DIVIDE': result = a / b; break;
                    case 'POWER': result = Math.pow(a, b); break;
                    case 'MOD': result = a % b; break;
                }
                return result;
            }

            // Controller kontrolleri
            else if (blockType === 'lever_angle') {
                const lever = block.getFieldValue('LEVER');
                let angle = 50; // Varsayƒ±lan deƒüer (orta pozisyon)

                if (lever === 'LEFT') {
                    angle = Math.round(controllerState.leftPercent || 50);
                } else if (lever === 'RIGHT') {
                    angle = Math.round(controllerState.rightPercent || 50);
                }

                console.log(`üïπÔ∏è Lever angle ${lever}: ${angle}%`);
                return angle;
            }
            else if (blockType === 'when_lever_position') {
                const lever = block.getFieldValue('LEVER');
                const position = block.getFieldValue('POSITION');
                console.log(`üïπÔ∏è When ${lever} lever is ${position}`);
            } else if (blockType === 'lever_position') {
                const lever = block.getFieldValue('LEVER');
                const position = block.getFieldValue('POSITION');

                // Mevcut controller durumunu kontrol et
                let currentPosition;
                if (lever === 'LEFT') {
                    currentPosition = controllerState.left;
                } else if (lever === 'RIGHT') {
                    currentPosition = controllerState.right;
                } else if (lever === 'ANY') {
                    currentPosition = controllerState.left !== 'RELEASED' ? controllerState.left : controllerState.right;
                } else if (lever === 'BOTH') {
                    if (controllerState.left === controllerState.right) {
                        currentPosition = controllerState.left;
                    } else {
                        currentPosition = 'RELEASED';
                    }
                }

                const result = currentPosition === position;
                console.log(`üïπÔ∏è Checking ${lever} lever is ${position}? Current: ${currentPosition}, Result: ${result}`);
                return result;
            }

            // Diƒüer boolean bloklarƒ± i√ßin
            console.log(`‚ö†Ô∏è Bilinmeyen ko≈üul bloƒüu: ${blockType}`);
            return false;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Ko≈üul bloƒüunu deƒüerlendir
        function evaluateCondition(conditionBlock) {
            if (!conditionBlock) return false;

            const blockType = conditionBlock.type;

            // lever_position bloƒüu
            if (blockType === 'lever_position') {
                const lever = conditionBlock.getFieldValue('LEVER');
                const position = conditionBlock.getFieldValue('POSITION');

                // Mevcut controller durumunu kontrol et
                let currentPosition;
                if (lever === 'LEFT') {
                    currentPosition = controllerState.left;
                } else if (lever === 'RIGHT') {
                    currentPosition = controllerState.right;
                } else if (lever === 'ANY') {
                    currentPosition = controllerState.left !== 'RELEASED' ? controllerState.left : controllerState.right;
                } else if (lever === 'BOTH') {
                    // Her iki lever da aynƒ± pozisyonda mƒ±?
                    if (controllerState.left === controllerState.right) {
                        currentPosition = controllerState.left;
                    } else {
                        currentPosition = 'RELEASED';
                    }
                }

                const result = currentPosition === position;
                console.log(`üïπÔ∏è Ko≈üul kontrol√º: ${lever} lever is ${position}? Mevcut: ${currentPosition}, Sonu√ß: ${result}`);
                return result;
            }

            // Diƒüer boolean bloklarƒ± i√ßin
            console.log(`‚ö†Ô∏è Bilinmeyen ko≈üul bloƒüu: ${blockType}`);
            return false;
        }

        function stopCode() {
            alert(TRANSLATIONS[currentLanguage].alert_stopped);
        }

        // --- EXPORT & IMPORT FUNCTIONS --- //
        function exportWorkspace() {
            try {
                const xml = Blockly.Xml.workspaceToDom(workspace);
                const xmlText = Blockly.Xml.domToText(xml);

                const blob = new Blob([xmlText], { type: 'text/xml' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = 'blockcode_project.xml'; // Varsayƒ±lan dosya adƒ±
                document.body.appendChild(a);
                a.click();

                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                console.log('‚úÖ Workspace exported successfully');
            } catch (e) {
                console.error('‚ùå Export error:', e);
                alert(TRANSLATIONS[currentLanguage].alert_export_error);
            }
        }

        function importWorkspace(input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const xmlText = e.target.result;
                    const xml = Blockly.Xml.textToDom(xmlText);

                    // Mevcut bloklarƒ± temizle (isteƒüe baƒülƒ±, kullanƒ±cƒ±ya sorulabilir)
                    if (confirm(TRANSLATIONS[currentLanguage].confirm_import)) {
                        workspace.clear();
                    }

                    Blockly.Xml.domToWorkspace(xml, workspace);
                    console.log('‚úÖ Workspace imported successfully');

                    // Input'u temizle ki aynƒ± dosyayƒ± tekrar se√ßebilsin
                    input.value = '';
                } catch (e) {
                    console.error('‚ùå Import error:', e);
                    alert(TRANSLATIONS[currentLanguage].alert_import_error);
                }
            };
            reader.readAsText(file);
        }
        // -------------------------------- //

        function resetEverything() {
            openResetModal();
        }

        function openResetModal() {
            document.getElementById('resetModal').classList.add('active');
        }

        function closeResetModal() {
            document.getElementById('resetModal').classList.remove('active');
        }

        function performReset() {
            closeResetModal();

            // √áalƒ±≈üan kod varsa durdur
            isExecutionCancelled = true;

            // RGB LED'leri s√∂nd√ºr
            rgbLedState = { red: false, green: false, blue: false };
            document.getElementById('rgbRedLed').classList.remove('active');
            document.getElementById('rgbGreenLed').classList.remove('active');
            document.getElementById('rgbBlueLed').classList.remove('active');

            // RGB sayƒ±larƒ± sƒ±fƒ±rla
            rgbNumberState = { red: 0, green: 0, blue: 0 };
            document.getElementById('rgbRedNum').textContent = '0';
            document.getElementById('rgbGreenNum').textContent = '0';
            document.getElementById('rgbBlueNum').textContent = '0';

            // Motor i≈ülem kilidini sƒ±fƒ±rla
            motorOperationInProgress = false;

            // √ú√ßgen butonlarƒ±n basƒ±lƒ± tutma durumunu sƒ±fƒ±rla
            stopHold();

            // Play butonunu aktif et ve g√∂r√ºn√ºm√ºn√º d√ºzelt
            const playBtn = document.querySelector('.play-btn');
            if (playBtn) {
                playBtn.disabled = false;
                playBtn.style.opacity = '1';
                playBtn.style.cursor = 'pointer';
                playBtn.style.pointerEvents = 'auto'; // Kilitlenmeyi √∂nler
                playBtn.style.background = '#FFBF00'; // Orijinal sarƒ± renk
            }

            console.log('üîÑ Her ≈üey sƒ±fƒ±rlandƒ± (cihazlar hari√ß)');

            // G√∂rsel feedback
            const resetBtn = document.querySelector('.reset-btn');
            resetBtn.style.background = '#51cf66';
            setTimeout(() => {
                resetBtn.style.background = '#FF6680';
            }, 300);
        }


        // Global scope'a ekle
        window.resetEverything = resetEverything;

        function addDevice() {
            console.log('addDevice √ßaƒürƒ±ldƒ±');
            console.log('navigator.bluetooth:', navigator.bluetooth);

            const modal = document.getElementById('deviceModal');
            console.log('deviceModal element:', modal);

            if (modal) {
                // Hem class hem inline style ekle
                modal.classList.add('show');
                modal.style.display = 'flex';
                modal.style.zIndex = '10000';

                console.log('Modal a√ßƒ±ldƒ±');
                console.log('Modal classes:', modal.className);
                console.log('Modal display:', modal.style.display);
            } else {
                console.error('deviceModal bulunamadƒ±!');
                alert('Modal element bulunamadƒ±!');
            }
        }

        // Global scope'a ekle
        window.addDevice = addDevice;

        // RGB LED kontrol fonksiyonlarƒ±
        let bluetoothDevice = null;
        let bluetoothServer = null;
        let connectedCharacteristics = {};
        let connectedDevices = [];
        let selectedDeviceId = null;
        let deviceMenuOpen = null; // A√ßƒ±k cihaz men√ºs√º

        // Button States
        let btnStates = { red: false, green: false, blue: false };
        let btnLock = { red: false, green: false, blue: false };
        let pressTimer = { red: null, green: null, blue: null };

        function handleBtnDown(color) {
            const btn = document.getElementById(`rgb${color.charAt(0).toUpperCase() + color.slice(1)}Btn`);
            if (!btn) return;

            // Eƒüer kilitliyse (basƒ±lƒ± tutularak a√ßƒ±lma kontrol√º i√ßin timer ba≈ülat)
            if (btnLock[color]) {
                // Tƒ±klama anƒ±nda kilitli olduƒüunu g√∂ster (opsiyonel)
                // 3 saniye basƒ±lƒ± tutulursa kilidi kaldƒ±r
                if (pressTimer[color]) clearTimeout(pressTimer[color]);
                pressTimer[color] = setTimeout(() => {
                    // UNLOCK
                    btnLock[color] = false;
                    btnStates[color] = false; // Bƒ±rakƒ±nca s√∂necek, ama timer bitince direkt s√∂ns√ºn m√º? 
                    // Kullanƒ±cƒ± parmaƒüƒ±nƒ± kaldƒ±rƒ±nca handleBtnUp √ßalƒ±≈üacak ve btnLock false olduƒüu i√ßin s√∂necek.
                    // Burada g√∂rsel feedback verelim:
                    btn.classList.remove('active');
                    btn.classList.add('flash');
                    setTimeout(() => btn.classList.remove('flash'), 500);
                    console.log(`${color} button UNLOCKED (3s hold)`);
                }, 3000);
                return;
            }

            // Kilitli deƒüilse: Normal basma i≈ülemi
            btnStates[color] = true;
            btn.classList.add('active');

            // 3 saniye basƒ±lƒ± tutulursa Kƒ∞Lƒ∞TLE
            if (pressTimer[color]) clearTimeout(pressTimer[color]);
            pressTimer[color] = setTimeout(() => {
                // LOCK
                btnLock[color] = true;
                btn.classList.add('flash'); // Parlama efekti
                setTimeout(() => btn.classList.remove('flash'), 500);
                console.log(`${color} button LOCKED (3s hold)`);
            }, 3000);
        }

        function handleBtnUp(color) {
            const btn = document.getElementById(`rgb${color.charAt(0).toUpperCase() + color.slice(1)}Btn`);

            if (pressTimer[color]) {
                clearTimeout(pressTimer[color]);
                pressTimer[color] = null;
            }

            // Eƒüer kilitliyse, bƒ±rakƒ±nca S√ñNMEZ (active kalƒ±r)
            // Sadece tƒ±klayƒ±p bƒ±rakƒ±nca (kƒ±sa basƒ±≈ü) kilitli state deƒüi≈ümez, ama timer iptal olduƒüu i√ßin (yukarƒ±da) bir ≈üey olmaz.

            // Eƒüer kilitli DEƒûƒ∞LSE, bƒ±rakƒ±nca s√∂ner
            if (!btnLock[color]) {
                if (btnStates[color]) {
                    btnStates[color] = false;
                    if (btn) btn.classList.remove('active');
                }
            }
        }




        // Global'e ekle
        window.handleBtnDown = handleBtnDown;
        window.handleBtnUp = handleBtnUp;

        const DEVICE_SHAPES = ['triangle', 'square', 'rectangle', 'pentagon', 'hexagon', 'octagon', 'circle'];
        const DEVICE_COLORS = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B739'];

        // ===== BLUETOOTH MOTOR KONTROL FONKSƒ∞YONLARI =====

        // Hex string'i byte array'e √ßevir
        function hexToBytes(hexString) {
            const hex = hexString.replace(/:/g, '');
            const bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i < hex.length; i += 2) {
                bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
            }
            return bytes;
        }

        // Motor komut sabitleri
        const MOTOR_COMMANDS = {
            INIT: hexToBytes("30:31:30:32:30:33:30:34:30:35:30:36:30:37:30:38"),
            CONFIG: hexToBytes("02:00"),
            CMD_START: hexToBytes("00"),
            CMD_PREPARE: hexToBytes("1a"),
            CMD_MODE: hexToBytes("28:32:00"),
            CMD_CONTROL: hexToBytes("20:00"),
            // CMD_EXECUTE rotasyon sayƒ±sƒ±na g√∂re deƒüi≈üir, a≈üaƒüƒ±da fonksiyon var
            MOTOR_INIT_1: hexToBytes("01:01:00:31:00:01:00:3e:00:01:00:00:00:f7:00:00:02"),
            MOTOR_INIT_2: hexToBytes("1b:9d:4d:ce:36:00:4b:12:00"),
            MOTOR_INIT_3: hexToBytes("29:00"),
            MOTOR_BASE: hexToBytes("3c:12:00:00:46:00:0a:01:07:56:01:00:00:00:ef:ff:ff:ff:11:01:ff"), // capturing_rotasyon_sagvesol.pcap
            MOTOR_STOP_INIT: hexToBytes("7d:01:00"),
            // Alternatif durma komutlarƒ±
            MOTOR_BRAKE: hexToBytes("00:00"),  // Fren
            MOTOR_FLOAT: hexToBytes("7d:00:00"), // Serbest bƒ±rak
        };

        // Y√∂ne g√∂re motor base komutu olu≈ütur
        function createMotorBaseCommand(direction = 'CW') {
            // capturing_rotasyon_sagvesol.pcap ANALƒ∞Zƒ∞ (ROTASYON):
            // SAƒûA (CW): 3c 12 00 00 46 00 0a 01 07 56 01 00 00 00 ef ff ff ff 11 01 ff
            // SOLA (CCW): Motor base byte 8-9 deƒüi≈ümiyor, execute komutu y√∂n√º belirliyor
            //             SOLA i√ßin motor base SAƒûA ile aynƒ±

            // Rotasyon i√ßin her iki y√∂n de aynƒ± motor base kullanƒ±yor
            return hexToBytes("3c:12:00:00:46:00:0a:01:07:56:01:00:00:00:ef:ff:ff:ff:11:01:ff");
        }

        // Rotasyon/a√ßƒ±ya g√∂re CMD_EXECUTE olu≈ütur
        function createExecuteCommand(value, isRotation = true, direction = 'CW') {
            // Eƒüer rotasyon ise dereceye √ßevir
            let degrees = isRotation ? (value * 360) : value;

            // PCAP ANALƒ∞Zƒ∞ (capturing_rotasyon_sagvesol.pcap):
            // SAƒûA: 7c 01 68 01 00 00 00 (son byte = 0x00)
            // SOLA: 7c 01 68 01 00 00 01 (son byte = 0x01)
            // Y√∂n son byte'ta kodlanƒ±yor, derece deƒüeri pozitif kalƒ±yor!

            // Derece deƒüeri her zaman pozitif (negatif YOK)
            const posDegrees = Math.abs(degrees);

            // Signed 16-bit integer olarak encode et (little endian)
            const signed16 = posDegrees & 0xFFFF;
            const lowByte = signed16 & 0xFF;
            const highByte = (signed16 >> 8) & 0xFF;

            // Son byte y√∂n√º belirliyor: 0x00 = SAƒûA, 0x01 = SOLA
            const directionByte = direction === 'CW' ? 0x00 : 0x01;

            // 7c:01:[LOW]:[HIGH]:00:00:[DIR]
            const cmd = new Uint8Array([0x7c, 0x01, lowByte, highByte, 0x00, 0x00, directionByte]);

            const unit = isRotation ? 'rotasyon' : 'derece';
            const dirSymbol = direction === 'CW' ? '‚Üª' : '‚Ü∫';
            console.log(`CMD_EXECUTE i√ßin ${value} ${unit} ${dirSymbol} = ${posDegrees}¬∞ = 0x${signed16.toString(16)} = [${lowByte.toString(16)}, ${highByte.toString(16)}, dir=${directionByte.toString(16)}]`);

            return cmd;
        }

        const MOTOR_SPEED_CHANGES = [
            hexToBytes("3c:12:00:00:64:00:0a:01:07:2e:01:00:00:00:c6:ff:ff:ff:11:01:ff"),
            hexToBytes("3c:12:00:00:64:00:0a:01:01:31:01:75:09:00:c9:ff:ff:ff:11:01:ff"),
            hexToBytes("3c:12:00:00:64:00:0a:01:01:42:01:cb:13:04:da:ff:ff:ff:11:01:ff"),
            hexToBytes("3c:12:00:00:64:00:0a:01:01:60:01:a3:1e:09:f8:ff:ff:ff:11:01:ff"),
        ];

        const MOTOR_SLOWDOWN = [
            hexToBytes("3c:12:00:00:64:00:0a:01:07:2e:01:00:00:33:fe:03:00:00:11:01:ff"),
            hexToBytes("3c:12:00:00:64:00:0a:01:07:2e:01:00:00:2d:fe:03:00:00:11:01:ff"),
            hexToBytes("3c:12:00:00:64:00:0a:01:07:2e:01:00:00:28:fe:03:00:00:11:01:ff"),
            hexToBytes("3c:12:00:00:64:00:0a:01:07:2e:01:00:00:23:fe:03:00:00:11:01:ff"),
        ];

        // Cihazƒ±n karakteristiklerini al
        async function getMotorCharacteristics(deviceId) {
            console.log('getMotorCharacteristics √ßaƒürƒ±ldƒ±, deviceId:', deviceId);
            console.log('connectedDevices:', connectedDevices);

            const deviceData = connectedDevices.find(d => d.id === deviceId);
            console.log('Bulunan deviceData:', deviceData);

            if (!deviceData) {
                console.error('‚ùå Motor cihazƒ± connectedDevices i√ßinde bulunamadƒ±!');
                return null;
            }

            if (!deviceData.server) {
                console.error('‚ùå deviceData.server yok!');
                return null;
            }

            if (!deviceData.server.connected) {
                console.error('‚ùå GATT server baƒülƒ± deƒüil!');
                return null;
            }

            // Motor UUID'leri (PCAP analizinden)
            const MOTOR_SERVICE_UUIDS = [
                '0000fd02-0000-1000-8000-00805f9b34fb', // Ana motor servisi
                '00002a05-0000-1000-8000-00805f9b34fb', // INIT
                '00002b2a-0000-1000-8000-00805f9b34fb', // CONFIG
            ];

            const MOTOR_CHAR_UUIDS = {
                INIT: '00002a05-0000-1000-8000-00805f9b34fb',
                CONFIG: '00002b2a-0000-1000-8000-00805f9b34fb',
                COMMAND: '0000fd02-0001-1000-8000-00805f9b34fb',
                MOTOR: '0000fd02-0002-1000-8000-00805f9b34fb'
            };

            try {
                console.log('‚úì Server baƒülƒ±, belirli servisleri arƒ±yoruz...');
                const chars = {};

                // Her UUID'yi deneyelim
                for (const serviceUUID of MOTOR_SERVICE_UUIDS) {
                    try {
                        console.log(`  ‚Üí Servis ${serviceUUID} deneniyor...`);
                        const service = await deviceData.server.getPrimaryService(serviceUUID);
                        console.log(`    ‚úì Servis bulundu!`);

                        const characteristics = await service.getCharacteristics();
                        console.log(`    ${characteristics.length} karakteristik bulundu`);

                        for (const char of characteristics) {
                            console.log(`      - UUID: ${char.uuid}, Write: ${char.properties.write}, WriteNoResp: ${char.properties.writeWithoutResponse}`);

                            // T√ºm write karakteristiklerini kaydet
                            if (char.properties.write || char.properties.writeWithoutResponse) {
                                chars[char.uuid] = char;
                                console.log(`        ‚úì Yazƒ±labilir karakteristik kaydedildi`);
                            }
                        }
                    } catch (e) {
                        console.log(`    ‚ö†Ô∏è Servis ${serviceUUID} bulunamadƒ±: ${e.message}`);
                    }
                }

                // Eƒüer hi√ß karakteristik bulamadƒ±ysak, belirli karakteristikleri deneyelim
                if (Object.keys(chars).length === 0) {
                    console.log('  ‚Üí Hi√ß servis bulunamadƒ±, karakteristikleri direkt deniyoruz...');

                    for (const [name, uuid] of Object.entries(MOTOR_CHAR_UUIDS)) {
                        try {
                            // Ana servisten karakteristiƒüi almayƒ± dene
                            const service = await deviceData.server.getPrimaryService('0000fd02-0000-1000-8000-00805f9b34fb');
                            const char = await service.getCharacteristic(uuid);
                            chars[uuid] = char;
                            console.log(`    ‚úì ${name} karakteristiƒüi bulundu: ${uuid}`);
                        } catch (e) {
                            console.log(`    ‚ö†Ô∏è ${name} karakteristiƒüi bulunamadƒ±`);
                        }
                    }
                }

                console.log(`‚úÖ Toplam ${Object.keys(chars).length} yazƒ±labilir karakteristik bulundu`);

                if (Object.keys(chars).length === 0) {
                    console.error('‚ùå Hi√ß karakteristik bulunamadƒ±! Motor cihazƒ± Web Bluetooth ile uyumlu olmayabilir.');
                    return null;
                }

                return chars;
            } catch (error) {
                console.error('‚ùå Karakteristikler alƒ±namadƒ±:', error);
                console.error('   Error name:', error.name);
                console.error('   Error message:', error.message);
                return null;
            }
        }

        // Karakteristiƒüe veri yaz
        async function writeMotorCommand(characteristic, data, delay = 50) {
            if (!characteristic) return;
            try {
                await characteristic.writeValue(data);
                await new Promise(resolve => setTimeout(resolve, delay));
            } catch (error) {
                console.error('Motor komut yazma hatasƒ±:', error);
            }
        }

        // Motor initialize
        async function initializeMotor(deviceId) {
            const chars = await getMotorCharacteristics(deviceId);
            if (!chars) return false;

            console.log('Motor ba≈ülatƒ±lƒ±yor...');

            // ƒ∞lk eri≈üilebilir karakteristik √ºzerinden komutlarƒ± g√∂nder
            // Ger√ßek uygulamada doƒüru UUID'leri bulup kullanmalƒ±sƒ±nƒ±z
            const writeChar = Object.values(chars)[0];

            if (writeChar) {
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.INIT);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CONFIG);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_START);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_INIT_1);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_PREPARE);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_INIT_2);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_MODE);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_INIT_3);
            }

            console.log('‚úì Motor ba≈ülatƒ±ldƒ±');
            return true;
        }

        // Helper function for unified motor control
        async function sendMotorPositionCommand(deviceId, angle) {

            // Device'ƒ± bul
            const deviceData = connectedDevices.find(d => d.id === deviceId);
            if (!deviceData || !deviceData.server) {
                console.error('‚ùå Device bulunamadƒ± veya baƒülƒ± deƒüil');
                return false;
            }

            console.log(`üìç Motor ${angle}¬∞ pozisyonuna g√∂nderiliyor...`);

            // Command characteristic - HER ZAMAN TAZE√¢ AL (cache kullanma, stale olabilir)
            let cmdChar = null;
            const charUUID = '0000fd02-0001-1000-8000-00805f9b34fb';
            const serviceUUID = '0000fd02-0000-1000-8000-00805f9b34fb';

            try {
                console.log('   üîÑ Servis ve Characteristic taze alƒ±nƒ±yor...');
                const service = await deviceData.server.getPrimaryService(serviceUUID);
                cmdChar = await service.getCharacteristic(charUUID);
                console.log('   ‚úÖ Taze characteristic alƒ±ndƒ±:', cmdChar.uuid);
            } catch (e) {
                console.error('   ‚ùå Characteristic alƒ±namadƒ±:', e);
                return false;
            }

            console.log('   üîó Kullanƒ±lan Characteristic:', cmdChar.uuid);

            // Pozisyon deƒüerini little-endian formatƒ±nda hazƒ±rla
            // A√ßƒ± negatif olabilir veya 360'tan b√ºy√ºk olabilir
            const posBytes = angle & 0xFFFF;
            const lowByte = posBytes & 0xFF;
            const highByte = (posBytes >> 8) & 0xFF;

            // 0. Notify Characteristic'i bul ve Subscribe ol
            try {
                const notifyUUID = '0000fd02-0002-1000-8000-00805f9b34fb';
                let notifyChar = null;

                if (deviceData.characteristics) {
                    notifyChar = deviceData.characteristics[notifyUUID];
                }

                // Cache'te yoksa servisten al (writeChar'ƒ±n servisini kullanabiliriz if available in obj or refetch)
                if (!notifyChar && cmdChar.service) {
                    try {
                        notifyChar = await cmdChar.service.getCharacteristic(notifyUUID);
                    } catch (e) { console.log('   ‚ö†Ô∏è Notify char servisten alƒ±namadƒ±'); }
                }

                if (notifyChar) {
                    // Start notifications safely
                    console.log('   üîî Notifications ba≈ülatƒ±lƒ±yor (Handshake i√ßin)...');
                    await notifyChar.startNotifications();
                }
            } catch (err) {
                console.log('   ‚ö†Ô∏è Notification ba≈ülatma hatasƒ± (kritik olmayabilir):', err);
            }

            try {
                // Verify connection is still active
                console.log('   üîç GATT Baƒülantƒ± durumu:', deviceData.server.connected ? '‚úÖ Baƒülƒ±' : '‚ùå Baƒülƒ± DEƒûƒ∞L');

                if (!deviceData.server.connected) {
                    console.error('   ‚ùå GATT baƒülantƒ±sƒ± kopmu≈ü! Yeniden baƒülanmayƒ± deneyin.');
                    return false;
                }

                // Log characteristic properties
                console.log('   üìã Characteristic √∂zellikleri:', {
                    uuid: cmdChar.uuid,
                    write: cmdChar.properties.write,
                    writeWithoutResponse: cmdChar.properties.writeWithoutResponse
                });

                // 1. Ba≈ülatma komutu: 20 00
                const startCmd = new Uint8Array([0x20, 0x00]);
                console.log('   üì§ CMD1 (Start) g√∂nderiliyor:', [...startCmd].map(b => b.toString(16).padStart(2, '0')).join(' '));

                try {
                    await cmdChar.writeValueWithoutResponse(startCmd);
                    console.log('   ‚úÖ CMD1 yazƒ±ldƒ± ba≈üarƒ±lƒ±');
                } catch (writeErr) {
                    console.error('   ‚ùå CMD1 yazma hatasƒ±:', writeErr);
                    return false;
                }

                await new Promise(resolve => setTimeout(resolve, 50));

                // 2. Pozisyon komutu: 80 [PORT] [LOW] [HIGH] 02
                // Port ID belirsiz olabilir (0, 1, 2 vb.), hepsini deneyelim (Shotgun approach)
                const ports = [0x00, 0x01, 0x02];
                let anySuccess = false;

                for (const port of ports) {
                    const positionCmd = new Uint8Array([0x80, port, lowByte, highByte, 0x02]);
                    console.log(`   üì§ CMD2 (Pos) g√∂nderiliyor (Port ${port}):`, [...positionCmd].map(b => b.toString(16).padStart(2, '0')).join(' '));

                    try {
                        await cmdChar.writeValueWithoutResponse(positionCmd);
                        console.log(`   ‚úÖ CMD2 (Port ${port}) yazƒ±ldƒ± ba≈üarƒ±lƒ±`);
                        anySuccess = true;
                        // Komutlar arasƒ±nda kƒ±sa bekleme
                        await new Promise(resolve => setTimeout(resolve, 30));
                    } catch (writeErr) {
                        console.error(`   ‚ùå CMD2 (Port ${port}) yazma hatasƒ±:`, writeErr);
                    }
                }

                if (!anySuccess) return false;

                // Update State
                motorState.currentAngle = angle;
                motorState.targetAngle = angle;
                updateMotorAngleDisplay(angle);

                return true;
            } catch (err) {
                console.error('‚ùå Motor komut hatasƒ±:', err);
                return false;
            }
        }

        // Motor rotasyon √ßalƒ±≈ütƒ±r
        /*
         * NOT: sendMotorPositionCommand fonksiyonu, belirli bir marka/model (√∂rn. Robot Invader) 
         * BLE motorlar i√ßin bir "Shotgun" yakla≈üƒ±mla port taramasƒ± yapar.
         * Standart port (0x01) bazen √ßalƒ±≈ümayabilir, bu y√ºzden 0x00, 0x01, 0x02 denenir.
         * Bu sayede "Go to Position" gibi komutlarƒ±n kararlƒ± √ßalƒ±≈ümasƒ± saƒülanmƒ±≈ütƒ±r.
         */

        // Motor rotasyon √ßalƒ±≈ütƒ±r (Karma≈üƒ±k 43-Komut Protokol√º - Restore Edildi)
        // Kullanƒ±cƒ± geri bildirimi: "Eskiden 0/43, 10/43 loglarƒ± vardƒ± ve tam tur atƒ±yordu."
        async function runMotorRotations(deviceId, rotations, direction = 'CW') {
            if (motorOperationInProgress) {
                console.log('‚è≥ Ba≈üka bir motor i≈ülemi devam ediyor...');
                return;
            }
            motorOperationInProgress = true;

            try {
                // 1. √ñnce eski protokol√ºn ihtiya√ß duyduƒüu ba≈ülatma sekansƒ±nƒ± g√∂nder
                await initializeMotor(deviceId);

                const chars = await getMotorCharacteristics(deviceId);
                if (!chars) {
                    console.error('‚ùå Karakteristikler alƒ±namadƒ±!');
                    return;
                }

                // Genellikle ilk karakteristik (fd02-0001) yazma i√ßin uygundur
                const writeChar = Object.values(chars)[0];
                if (!writeChar) {
                    console.error('‚ùå Yazƒ±labilir karakteristik bulunamadƒ±');
                    return;
                }

                // Number'a √ßevir ve default 1 yap
                const r = Number(rotations);
                const validRotations = isNaN(r) ? 1 : r;

                console.log(`üîÑ ${validRotations} rotasyon ba≈ülatƒ±lƒ±yor (${direction}) - 43 Komut Protokol√º...`);

                // 2. 43 adet MOTOR_BASE komutu g√∂nder (Hƒ±zlanma/Hazƒ±rlƒ±k?)
                // "GATT operation already in progress" hatasƒ±nƒ± √∂nlemek i√ßin delay ekliyoruz
                const totalCommands = 43;
                for (let i = 0; i < totalCommands; i++) {
                    // writeMotorCommand i√ßinde 50ms delay var, burada ekstra g√ºvenli yapalƒ±m (100ms total)
                    await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_BASE, 50);
                    if (i % 10 === 0) console.log(`   üì§ ${i}/${totalCommands} komut g√∂nderildi`);
                }

                // 3. Kontrol ve tekrar Base
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_CONTROL);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_BASE);

                // 4. Execute Komutu (Rotasyon sayƒ±sƒ± ve y√∂n burada)
                const executeCmd = createExecuteCommand(validRotations, true, direction);
                await writeMotorCommand(writeChar, executeCmd);

                // 5. Hƒ±z deƒüi≈üimleri
                for (const cmd of MOTOR_SPEED_CHANGES) {
                    await writeMotorCommand(writeChar, cmd);
                }

                // 6. Devam komutlarƒ± (Magic bytes from PCAP)
                const rotationCommands = [
                    hexToBytes("3c:12:00:00:64:00:0a:01:01:21:00:97:22:11:22:00:00:00:11:01:ff"),
                    hexToBytes("3c:12:00:00:64:00:0a:01:01:50:00:60:22:18:51:00:00:00:11:01:ff"),
                    hexToBytes("3c:12:00:00:64:00:0a:01:01:7e:00:ee:21:1f:7f:00:00:00:11:01:ff"),
                ];

                for (const cmd of rotationCommands) {
                    await writeMotorCommand(writeChar, cmd);
                }

                // 7. Durma sekansƒ±
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_STOP_INIT);

                for (const cmd of MOTOR_SLOWDOWN) {
                    await writeMotorCommand(writeChar, cmd);
                }

                // Final temizlik
                for (let i = 0; i < 5; i++) {
                    await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_BASE, 30);
                }

                console.log('‚úÖ Rotasyon komutlarƒ± tamamlandƒ±!');

                // State g√ºncelle (Tahmini)
                let current = motorState.currentAngle || 0;
                let delta = validRotations * 360 * (direction === 'CCW' ? -1 : 1);
                motorState.currentAngle = current + delta;
                updateMotorAngleDisplay(motorState.currentAngle);

            } catch (err) {
                console.error('‚ùå Rotasyon hatasƒ±:', err);
            } finally {
                motorOperationInProgress = false;
            }
        }


        // Motor a√ßƒ±ya git (G√∂receli hareket: Mevcut + A√ßƒ±)
        // Kullanƒ±cƒ± "Run to Angle" bloƒüunu "Turn By Angle" (G√∂receli D√∂n√º≈ü) olarak bekliyor.
        async function runMotorToAngle(deviceId, angle, direction = 'CW') {
            if (motorOperationInProgress) {
                console.log('‚è≥ Ba≈üka bir motor i≈ülemi devam ediyor...');
                return;
            }
            motorOperationInProgress = true;

            try {
                console.log(`üéØ ${angle}¬∞ a√ßƒ±ya g√∂receli gidiliyor (${direction})...`);

                let current = motorState.currentAngle || 0;
                let targetDelta = angle;

                if (direction === 'CCW') {
                    targetDelta = -targetDelta;
                }

                const targetAngle = current + targetDelta;
                console.log(`   üìç A√ßƒ± Hedef: ${current}¬∞ + ${targetDelta}¬∞ = ${targetAngle}¬∞`);

                const success = await sendMotorPositionCommand(deviceId, targetAngle);
                if (success) {
                    const waitTime = Math.max(500, Math.abs(targetDelta) * 10);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                    console.log(`‚úÖ ${angle}¬∞ deƒüi≈üimi tamamlandƒ±!`);
                }
            } finally {
                motorOperationInProgress = false;
            }
        }

        // Motor mutlak pozisyona git (Eski fonksiyonu koru ama yeni helper'ƒ± kullansƒ±n)
        // PCAP ANALƒ∞Zƒ∞ (capturing_bluetooth_67angle.pcap):
        // Frame 23: 20 00            ‚Üí Handle 0x000c (CMD char) - Ba≈ülatma komutu
        // Frame 25: 80 01 43 00 02   ‚Üí Handle 0x000c (CMD char) - 67¬∞ pozisyon komutu (0x43 = 67)
        // Frame 86: 20 01            ‚Üí Handle 0x000c (CMD char) - Tamamlama komutu (opsiyonel)
        async function goToPosition(deviceId, position) {
            if (motorOperationInProgress) {
                console.log('‚è≥ Ba≈üka bir motor i≈ülemi devam ediyor...');
                return;
            }
            motorOperationInProgress = true;
            try {
                const success = await sendMotorPositionCommand(deviceId, position);
                if (success) {
                    const waitTime = Math.max(500, Math.abs(position - (motorState.currentAngle || 0)) * 10);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                    console.log(`‚úÖ ${position}¬∞ pozisyonuna gidildi!`);
                }
            } finally {
                motorOperationInProgress = false;
            }
        }

        // Motor ba≈ülat (s√ºrekli d√∂nme)
        async function startMotor(deviceId, direction = 'CW') {
            // Motor i≈ülemi devam ediyorsa bekle
            if (motorOperationInProgress) {
                console.log('‚è≥ Ba≈üka bir motor i≈ülemi devam ediyor, bekleniyor...');
                return;
            }

            motorOperationInProgress = true;

            try {
                const chars = await getMotorCharacteristics(deviceId);

                if (!chars) {
                    console.error('‚ùå Karakteristikler alƒ±namadƒ±!');
                    return;
                }

                console.log(`‚ñ∂Ô∏è Motor ${direction === 'CW' ? 'saƒüa ‚Üª' : 'sola ‚Ü∫'} ba≈ülatƒ±lƒ±yor...`);

                const writeChar = Object.values(chars)[0];

                if (!writeChar) {
                    console.error('‚ùå Yazƒ±labilir karakteristik bulunamadƒ±');
                    return;
                }

                // Ba≈ülatma komutlarƒ±
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_START);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_INIT_1);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_PREPARE);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_INIT_2);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_MODE);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_INIT_3);

                // Y√∂ne g√∂re motor base komutu
                const motorBaseCmd = createMotorBaseCommand(direction);

                // Sabit hƒ±z komutlarƒ± (43 komut)
                for (let i = 0; i < 43; i++) {
                    await writeMotorCommand(writeChar, motorBaseCmd, 30);
                }

                // Kontrol ve execute
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_CONTROL);
                await writeMotorCommand(writeChar, motorBaseCmd);

                // S√ºrekli d√∂nme i√ßin y√ºksek rotasyon execute komutu
                const continuousRotations = 100;
                const executeCmd = createExecuteCommand(continuousRotations, true, direction);
                await writeMotorCommand(writeChar, executeCmd);

                console.log(`‚úÖ Motor ${direction === 'CW' ? 'saƒüa ‚Üª' : 'sola ‚Ü∫'} ba≈ülatƒ±ldƒ±!`);
            } finally {
                motorOperationInProgress = false;
            }
        }

        // Motor durdur
        async function stopMotor(deviceId) {
            // Stop komutu her zaman √ßalƒ±≈üabilmeli - kilidi temizle ve √ßalƒ±≈ütƒ±r
            motorOperationInProgress = false;

            try {
                const chars = await getMotorCharacteristics(deviceId);

                if (!chars) {
                    console.error('‚ùå Karakteristikler alƒ±namadƒ±!');
                    return;
                }

                console.log('‚èπÔ∏è Motor durduruluyor...');

                const writeChar = Object.values(chars)[0];

                if (!writeChar) {
                    console.error('‚ùå Yazƒ±labilir karakteristik bulunamadƒ±');
                    return;
                }

                // √áoklu durma yakla≈üƒ±mƒ±
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_STOP_INIT);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_STOP_INIT);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_STOP_INIT);

                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_CONTROL);
                const stopExecute = new Uint8Array([0x7c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00]);
                await writeMotorCommand(writeChar, stopExecute);

                for (const cmd of MOTOR_SLOWDOWN) {
                    await writeMotorCommand(writeChar, cmd, 50);
                }

                for (let i = 0; i < 30; i++) {
                    await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_BASE, 10);
                }

                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_STOP_INIT);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_BRAKE);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_FLOAT);

                console.log('‚úÖ Motor durduruldu!');
            } catch (error) {
                console.error('‚ùå stopMotor hatasƒ±:', error);
            }
        }

        // Cihaz tiplerini isimden algƒ±la
        function detectDeviceType(deviceName) {
            const name = deviceName.toLowerCase();
            if (name.includes('motor')) return 'motor';
            if (name.includes('controller') || name.includes('joystick') || name.includes('gamepad')) return 'controller';
            if (name.includes('sensor')) return 'sensor';
            return 'generic';
        }



        // Cihaz tipine g√∂re √∂zel bloklar
        const DEVICE_BLOCKS = {
            'motor': [
                {
                    type: 'motor_run_rotation',
                    icon: 'rotate',
                    label: 'run for [1] rotations',
                    color: '#4ECDC4'
                },
                {
                    type: 'motor_run_seconds',
                    icon: 'timer',
                    label: 'run for [1] seconds',
                    color: '#4ECDC4'
                },
                {
                    type: 'motor_set_speed',
                    icon: 'speed',
                    label: 'set speed to [100]%',
                    color: '#4ECDC4'
                },
                {
                    type: 'motor_stop',
                    icon: 'stop',
                    label: 'stop',
                    color: '#4ECDC4'
                }
            ],
            'controller': [
                {
                    type: 'when_lever_up',
                    icon: 'üïπÔ∏è',
                    label: 'when left lever is up',
                    color: '#45B7D1',
                    isEvent: true
                },
                {
                    type: 'when_lever_down',
                    icon: 'üïπÔ∏è',
                    label: 'when left lever is down',
                    color: '#45B7D1',
                    isEvent: true
                },
                {
                    type: 'when_button_pressed',
                    icon: 'üîò',
                    label: 'when button A pressed',
                    color: '#45B7D1',
                    isEvent: true
                }
            ],
            'generic': [
                {
                    type: 'device_command',
                    icon: 'üì°',
                    label: 'send command',
                    color: '#98D8C8'
                }
            ]
        };

        function getRandomShape() {
            return DEVICE_SHAPES[Math.floor(Math.random() * DEVICE_SHAPES.length)];
        }

        function getRandomColor() {
            return DEVICE_COLORS[Math.floor(Math.random() * DEVICE_COLORS.length)];
        }

        function addDeviceToSidebar(device, overrideColor = null) {
            const deviceType = detectDeviceType(device.name || '');

            const deviceData = {
                id: device.id,
                name: device.name || 'Motor',
                type: deviceType,
                shape: getRandomShape(),
                color: overrideColor || getRandomColor(),
                device: device,
                server: bluetoothServer,
                characteristics: { ...connectedCharacteristics },
                connected: true
            };

            connectedDevices.push(deviceData);

            // Ana device list'e ekle
            const deviceList = document.getElementById('deviceList');
            const deviceIcon = document.createElement('div');
            deviceIcon.className = `device-icon ${deviceData.shape}`;
            deviceIcon.dataset.deviceId = deviceData.id;
            deviceIcon.title = deviceData.name;

            // Controller i√ßin √∂zel stil
            if (deviceType === 'controller') {
                deviceIcon.classList.add('controller');
                deviceIcon.style.setProperty('--device-color', deviceData.color);

                // Normal durumda beyaz arka plan, siyah yazƒ±
                deviceIcon.style.background = '#FFFFFF';
                deviceIcon.style.borderColor = deviceData.color;
                deviceIcon.style.color = 'black';

                deviceIcon.innerHTML = '<img src="controller.png" style="width: 28px; height: 28px; object-fit: contain;">';
                // deviceIcon.style.fontSize = '16px'; // No longer needed
            } else {
                deviceIcon.style.borderColor = deviceData.color;
                deviceIcon.style.color = deviceData.color;

                // Single Motor i√ßin √∂zel kontrol
                if (deviceData.name && deviceData.name.toLowerCase().includes('single motor')) {
                    deviceIcon.innerHTML = '<img src="single-motor.png" style="width: 28px; height: 28px; object-fit: contain;">';
                } else {
                    // Diƒüer cihazlar i√ßin ID'nin son 4 karakteri
                    const shortId = deviceData.id.split('-').pop().substring(0, 4).toUpperCase();
                    deviceIcon.innerHTML = `${shortId}`;
                }
            }

            deviceIcon.onclick = (e) => {
                e.stopPropagation();

                // T√ºm ikonlardan se√ßili durumunu kaldƒ±r
                document.querySelectorAll('.device-icon').forEach(icon => icon.classList.remove('selected'));

                // Eƒüer aynƒ± cihaza tekrar tƒ±klandƒ±ysa toolbox'ƒ± kapat
                if (currentToolboxDevice === deviceData.id && currentToolboxMode === 'device') {
                    hideAllToolboxes();
                    currentToolboxDevice = null;
                } else {
                    // Farklƒ± cihaz - cihaz bloklarƒ±nƒ± toolbox'ta g√∂ster
                    currentToolboxDevice = deviceData.id;
                    showDeviceToolbox(deviceData);
                    deviceIcon.classList.add('selected');
                }
            };

            deviceList.appendChild(deviceIcon);

            // Tabloyu g√ºncelle
            updateDevicesTable();

            console.log('Cihaz eklendi:', deviceData);
        }

        function toggleDeviceMenu(deviceData) {
            const sidebar = document.getElementById('sidebar');
            const panelTitle = document.getElementById('panelTitle');
            const panelContent = document.getElementById('panelContent');
            const icon = document.querySelector(`[data-device-id="${deviceData.id}"]`);

            // Aynƒ± cihaza tekrar tƒ±klanƒ±rsa kapat
            if (deviceMenuOpen === deviceData.id) {
                sidebar.classList.remove('expanded');
                icon.classList.remove('active');
                deviceMenuOpen = null;
                return;
            }

            // √ñnceki aktif ikonu temizle
            document.querySelectorAll('.device-icon').forEach(i => i.classList.remove('active'));
            icon.classList.add('active');

            // Panel i√ßeriƒüini olu≈ütur
            const blocks = DEVICE_BLOCKS[deviceData.type] || DEVICE_BLOCKS['generic'];
            panelTitle.textContent = `${deviceData.name} Bloklarƒ±`;
            panelContent.innerHTML = '';

            blocks.forEach(blockDef => {
                const blockDiv = document.createElement('div');
                blockDiv.className = 'device-menu-block';

                // Ge√ßici bir Blockly bloƒüu olu≈ütur
                const tempBlockType = `temp_${deviceData.id}_${blockDef.type}`;

                // Blok tipini tanƒ±mla
                if (!Blockly.Blocks[tempBlockType]) {
                    createDeviceBlock(tempBlockType, blockDef, deviceData);
                }

                try {
                    // Workspace'de ge√ßici blok olu≈ütur
                    const tempBlock = workspace.newBlock(tempBlockType);
                    tempBlock.initSvg();
                    tempBlock.render();

                    // Bloƒüun SVG'sini al
                    const blockSvg = tempBlock.getSvgRoot();
                    const bbox = blockSvg.getBBox();

                    // SVG wrapper olu≈ütur
                    const svgWrapper = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svgWrapper.setAttribute('width', bbox.width + 10);
                    svgWrapper.setAttribute('height', bbox.height + 10);
                    svgWrapper.setAttribute('viewBox', `${bbox.x - 5} ${bbox.y - 5} ${bbox.width + 10} ${bbox.height + 10}`);

                    // ƒ∞√ßeriƒüi clone'la
                    const clonedContent = blockSvg.cloneNode(true);
                    svgWrapper.appendChild(clonedContent);

                    blockDiv.appendChild(svgWrapper);

                    // Ge√ßici bloƒüu sil
                    tempBlock.dispose(false);

                } catch (error) {
                    console.error('Blok √∂nizleme hatasƒ±:', error);
                    // Hata durumunda basit g√∂sterim
                    blockDiv.innerHTML = `
                        <div style="background: ${blockDef.color}; color: white; padding: 10px 15px; border-radius: 8px; font-size: 13px; font-weight: 600;">
                            ${blockDef.icon} ${blockDef.label}
                        </div>
                    `;
                }

                // Drag and drop
                blockDiv.draggable = true;

                blockDiv.ondragstart = (e) => {
                    e.dataTransfer.effectAllowed = 'copy';
                    e.dataTransfer.setData('blockType', blockDef.type);
                    e.dataTransfer.setData('deviceId', deviceData.id);
                    blockDiv.style.opacity = '0.5';
                };

                blockDiv.ondragend = (e) => {
                    blockDiv.style.opacity = '1';
                };

                panelContent.appendChild(blockDiv);
            });

            // Sidebar'ƒ± geni≈ület
            sidebar.classList.add('expanded');
            deviceMenuOpen = deviceData.id;
        }

        function adjustColor(color, amount) {
            const num = parseInt(color.replace("#", ""), 16);
            const r = Math.max(0, Math.min(255, (num >> 16) + amount));
            const g = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amount));
            const b = Math.max(0, Math.min(255, (num & 0x0000FF) + amount));
            return "#" + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
        }

        // Workspace'e drop handler ekle
        function setupWorkspaceDrop() {
            const workspaceDiv = document.getElementById('blocklyDiv');

            workspaceDiv.ondragover = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            };

            workspaceDiv.ondrop = (e) => {
                e.preventDefault();
                const blockType = e.dataTransfer.getData('blockType');
                const deviceId = e.dataTransfer.getData('deviceId');

                if (blockType && deviceId) {
                    const deviceData = connectedDevices.find(d => d.id === deviceId);
                    const blockDef = Object.values(DEVICE_BLOCKS).flat()
                        .find(b => b.type === blockType);

                    if (deviceData && blockDef) {
                        // Mouse pozisyonunu Blockly koordinatlarƒ±na √ßevir
                        const metrics = workspace.getMetrics();
                        const scale = workspace.scale;

                        // Blockly canvas'ƒ±nƒ±n pozisyonunu al
                        const blocklyRect = workspaceDiv.getBoundingClientRect();

                        // Mouse pozisyonunu workspace koordinatlarƒ±na √ßevir
                        const x = (e.clientX - blocklyRect.left) / scale - metrics.viewLeft;
                        const y = (e.clientY - blocklyRect.top) / scale - metrics.viewTop;

                        addDeviceBlockToWorkspace(blockDef, deviceData, x, y);
                    }
                }
            };
        }

        function addDeviceBlockToWorkspace(blockDef, deviceData, x, y) {
            // Dinamik blok olu≈ütur
            const blockType = `${deviceData.id}_${blockDef.type}`;

            // Blok zaten tanƒ±mlƒ± deƒüilse olu≈ütur
            if (!Blockly.Blocks[blockType]) {
                createDeviceBlock(blockType, blockDef, deviceData);
            }

            // Workspace'e ekle
            const newBlock = workspace.newBlock(blockType);
            newBlock.initSvg();
            newBlock.render();

            // Pozisyon belirtilmi≈üse kullan, yoksa varsayƒ±lan
            if (x !== undefined && y !== undefined) {
                newBlock.moveBy(x, y);
            } else {
                newBlock.moveBy(200, 100);
            }

            console.log('Cihaz bloƒüu eklendi:', blockType, 'at', x, y);
        }

        function createDeviceBlock(blockType, blockDef, deviceData) {
            Blockly.Blocks[blockType] = {
                init: function () {
                    const input = this.appendDummyInput();

                    if (DEVICE_ICONS[blockDef.icon]) {
                        input.appendField(new Blockly.FieldImage(DEVICE_ICONS[blockDef.icon], 16, 16, "*"));
                    } else {
                        input.appendField(blockDef.icon);
                    }

                    // Label'ƒ± par√ßala ve number field'larƒ± ekle
                    const parts = blockDef.label.split(/\[|\]/);
                    parts.forEach((part, index) => {
                        if (index % 2 === 0) {
                            // Normal text
                            if (part.trim()) input.appendField(part.trim());
                        } else {
                            // Number field
                            const value = parseInt(part) || 1;
                            input.appendField(new CustomNumberField(value, 1, 100), `VAL${index}`);
                        }
                    });

                    if (blockDef.isEvent) {
                        this.setNextStatement(true, null);
                    } else {
                        this.setPreviousStatement(true, null);
                        this.setNextStatement(true, null);
                    }

                    this.setColour(blockDef.color);
                    this.data = deviceData.id;
                }
            };

            // Kod √ºretici
            Blockly.Python[blockType] = function (block) {
                return `# ${deviceData.name}: ${blockDef.label}\n`;
            };
        }

        function updateDevicesTable() {
            const tbody = document.getElementById('devicesTableBody');
            const t = TRANSLATIONS[currentLanguage];

            if (connectedDevices.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="4" style="padding: 30px; text-align: center; color: #999;">
                            ${t.no_device}
                        </td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = '';

            connectedDevices.forEach((device, index) => {
                const row = document.createElement('tr');
                row.style.borderBottom = '1px solid #e0e0e0';
                row.style.background = index % 2 === 0 ? 'white' : '#f9f9f9';

                const statusIcon = device.connected ? 'üü¢' : 'üî¥';
                const statusText = device.connected ? t.status_connected : t.status_disconnected;
                const statusColor = device.connected ? '#0FBD8C' : '#FF6680';

                row.innerHTML = `
                    <td style="padding: 12px; font-size: 14px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div style="width: 20px; height: 20px; border-radius: 50%; background: ${device.color}; border: 2px solid ${device.color};"></div>
                            <strong>${device.name}</strong>
                        </div>
                    </td>
                    <td style="padding: 12px; font-size: 12px; color: #666; font-family: monospace;">
                        ${device.id}
                    </td>
                    <td style="padding: 12px; text-align: center;">
                        <span style="background: ${statusColor}20; color: ${statusColor}; padding: 4px 12px; border-radius: 12px; font-size: 12px; font-weight: bold;">
                            ${statusIcon} ${statusText}
                        </span>
                    </td>
                    <td style="padding: 12px; text-align: center;">
                        <button onclick="removeDeviceFromTable('${device.id}')" style="background: #FF6680; color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: bold; display: flex; align-items: center; gap: 6px;">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="white"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
                            ${t.btn_remove}
                        </button>
                    </td>
                `;

                tbody.appendChild(row);
            });
        }

        let pendingRemoveDeviceId = null;

        function removeDeviceFromTable(deviceId) {
            pendingRemoveDeviceId = deviceId;
            const modal = document.getElementById('removeDeviceModal');
            if (modal) {
                modal.classList.add('active');
            }
        }

        function closeRemoveDeviceModal() {
            const modal = document.getElementById('removeDeviceModal');
            if (modal) {
                modal.classList.remove('active');
            }
            pendingRemoveDeviceId = null;
        }

        function confirmRemoveDevice() {
            if (pendingRemoveDeviceId) {
                removeDevice(pendingRemoveDeviceId);
            }
            closeRemoveDeviceModal();
        }

        let selectedBlock = null;

        function handleBlockSelection(event) {
            const deleteOverlay = document.getElementById('deleteBlockOverlay');

            if (event.newElementId) {
                // Bir blok se√ßildi
                selectedBlock = workspace.getBlockById(event.newElementId);
                if (selectedBlock) {
                    deleteOverlay.classList.add('show');
                }
            } else {
                // Se√ßim kaldƒ±rƒ±ldƒ±
                selectedBlock = null;
                deleteOverlay.classList.remove('show');
            }
        }

        function deleteSelectedBlock() {
            if (selectedBlock) {
                selectedBlock.dispose(true);
                selectedBlock = null;
                document.getElementById('deleteBlockOverlay').classList.remove('show');
            }
        }

        function duplicateSelectedBlock() {
            if (selectedBlock && workspace) {
                // Blok XML'ini al
                const xml = Blockly.Xml.blockToDom(selectedBlock);
                // Yeni blok olu≈ütur
                const newBlock = Blockly.Xml.domToBlock(xml, workspace);
                // Yeni bloƒüu biraz kaydƒ±r
                const oldPos = selectedBlock.getRelativeToSurfaceXY();
                newBlock.moveBy(oldPos.x + 30, oldPos.y + 30);
                console.log('üìã Blok kopyalandƒ±');
            }
        }

        function selectDevice(deviceId) {
            const icon = document.querySelector(`[data-device-id="${deviceId}"]`);

            // Toggle se√ßimi
            if (selectedDeviceId === deviceId) {
                // Aynƒ± cihaza basƒ±ldƒ± - se√ßimi kaldƒ±r
                if (icon) icon.classList.remove('selected');
                selectedDeviceId = null;
                document.getElementById('disconnectOverlay').classList.remove('show');
                console.log('Se√ßim iptal edildi');
            } else {
                // Farklƒ± cihaz se√ßildi
                document.querySelectorAll('.device-icon').forEach(i => {
                    i.classList.remove('selected');
                });

                if (icon) {
                    icon.classList.add('selected');
                    selectedDeviceId = deviceId;
                    document.getElementById('disconnectOverlay').classList.add('show');
                    console.log('Se√ßili cihaz:', deviceId);
                }
            }
        }

        function disconnectSelectedDevice() {
            if (selectedDeviceId) {
                removeDevice(selectedDeviceId);
            }
        }

        function removeDevice(deviceId, event) {
            if (event) event.stopPropagation();

            const device = connectedDevices.find(d => d.id === deviceId);
            if (device && device.device && device.device.gatt.connected) {
                device.device.gatt.disconnect();
            }

            connectedDevices = connectedDevices.filter(d => d.id !== deviceId);

            const icon = document.querySelector(`[data-device-id="${deviceId}"]`);
            if (icon) {
                icon.remove();
            }

            if (selectedDeviceId === deviceId) {
                selectedDeviceId = null;
                document.getElementById('disconnectOverlay').classList.remove('show');

                if (connectedDevices.length > 0) {
                    selectDevice(connectedDevices[0].id);
                }
            }

            // Tabloyu g√ºncelle
            updateDevicesTable();

            console.log('Cihaz kaldƒ±rƒ±ldƒ±:', deviceId);
        }

        function getSelectedDevice() {
            return connectedDevices.find(d => d.id === selectedDeviceId);
        }

        function getDeviceIcon(deviceId) {
            const device = connectedDevices.find(d => d.id === deviceId);
            if (!device) return '';

            // SVG shape generator - daha k√º√ß√ºk
            let shape = '';
            const size = 14;
            const color = device.color;

            switch (device.shape) {
                case 'triangle':
                    shape = `<svg width="${size}" height="${size}"><polygon points="${size / 2},0 0,${size} ${size},${size}" fill="${color}"/></svg>`;
                    break;
                case 'square':
                    shape = `<svg width="${size}" height="${size}"><rect width="${size}" height="${size}" rx="2" fill="${color}"/></svg>`;
                    break;
                case 'rectangle':
                    shape = `<svg width="${size}" height="${size * 0.7}"><rect width="${size}" height="${size * 0.7}" rx="2" fill="${color}"/></svg>`;
                    break;
                case 'pentagon':
                    shape = `<svg width="${size}" height="${size}"><polygon points="${size / 2},0 ${size},${size * 0.38} ${size * 0.82},${size} ${size * 0.18},${size} 0,${size * 0.38}" fill="${color}"/></svg>`;
                    break;
                case 'hexagon':
                    shape = `<svg width="${size}" height="${size}"><polygon points="${size / 2},0 ${size},${size * 0.25} ${size},${size * 0.75} ${size / 2},${size} 0,${size * 0.75} 0,${size * 0.25}" fill="${color}"/></svg>`;
                    break;
                case 'octagon':
                    shape = `<svg width="${size}" height="${size}"><polygon points="${size * 0.3},0 ${size * 0.7},0 ${size},${size * 0.3} ${size},${size * 0.7} ${size * 0.7},${size} ${size * 0.3},${size} 0,${size * 0.7} 0,${size * 0.3}" fill="${color}"/></svg>`;
                    break;
                case 'circle':
                    shape = `<svg width="${size}" height="${size}"><circle cx="${size / 2}" cy="${size / 2}" r="${size / 2}" fill="${color}"/></svg>`;
                    break;
            }

            return shape;
        }

        const OPTIONAL_SERVICES = [
            'generic_access', 'generic_attribute', 'device_information', 'battery_service',
            '00002a05-0000-1000-8000-00805f9b34fb', '00002b2a-0000-1000-8000-00805f9b34fb',
            '0000fd02-0000-1000-8000-00805f9b34fb', '0000fd02-0001-1000-8000-00805f9b34fb', '0000fd02-0002-1000-8000-00805f9b34fb',
            0x1800, 0x1801, 0x180a, 0x180f, 0x2a05, 0x2b2a, 0xfd02,
            0xffe0, 0xffe1, 0xffe2, 0xffe3, 0xffe4, 0xffe5, 0xffe6, 0xffe7, 0xffe8, 0xffe9,
            0x1623, 0x1624, 0x1625, 0x1626,
            '00001623-1212-efde-1623-785feabcd123', '00001624-1212-efde-1623-785feabcd123', '00001625-1212-efde-1623-785feabcd123',
            '0000ffe0-0000-1000-8000-00805f9b34fb', '0000ffe1-0000-1000-8000-00805f9b34fb'
        ];

        function openSpecificDeviceModal() {
            document.getElementById('specificDeviceModal').classList.add('show');
        }

        function closeSpecificDeviceModal() {
            document.getElementById('specificDeviceModal').classList.remove('show');
        }

        async function scanSpecificDevice(type) {
            closeSpecificDeviceModal();
            let options = { filters: [] };
            if (type === 'controller') {
                // "Controller" veya "Handset" ile ba≈ülayanlar
                options.filters.push({ namePrefix: 'Controller' });
                options.filters.push({ namePrefix: 'Handset' });
                options.filters.push({ namePrefix: '‚¨úÔ∏è' });
            } else if (type === 'single_motor') {
                // "Single Motor" veya emoji ile ba≈ülayanlar (API sadece startsWith destekler)
                options.filters.push({ namePrefix: 'Single Motor' });
                options.filters.push({ namePrefix: '‚¨úÔ∏è' });
            }
            await scanDeviceInternal(options);
        }

        async function scanAndConnect() {
            await scanDeviceInternal({ acceptAllDevices: true });
        }

        async function scanDeviceInternal(customOptions) {
            // Bluetooth kontrol√º
            if (!navigator.bluetooth) {
                alert('‚ùå Tarayƒ±cƒ±nƒ±z Web Bluetooth desteklemiyor!\n\nChrome, Edge veya Opera kullanƒ±n.');
                return;
            }

            try {
                const scanStatus = document.getElementById('scanStatus');
                const t = TRANSLATIONS[currentLanguage];
                scanStatus.style.display = 'block';
                scanStatus.textContent = t.device_list_opening;

                // Motor/cihaz tarama
                const requestOptions = {
                    optionalServices: OPTIONAL_SERVICES,
                    ...customOptions
                };
                bluetoothDevice = await navigator.bluetooth.requestDevice(requestOptions);

                scanStatus.textContent = `${t.connecting_to} ${bluetoothDevice.name || t.unknown_device}...`;
                console.log('Se√ßilen cihaz:', bluetoothDevice.name, bluetoothDevice.id);

                // GATT sunucusuna baƒülan
                bluetoothServer = await bluetoothDevice.gatt.connect();

                // Rengi √∂nceden belirle, b√∂ylece hem sidebar hem panel aynƒ± rengi kullanƒ±r
                const assignedColor = getRandomColor();

                scanStatus.textContent = `${t.connected_to} ${bluetoothDevice.name || bluetoothDevice.id}`;

                console.log('GATT server connected');
                console.log('Server:', bluetoothServer);
                console.log('Server.connected:', bluetoothServer.connected);

                // Servisleri al ve logla
                try {
                    console.log('‚Üí getPrimaryServices() √ßaƒürƒ±lƒ±yor...');
                    const services = await bluetoothServer.getPrimaryServices();
                    console.log(`‚úì ${services.length} servis bulundu!`);

                    for (const service of services) {
                        console.log(`  Servis UUID: ${service.uuid}`);
                        try {
                            const chars = await service.getCharacteristics();
                            console.log(`    ${chars.length} karakteristik bulundu`);

                            let writeChar = null;
                            let notifyChar = null;

                            for (const char of chars) {
                                console.log(`      - ${char.uuid} (write: ${char.properties.write}, writeNoResp: ${char.properties.writeWithoutResponse}, notify: ${char.properties.notify})`);

                                // Write karakteristiƒüi sakla
                                if (char.properties.writeWithoutResponse) {
                                    writeChar = char;
                                }

                                // Notify karakteristiƒüi tespit et
                                // Her cihaz kendi notify char'ƒ±nƒ± kullanabilsin
                                if (char.properties.notify) {
                                    notifyChar = char;
                                }
                            }

                            // Eƒüer controller ise, √∂nce write ile ba≈ülat, sonra notify dinle
                            // Eƒüer controller ise, sadece notify dinle (write YOK)
                            // Sadece "Controller" tipindeyse display'i a√ß (Single Motor vs a√ßmasƒ±n)
                            const deviceType = detectDeviceType(bluetoothDevice.name || '');
                            if (notifyChar && deviceType === 'controller') {
                                console.log('      üéÆ Controller tespit edildi!');
                                console.log('      DEBUG: writeChar var mƒ±?', !!writeChar);
                                console.log('      DEBUG: writeChar UUID:', writeChar ? writeChar.uuid : 'YOK');

                                // Characteristic'leri kaydet
                                connectedCharacteristics[notifyChar.uuid] = notifyChar;
                                if (writeChar) {
                                    connectedCharacteristics[writeChar.uuid] = writeChar;

                                    // DENEME: Controller'a "wake up" ping g√∂nder
                                    try {
                                        console.log('      üì§ Controller wake-up ping g√∂nderiliyor...');
                                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x00]));
                                        console.log('      ‚úì Ping g√∂nderildi!');
                                        await new Promise(resolve => setTimeout(resolve, 100));
                                    } catch (e) {
                                        console.log('      ‚ö†Ô∏è Ping hatasƒ±:', e.message);
                                    }
                                }

                                // Monitoring ba≈ülat (periyodik ping ile)
                                console.log('      üéÆ Monitoring ba≈ülatƒ±lƒ±yor...');
                                await startControllerMonitoring(bluetoothDevice, notifyChar, writeChar, assignedColor);
                            }

                            // Motor i√ßin notification monitoring ba≈ülat
                            // Motor a√ßƒ±sƒ±nƒ± Bluetooth'tan ger√ßek zamanlƒ± almak i√ßin
                            if (notifyChar && deviceType === 'motor' && !motorMonitoringActive) {
                                console.log('      ‚öôÔ∏è Motor tespit edildi!');
                                console.log('      DEBUG: notifyChar UUID:', notifyChar.uuid);

                                // Characteristic'leri kaydet
                                connectedCharacteristics[notifyChar.uuid] = notifyChar;
                                if (writeChar) {
                                    connectedCharacteristics[writeChar.uuid] = writeChar;
                                }

                                // Motor a√ßƒ± monitoring ba≈ülat
                                console.log('      ‚öôÔ∏è Motor a√ßƒ± monitoring ba≈ülatƒ±lƒ±yor...');

                                // Motor'a sensor stream ba≈ülatma komutu g√∂nder (PCAP'tan: 0x28 0x32 0x00)
                                if (writeChar) {
                                    try {
                                        console.log('      üì§ Motor sensor stream ba≈ülatƒ±lƒ±yor...');

                                        // Adƒ±m 1: Reset/Init
                                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x00]));
                                        await new Promise(resolve => setTimeout(resolve, 100));

                                        // Adƒ±m 2: Handshake
                                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x1a]));
                                        await new Promise(resolve => setTimeout(resolve, 100));

                                        // Adƒ±m 3: Sensor data stream ba≈ülat
                                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x28, 0x32, 0x00]));
                                        console.log('      ‚úì Sensor stream ba≈ülatƒ±ldƒ±!');

                                    } catch (e) {
                                        console.log('      ‚ö†Ô∏è Motor ba≈ülatma hatasƒ±:', e.message);
                                    }
                                }

                                // Monitoring ba≈ülat
                                await startMotorAngleMonitoring(bluetoothDevice, notifyChar, bluetoothDevice.id, assignedColor);
                            }

                        } catch (e) {
                            console.log(`    Karakteristik hatasƒ±: ${e.message}`);
                        }
                    }

                    // connectedCharacteristics = {}; // KALDIRDIM - characteristic'leri silme!
                } catch (err) {
                    console.error('‚ùå Servis hatasƒ±:', err);
                    console.error('   Bu motor cihazƒ±nƒ±n servisleri Web Bluetooth izin listesinde olmayabilir.');
                    console.error('   Motor √ßalƒ±≈ümayabilir ama cihaz listeye eklendi.');
                }

                // Baƒülantƒ± kesilince
                bluetoothDevice.addEventListener('gattserverdisconnected', onDisconnected);

                // Cihazƒ± sidebar'a ekle (aynƒ± rengi kullanarak)
                addDeviceToSidebar(bluetoothDevice, assignedColor);

                // Eƒüer Motor ise Display'i g√∂ster
                const connectedType = detectDeviceType(bluetoothDevice.name || '');
                if (connectedType === 'motor') {
                    showMotorDisplay(bluetoothDevice, assignedColor);
                }

                scanStatus.textContent = t.device_added;

                // Scan status'u gizle
                setTimeout(() => {
                    scanStatus.style.display = 'none';
                }, 2000);

            } catch (error) {
                console.error('Bluetooth hatasƒ±:', error);
                const scanStatus = document.getElementById('scanStatus');
                scanStatus.style.display = 'block';
                scanStatus.style.background = '#FFE5E5';
                scanStatus.textContent = `‚ùå Hata: ${error.message}`;

                let errorMsg = `Bluetooth baƒülantƒ± hatasƒ±:\n${error.message}\n\n`;

                if (error.message.includes('User cancelled')) {
                    scanStatus.style.display = 'none';
                    return; // ƒ∞ptal - hata g√∂sterme
                } else if (error.message.includes('Bluetooth adapter not available')) {
                    errorMsg = '‚ùå Bluetooth a√ßƒ±k deƒüil!\n\nL√ºtfen Bluetooth\'u a√ßƒ±n ve tekrar deneyin.';
                } else {
                    errorMsg += 'Kontrol edin:\n‚úì Bluetooth a√ßƒ±k mƒ±?\n‚úì Cihaz a√ßƒ±k mƒ±?\n‚úì Cihaz menzilde mi?';
                }

                alert(errorMsg);

                setTimeout(() => {
                    scanStatus.style.display = 'none';
                    scanStatus.style.background = '#f0f0f0';
                }, 5000);
            }
        }

        function onDisconnected() {
            console.log('Bluetooth cihaz baƒülantƒ±sƒ± kesildi');

            // Controller monitoring'i durdur
            if (controllerMonitoring) {
                clearInterval(controllerMonitoring);
                controllerMonitoring = null;
            }

            // Controller ping'i durdur
            if (controllerPingInterval) {
                clearInterval(controllerPingInterval);
                controllerPingInterval = null;
            }

            activeControllerDevice = null;
            activeControllerCharacteristic = null;

            // Motor monitoring'i durdur
            if (motorMonitoringActive) {
                stopMotorAngleMonitoring();
            }

            // Controller display'i gizle
            hideControllerDisplay();
            hideMotorDisplay();

            // Baƒülantƒ±sƒ± kesilen cihazƒ± bul ve durumunu g√ºncelle
            const device = connectedDevices.find(d => d.device === bluetoothDevice);
            if (device) {
                device.connected = false;
                updateDevicesTable();
            }

            bluetoothDevice = null;
            bluetoothServer = null;
            connectedCharacteristics = {};
        }

        // Controller'dan veri oku ve state g√ºncelle
        async function startControllerMonitoring(device, notifyChar, writeChar, deviceColor = null) {
            console.log('üéÆ Controller monitoring ba≈ülatƒ±lƒ±yor...');
            activeControllerDevice = device;
            activeControllerCharacteristic = notifyChar; // Global'e kaydet

            console.log('   DEBUG: Notify characteristic:', notifyChar.uuid);
            console.log('   DEBUG: Write characteristic:', writeChar ? writeChar.uuid : 'YOK');

            // Controller display'i g√∂ster - cihaz bilgilerini bul
            // Eƒüer renk parametre olarak geldiyse kullan, yoksa listeden bulmaya √ßalƒ±≈ü
            let colorToUse = deviceColor;
            let nameToUse = device.name || 'Controller';

            if (!colorToUse) {
                const deviceData = connectedDevices.find(d => d.device === device || d.id === device.id);
                if (deviceData) {
                    nameToUse = deviceData.name;
                    colorToUse = deviceData.color;
                } else {
                    colorToUse = '#4C97FF';
                }
            }

            showControllerDisplay(nameToUse, colorToUse);

            // Notification'larƒ± dinle
            try {
                await notifyChar.startNotifications();
                console.log('‚úÖ Notifications ba≈ülatƒ±ldƒ± - kollarƒ± hareket ettirin');
                console.log('   Characteristic UUID:', notifyChar.uuid);
                console.log('   Is notifying:', notifyChar.properties.notify);

                // Event listener ekle - notification'dan SONRA
                notifyChar.addEventListener('characteristicvaluechanged', (event) => {
                    const value = event.target.value;

                    // RAW HEX DUMP (Debugging i√ßin - ilk 10 paket)
                    if (!event.target._logCount) event.target._logCount = 0;
                    if (event.target._logCount < 10) {
                        const bytes = new Uint8Array(value.buffer);
                        const hexDump = [...bytes].map(b => b.toString(16).padStart(2, '0')).join(' ');
                        console.log(`üéÆ Controller RAW [${value.byteLength} bytes]: ${hexDump}`);
                        event.target._logCount++;
                    }

                    // Format: 60, 10, 0, 0, 50, 0, 15, 1, 0, 50, 0, 248, 255
                    // Index:   0   1  2  3   4  5   6  7  8   9 10   11  12
                    // Index 7 = Sol lever byte
                    // Index 8 = Saƒü lever byte
                    // Deƒüerler: 0-1 = normal, 2-104 = up, 152-255 = down

                    if (value.byteLength >= 9) {
                        const leftByte = value.getUint8(7);   // Index 7 = Sol lever
                        const rightByte = value.getUint8(8);  // Index 8 = Saƒü lever

                        // Sadece deƒüer deƒüi≈ütiyse g√ºncelle
                        if (leftByte !== controllerState.leftValue || rightByte !== controllerState.rightValue) {
                            updateControllerState(leftByte, rightByte);
                        }

                        // Pil y√ºzdesini al (index 4 olabilir - motor ile aynƒ± gibi deneyelim)
                        if (value.byteLength >= 5) {
                            let batteryPercent = value.getUint8(4);
                            // 0-100 arasƒ±na normalize et
                            if (batteryPercent > 100) {
                                batteryPercent = Math.round((batteryPercent / 255) * 100);
                            }

                            // Pil g√∂stergesini g√ºncelle
                            const batteryEl = document.getElementById('controllerBatteryPercent');
                            const batteryFill = document.getElementById('controllerBatteryFill');
                            if (batteryEl) {
                                batteryEl.textContent = `${batteryPercent}%`;

                                // Pil doluluk g√∂stergesini g√ºncelle
                                if (batteryFill) {
                                    const fillWidth = Math.round((batteryPercent / 100) * 14);
                                    batteryFill.setAttribute('width', fillWidth);
                                }

                                // Renk ayarla
                                if (batteryPercent < 20) {
                                    batteryEl.parentElement.style.color = '#e03131';
                                } else if (batteryPercent < 50) {
                                    batteryEl.parentElement.style.color = '#fab005';
                                } else {
                                    batteryEl.parentElement.style.color = '#37b24d';
                                }
                            }
                        }
                    }
                });

                console.log('‚úì Event listener eklendi');

                // Controller'ƒ± ba≈ülat ve sensor stream'i a√ß
                if (writeChar) {
                    console.log('üîÑ Controller sensor stream ba≈ülatƒ±lƒ±yor...');

                    try {
                        // PCAP analizinden: Ba≈ülatma sƒ±rasƒ±
                        // Paket 403: 0x00 (reset/init)
                        // 0. Notify Characteristic'i bul ve Subscribe ol (Gerekli olabilir)
                        try {
                            const notifyUUID = '0000fd02-0002-1000-8000-00805f9b34fb';
                            let notifyChar = null;

                            // deviceData'yƒ± bul
                            const deviceData = connectedDevices.find(d => d.device === device || d.id === device.id);

                            if (deviceData && deviceData.characteristics) {
                                notifyChar = deviceData.characteristics[notifyUUID];
                            }

                            // Cache'te yoksa servisten al (writeChar'ƒ±n servisini kullanabiliriz)
                            if (!notifyChar && writeChar && writeChar.service) {
                                try {
                                    notifyChar = await writeChar.service.getCharacteristic(notifyUUID);
                                } catch (e) { console.log('   ‚ö†Ô∏è Notify char servisten alƒ±namadƒ±:', e.message); }
                            }

                            if (notifyChar) {
                                // Start notifications if we haven't tracked it yet or just to be safe
                                // Web Bluetooth automatically handles duplicate startNotifications calls usually, or checks properties
                                console.log('   üîî Notifications ba≈ülatƒ±lƒ±yor (Handshake i√ßin gerekli olabilir)...');
                                await notifyChar.startNotifications();
                                // Listener eklemeye gerek yok, sadece aktif olmasƒ± yetebilir
                            } else {
                                console.log('   ‚ö†Ô∏è Notify char bulunamadƒ±, bu adƒ±m atlanƒ±yor.');
                            }
                        } catch (err) {
                            console.log('   ‚ö†Ô∏è Notification ba≈ülatma uyarƒ±sƒ±:', err);
                            // Notification hatasƒ± motoru durdurmamalƒ±, devam et
                        }

                        // 1. Wake UP / Init / Handshake)
                        // Paket 409: 0x28 0x32 0x00 (sensor data stream ba≈ülat)

                        // Adƒ±m 1: Reset/Init
                        console.log('   üì§ Adƒ±m 1: Reset komutu (0x00)...');
                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x00]));
                        await new Promise(resolve => setTimeout(resolve, 100));

                        // Adƒ±m 2: Handshake
                        console.log('   üì§ Adƒ±m 2: Handshake komutu (0x1a)...');
                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x1a]));
                        await new Promise(resolve => setTimeout(resolve, 100));

                        // Adƒ±m 3: Sensor data stream ba≈ülat (PCAP Paket 409)
                        // Bu komut g√∂nderildikten sonra cihaz S√úREKLƒ∞ notification g√∂nderir
                        const sensorStreamCmd = new Uint8Array([0x28, 0x32, 0x00]);
                        console.log('   üì§ Adƒ±m 3: Sensor stream ba≈ülat (0x28 0x32 0x00)...');
                        await writeChar.writeValueWithoutResponse(sensorStreamCmd);

                        console.log('   ‚úÖ Sensor stream ba≈ülatƒ±ldƒ±! Cihaz artƒ±k s√ºrekli veri g√∂nderecek.');

                    } catch (e) {
                        console.error('   ‚ùå Ba≈ülatma hatasƒ±:', e.message);
                    }

                    // NOT: Periyodik ping GEREKMEYOR - cihaz tek komutla s√ºrekli stream yapƒ±yor
                    // Eski periyodik ping kaldƒ±rƒ±ldƒ±
                }

                // TEST: Event listener ger√ßekten √ßalƒ±≈üƒ±yor mu?
                console.log('üß™ TEST: Event listener count:',
                    notifyChar.getAttributeNames ? 'Modern API' : 'Eski API');

                // Manuel bir test eventi tetikle
                setTimeout(() => {
                    console.log('üß™ 5 saniye ge√ßti, manuel test...');
                    console.log('   Characteristic hala var mƒ±?', !!activeControllerCharacteristic);
                    console.log('   Event listener sayƒ±sƒ± kontrol edilemiyor (Web Bluetooth API sƒ±nƒ±rlamasƒ±)');
                }, 5000);

                // ƒ∞lk deƒüeri okumayƒ± dene
                if (notifyChar.properties.read) {
                    try {
                        console.log('   üìñ ƒ∞lk deƒüer okunuyor...');
                        const initialValue = await notifyChar.readValue();
                        console.log('   üìñ ƒ∞lk deƒüer:', initialValue.byteLength, 'bytes');

                        // ƒ∞lk deƒüeri manuel olarak i≈üle
                        if (initialValue.byteLength >= 9) {
                            const leftByte = initialValue.getUint8(7);   // Index 7 = Sol
                            const rightByte = initialValue.getUint8(8);  // Index 8 = Saƒü
                            console.log(`   üìñ ƒ∞lk deƒüerler: Left=${leftByte}, Right=${rightByte}`);
                        }
                    } catch (e) {
                        console.log('   ‚ö†Ô∏è Read desteklenmiyor:', e.message);
                    }
                }

                // Test: 5 saniye sonra hala veri gelmediyse uyar
                setTimeout(() => {
                    console.log('‚è∞ 5 saniye ge√ßti - Eƒüer hala veri gelmediyse:');
                    console.log('   1. Kollarƒ± hareket ettirmeyi deneyin');
                    console.log('   2. Controller\'ƒ± yeniden baƒülayƒ±n');
                    console.log('   3. Controller\'ƒ±n pilini kontrol edin');
                }, 5000);

            } catch (err) {
                console.error('‚ùå Notification ba≈ülatma hatasƒ±:', err.message);
            }
        }

        function updateControllerState(leftByte, rightByte) {
            // √ñnceki state'i kaydet
            const prevLeft = controllerState.left;
            const prevRight = controllerState.right;

            // Y√ºzdeleri hesapla - her iki lever i√ßin aynƒ± mantƒ±k
            const leftPercent = calculateLeverPercent(leftByte);
            const rightPercent = calculateLeverPercent(rightByte);

            // State'i y√ºzdeye g√∂re belirle
            // >55%: UP, <45%: DOWN, 45-55%: RELEASED
            const newLeft = leftPercent > 55 ? 'UP' : (leftPercent < 45 ? 'DOWN' : 'RELEASED');
            const newRight = rightPercent > 55 ? 'UP' : (rightPercent < 45 ? 'DOWN' : 'RELEASED');

            controllerState.left = newLeft;
            controllerState.right = newRight;
            controllerState.leftValue = leftByte;
            controllerState.rightValue = rightByte;

            // G√∂rseli throttle ile g√ºncelle (100ms'de bir)
            const now = Date.now();
            if (now - lastVisualUpdate >= VISUAL_UPDATE_INTERVAL) {
                lastVisualUpdate = now;
                updateControllerVisualThrottled(leftPercent, rightPercent);
            }

            // State deƒüi≈üikliklerinde when bloklarƒ±nƒ± tetikle
            if (newLeft !== prevLeft) {
                triggerLeverEvents('LEFT', newLeft);
            }
            if (newRight !== prevRight) {
                triggerLeverEvents('RIGHT', newRight);
            }

            // Both ve Any kontrol√º
            if (newLeft !== prevLeft || newRight !== prevRight) {
                triggerLeverEvents('BOTH', newLeft === newRight ? newLeft : null);
                triggerLeverEvents('ANY', newLeft !== 'RELEASED' || newRight !== 'RELEASED' ?
                    (newLeft !== 'RELEASED' ? newLeft : newRight) : null);
            }
        }

        // Throttled g√∂rsel g√ºncelleme - dikey bar i√ßin height kullan
        function updateControllerVisualThrottled(leftPercent, rightPercent) {
            // Sol kol
            const leftFill = document.getElementById('leftLeverFill');
            const leftValue = document.getElementById('leftLeverValue');

            if (leftFill && leftValue) {
                const leftHeight = Math.round(leftPercent);
                leftFill.style.height = leftHeight + '%';
                leftValue.textContent = leftHeight + '%';
            }

            // Saƒü kol
            const rightFill = document.getElementById('rightLeverFill');
            const rightValueEl = document.getElementById('rightLeverValue');

            if (rightFill && rightValueEl) {
                const rightHeight = Math.round(rightPercent);
                rightFill.style.height = rightHeight + '%';
                rightValueEl.textContent = rightHeight + '%';
            }
        }

        // Lever y√ºzde hesaplama
        // 0-1 = normal (ortada) = %50
        // 2-104 = up (yukarƒ±) = %50-%100 (2‚Üí%50, 104‚Üí%100)
        // 152-255 = down (a≈üaƒüƒ±) = %0-%50 (255‚Üí%50, 152‚Üí%0)
        function calculateLeverPercent(byteValue) {
            let percent;

            if (byteValue <= 1) {
                // NORMAL - ortada
                percent = 50;
            } else if (byteValue >= 2 && byteValue <= 104) {
                // UP - yukarƒ±
                // 2 ‚Üí %50, 104 ‚Üí %100
                percent = 50 + ((byteValue - 2) / (104 - 2)) * 50;
            } else if (byteValue >= 152 && byteValue <= 255) {
                // DOWN - a≈üaƒüƒ±
                // 255 ‚Üí %50'ye yakƒ±n, 152 ‚Üí %0
                // 255'ten 152'ye gittik√ße a≈üaƒüƒ± iniyor
                percent = ((byteValue - 152) / (255 - 152)) * 50;
            } else {
                // Ara deƒüerler (105-151) - ge√ßi≈ü b√∂lgesi, ortada say
                percent = 50;
            }

            return Math.max(0, Math.min(100, percent));
        }

        // Lever angle deƒüerini d√∂nd√ºr (bloklar i√ßin)
        function getLeverAngle(lever) {
            if (lever === 'LEFT') {
                return Math.round(calculateLeverPercent(controllerState.leftValue));
            } else if (lever === 'RIGHT') {
                return Math.round(calculateLeverPercent(controllerState.rightValue));
            }
            return 50;
        }

        function triggerLeverEvents(lever, position) {
            if (!position) return;

            // Motor i≈ülemi devam ediyorsa yeni i≈ülem ba≈ülatma
            if (motorOperationInProgress) {
                return;
            }

            // Workspace'teki t√ºm when_lever_position bloklarƒ±nƒ± bul
            const allBlocks = workspace.getAllBlocks();
            allBlocks.forEach(block => {
                if (block.type === 'when_lever_position') {
                    const blockLever = block.getFieldValue('LEVER');
                    const blockPosition = block.getFieldValue('POSITION');

                    // Eƒüer blok parametreleri mevcut durumla e≈üle≈üiyorsa
                    if (blockLever === lever && blockPosition === position) {
                        // Bloƒüu vurgula
                        highlightBlock(block);

                        // Bloktan sonraki komutlarƒ± √ßalƒ±≈ütƒ±r
                        executeBlockChain(block);
                    }
                }
            });
        }

        function highlightBlock(block) {
            // Bloƒüu kƒ±sa s√ºreliƒüine vurgula
            const blockSvg = block.getSvgRoot();
            if (blockSvg) {
                blockSvg.style.filter = 'brightness(1.3)';
                setTimeout(() => {
                    blockSvg.style.filter = '';
                }, 300);
            }
        }

        async function executeBlockChain(startBlock) {
            // Bloƒüun altƒ±ndaki komut zincirini √ßalƒ±≈ütƒ±r
            let nextBlock = startBlock.getNextBlock();

            while (nextBlock) {
                await executeBlock(nextBlock);
                nextBlock = nextBlock.getNextBlock();
            }
        }

        async function executeBlock(block) {
            const blockType = block.type;
            console.log('  ‚Üí Executing block:', blockType);

            // RGB LED bloklarƒ±
            if (blockType === 'rgb_red_on') {
                rgbLedState.red = true;
                updateRGBDisplay();
            } else if (blockType === 'rgb_red_off') {
                rgbLedState.red = false;
                updateRGBDisplay();
            } else if (blockType === 'rgb_green_on') {
                rgbLedState.green = true;
                updateRGBDisplay();
            } else if (blockType === 'rgb_green_off') {
                rgbLedState.green = false;
                updateRGBDisplay();
            } else if (blockType === 'rgb_blue_on') {
                rgbLedState.blue = true;
                updateRGBDisplay();
            } else if (blockType === 'rgb_blue_off') {
                rgbLedState.blue = false;
                updateRGBDisplay();
            }
            // RGB sayƒ± g√∂nder bloklarƒ±
            else if (blockType === 'rgb_red_num') {
                const value = block.getFieldValue('NUM') || 1;
                rgbNumberState.red = parseInt(value);
                updateRGBNumberDisplay();
            } else if (blockType === 'rgb_green_num') {
                const value = block.getFieldValue('NUM') || 1;
                rgbNumberState.green = parseInt(value);
                updateRGBNumberDisplay();
            } else if (blockType === 'rgb_blue_num') {
                const value = block.getFieldValue('NUM') || 1;
                rgbNumberState.blue = parseInt(value);
                updateRGBNumberDisplay();
            }
            // Motor bloklarƒ± - Ger√ßek Bluetooth kontrol√º
            else if (blockType === 'motor_run_rotation') {
                const direction = block.getFieldValue('DIRECTION');
                const rotations = block.getFieldValue('ROTATIONS');
                console.log(`  ‚öôÔ∏è Motor: ${rotations} rotation ${direction}`);

                const deviceId = block.data;
                if (deviceId) {
                    await runMotorRotations(deviceId, parseInt(rotations), direction);
                } else {
                    console.log('  ‚ùå deviceId yok - motor √ßalƒ±≈ütƒ±rƒ±lamadƒ±');
                }
            } else if (blockType === 'motor_run_to_angle') {
                const direction = block.getFieldValue('DIRECTION');
                const angle = block.getFieldValue('ANGLE');
                console.log(`  ‚öôÔ∏è Motor: Go to ${angle}¬∞ ${direction}`);

                const deviceId = block.data;
                if (deviceId) {
                    await runMotorToAngle(deviceId, parseInt(angle), direction);
                } else {
                    console.log('  ‚ùå deviceId yok');
                }
            } else if (blockType === 'motor_go_to_position') {
                const position = block.getFieldValue('POSITION');
                console.log(`  ‚öôÔ∏è Motor: Go to position ${position}`);

                const deviceId = block.data;
                if (deviceId) {
                    await goToPosition(deviceId, parseInt(position));
                } else {
                    console.log('  ‚ùå deviceId yok');
                }
            } else if (blockType === 'motor_start') {
                const direction = block.getFieldValue('DIRECTION');
                console.log(`  ‚öôÔ∏è Motor: Start ${direction}`);

                const deviceId = block.data;
                if (deviceId) {
                    await startMotor(deviceId, direction);
                } else {
                    console.log('  ‚ùå deviceId yok');
                }
            } else if (blockType === 'motor_stop') {
                console.log(`  ‚öôÔ∏è Motor: Stop`);

                const deviceId = block.data;
                if (deviceId) {
                    await stopMotor(deviceId);
                } else {
                    console.log('  ‚ùå deviceId yok');
                }
            }
            // Wait bloƒüu
            else if (blockType === 'wait') {
                const seconds = block.getFieldValue('SECONDS') || 1;
                console.log(`  ‚Üí Waiting ${seconds} seconds...`);
                await new Promise(resolve => setTimeout(resolve, seconds * 1000));
            }
        }

        function showDeviceModal() {
            document.getElementById('deviceModal').classList.add('show');
        }

        function closeDeviceModal() {
            const modal = document.getElementById('deviceModal');
            if (modal) {
                modal.classList.remove('show');
                modal.style.display = 'none';
            }
        }

        function zoomIn() {
            workspace.zoomCenter(1.2);
        }

        function zoomOut() {
            workspace.zoomCenter(-1.2);
        }

        function resetView() {
            workspace.setScale(1);
            workspace.scrollCenter();
        }

        function clearWorkspace() {
            if (workspace.getAllBlocks().length > 0 && confirm('T√ºm bloklarƒ± sil?')) {
                workspace.clear();
            }
        }

        function toggleStartBlocks() {
            console.log('toggleStartBlocks √ßaƒürƒ±ldƒ±, currentMode:', currentToolboxMode);

            if (!workspace) {
                console.error('Workspace hen√ºz y√ºklenmedi!');
                return;
            }

            if (currentToolboxMode === 'start') {
                hideAllToolboxes();
            } else {
                showStartToolbox();
            }
        }

        function toggleControlBlocks() {
            console.log('toggleControlBlocks √ßaƒürƒ±ldƒ±, currentMode:', currentToolboxMode);

            if (!workspace) {
                console.error('Workspace hen√ºz y√ºklenmedi!');
                return;
            }

            if (currentToolboxMode === 'control') {
                hideAllToolboxes();
            } else {
                showControlToolbox();
            }
        }

        function toggleActionLedBlocks() {
            console.log('toggleActionLedBlocks √ßaƒürƒ±ldƒ±, currentMode:', currentToolboxMode);

            if (!workspace) {
                console.error('Workspace hen√ºz y√ºklenmedi!');
                return;
            }

            if (currentToolboxMode === 'action_led') {
                hideAllToolboxes();
            } else {
                showActionLedToolbox();
            }
        }

        function toggleActionNumBlocks() {
            console.log('toggleActionNumBlocks √ßaƒürƒ±ldƒ±, currentMode:', currentToolboxMode);

            if (!workspace) {
                console.error('Workspace hen√ºz y√ºklenmedi!');
                return;
            }

            if (currentToolboxMode === 'action_num') {
                hideAllToolboxes();
            } else {
                showActionNumToolbox();
            }
        }

        function toggleOperatorBlocks() {
            console.log('toggleOperatorBlocks √ßaƒürƒ±ldƒ±, currentMode:', currentToolboxMode);

            if (!workspace) {
                console.error('Workspace hen√ºz y√ºklenmedi!');
                return;
            }

            // Eƒüer zaten operator mode aktifse kapat, deƒüilse operator mode a√ß
            if (currentToolboxMode === 'operator') {
                hideAllToolboxes();
            } else {
                showOperatorToolbox();
            }
        }

        function toggleMotorControl() {
            console.log('toggleMotorControl √ßaƒürƒ±ldƒ±, currentMode:', currentToolboxMode);

            if (!workspace) {
                console.error('Workspace hen√ºz y√ºklenmedi!');
                return;
            }

            // Eƒüer zaten motor mode aktifse kapat, deƒüilse motor mode a√ß
            if (currentToolboxMode === 'motor') {
                hideAllToolboxes();
            } else {
                // Full veya kapalƒ± olabilir - her durumda motor a√ß
                showMotorToolbox();
            }
        }

        let currentToolboxMode = null;

        // Toolbox deƒüi≈ütiƒüinde bloklarƒ±n kaymasƒ±nƒ± √∂nlemek i√ßin bloklarƒ± fiziksel olarak geri ta≈üƒ±
        function updateToolboxPreservingScroll(toolboxXml) {
            // T√ºm √ºst seviye bloklarƒ±n pozisyonlarƒ±nƒ± kaydet
            const allBlocks = workspace.getTopBlocks(false);
            const originalPositions = [];

            allBlocks.forEach(block => {
                const pos = block.getRelativeToSurfaceXY();
                originalPositions.push({
                    block: block,
                    x: pos.x,
                    y: pos.y
                });
            });

            // Toolbox'ƒ± g√ºncelle
            workspace.updateToolbox(toolboxXml);

            // Bloklarƒ±n yeni pozisyonlarƒ±nƒ± kontrol et ve delta varsa geri ta≈üƒ±
            originalPositions.forEach(item => {
                const newPos = item.block.getRelativeToSurfaceXY();
                const deltaX = newPos.x - item.x;
                const deltaY = newPos.y - item.y;

                // Eƒüer blok kaydƒ±ysa, ters y√∂nde geri ta≈üƒ±
                if (deltaX !== 0 || deltaY !== 0) {
                    item.block.moveBy(-deltaX, -deltaY);
                }
            });
        }

        function showStartToolbox() {
            const startToolbox = `
                <xml xmlns="https://developers.google.com/blockly/xml">
                    <block type="start"></block>
                    <block type="when_condition"></block>
                    <block type="when_message_received">
                        <field name="MESSAGE">message1</field>
                    </block>
                    <block type="send_message">
                        <field name="MESSAGE">message1</field>
                    </block>
                    <block type="wait">
                        <value name="SECONDS">
                            <shadow type="math_number">
                                <field name="NUM">1</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="wait_until"></block>
                </xml>
            `;

            updateToolboxPreservingScroll(startToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'start';
            currentToolboxDevice = null;
            selectedDeviceId = null;

            updateToolboxButtons('startToggle');
            resetDeviceIcons();
            console.log('Start toolbox g√∂sterildi');
        }

        function showControlToolbox() {
            const controlToolbox = `
                <xml xmlns="https://developers.google.com/blockly/xml">
                    <block type="repeat">
                        <value name="TIMES">
                            <shadow type="math_number">
                                <field name="NUM">10</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="forever"></block>
                    <block type="if_then"></block>
                    <block type="if_then_else"></block>
                    <block type="repeat_until"></block>
                </xml>
            `;

            updateToolboxPreservingScroll(controlToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'control';
            currentToolboxDevice = null;
            selectedDeviceId = null;

            updateToolboxButtons('controlToggle');
            resetDeviceIcons();
            console.log('Control toolbox g√∂sterildi');
        }

        function showActionLedToolbox() {
            const actionLedToolbox = `
                <xml xmlns="https://developers.google.com/blockly/xml">
                    <block type="rgb_red_on"></block>
                    <block type="rgb_green_on"></block>
                    <block type="rgb_blue_on"></block>
                    <block type="rgb_red_off"></block>
                    <block type="rgb_green_off"></block>
                    <block type="rgb_blue_off"></block>
                    <block type="rgb_red_light_get"></block>
                    <block type="rgb_green_light_get"></block>
                    <block type="rgb_blue_light_get"></block>
                </xml>
            `;

            updateToolboxPreservingScroll(actionLedToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'action_led';
            selectedDeviceId = null;
            currentToolboxDevice = null;

            updateToolboxButtons('actionLedToggle');
            resetDeviceIcons();
            console.log('Action LED toolbox g√∂sterildi');
        }

        function showActionNumToolbox() {
            const actionNumToolbox = `
                <xml xmlns="https://developers.google.com/blockly/xml">
                    <block type="rgb_red_num">
                        <value name="NUM">
                            <shadow type="math_number">
                                <field name="NUM">1</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="rgb_green_num">
                        <value name="NUM">
                            <shadow type="math_number">
                                <field name="NUM">1</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="rgb_blue_num">
                        <value name="NUM">
                            <shadow type="math_number">
                                <field name="NUM">1</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="rgb_red_get"></block>
                    <block type="rgb_green_get"></block>
                    <block type="rgb_blue_get"></block>
                </xml>
            `;

            updateToolboxPreservingScroll(actionNumToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'action_num';
            selectedDeviceId = null;
            currentToolboxDevice = null;

            updateToolboxButtons('actionNumToggle');
            resetDeviceIcons();
            console.log('Action Num toolbox g√∂sterildi');
        }

        function showDeviceToolbox(deviceData) {
            // selectedDeviceId'yi set et - √ñNEMLI!
            selectedDeviceId = deviceData.id;
            console.log('selectedDeviceId set edildi:', selectedDeviceId);

            // Cihaz tipine g√∂re bloklarƒ± al
            const blocks = DEVICE_BLOCKS[deviceData.type] || DEVICE_BLOCKS['generic'];

            // Toolbox XML'i olu≈ütur
            let deviceToolboxXml = '<xml xmlns="https://developers.google.com/blockly/xml">';

            // Motor bloklarƒ± ekle
            if (deviceData.type === 'motor') {
                deviceToolboxXml += `
                    <block type="motor_run_rotation">
                        <field name="DIRECTION">CW</field>
                        <field name="ROTATIONS">1</field>
                    </block>
                    <block type="motor_run_to_angle">
                        <field name="DIRECTION">CW</field>
                        <field name="ANGLE">90</field>
                    </block>
                    <block type="motor_go_to_position">
                        <field name="POSITION">270</field>
                    </block>
                    <block type="motor_start">
                        <field name="DIRECTION">CW</field>
                    </block>
                    <block type="motor_stop"></block>
                `;
            }
            // Controller bloklarƒ± ekle
            else if (deviceData.type === 'controller') {
                deviceToolboxXml += `
                    <block type="when_lever_position">
                        <field name="LEVER">LEFT</field>
                        <field name="POSITION">UP</field>
                    </block>
                    <block type="lever_position">
                        <field name="LEVER">LEFT</field>
                        <field name="POSITION">UP</field>
                    </block>
                    <block type="lever_angle">
                        <field name="LEVER">LEFT</field>
                    </block>
                `;
            }
            // Generic bloklar
            else {
                deviceToolboxXml += '<block type="led_on"><field name="VAL">90</field></block>';
            }

            deviceToolboxXml += '</xml>';

            updateToolboxPreservingScroll(deviceToolboxXml);
            isToolboxVisible = true;
            currentToolboxMode = 'device';
            currentToolboxDevice = deviceData.id; // Bu da ekleyelim

            // T√ºm butonlarƒ± pasif yap, cihaz ikonu aktif
            updateToolboxButtons(null);

            // Cihaz ikonunu aktif g√∂ster
            document.querySelectorAll('.device-icon').forEach(icon => {
                icon.style.background = 'white';
            });
            const activeIcon = document.querySelector(`[data-device-id="${deviceData.id}"]`);
            if (activeIcon) {
                activeIcon.style.background = '#0FBD8C';
            }

            console.log('Device toolbox g√∂sterildi:', deviceData.name);
            console.log('currentToolboxDevice:', currentToolboxDevice);
        }

        function showOperatorToolbox() {
            const operatorToolbox = `
                <xml xmlns="https://developers.google.com/blockly/xml">
                    <block type="math_number">
                        <field name="NUM">0</field>
                    </block>
                    <block type="math_arithmetic">
                        <field name="OP">ADD</field>
                        <value name="A">
                            <shadow type="math_number">
                                <field name="NUM">2</field>
                            </shadow>
                        </value>
                        <value name="B">
                            <shadow type="math_number">
                                <field name="NUM">1</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="math_random">
                        <value name="FROM">
                            <shadow type="math_number">
                                <field name="NUM">1</field>
                            </shadow>
                        </value>
                        <value name="TO">
                            <shadow type="math_number">
                                <field name="NUM">10</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="logic_compare">
                        <field name="OP">GT</field>
                        <value name="A">
                            <shadow type="math_number">
                                <field name="NUM">3</field>
                            </shadow>
                        </value>
                        <value name="B">
                            <shadow type="math_number">
                                <field name="NUM">2</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="logic_and"></block>
                    <block type="logic_or"></block>
                    <block type="logic_negate"></block>
                </xml>
            `;

            updateToolboxPreservingScroll(operatorToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'operator';
            selectedDeviceId = null;
            currentToolboxDevice = null;

            updateToolboxButtons('operatorToggle');
            resetDeviceIcons();
            console.log('Operator toolbox g√∂sterildi');
        }

        function showMotorToolbox() {
            const motorToolbox = `
                <xml xmlns="https://developers.google.com/blockly/xml">
                    <block type="led_on"><field name="VAL">90</field></block>
                </xml>
            `;

            updateToolboxPreservingScroll(motorToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'motor';
            selectedDeviceId = null;
            currentToolboxDevice = null;

            updateToolboxButtons('motorToggle');
            resetDeviceIcons();
            console.log('Motor toolbox g√∂sterildi');
        }

        function resetDeviceIcons() {
            document.querySelectorAll('.device-icon').forEach(icon => {
                icon.style.background = '';
            });
        }

        function toggleActionButtonBlocks() {
            console.log('toggleActionButtonBlocks √ßaƒürƒ±ldƒ±, currentMode:', currentToolboxMode);

            if (!workspace) {
                console.error('Workspace hen√ºz y√ºklenmedi!');
                return;
            }

            if (currentToolboxMode === 'action_button') {
                hideAllToolboxes();
            } else {
                showActionButtonToolbox();
            }
        }

        function showActionButtonToolbox() {
            const actionButtonToolbox = `
                <xml xmlns="https://developers.google.com/blockly/xml">
                    <block type="rgb_red_button_get"></block>
                    <block type="rgb_green_button_get"></block>
                    <block type="rgb_blue_button_get"></block>
                </xml>
            `;

            updateToolboxPreservingScroll(actionButtonToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'action_button';
            selectedDeviceId = null;
            currentToolboxDevice = null;

            updateToolboxButtons('actionButtonToggle');
            resetDeviceIcons();
            console.log('Action Button toolbox g√∂sterildi');
        }

        function updateToolboxButtons(activeButtonId) {
            const buttons = ['startToggle', 'controlToggle', 'actionLedToggle', 'actionNumToggle', 'actionButtonToggle', 'operatorToggle'];

            buttons.forEach(buttonId => {
                const btn = document.getElementById(buttonId);
                if (btn) {
                    if (buttonId === activeButtonId) {
                        btn.style.background = '#0FBD8C';
                        btn.style.color = 'white';
                    } else {
                        btn.style.background = 'white';
                        btn.style.color = '#666';
                    }
                }
            });
        }

        function hideAllToolboxes() {
            const emptyToolbox = '<xml xmlns="https://developers.google.com/blockly/xml"></xml>';
            updateToolboxPreservingScroll(emptyToolbox);
            isToolboxVisible = false;
            currentToolboxMode = null;
            currentToolboxDevice = null;

            updateToolboxButtons(null);
            resetDeviceIcons();

            console.log('Toolbox gizlendi');
        }

        function showToolbox() {
            showStartToolbox();
        }

        function hideToolbox() {
            hideAllToolboxes();
        }

        document.getElementById('codeModal').addEventListener('click', (e) => {
            if (e.target.id === 'codeModal') closeModal();
        });

        document.getElementById('deviceModal').addEventListener('click', (e) => {
            if (e.target.id === 'deviceModal') closeDeviceModal();
        });

        // Cihaz ekle butonu event listener
        window.addEventListener('load', () => {
            const addDeviceBtn = document.getElementById('addDeviceBtn');
            if (addDeviceBtn) {
                addDeviceBtn.addEventListener('click', addDevice);
                console.log('‚úì addDevice event listener eklendi');
            } else {
                console.error('‚ùå addDeviceBtn bulunamadƒ±!');
            }
        });

        window.addEventListener('load', initBlockly);
        window.addEventListener('resize', () => Blockly.svgResize(workspace));
    </script>
</body>

</html>
