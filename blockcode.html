<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blok Kodlama</title>
    <script src="https://unpkg.com/blockly@10.4.3/blockly.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background: #4C97FF;
            overflow: hidden;
        }

        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }

        .top-bar {
            height: 60px;
            background: #4C97FF;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            gap: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 100;
        }

        .logo {
            color: white;
            font-size: 24px;
            font-weight: bold;
        }

        .play-btn {
            width: 48px;
            height: 48px;
            background: #FFBF00;
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        }

        .play-btn:hover {
            background: #FFA500;
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.3);
        }

        .play-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .play-btn svg {
            margin-left: 2px;
        }

        .reset-btn {
            width: 48px;
            height: 48px;
            background: #FF6680;
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        }

        .reset-btn:hover {
            background: #FF4466;
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.3);
        }

        .reset-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .top-btn {
            padding: 10px 24px;
            border: none;
            border-radius: 20px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .run-btn {
            background: #0FBD8C;
            color: white;
        }

        .run-btn:hover {
            background: #0DA574;
            transform: translateY(-2px);
        }

        .stop-btn {
            background: #FF6680;
            color: white;
        }

        .code-btn {
            background: white;
            color: #4C97FF;
            margin-left: auto;
        }

        .sidebar {
            width: 70px;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            padding: 0;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
            position: fixed;
            left: 0;
            top: 60px;
            bottom: 0;
            z-index: 50;
            transition: width 0.3s ease;
        }

        .sidebar.expanded {
            width: 280px;
        }

        .sidebar-content {
            width: 70px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
            padding: 15px 0;
            flex-shrink: 0;
            height: 100%;
        }

        .sidebar-divider {
            width: 40px;
            height: 2px;
            background: linear-gradient(90deg, transparent, #ccc, transparent);
            margin: 8px 0;
            flex-shrink: 0;
        }

        /* RGB Control Panel */
        .rgb-control-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 15px 25px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 100;
        }

        .rgb-led {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 3px solid #ddd;
            transition: all 0.2s;
            position: relative;
        }

        .rgb-led.red {
            background: #fff;
            border-color: #ff6b6b;
        }

        .rgb-led.red.active {
            background: #ff6b6b;
            box-shadow: 0 0 15px #ff6b6b;
        }

        .rgb-led.green {
            background: #fff;
            border-color: #51cf66;
        }

        .rgb-led.green.active {
            background: #51cf66;
            box-shadow: 0 0 15px #51cf66;
        }

        .rgb-led.blue {
            background: #fff;
            border-color: #4dabf7;
        }

        .rgb-led.blue.active {
            background: #4dabf7;
            box-shadow: 0 0 15px #4dabf7;
        }

        .rgb-number-box {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            font-weight: bold;
            transition: all 0.2s;
            border: 3px solid #ddd;
        }

        .rgb-number-box.red {
            background: #ffb3b3;
            border-color: #ff6b6b;
            color: #c92a2a;
        }

        .rgb-number-box.green {
            background: #b3e0b3;
            border-color: #51cf66;
            color: #2b8a3e;
        }

        .rgb-number-box.blue {
            background: #b3d9ff;
            border-color: #4dabf7;
            color: #1971c2;
        }

        .sidebar-bottom-tools {
            margin-top: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
            padding-bottom: 15px;
        }

        /* Blockly toolbox gizle/g√∂ster */
        .blocklyToolboxDiv.hidden {
            display: none !important;
        }

        .blocklyMainBackground {
            transition: transform 0.3s ease;
        }

        .sidebar-panel {
            width: 210px;
            background: white;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.05) inset;
            overflow-y: auto;
            padding: 20px 15px;
            display: none;
            flex-shrink: 0;
        }

        .sidebar.expanded .sidebar-panel {
            display: block;
        }

        .sidebar-panel h3 {
            margin: 0 0 15px 0;
            font-size: 14px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tool-btn {
            width: 45px;
            height: 45px;
            border: none;
            background: white;
            border-radius: 50%;
            font-size: 22px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            flex-shrink: 0;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tool-btn:hover {
            transform: scale(1.15);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        #deviceList {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 10px 0;
            padding: 5px 0;
            width: 100%;
            align-items: center;
        }

        .device-icon {
            width: 40px;
            height: 40px;
            border: 3px solid;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 7px;
            font-weight: bold;
            flex-shrink: 0;
        }

        .device-icon:hover {
            transform: scale(1.15);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .device-icon.active {
            box-shadow: 0 0 0 4px rgba(76, 151, 255, 0.3);
            transform: scale(1.1);
        }

        .device-icon svg {
            width: 16px;
            height: 16px;
        }

        .device-menu {
            display: none;
        }

        .device-menu-block {
            margin: 12px 0;
            cursor: grab;
            user-select: none;
            display: inline-block;
            transition: all 0.2s;
        }

        .device-menu-block svg {
            display: block;
        }

        .device-menu-block:hover {
            transform: translateY(-2px);
        }

        .device-menu-block:active {
            transform: translateY(1px);
            cursor: grabbing;
        }

        .device-menu-icon {
            font-size: 18px;
            flex-shrink: 0;
        }

        .disconnect-overlay {
            display: none;
            position: fixed;
            top: 70px;
            right: 10px;
            z-index: 1000;
        }

        .disconnect-overlay.show {
            display: block;
        }

        .disconnect-btn-overlay {
            padding: 12px 20px;
            background: #FF6680;
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 102, 128, 0.4);
            transition: all 0.2s;
        }

        .disconnect-btn-overlay:hover {
            background: #FF4466;
            transform: translateY(-2px);
        }

        .delete-block-overlay {
            display: none;
            position: fixed;
            top: 70px;
            right: 10px;
            z-index: 1000;
        }

        .delete-block-overlay.show {
            display: block;
        }

        .delete-block-btn {
            padding: 12px 20px;
            background: #FF6680;
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 102, 128, 0.4);
            transition: all 0.2s;
        }

        .delete-block-btn:hover {
            background: #FF4466;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 102, 128, 0.5);
        }

        /* Controller Display Panel - Kompakt dikey tasarƒ±m */
        .controller-display {
            display: none;
            position: fixed;
            top: 70px;
            right: 20px;
            background: white;
            border-radius: 10px;
            padding: 8px 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
            z-index: 1000;
        }

        .controller-display.active {
            display: block;
        }

        .controller-levers {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .lever-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .lever-label-mini {
            font-size: 10px;
            font-weight: bold;
            color: #666;
        }

        .lever-bar {
            width: 8px;
            height: 60px;
            background: #e0e0e0;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .lever-bar-fill {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 4px;
            transition: height 0.1s ease-out;
        }

        .lever-bar-fill.left {
            background: linear-gradient(to top, #ff6b6b, #ff8787);
        }

        .lever-bar-fill.right {
            background: linear-gradient(to top, #4C97FF, #7BB3FF);
        }

        .lever-value-mini {
            font-size: 11px;
            font-weight: bold;
            color: #333;
        }

        .workspace-container {
            flex: 1;
            margin-left: 70px;
            position: relative;
            background: white;
            transition: margin-left 0.3s ease;
        }

        .sidebar.expanded~.workspace-container {
            margin-left: 280px;
        }

        /* Blockly toolbox'ƒ± sola ta≈üƒ±mak i√ßin ek margin */
        #blocklyDiv {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        /* Blockly toolbox stilini √∂zelle≈ütir */
        .blocklyToolboxDiv {
            background-color: rgba(255, 255, 255, 0.95) !important;
            border-right: 2px solid #E8E8E8 !important;
        }

        .blocklyFlyout {
            fill: #f9f9f9 !important;
        }

        /* Number Panel Popup */
        .number-panel {
            display: none;
            position: fixed;
            background: #4C97FF;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
            z-index: 10000;
            min-width: 200px;
        }

        .number-panel.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .number-display {
            background: white;
            border: 4px solid #4C97FF;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            font-weight: bold;
            color: #4C97FF;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .number-controls {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .num-btn {
            width: 60px;
            height: 60px;
            border: 3px solid white;
            background: transparent;
            border-radius: 50%;
            color: white;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .num-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .num-btn:active {
            transform: scale(0.95);
        }

        /* Angle Panel Popup */
        .angle-panel {
            display: none;
            position: fixed;
            background: #4C97FF;
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            z-index: 10000;
        }

        .angle-panel.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .angle-display-container {
            position: relative;
            width: 200px;
            height: 200px;
        }

        .angle-circle {
            width: 100%;
            height: 100%;
            background: white;
            border-radius: 50%;
            position: relative;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .angle-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 90px;
            background: #667eea;
            transform-origin: bottom center;
            transform: translate(-50%, -100%) rotate(0deg);
            border-radius: 2px 2px 0 0;
            transition: transform 0.1s ease-out;
            pointer-events: none;
        }

        .angle-center-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 16px;
            height: 16px;
            background: #667eea;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            pointer-events: none;
        }

        .angle-degrees {
            font-size: 32px;
            font-weight: bold;
            color: white;
            min-width: 80px;
            text-align: center;
        }

        .angle-markers {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .angle-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 12px;
            background: #ddd;
            transform-origin: bottom center;
        }

        .angle-marker.major {
            height: 18px;
            width: 3px;
            background: #999;
        }

        .angle-marker-label {
            position: absolute;
            font-size: 11px;
            font-weight: bold;
            color: white;
        }

        .angle-controls {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .angle-btn {
            width: 60px;
            height: 60px;
            border: 3px solid white;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            color: white;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .angle-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .angle-btn:active {
            transform: scale(0.95);
        }

        .code-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .code-modal.show {
            display: flex;
        }

        .code-content {
            background: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .code-header h2 {
            color: #4C97FF;
        }

        .close-btn {
            background: #FF6680;
            color: white;
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .close-btn:hover {
            background: #FF4466;
        }

        .code-display {
            background: #F9F9F9;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            white-space: pre-wrap;
            max-height: 400px;
            overflow: auto;
            border: 2px solid #E0E0E0;
        }

        .copy-btn {
            margin-top: 15px;
            padding: 12px 24px;
            background: #4C97FF;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .copy-btn:hover {
            background: #3A7FDF;
        }

        /* Blockly styling */
        .blocklyMainBackground {
            stroke: none !important;
            fill: #FFFFFF !important;
        }

        .blocklyToolboxDiv {
            background: #F9F9F9 !important;
            border-top: 3px solid #CCCCCC !important;
        }

        .blocklyFlyoutBackground {
            fill: #F9F9F9 !important;
            fill-opacity: 0.95 !important;
        }

        .blocklyPath {
            stroke-width: 1.5px !important;
        }

        .blocklyText {
            font-size: 18px !important;
            font-weight: 500 !important;
        }

        .blocklyEditableText .blocklyText {
            font-size: 20px !important;
            font-weight: bold !important;
        }

        /* Field kutularƒ±na padding ekle */
        .blocklyEditableText>rect {
            rx: 4 !important;
            ry: 4 !important;
        }

        /* Dropdown i√ßindeki metinleri dikey ortala */
        .blocklyDropdownText {
            dominant-baseline: middle !important;
            alignment-baseline: middle !important;
        }

        /* T√ºm field text'leri ortala */
        .blocklyText {
            dominant-baseline: middle !important;
        }
    </style>
</head>

<body>
    <div class="app">
        <div class="top-bar">
            <div class="logo">BlockCode</div>
            <div style="display: flex; gap: 10px;">
                <button class="reset-btn" onclick="resetEverything()" title="Sƒ±fƒ±rla">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
                        <path d="M21 3v5h-5" />
                        <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" />
                        <path d="M3 21v-5h5" />
                    </svg>
                </button>
                <button class="play-btn" onclick="runCode()" title="Kodu √áalƒ±≈ütƒ±r">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M8 5v14l11-7z" />
                    </svg>
                </button>
            </div>
        </div>

        <div class="sidebar" id="sidebar">
            <div class="sidebar-content">
                <button class="tool-btn device-add" id="addDeviceBtn" title="Cihaz Ekle">‚ûï</button>
                <div id="deviceList"></div>
                <div class="sidebar-divider"></div>
                <button class="tool-btn" id="startToggle" onclick="toggleStartBlocks()" title="Ba≈ülangƒ±√ß">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="5 3 19 12 5 21 5 3"></polygon>
                    </svg>
                </button>
                <button class="tool-btn" id="controlToggle" onclick="toggleControlBlocks()" title="Kontrol">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <path
                            d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z">
                        </path>
                    </svg>
                </button>
                <button class="tool-btn" id="actionLedToggle" onclick="toggleActionLedBlocks()" title="LED Kontrol">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <circle cx="12" cy="12" r="3"></circle>
                    </svg>
                </button>
                <button class="tool-btn" id="actionNumToggle" onclick="toggleActionNumBlocks()" title="Sayƒ± Kontrol">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                        <line x1="9" y1="9" x2="15" y2="15"></line>
                        <line x1="15" y1="9" x2="9" y2="15"></line>
                    </svg>
                </button>
                <button class="tool-btn" id="operatorToggle" onclick="toggleOperatorBlocks()" title="Operat√∂rler">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <path d="M4 7V4h16v3"></path>
                        <path d="M9 20h6"></path>
                        <path d="M12 4v16"></path>
                    </svg>
                </button>
                <div class="sidebar-divider"></div>
                <div class="sidebar-bottom-tools">
                    <button class="tool-btn" onclick="zoomIn()" title="Yakƒ±nla≈ütƒ±r">üîç+</button>
                    <button class="tool-btn" onclick="zoomOut()" title="Uzakla≈ütƒ±r">üîç‚àí</button>
                    <button class="tool-btn" onclick="resetView()" title="G√∂r√ºn√ºm√º Ortala">‚äô</button>
                </div>
            </div>
            <div class="sidebar-panel" id="sidebarPanel">
                <h3 id="panelTitle">Cihaz Bloklarƒ±</h3>
                <div id="panelContent"></div>
            </div>
        </div>

        <div class="workspace-container">
            <div id="blocklyDiv"></div>

            <!-- RGB Control Panel -->
            <div class="rgb-control-panel">
                <div class="rgb-led red" id="rgbRedLed" title="Kƒ±rmƒ±zƒ± LED"></div>
                <div class="rgb-led green" id="rgbGreenLed" title="Ye≈üil LED"></div>
                <div class="rgb-led blue" id="rgbBlueLed" title="Mavi LED"></div>
                <div class="rgb-number-box red" id="rgbRedNum">0</div>
                <div class="rgb-number-box green" id="rgbGreenNum">0</div>
                <div class="rgb-number-box blue" id="rgbBlueNum">0</div>
            </div>
        </div>

        <!-- Disconnect Button Overlay -->
        <div class="disconnect-overlay" id="disconnectOverlay">
            <button class="disconnect-btn-overlay" onclick="disconnectSelectedDevice()">
                üîå Baƒülantƒ±yƒ± Kes
            </button>
        </div>

        <!-- Blok silme butonu -->
        <div class="delete-block-overlay" id="deleteBlockOverlay">
            <button class="delete-block-btn" onclick="deleteSelectedBlock()">
                üóëÔ∏è Bloƒüu Sil
            </button>
        </div>

        <!-- Controller Display Panel - Kompakt -->
        <div class="controller-display" id="controllerDisplay">
            <div class="controller-levers">
                <!-- Sol Kol -->
                <div class="lever-container">
                    <div class="lever-label-mini">L</div>
                    <div class="lever-bar">
                        <div class="lever-bar-fill left" id="leftLeverFill"></div>
                    </div>
                    <div class="lever-value-mini" id="leftLeverValue">50%</div>
                </div>
                <!-- Saƒü Kol -->
                <div class="lever-container">
                    <div class="lever-label-mini">R</div>
                    <div class="lever-bar">
                        <div class="lever-bar-fill right" id="rightLeverFill"></div>
                    </div>
                    <div class="lever-value-mini" id="rightLeverValue">50%</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Number Panel Popup -->
    <div class="number-panel" id="numberPanel">
        <div class="number-display" id="numberDisplay">1</div>
        <div class="number-controls">
            <button class="num-btn" id="decrementBtn">‚àí</button>
            <button class="num-btn" id="incrementBtn">+</button>
        </div>
    </div>

    <!-- Angle Panel Popup -->
    <div class="angle-panel" id="anglePanel">
        <div class="angle-display-container">
            <div class="angle-circle" id="angleCircle">
                <div class="angle-markers" id="angleMarkers"></div>
                <div class="angle-indicator" id="angleIndicator"></div>
                <div class="angle-center-dot"></div>
            </div>
        </div>
        <div class="angle-controls">
            <button class="angle-btn" id="angleDecrementBtn">‚àí</button>
            <div class="angle-degrees" id="angleDegrees">0¬∞</div>
            <button class="angle-btn" id="angleIncrementBtn">+</button>
        </div>
    </div>

    <!-- Message Input Panel -->
    <div class="number-panel" id="messagePanel" style="width: 300px;">
        <div
            style="background: white; border: 4px solid #4C97FF; border-radius: 15px; padding: 20px; box-shadow: 0 4px 10px rgba(0,0,0,0.2);">
            <input type="text" id="messageInput" placeholder="Mesaj adƒ±..."
                style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #4C97FF; border-radius: 8px; outline: none; font-weight: bold;">
            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button onclick="saveMessage()"
                    style="flex: 1; padding: 10px; background: #0FBD8C; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer;">
                    ‚úì Kaydet
                </button>
                <button onclick="closeMessagePanel()"
                    style="flex: 1; padding: 10px; background: #FF6680; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer;">
                    √ó ƒ∞ptal
                </button>
            </div>
        </div>
    </div>

    <div class="code-modal" id="codeModal">
        <div class="code-content">
            <div class="code-header">
                <h2>üìù MicroPython</h2>
                <button class="close-btn" onclick="closeModal()">√ó</button>
            </div>
            <div class="code-display" id="codeDisplay"></div>
            <button class="copy-btn" onclick="copyCode()">üìã Kopyala</button>
        </div>
    </div>

    <!-- Device Connection Modal -->
    <div class="code-modal" id="deviceModal">
        <div class="code-content" style="max-width: 800px;">
            <div class="code-header">
                <h2>üì± Bluetooth Cihaz Y√∂netimi</h2>
                <button class="close-btn" onclick="closeDeviceModal()">√ó</button>
            </div>

            <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                <button class="copy-btn" onclick="scanAndConnect()" style="flex: 1; margin: 0;">
                    üîç Yeni Cihaz Ara & Baƒülan
                </button>
            </div>

            <div
                style="background: white; border-radius: 8px; border: 2px solid #e0e0e0; overflow: hidden; margin-bottom: 20px;">
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: #4C97FF; color: white;">
                            <th style="padding: 12px; text-align: left; font-size: 14px;">Cihaz Adƒ±</th>
                            <th style="padding: 12px; text-align: left; font-size: 14px;">Cihaz ID</th>
                            <th style="padding: 12px; text-align: center; font-size: 14px;">Durum</th>
                            <th style="padding: 12px; text-align: center; font-size: 14px;">ƒ∞≈ülem</th>
                        </tr>
                    </thead>
                    <tbody id="devicesTableBody">
                        <tr>
                            <td colspan="4" style="padding: 30px; text-align: center; color: #999;">
                                Hen√ºz baƒülƒ± cihaz yok. "Yeni Cihaz Ara & Baƒülan" butonuna tƒ±klayƒ±n.
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div id="scanStatus"
                style="display: none; background: #f0f0f0; padding: 15px; border-radius: 8px; margin-bottom: 20px; text-align: center; font-size: 14px;">
                üîç Tarama yapƒ±lƒ±yor...
            </div>

            <div style="padding: 15px; background: #FFF3CD; border-radius: 8px; border: 2px solid #FFC107;">
                <p style="margin: 0; font-size: 13px;">
                    <strong>‚ÑπÔ∏è Not:</strong> Bu √∂zellik sadece <strong>Chrome, Edge, Opera</strong> tarayƒ±cƒ±larƒ±nda
                    √ßalƒ±≈üƒ±r.
                    HTTPS baƒülantƒ±sƒ± veya localhost gereklidir.
                </p>
            </div>
        </div>
    </div>

    <script>
        let workspace;
        let currentNumberField = null;
        let currentValue = 1;
        let minValue = 1;
        let maxValue = 100;
        let messages = ['message1', 'message2']; // Varsayƒ±lan mesajlar
        let currentMessageField = null;
        let currentMessageBlock = null;
        let isToolboxVisible = false;
        let currentToolboxDevice = null;

        // RGB kontrol deƒüi≈ükenleri
        let rgbLedState = { red: false, green: false, blue: false };
        let rgbNumberState = { red: 0, green: 0, blue: 0 };

        // A√ßƒ± se√ßici deƒüi≈ükenleri
        let currentAngleField = null;
        let currentAngle = 0;

        // Motor i≈ülem kilidi - aynƒ± anda sadece bir motor i≈ülemi yapƒ±labilir
        let motorOperationInProgress = false;

        // G√∂rsel g√ºncelleme throttle - 100ms'de bir g√ºncelle
        let lastVisualUpdate = 0;
        const VISUAL_UPDATE_INTERVAL = 100;

        // Controller state tracking
        let controllerState = {
            left: 'RELEASED',  // UP, DOWN, RELEASED
            right: 'RELEASED',
            leftValue: 0,
            rightValue: 0
        };
        let controllerMonitoring = null;  // Interval ID for monitoring
        let activeControllerDevice = null; // Aktif controller cihazƒ±
        let activeControllerCharacteristic = null; // DEBUG i√ßin
        let controllerPingInterval = null; // Periyodik ping i√ßin

        // DEBUG: Manuel test fonksiyonu
        window.testControllerCharacteristic = async function () {
            console.log('üß™ Controller characteristic test ba≈ülatƒ±lƒ±yor...');

            if (!activeControllerCharacteristic) {
                console.log('‚ùå activeControllerCharacteristic yok!');
                return;
            }

            console.log('‚úì Characteristic var:', activeControllerCharacteristic.uuid);

            // Read dene
            if (activeControllerCharacteristic.properties.read) {
                try {
                    const value = await activeControllerCharacteristic.readValue();
                    const bytes = [];
                    for (let i = 0; i < value.byteLength; i++) {
                        bytes.push(value.getUint8(i));
                    }
                    console.log('‚úì Read ba≈üarƒ±lƒ±:', bytes.join(', '));
                } catch (e) {
                    console.log('‚ùå Read hatasƒ±:', e.message);
                }
            } else {
                console.log('‚ö†Ô∏è Read desteklenmiyor');
            }

            // Notification durumunu kontrol et
            console.log('Notification durumu:', activeControllerCharacteristic.properties.notify);
        };

        function updateControllerVisual() {
            const leftValue = controllerState.leftValue;
            const rightValue = controllerState.rightValue;

            const leftPercent = calculateLeverPercent(leftValue);
            const rightPercent = calculateLeverPercent(rightValue);

            // Sol kol
            const leftFill = document.getElementById('leftLeverFill');
            const leftValueEl = document.getElementById('leftLeverValue');
            if (leftFill && leftValueEl) {
                leftFill.style.height = Math.round(leftPercent) + '%';
                leftValueEl.textContent = Math.round(leftPercent) + '%';
            }

            // Saƒü kol
            const rightFill = document.getElementById('rightLeverFill');
            const rightValueEl = document.getElementById('rightLeverValue');
            if (rightFill && rightValueEl) {
                rightFill.style.height = Math.round(rightPercent) + '%';
                rightValueEl.textContent = Math.round(rightPercent) + '%';
            }
        }

        function showControllerDisplay() {
            const display = document.getElementById('controllerDisplay');
            if (display) {
                display.classList.add('active');
            }
        }

        function hideControllerDisplay() {
            const display = document.getElementById('controllerDisplay');
            if (display) {
                display.classList.remove('active');
            }
        }

        // RGB Display g√ºncelleme fonksiyonlarƒ±
        function updateRGBDisplay() {
            const redLed = document.getElementById('rgbRedLed');
            const greenLed = document.getElementById('rgbGreenLed');
            const blueLed = document.getElementById('rgbBlueLed');

            if (redLed) {
                redLed.classList.toggle('active', rgbLedState.red);
            }
            if (greenLed) {
                greenLed.classList.toggle('active', rgbLedState.green);
            }
            if (blueLed) {
                blueLed.classList.toggle('active', rgbLedState.blue);
            }
        }

        function updateRGBNumberDisplay() {
            const redNum = document.getElementById('rgbRedNum');
            const greenNum = document.getElementById('rgbGreenNum');
            const blueNum = document.getElementById('rgbBlueNum');

            if (redNum) redNum.textContent = rgbNumberState.red;
            if (greenNum) greenNum.textContent = rgbNumberState.green;
            if (blueNum) blueNum.textContent = rgbNumberState.blue;
        }

        // Custom Angle Field (A√ßƒ± se√ßici)
        class CustomAngleField extends Blockly.FieldNumber {
            showEditor_() {
                const fieldRect = this.getScaledBBox();
                const panel = document.getElementById('anglePanel');

                currentAngle = parseInt(this.getValue()) || 0;
                currentAngleField = this;

                updateAngleDisplay();

                panel.style.left = (fieldRect.right + 10) + 'px';
                panel.style.top = fieldRect.top + 'px';
                panel.classList.add('active');

                // A√ßƒ± dairesi interaksiyonunu kur
                setTimeout(() => {
                    setupAngleCircleInteraction();
                }, 50);

                document.addEventListener('click', closeAnglePanelOnClickOutside);
            }
        }

        // Custom Message Field with Dropdown
        class CustomMessageField extends Blockly.FieldDropdown {
            constructor(value) {
                const options = messages.map(m => [m, m]);
                options.push(['üìù Yeni mesaj...', 'NEW']);
                super(options);
                this.setValue(value || messages[0]);
            }

            doValueUpdate_(newValue) {
                super.doValueUpdate_(newValue);

                // NEW se√ßilirse panel a√ß
                if (newValue === 'NEW') {
                    setTimeout(() => {
                        showMessagePanel(this);
                    }, 50);
                    return;
                }
            }

            updateOptions() {
                const currentValue = this.getValue();
                const options = messages.map(m => [m, m]);
                options.push(['üìù Yeni mesaj...', 'NEW']);
                this.menuGenerator_ = options;

                // Eƒüer mevcut deƒüer listede yoksa, ilk mesajƒ± se√ß
                if (currentValue === 'NEW' || !messages.includes(currentValue)) {
                    this.setValue(messages[0]);
                }
            }
        }

        function showMessagePanel(field) {
            currentMessageField = field;
            const panel = document.getElementById('messagePanel');
            const input = document.getElementById('messageInput');

            // Bloƒüun pozisyonunu al
            const block = field.getSourceBlock();
            const blockSvg = block.getSvgRoot();
            const rect = blockSvg.getBoundingClientRect();

            panel.style.left = (rect.right + 20) + 'px';
            panel.style.top = rect.top + 'px';
            panel.classList.add('active');

            input.value = '';
            input.focus();

            // Enter tu≈üu ile kaydet
            input.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    saveMessage();
                } else if (e.key === 'Escape') {
                    closeMessagePanel();
                }
            };

            document.addEventListener('click', closeMessagePanelOnClickOutside);
        }

        function closeMessagePanelOnClickOutside(e) {
            const panel = document.getElementById('messagePanel');
            if (!panel.contains(e.target) && !e.target.closest('.blocklyDropDownDiv')) {
                closeMessagePanel();
            }
        }

        function saveMessage() {
            const input = document.getElementById('messageInput');
            const newMessage = input.value.trim();

            if (newMessage && newMessage !== 'NEW') {
                if (!messages.includes(newMessage)) {
                    messages.push(newMessage);
                    console.log('Yeni mesaj eklendi:', newMessage);
                }

                if (currentMessageField) {
                    // T√ºm mesaj field'larƒ±nƒ± g√ºncelle
                    workspace.getAllBlocks().forEach(block => {
                        ['MESSAGE'].forEach(fieldName => {
                            const field = block.getField(fieldName);
                            if (field && field instanceof CustomMessageField) {
                                field.updateOptions();
                            }
                        });
                    });

                    currentMessageField.setValue(newMessage);
                    currentMessageField = null;
                }
            }

            closeMessagePanel();
        }

        function closeMessagePanel() {
            const panel = document.getElementById('messagePanel');
            panel.classList.remove('active');
            document.removeEventListener('click', closeMessagePanelOnClickOutside);

            // Eƒüer yeni mesaj se√ßilmediyse, ilk mesaja d√∂n
            if (currentMessageField && currentMessageField.getValue() === 'NEW') {
                currentMessageField.setValue(messages[0]);
            }

            currentMessageField = null;
        }

        // Custom Number Field with Popup
        class CustomNumberField extends Blockly.FieldNumber {
            showEditor_() {
                const fieldRect = this.getScaledBBox();
                const panel = document.getElementById('numberPanel');
                const display = document.getElementById('numberDisplay');

                currentValue = parseInt(this.getValue()) || 1;
                currentNumberField = this;
                minValue = this.min_ || 1;
                maxValue = this.max_ || 100;

                display.textContent = currentValue;

                panel.style.left = (fieldRect.right + 10) + 'px';
                panel.style.top = fieldRect.top + 'px';
                panel.classList.add('active');

                document.addEventListener('click', closeNumberPanelOnClickOutside);
            }
        }

        function closeNumberPanelOnClickOutside(e) {
            const panel = document.getElementById('numberPanel');
            if (!panel.contains(e.target) && !e.target.closest('.blocklyEditableText')) {
                closeNumberPanel();
            }
        }

        function closeNumberPanel() {
            const panel = document.getElementById('numberPanel');
            panel.classList.remove('active');
            document.removeEventListener('click', closeNumberPanelOnClickOutside);

            if (currentNumberField) {
                currentNumberField.setValue(currentValue);
                currentNumberField = null;
            }
        }

        function incrementNumber() {
            if (currentValue < maxValue) {
                currentValue++;
                updateDisplay();
            }
        }

        function decrementNumber() {
            if (currentValue > minValue) {
                currentValue--;
                updateDisplay();
            }
        }

        // Basƒ±lƒ± tutma i√ßin deƒüi≈ükenler
        let holdTimer = null;
        let holdInterval = null;
        let isHolding = false;

        // Basƒ±lƒ± tutma fonksiyonlarƒ±
        function startHold(incrementFunc) {
            isHolding = false;

            // ƒ∞lk tƒ±klama - hemen √ßalƒ±≈ütƒ±r
            incrementFunc();

            // 500ms basƒ±lƒ± tutulursa hƒ±zlƒ± mod ba≈ülat
            holdTimer = setTimeout(() => {
                isHolding = true;
                holdInterval = setInterval(() => {
                    incrementFunc();
                }, 100); // Her 100ms'de bir deƒüi≈üir
            }, 500);
        }

        function stopHold() {
            if (holdTimer) {
                clearTimeout(holdTimer);
                holdTimer = null;
            }
            if (holdInterval) {
                clearInterval(holdInterval);
                holdInterval = null;
            }
            isHolding = false;
        }

        function updateDisplay() {
            document.getElementById('numberDisplay').textContent = currentValue;
        }

        // Event listener'larƒ± sayfa y√ºklendiƒüinde ekle
        window.addEventListener('load', () => {
            const incrementBtn = document.getElementById('incrementBtn');
            const decrementBtn = document.getElementById('decrementBtn');

            if (incrementBtn && decrementBtn) {
                // Artƒ± butonu
                incrementBtn.addEventListener('mousedown', () => startHold(incrementNumber));
                incrementBtn.addEventListener('mouseup', stopHold);
                incrementBtn.addEventListener('mouseleave', stopHold);
                incrementBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startHold(incrementNumber);
                });
                incrementBtn.addEventListener('touchend', stopHold);
                incrementBtn.addEventListener('touchcancel', stopHold);

                // Eksi butonu
                decrementBtn.addEventListener('mousedown', () => startHold(decrementNumber));
                decrementBtn.addEventListener('mouseup', stopHold);
                decrementBtn.addEventListener('mouseleave', stopHold);
                decrementBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startHold(decrementNumber);
                });
                decrementBtn.addEventListener('touchend', stopHold);
                decrementBtn.addEventListener('touchcancel', stopHold);
            }

            // A√ßƒ± se√ßici butonlarƒ±
            const angleIncrementBtn = document.getElementById('angleIncrementBtn');
            const angleDecrementBtn = document.getElementById('angleDecrementBtn');

            if (angleIncrementBtn && angleDecrementBtn) {
                // Artƒ± butonu
                angleIncrementBtn.addEventListener('mousedown', () => startHold(incrementAngle));
                angleIncrementBtn.addEventListener('mouseup', stopHold);
                angleIncrementBtn.addEventListener('mouseleave', stopHold);
                angleIncrementBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startHold(incrementAngle);
                });
                angleIncrementBtn.addEventListener('touchend', stopHold);
                angleIncrementBtn.addEventListener('touchcancel', stopHold);

                // Eksi butonu
                angleDecrementBtn.addEventListener('mousedown', () => startHold(decrementAngle));
                angleDecrementBtn.addEventListener('mouseup', stopHold);
                angleDecrementBtn.addEventListener('mouseleave', stopHold);
                angleDecrementBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startHold(decrementAngle);
                });
                angleDecrementBtn.addEventListener('touchend', stopHold);
                angleDecrementBtn.addEventListener('touchcancel', stopHold);
            }

            // A√ßƒ± i≈üaret√ßilerini olu≈ütur
            createAngleMarkers();

            // A√ßƒ± dairesine tƒ±klama/s√ºr√ºkleme √∂zelliƒüi ekle
            setupAngleCircleInteraction();
        });

        // A√ßƒ± dairesi etkile≈üimi
        let isDraggingAngle = false;

        function setupAngleCircleInteraction() {
            const circle = document.getElementById('angleCircle');
            if (!circle) {
                // Circle hen√ºz yok, daha sonra eklenecek
                return;
            }

            // Mouse olaylarƒ±
            circle.addEventListener('mousedown', (e) => {
                isDraggingAngle = true;
                updateAngleFromMouse(e);
            });

            document.addEventListener('mousemove', (e) => {
                if (isDraggingAngle) {
                    updateAngleFromMouse(e);
                }
            });

            document.addEventListener('mouseup', () => {
                isDraggingAngle = false;
            });

            // Touch olaylarƒ±
            circle.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isDraggingAngle = true;
                updateAngleFromTouch(e);
            });

            document.addEventListener('touchmove', (e) => {
                if (isDraggingAngle) {
                    e.preventDefault();
                    updateAngleFromTouch(e);
                }
            });

            document.addEventListener('touchend', () => {
                isDraggingAngle = false;
            });
        }

        function updateAngleFromMouse(e) {
            const circle = document.getElementById('angleCircle');
            if (!circle) return;

            const rect = circle.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const dx = e.clientX - centerX;
            const dy = e.clientY - centerY;

            calculateAngleFromCoordinates(dx, dy);
        }

        function updateAngleFromTouch(e) {
            const circle = document.getElementById('angleCircle');
            if (!circle || e.touches.length === 0) return;

            const rect = circle.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const touch = e.touches[0];
            const dx = touch.clientX - centerX;
            const dy = touch.clientY - centerY;

            calculateAngleFromCoordinates(dx, dy);
        }

        function calculateAngleFromCoordinates(dx, dy) {
            // A√ßƒ±yƒ± hesapla (radyan cinsinden)
            let angleRad = Math.atan2(dy, dx);

            // Radyandan dereceye √ßevir
            let angleDeg = angleRad * 180 / Math.PI;

            // 0-360 aralƒ±ƒüƒ±na √ßevir (saat 3'ten ba≈ülayarak saat y√∂n√ºnde)
            // atan2 saat 3'ten ba≈ülar, biz saat 12'den ba≈ülatmak istiyoruz
            angleDeg = (angleDeg + 90) % 360;
            if (angleDeg < 0) angleDeg += 360;

            // 1'in katƒ±na yuvarla
            currentAngle = Math.round(angleDeg);
            if (currentAngle === 360) currentAngle = 0;

            updateAngleDisplay();
        }

        // A√ßƒ± se√ßici fonksiyonlarƒ±
        function incrementAngle() {
            currentAngle = (currentAngle + 1) % 360;
            updateAngleDisplay();
        }

        function decrementAngle() {
            currentAngle = (currentAngle - 1 + 360) % 360;
            updateAngleDisplay();
        }

        function updateAngleDisplay() {
            const indicator = document.getElementById('angleIndicator');
            const degrees = document.getElementById('angleDegrees');

            indicator.style.transform = `translate(-50%, -100%) rotate(${currentAngle}deg)`;
            degrees.textContent = `${currentAngle}¬∞`;
        }

        function createAngleMarkers() {
            const markersContainer = document.getElementById('angleMarkers');
            if (!markersContainer) return;

            markersContainer.innerHTML = '';

            // Her 30 derece i√ßin i≈üaret (0, 30, 60, 90, ...)
            for (let angle = 0; angle < 360; angle += 30) {
                const marker = document.createElement('div');
                marker.className = 'angle-marker major';
                marker.style.transform = `translate(-50%, -100%) rotate(${angle}deg)`;
                markersContainer.appendChild(marker);

                // Sadece ana a√ßƒ±larda (0, 90, 180, 270) etiket ekle
                if (angle % 90 === 0) {
                    const label = document.createElement('div');
                    label.className = 'angle-marker-label';
                    label.textContent = angle + '¬∞';

                    // Etiketin pozisyonunu hesapla - daha da i√ße alƒ±ndƒ±
                    const radius = 60; // 72'den 60'a d√º≈ü√ºrd√ºk
                    const rad = (angle - 90) * Math.PI / 180;
                    const x = 50 + radius * Math.cos(rad);
                    const y = 50 + radius * Math.sin(rad);

                    label.style.left = x + '%';
                    label.style.top = y + '%';
                    label.style.transform = 'translate(-50%, -50%)';

                    markersContainer.appendChild(label);
                }
            }

            // Her 15 derece i√ßin k√º√ß√ºk i≈üaret (15, 45, 75, ...)
            for (let angle = 15; angle < 360; angle += 30) {
                const marker = document.createElement('div');
                marker.className = 'angle-marker';
                marker.style.transform = `translate(-50%, -100%) rotate(${angle}deg)`;
                markersContainer.appendChild(marker);
            }
        }

        function closeAnglePanelOnClickOutside(e) {
            const panel = document.getElementById('anglePanel');
            if (!panel.contains(e.target) && !e.target.closest('.blocklyEditableText')) {
                closeAnglePanel();
            }
        }

        function closeAnglePanel() {
            const panel = document.getElementById('anglePanel');
            panel.classList.remove('active');
            document.removeEventListener('click', closeAnglePanelOnClickOutside);

            if (currentAngleField) {
                currentAngleField.setValue(currentAngle);
                currentAngleField = null;
            }
        }

        // Event bloklarƒ±
        Blockly.Blocks['start'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üö©  play tƒ±klandƒ±ƒüƒ±nda  ");
                this.setNextStatement(true, null);
                this.setColour("#FFBF00");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['when_condition'] = {
            init: function () {
                this.appendValueInput("CONDITION")
                    .setCheck("Boolean")
                    .appendField("‚ö°  ");
                this.appendDummyInput()
                    .appendField("  olduƒüunda  ");
                this.setInputsInline(true);
                this.setNextStatement(true, null);
                this.setColour("#FFBF00");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['when_message_received'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üì®  ")
                    .appendField(new CustomMessageField('message1'), "MESSAGE")
                    .appendField("  alƒ±ndƒ±ƒüƒ±nda  ");
                this.setNextStatement(true, null);
                this.setColour("#FFBF00");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['send_message'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üì§  ")
                    .appendField(new CustomMessageField('message1'), "MESSAGE")
                    .appendField("  g√∂nder  ");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['forward'] = {
            init: function () {
                this.appendValueInput('STEPS')
                    .setCheck('Number')
                    .appendField("‚¨ÜÔ∏è");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FF8C1A");
                this.setInputsInline(true);
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['turn_right'] = {
            init: function () {
                this.appendValueInput('DEG')
                    .setCheck('Number')
                    .appendField("‚Üª");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FF8C1A");
                this.setInputsInline(true);
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['turn_left'] = {
            init: function () {
                this.appendValueInput('DEG')
                    .setCheck('Number')
                    .appendField("‚Ü∫");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FF8C1A");
                this.setInputsInline(true);
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['repeat'] = {
            init: function () {
                this.appendValueInput('TIMES')
                    .setCheck('Number')
                    .appendField("üîÑ");
                this.appendStatementInput('DO');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setInputsInline(true);
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['wait'] = {
            init: function () {
                this.appendValueInput('SECONDS')
                    .setCheck('Number')
                    .appendField("‚è±Ô∏è");
                this.appendDummyInput()
                    .appendField("saniye");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setInputsInline(true);
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['forever'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("‚ôæÔ∏è s√ºrekli");
                this.appendStatementInput('DO');
                this.setPreviousStatement(true, null);
                this.setColour("#FFAB19");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['if_then'] = {
            init: function () {
                this.appendValueInput('CONDITION')
                    .setCheck('Boolean')
                    .appendField("üî∂ if");
                this.appendDummyInput()
                    .appendField("then");
                this.appendStatementInput('DO');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['if_then_else'] = {
            init: function () {
                this.appendValueInput('CONDITION')
                    .setCheck('Boolean')
                    .appendField("üî∂ if");
                this.appendDummyInput()
                    .appendField("then");
                this.appendStatementInput('DO');
                this.appendDummyInput()
                    .appendField("else");
                this.appendStatementInput('ELSE');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['wait_until'] = {
            init: function () {
                this.appendValueInput('CONDITION')
                    .setCheck('Boolean')
                    .appendField("‚è≥  wait until  ");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['repeat_until'] = {
            init: function () {
                this.appendValueInput('CONDITION')
                    .setCheck('Boolean')
                    .appendField("üîÅ  repeat until  ");
                this.appendStatementInput('DO');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['alarm'] = {
            init: function () {
                this.appendDummyInput().appendField("üîî");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#CF63CF");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['sound'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üîä")
                    .appendField(new CustomNumberField(300, 100, 1000), 'FREQ');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#CF63CF");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['light'] = {
            init: function () {
                this.appendDummyInput().appendField("üí°");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#0FBD8C");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['led_on'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üü¶")
                    .appendField(new CustomNumberField(90, 0, 255), 'VAL');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5CB1D6");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['led_off'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("‚¨õ")
                    .appendField(new CustomNumberField(90, 0, 255), 'VAL');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5CB1D6");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['smile'] = {
            init: function () {
                this.appendDummyInput().appendField("üòä");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FF6680");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // RGB LED Bloklarƒ±
        Blockly.Blocks['rgb_red_on'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üî¥  kƒ±rmƒ±zƒ± ƒ±≈üƒ±k yak  ");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#ff6b6b");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_green_on'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üü¢  ye≈üil ƒ±≈üƒ±k yak  ");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#51cf66");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_blue_on'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üîµ  mavi ƒ±≈üƒ±k yak  ");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4dabf7");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // RGB LED S√∂nd√ºr Bloklarƒ±
        Blockly.Blocks['rgb_red_off'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("‚óØ  kƒ±rmƒ±zƒ± ƒ±≈üƒ±k s√∂nd√ºr  ");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#ff6b6b");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_green_off'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("‚óØ  ye≈üil ƒ±≈üƒ±k s√∂nd√ºr  ");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#51cf66");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_blue_off'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("‚óØ  mavi ƒ±≈üƒ±k s√∂nd√ºr  ");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4dabf7");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_red_num'] = {
            init: function () {
                this.appendValueInput('NUM')
                    .setCheck('Number')
                    .appendField("üü•  ");
                this.appendDummyInput()
                    .appendField("  g√∂nder  ");
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#ffb3b3");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_green_num'] = {
            init: function () {
                this.appendValueInput('NUM')
                    .setCheck('Number')
                    .appendField("üü©  ");
                this.appendDummyInput()
                    .appendField("  g√∂nder  ");
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#b3e0b3");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_blue_num'] = {
            init: function () {
                this.appendValueInput('NUM')
                    .setCheck('Number')
                    .appendField("üü¶  ");
                this.appendDummyInput()
                    .appendField("  g√∂nder  ");
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#b3d9ff");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // RGB Sayƒ± Getir Bloklarƒ± (Yuvarlak ≈üekilli - Number output)
        Blockly.Blocks['rgb_red_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üü•  sayƒ± getir  ");
                this.setOutput(true, "Number");
                this.setColour("#ff6b6b");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_green_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üü©  sayƒ± getir  ");
                this.setOutput(true, "Number");
                this.setColour("#51cf66");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_blue_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üü¶  sayƒ± getir  ");
                this.setOutput(true, "Number");
                this.setColour("#4dabf7");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // RGB I≈üƒ±k Getir Bloklarƒ± (Altƒ±gen ≈üekilli - Boolean output)
        Blockly.Blocks['rgb_red_light_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üî¥  ƒ±≈üƒ±k getir  ");
                this.setOutput(true, "Boolean");
                this.setColour("#ff6b6b");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_green_light_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üü¢  ƒ±≈üƒ±k getir  ");
                this.setOutput(true, "Boolean");
                this.setColour("#51cf66");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_blue_light_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üîµ  ƒ±≈üƒ±k getir  ");
                this.setOutput(true, "Boolean");
                this.setColour("#4dabf7");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Motor Bloklarƒ±
        Blockly.Blocks['motor_run_rotation'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üîÑ run")
                    .appendField(new Blockly.FieldDropdown([["‚Üª", "CW"], ["‚Ü∫", "CCW"]]), "DIRECTION")
                    .appendField("for")
                    .appendField(new CustomNumberField(1, 1, 100), 'ROTATIONS')
                    .appendField("rotations");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4ECDC4");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['motor_run_to_angle'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üéØ run")
                    .appendField(new Blockly.FieldDropdown([["‚Üª", "CW"], ["‚Ü∫", "CCW"]]), "DIRECTION")
                    .appendField("to")
                    .appendField(new CustomAngleField(0, 0, 360), 'ANGLE')
                    .appendField("angle");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4ECDC4");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // YENƒ∞ BLOK: Mutlak pozisyon (0¬∞ referansƒ±na g√∂re)
        Blockly.Blocks['motor_go_to_position'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üìç go to position")
                    .appendField(new CustomAngleField(0, 0, 360), 'POSITION')
                    .appendField("¬∞");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4ECDC4");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['motor_start'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("‚ñ∂Ô∏è start motor")
                    .appendField(new Blockly.FieldDropdown([["‚Üª", "CW"], ["‚Ü∫", "CCW"]]), "DIRECTION");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4ECDC4");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['motor_stop'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("‚èπÔ∏è stop motor");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4ECDC4");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Controller Bloklarƒ±
        Blockly.Blocks['when_lever_position'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üïπÔ∏è when")
                    .appendField(new Blockly.FieldDropdown([
                        ["left", "LEFT"],
                        ["right", "RIGHT"],
                        ["both", "BOTH"],
                        ["any", "ANY"]
                    ]), "LEVER")
                    .appendField("lever is")
                    .appendField(new Blockly.FieldDropdown([
                        ["released", "RELEASED"],
                        ["up", "UP"],
                        ["down", "DOWN"]
                    ]), "POSITION");
                this.setNextStatement(true, null);
                this.setColour("#45B7D1");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['lever_position'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üïπÔ∏è")
                    .appendField(new Blockly.FieldDropdown([
                        ["left", "LEFT"],
                        ["right", "RIGHT"],
                        ["both", "BOTH"],
                        ["any", "ANY"]
                    ]), "LEVER")
                    .appendField("lever is")
                    .appendField(new Blockly.FieldDropdown([
                        ["released", "RELEASED"],
                        ["up", "UP"],
                        ["down", "DOWN"]
                    ]), "POSITION");
                this.setOutput(true, "Boolean");
                this.setColour("#45B7D1");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Yeni: Lever angle/percent bloƒüu (0-100 arasƒ± deƒüer d√∂ner)
        Blockly.Blocks['lever_angle'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("üïπÔ∏è")
                    .appendField(new Blockly.FieldDropdown([
                        ["left", "LEFT"],
                        ["right", "RIGHT"]
                    ]), "LEVER")
                    .appendField("lever angle");
                this.setOutput(true, "Number");
                this.setColour("#45B7D1");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Operat√∂r Bloklarƒ±
        Blockly.Blocks['math_arithmetic'] = {
            init: function () {
                this.appendValueInput('A')
                    .setCheck('Number');
                this.appendDummyInput()
                    .appendField(new Blockly.FieldDropdown([
                        ["+", "ADD"],
                        ["-", "MINUS"],
                        ["√ó", "MULTIPLY"],
                        ["√∑", "DIVIDE"],
                        ["^", "POWER"],
                        ["mod", "MOD"]
                    ]), "OP");
                this.appendValueInput('B')
                    .setCheck('Number');
                this.setOutput(true, 'Number');
                this.setInputsInline(true);
                this.setColour("#59C059");
            }
        };

        Blockly.Blocks['math_random'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("pick random");
                this.appendValueInput('FROM')
                    .setCheck('Number');
                this.appendDummyInput()
                    .appendField("to");
                this.appendValueInput('TO')
                    .setCheck('Number');
                this.setOutput(true, 'Number');
                this.setInputsInline(true);
                this.setColour("#59C059");
            }
        };

        Blockly.Blocks['logic_compare'] = {
            init: function () {
                this.appendValueInput('A')
                    .setCheck('Number');
                this.appendDummyInput()
                    .appendField(new Blockly.FieldDropdown([
                        [">", "GT"],
                        ["<", "LT"],
                        ["=", "EQ"],
                        ["‚â•", "GTE"],
                        ["‚â§", "LTE"]
                    ]), "OP");
                this.appendValueInput('B')
                    .setCheck('Number');
                this.setOutput(true, 'Boolean');
                this.setInputsInline(true);
                this.setColour("#5CB15C");
            }
        };

        Blockly.Blocks['logic_operation'] = {
            init: function () {
                this.appendValueInput('A')
                    .setCheck('Boolean');
                this.appendDummyInput()
                    .appendField(new Blockly.FieldDropdown([
                        ["and", "AND"],
                        ["or", "OR"]
                    ]), "OP");
                this.appendValueInput('B')
                    .setCheck('Boolean');
                this.setOutput(true, 'Boolean');
                this.setInputsInline(true);
                this.setColour("#5CB15C");
            }
        };

        Blockly.Blocks['logic_negate'] = {
            init: function () {
                this.appendValueInput('BOOL')
                    .setCheck('Boolean')
                    .appendField("not");
                this.setOutput(true, 'Boolean');
                this.setColour("#5CB15C");
            }
        };

        // Sayƒ± bloƒüu (shadow bloklar i√ßin)
        Blockly.Blocks['math_number'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new CustomNumberField(0, -999, 999), 'NUM');
                this.setOutput(true, 'Number');
                this.setColour("#59C059");
            }
        };

        // Kod √ºretici
        Blockly.Python = new Blockly.Generator('Python');

        Blockly.Python['start'] = () => '# When play clicked\n';
        Blockly.Python['when_condition'] = (b) => {
            const condition = Blockly.Python.valueToCode(b, 'CONDITION', Blockly.Python.ORDER_NONE) || 'True';
            return `# When ${condition}\n`;
        };
        Blockly.Python['when_message_received'] = (b) => {
            const message = b.getFieldValue('MESSAGE');
            return `# When ${message} received\n`;
        };
        Blockly.Python['send_message'] = (b) => {
            const message = b.getFieldValue('MESSAGE');
            return `send_message("${message}")\n`;
        };
        Blockly.Python['forward'] = (b) => `forward(${b.getFieldValue('STEPS')})\n`;
        Blockly.Python['turn_right'] = (b) => `turn_right(${b.getFieldValue('DEG')})\n`;
        Blockly.Python['turn_left'] = (b) => `turn_left(${b.getFieldValue('DEG')})\n`;
        Blockly.Python['repeat'] = (b) => {
            const times = b.getFieldValue('TIMES');
            const branch = Blockly.Python.statementToCode(b, 'DO');
            return `for i in range(${times}):\n${branch}\n`;
        };
        Blockly.Python['wait'] = (b) => `time.sleep(${b.getFieldValue('SECONDS')})\n`;
        Blockly.Python['forever'] = (b) => {
            const branch = Blockly.Python.statementToCode(b, 'DO');
            return `while True:\n${branch}\n`;
        };
        Blockly.Python['if_then'] = (b) => {
            const condition = Blockly.Python.valueToCode(b, 'CONDITION', Blockly.Python.ORDER_NONE) || 'False';
            const branch = Blockly.Python.statementToCode(b, 'DO');
            return `if ${condition}:\n${branch}\n`;
        };
        Blockly.Python['if_then_else'] = (b) => {
            const condition = Blockly.Python.valueToCode(b, 'CONDITION', Blockly.Python.ORDER_NONE) || 'False';
            const branchDo = Blockly.Python.statementToCode(b, 'DO');
            const branchElse = Blockly.Python.statementToCode(b, 'ELSE');
            return `if ${condition}:\n${branchDo}else:\n${branchElse}\n`;
        };
        Blockly.Python['wait_until'] = (b) => {
            const condition = Blockly.Python.valueToCode(b, 'CONDITION', Blockly.Python.ORDER_NONE) || 'False';
            return `while not (${condition}):\n    time.sleep(0.1)\n`;
        };
        Blockly.Python['repeat_until'] = (b) => {
            const condition = Blockly.Python.valueToCode(b, 'CONDITION', Blockly.Python.ORDER_NONE) || 'False';
            const branch = Blockly.Python.statementToCode(b, 'DO');
            return `while not (${condition}):\n${branch}\n`;
        };
        Blockly.Python['alarm'] = () => 'alarm()\n';
        Blockly.Python['sound'] = (b) => `play_tone(${b.getFieldValue('FREQ')})\n`;
        Blockly.Python['light'] = () => 'light_on()\n';
        Blockly.Python['led_on'] = (b) => `led_on(${b.getFieldValue('VAL')})\n`;
        Blockly.Python['led_off'] = (b) => `led_off(${b.getFieldValue('VAL')})\n`;
        Blockly.Python['smile'] = () => 'show_smile()\n';
        Blockly.Python['rgb_red_on'] = () => 'rgb_red_on()\n';
        Blockly.Python['rgb_green_on'] = () => 'rgb_green_on()\n';
        Blockly.Python['rgb_blue_on'] = () => 'rgb_blue_on()\n';
        Blockly.Python['rgb_red_off'] = () => 'rgb_red_off()\n';
        Blockly.Python['rgb_green_off'] = () => 'rgb_green_off()\n';
        Blockly.Python['rgb_blue_off'] = () => 'rgb_blue_off()\n';
        Blockly.Python['rgb_red_num'] = (b) => {
            const num = Blockly.Python.valueToCode(b, 'NUM', Blockly.Python.ORDER_ATOMIC) || '0';
            return `rgb_red_num(${num})\n`;
        };
        Blockly.Python['rgb_green_num'] = (b) => {
            const num = Blockly.Python.valueToCode(b, 'NUM', Blockly.Python.ORDER_ATOMIC) || '0';
            return `rgb_green_num(${num})\n`;
        };
        Blockly.Python['rgb_blue_num'] = (b) => {
            const num = Blockly.Python.valueToCode(b, 'NUM', Blockly.Python.ORDER_ATOMIC) || '0';
            return `rgb_blue_num(${num})\n`;
        };
        Blockly.Python['rgb_red_get'] = () => ['rgb_red_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_green_get'] = () => ['rgb_green_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_blue_get'] = () => ['rgb_blue_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_red_light_get'] = () => ['rgb_red_light_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_green_light_get'] = () => ['rgb_green_light_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_blue_light_get'] = () => ['rgb_blue_light_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['motor_run_rotation'] = (b) => {
            const dir = b.getFieldValue('DIRECTION');
            const rot = b.getFieldValue('ROTATIONS');
            return `motor.run_for_rotations(${rot}, ${dir === 'CW' ? '1' : '-1'})\n`;
        };
        Blockly.Python['motor_run_to_angle'] = (b) => {
            const dir = b.getFieldValue('DIRECTION');
            const angle = b.getFieldValue('ANGLE');
            return `motor.run_to_angle(${angle}, ${dir === 'CW' ? '1' : '-1'})\n`;
        };
        Blockly.Python['motor_go_to_position'] = (b) => {
            const position = b.getFieldValue('POSITION');
            return `motor.go_to_position(${position})\n`;
        };
        Blockly.Python['motor_start'] = (b) => {
            const dir = b.getFieldValue('DIRECTION');
            return `motor.start(${dir === 'CW' ? '1' : '-1'})\n`;
        };
        Blockly.Python['motor_stop'] = () => 'motor.stop()\n';
        Blockly.Python['when_lever_position'] = (b) => {
            const lever = b.getFieldValue('LEVER');
            const position = b.getFieldValue('POSITION');
            return `# When ${lever} lever is ${position}\n`;
        };
        Blockly.Python['lever_position'] = (b) => {
            const lever = b.getFieldValue('LEVER');
            const position = b.getFieldValue('POSITION');
            return [`controller.${lever.toLowerCase()}_lever_is_${position.toLowerCase()}()`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['lever_angle'] = (b) => {
            const lever = b.getFieldValue('LEVER');
            return [`controller.${lever.toLowerCase()}_lever_angle()`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['math_arithmetic'] = (b) => {
            const ops = {
                'ADD': '+', 'MINUS': '-', 'MULTIPLY': '*',
                'DIVIDE': '/', 'POWER': '**', 'MOD': '%'
            };
            const op = ops[b.getFieldValue('OP')];
            const a = Blockly.Python.valueToCode(b, 'A', Blockly.Python.ORDER_ATOMIC) || '0';
            const bVal = Blockly.Python.valueToCode(b, 'B', Blockly.Python.ORDER_ATOMIC) || '0';
            return [`(${a} ${op} ${bVal})`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['math_random'] = (b) => {
            const from = Blockly.Python.valueToCode(b, 'FROM', Blockly.Python.ORDER_ATOMIC) || '1';
            const to = Blockly.Python.valueToCode(b, 'TO', Blockly.Python.ORDER_ATOMIC) || '10';
            return [`random.randint(${from}, ${to})`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['logic_compare'] = (b) => {
            const ops = { 'GT': '>', 'LT': '<', 'EQ': '==', 'GTE': '>=', 'LTE': '<=' };
            const op = ops[b.getFieldValue('OP')];
            const a = Blockly.Python.valueToCode(b, 'A', Blockly.Python.ORDER_ATOMIC) || '0';
            const bVal = Blockly.Python.valueToCode(b, 'B', Blockly.Python.ORDER_ATOMIC) || '0';
            return [`(${a} ${op} ${bVal})`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['logic_operation'] = (b) => {
            const op = b.getFieldValue('OP') === 'AND' ? 'and' : 'or';
            const a = Blockly.Python.valueToCode(b, 'A', Blockly.Python.ORDER_ATOMIC) || 'False';
            const bVal = Blockly.Python.valueToCode(b, 'B', Blockly.Python.ORDER_ATOMIC) || 'False';
            return [`(${a} ${op} ${bVal})`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['logic_negate'] = (b) => {
            const bool = Blockly.Python.valueToCode(b, 'BOOL', Blockly.Python.ORDER_ATOMIC) || 'False';
            return [`not ${bool}`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['math_number'] = (b) => {
            const num = b.getFieldValue('NUM');
            return [num, Blockly.Python.ORDER_ATOMIC];
        };

        function initBlockly() {
            workspace = Blockly.inject('blocklyDiv', {
                toolbox: `
                    <xml xmlns="https://developers.google.com/blockly/xml">
                        <block type="start"></block>
                        <block type="when_condition"></block>
                        <block type="when_message_received">
                            <field name="MESSAGE">message1</field>
                        </block>
                        <block type="send_message">
                            <field name="MESSAGE">message1</field>
                        </block>
                        <block type="forward">
                            <value name="STEPS">
                                <shadow type="math_number">
                                    <field name="NUM">4</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="turn_right">
                            <value name="DEG">
                                <shadow type="math_number">
                                    <field name="NUM">4</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="turn_left">
                            <value name="DEG">
                                <shadow type="math_number">
                                    <field name="NUM">4</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="repeat">
                            <value name="TIMES">
                                <shadow type="math_number">
                                    <field name="NUM">10</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="alarm"></block>
                        <block type="sound"><field name="FREQ">300</field></block>
                        <block type="light"></block>
                        <block type="led_on"><field name="VAL">90</field></block>
                        <block type="led_off"><field name="VAL">90</field></block>
                        <block type="smile"></block>
                    </xml>
                `,
                horizontalLayout: false,
                toolboxPosition: 'start',
                renderer: 'zelos',
                zoom: {
                    controls: false,
                    wheel: true,
                    startScale: 1.0,
                    maxScale: 2.0,
                    minScale: 0.5,
                    scaleSpeed: 1.15
                },
                grid: {
                    spacing: 20,
                    length: 2,
                    colour: '#E8E8E8',
                    snap: true
                },
                move: {
                    scrollbars: {
                        horizontal: true,
                        vertical: true
                    },
                    drag: true,
                    wheel: true
                },
                trashcan: false
            });

            // Blok eklendiƒüinde cihaz ikonu ekle
            workspace.addChangeListener(function (event) {
                // Blok se√ßildiƒüinde silme butonunu g√∂ster
                if (event.type === Blockly.Events.SELECTED) {
                    handleBlockSelection(event);
                }

                if (event.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                    const block = workspace.getBlockById(event.blockId);
                    if (block && block.data === selectedDeviceId) {
                        // Bloƒüun SVG'sine cihaz ikonu ekle
                        setTimeout(() => {
                            const blockSvg = block.getSvgRoot();
                            if (blockSvg && !blockSvg.querySelector('.device-badge')) {
                                const deviceIcon = getDeviceIcon(selectedDeviceId);
                                if (deviceIcon) {
                                    const foreignObject = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
                                    foreignObject.setAttribute('x', '2');
                                    foreignObject.setAttribute('y', block.height - 18);
                                    foreignObject.setAttribute('width', '14');
                                    foreignObject.setAttribute('height', '14');
                                    foreignObject.classList.add('device-badge');

                                    const div = document.createElement('div');
                                    div.innerHTML = deviceIcon;
                                    div.style.width = '14px';
                                    div.style.height = '14px';

                                    foreignObject.appendChild(div);
                                    blockSvg.appendChild(foreignObject);
                                }
                            }
                        }, 100);
                    }
                }
            });

            // Workspace drop handler
            setupWorkspaceDrop();

            // Toolbox'ƒ± ba≈ülangƒ±√ßta gizle
            setTimeout(() => {
                hideAllToolboxes();
                console.log('Toolbox ba≈ülangƒ±√ßta gizlendi');
            }, 100);
        }

        function showCode() {
            const code = Blockly.Python.workspaceToCode(workspace);
            if (!code.trim()) {
                alert('√ñnce blok ekle! üé®');
                return;
            }
            document.getElementById('codeDisplay').textContent = '# MicroPython\n\n' + code;
            document.getElementById('codeModal').classList.add('show');
        }

        function closeModal() {
            document.getElementById('codeModal').classList.remove('show');
        }

        function copyCode() {
            const code = document.getElementById('codeDisplay').textContent;
            navigator.clipboard.writeText(code).then(() => alert('‚úÖ Kopyalandƒ±!'));
        }

        async function runCode() {
            // Workspace'teki t√ºm bloklarƒ± al
            const allBlocks = workspace.getAllBlocks();

            // "start" bloklarƒ±nƒ± bul
            const startBlocks = allBlocks.filter(block => block.type === 'start');

            if (startBlocks.length === 0) {
                alert('‚ùå Play bloƒüu bulunamadƒ±!\n\n"üö© play tƒ±klandƒ±ƒüƒ±nda" bloƒüunu ekleyin.');
                return;
            }

            // Play butonunu devre dƒ±≈üƒ± bƒ±rak
            const playBtn = document.querySelector('.play-btn');
            playBtn.disabled = true;
            playBtn.style.opacity = '0.5';
            playBtn.style.cursor = 'not-allowed';

            // Her start bloƒüu i√ßin kodu √ßalƒ±≈ütƒ±r
            let fullCode = '# Play tƒ±klandƒ±!\n\n';

            for (const [index, startBlock] of startBlocks.entries()) {
                fullCode += `# Start Block ${index + 1}\n`;

                // Start bloƒüundan sonraki bloklarƒ± al ve sƒ±rayla √ßalƒ±≈ütƒ±r
                let nextBlock = startBlock.getNextBlock();
                while (nextBlock) {
                    // Python kodu √ºretmeyi dene (hata olursa devam et)
                    try {
                        const blockCode = Blockly.Python.blockToCode(nextBlock);
                        if (blockCode && typeof blockCode === 'string') {
                            fullCode += blockCode;
                        }
                    } catch (e) {
                        // Kod √ºretme hatasƒ± - devam et
                        console.log(`‚ö†Ô∏è Kod √ºretme atlandƒ±: ${nextBlock.type}`);
                    }

                    // Bloƒüu ger√ßekten √ßalƒ±≈ütƒ±r - AWAIT ile bekle
                    await executeBlockPlay(nextBlock);

                    nextBlock = nextBlock.getNextBlock();
                }
                fullCode += '\n';
            }

            console.log('Running code:');
            console.log(fullCode);

            // G√∂rsel feedback
            playBtn.style.background = '#51cf66';
            setTimeout(() => {
                playBtn.style.background = '#FFBF00';
                playBtn.disabled = false;
                playBtn.style.opacity = '1';
                playBtn.style.cursor = 'pointer';
            }, 300);

            console.log('‚úÖ T√ºm bloklar √ßalƒ±≈ütƒ±rƒ±ldƒ±!');
        }

        // Global scope'a ekle
        window.runCode = runCode;

        async function executeBlockPlay(block) {
            if (!block) return;

            const blockType = block.type;
            console.log('üéØ executeBlockPlay √ßalƒ±≈ütƒ±rƒ±lƒ±yor:', blockType);

            // Wait bloƒüu - ger√ßek bekleme
            if (blockType === 'wait') {
                // ValueInput'tan baƒülƒ± bloƒüun deƒüerini al
                const secondsBlock = block.getInputTargetBlock('SECONDS');
                let seconds = 1; // varsayƒ±lan
                if (secondsBlock) {
                    // math_number veya benzeri bloktan deƒüer al
                    if (secondsBlock.type === 'math_number') {
                        seconds = parseFloat(secondsBlock.getFieldValue('NUM')) || 1;
                    } else {
                        // Diƒüer sayƒ± bloklarƒ± i√ßin
                        seconds = parseFloat(secondsBlock.getFieldValue('NUM') || secondsBlock.getFieldValue('VALUE')) || 1;
                    }
                }
                console.log(`‚è±Ô∏è ${seconds} saniye bekleniyor...`);
                await sleep(seconds * 1000);
                console.log(`‚è±Ô∏è ${seconds} saniye bekleme tamamlandƒ±`);
                return;
            }

            // Repeat bloƒüu - d√∂ng√º
            if (blockType === 'repeat') {
                const timesBlock = block.getInputTargetBlock('TIMES');
                let times = 10; // varsayƒ±lan
                if (timesBlock) {
                    times = await executeBlockPlay(timesBlock);
                }
                const doBlock = block.getInputTargetBlock('DO');

                console.log(`üîÑ ${times} kez tekrarlanƒ±yor...`);
                for (let i = 0; i < times; i++) {
                    let innerBlock = doBlock;
                    while (innerBlock) {
                        await executeBlockPlay(innerBlock);
                        innerBlock = innerBlock.getNextBlock();
                    }
                }
                return;
            }

            // If-then bloƒüu
            if (blockType === 'if_then') {
                const conditionBlock = block.getInputTargetBlock('CONDITION');
                const doBlock = block.getInputTargetBlock('DO');

                // Ko≈üulu deƒüerlendir
                let conditionTrue = false;
                if (conditionBlock) {
                    const result = await executeBlockPlay(conditionBlock);
                    conditionTrue = Boolean(result);
                }

                console.log('üî∂ If ko≈üulu kontrol ediliyor...', conditionTrue);
                if (conditionTrue) {
                    console.log('‚úÖ Ko≈üul doƒüru, then bloƒüu √ßalƒ±≈ütƒ±rƒ±lƒ±yor');
                    let innerBlock = doBlock;
                    while (innerBlock) {
                        await executeBlockPlay(innerBlock);
                        innerBlock = innerBlock.getNextBlock();
                    }
                } else {
                    console.log('‚ùå Ko≈üul yanlƒ±≈ü, atlanƒ±yor');
                }
                return;
            }

            // If-then-else bloƒüu
            if (blockType === 'if_then_else') {
                const conditionBlock = block.getInputTargetBlock('CONDITION');
                const doBlock = block.getInputTargetBlock('DO');
                const elseBlock = block.getInputTargetBlock('ELSE');

                // Ko≈üulu deƒüerlendir
                let conditionTrue = false;
                if (conditionBlock) {
                    const result = await executeBlockPlay(conditionBlock);
                    conditionTrue = Boolean(result);
                }

                console.log('üî∂ If-else ko≈üulu kontrol ediliyor...', conditionTrue);
                if (conditionTrue) {
                    console.log('‚úÖ Ko≈üul doƒüru, then bloƒüu √ßalƒ±≈ütƒ±rƒ±lƒ±yor');
                    let innerBlock = doBlock;
                    while (innerBlock) {
                        await executeBlockPlay(innerBlock);
                        innerBlock = innerBlock.getNextBlock();
                    }
                } else {
                    console.log('‚ùå Ko≈üul yanlƒ±≈ü, else bloƒüu √ßalƒ±≈ütƒ±rƒ±lƒ±yor');
                    let innerBlock = elseBlock;
                    while (innerBlock) {
                        await executeBlockPlay(innerBlock);
                        innerBlock = innerBlock.getNextBlock();
                    }
                }
                return;
            }

            // Wait until bloƒüu
            if (blockType === 'wait_until') {
                console.log('‚è≥ Wait until - ko≈üul bekleniyor...');
                // Basitle≈ütirilmi≈ü: 1 saniye bekle
                await sleep(1000);
                console.log('‚úÖ Wait until tamamlandƒ±');
                return;
            }

            // Repeat until bloƒüu - ko≈üul saƒülanana kadar tekrarla
            if (blockType === 'repeat_until') {
                const conditionBlock = block.getInputTargetBlock('CONDITION');
                const doBlock = block.getInputTargetBlock('DO');

                console.log('üîÅ Repeat until ba≈üladƒ±...');

                // Maksimum 1000 iterasyon (sonsuz d√∂ng√º korumasƒ±)
                for (let i = 0; i < 1000; i++) {
                    // Ko≈üulu kontrol et
                    let conditionMet = false;
                    if (conditionBlock) {
                        const result = await executeBlockPlay(conditionBlock);
                        conditionMet = Boolean(result);
                    }

                    if (conditionMet) {
                        console.log('üîÅ Repeat until ko≈üul saƒülandƒ±, √ßƒ±kƒ±lƒ±yor');
                        break;
                    }

                    // ƒ∞√ß bloklarƒ± √ßalƒ±≈ütƒ±r
                    let innerBlock = doBlock;
                    while (innerBlock) {
                        await executeBlockPlay(innerBlock);
                        innerBlock = innerBlock.getNextBlock();
                    }

                    // Her iterasyonda k√º√ß√ºk bir bekleme
                    await sleep(50);
                }
                console.log('üîÅ Repeat until tamamlandƒ±');
                return;
            }

            // Forever bloƒüu - sonsuz d√∂ng√º (≈üimdilik 100 kez)
            if (blockType === 'forever') {
                const doBlock = block.getInputTargetBlock('DO');
                console.log('‚ôæÔ∏è S√ºrekli d√∂ng√º ba≈üladƒ± (100 iterasyon)...');

                for (let i = 0; i < 100; i++) {
                    let innerBlock = doBlock;
                    while (innerBlock) {
                        await executeBlockPlay(innerBlock);
                        innerBlock = innerBlock.getNextBlock();
                    }
                }
                return;
            }

            // RGB LED kontrolleri
            if (blockType === 'rgb_red_on') {
                rgbLedState.red = true;
                document.getElementById('rgbRedLed').classList.add('active');
                console.log('üî¥ Kƒ±rmƒ±zƒ± LED yakƒ±ldƒ±');
            } else if (blockType === 'rgb_green_on') {
                rgbLedState.green = true;
                document.getElementById('rgbGreenLed').classList.add('active');
                console.log('üü¢ Ye≈üil LED yakƒ±ldƒ±');
            } else if (blockType === 'rgb_blue_on') {
                rgbLedState.blue = true;
                document.getElementById('rgbBlueLed').classList.add('active');
                console.log('üîµ Mavi LED yakƒ±ldƒ±');
            }

            // RGB LED s√∂nd√ºr kontrolleri
            else if (blockType === 'rgb_red_off') {
                rgbLedState.red = false;
                document.getElementById('rgbRedLed').classList.remove('active');
                console.log('‚óØ Kƒ±rmƒ±zƒ± LED s√∂nd√ºr√ºld√º');
            } else if (blockType === 'rgb_green_off') {
                rgbLedState.green = false;
                document.getElementById('rgbGreenLed').classList.remove('active');
                console.log('‚óØ Ye≈üil LED s√∂nd√ºr√ºld√º');
            } else if (blockType === 'rgb_blue_off') {
                rgbLedState.blue = false;
                document.getElementById('rgbBlueLed').classList.remove('active');
                console.log('‚óØ Mavi LED s√∂nd√ºr√ºld√º');
            }

            // RGB sayƒ± kontrolleri
            else if (blockType === 'rgb_red_num') {
                const numBlock = block.getInputTargetBlock('NUM');
                const numValue = numBlock ? await executeBlockPlay(numBlock) : 0;
                rgbNumberState.red = numValue;
                document.getElementById('rgbRedNum').textContent = numValue;
                console.log('üü• Kƒ±rmƒ±zƒ± sayƒ±:', numValue);
            } else if (blockType === 'rgb_green_num') {
                const numBlock = block.getInputTargetBlock('NUM');
                const numValue = numBlock ? await executeBlockPlay(numBlock) : 0;
                rgbNumberState.green = numValue;
                document.getElementById('rgbGreenNum').textContent = numValue;
                console.log('üü© Ye≈üil sayƒ±:', numValue);
            } else if (blockType === 'rgb_blue_num') {
                const numBlock = block.getInputTargetBlock('NUM');
                const numValue = numBlock ? await executeBlockPlay(numBlock) : 0;
                rgbNumberState.blue = numValue;
                document.getElementById('rgbBlueNum').textContent = numValue;
                console.log('üü¶ Mavi sayƒ±:', numValue);
            }

            // RGB sayƒ± getir kontrolleri
            else if (blockType === 'rgb_red_get') {
                console.log('üü• Kƒ±rmƒ±zƒ± sayƒ± getir:', rgbNumberState.red);
                return rgbNumberState.red;
            } else if (blockType === 'rgb_green_get') {
                console.log('üü© Ye≈üil sayƒ± getir:', rgbNumberState.green);
                return rgbNumberState.green;
            } else if (blockType === 'rgb_blue_get') {
                console.log('üü¶ Mavi sayƒ± getir:', rgbNumberState.blue);
                return rgbNumberState.blue;
            }

            // RGB ƒ±≈üƒ±k getir kontrolleri
            else if (blockType === 'rgb_red_light_get') {
                console.log('üî¥ Kƒ±rmƒ±zƒ± ƒ±≈üƒ±k getir:', rgbLedState.red);
                return rgbLedState.red;
            } else if (blockType === 'rgb_green_light_get') {
                console.log('üü¢ Ye≈üil ƒ±≈üƒ±k getir:', rgbLedState.green);
                return rgbLedState.green;
            } else if (blockType === 'rgb_blue_light_get') {
                console.log('üîµ Mavi ƒ±≈üƒ±k getir:', rgbLedState.blue);
                return rgbLedState.blue;
            }

            // Motor kontrolleri
            else if (blockType === 'motor_run_rotation') {
                const dir = block.getFieldValue('DIRECTION');
                const rot = block.getFieldValue('ROTATIONS');
                console.log(`üîÑ Motor ${dir === 'CW' ? '‚Üª' : '‚Ü∫'} ${rot} rotasyon`);

                // Bluetooth motor kontrol√º
                const deviceId = block.data;
                console.log('DEBUG: deviceId =', deviceId);
                console.log('DEBUG: block =', block);
                console.log('DEBUG: block.data =', block.data);

                if (deviceId) {
                    console.log('‚úÖ deviceId var, runMotorRotations √ßaƒürƒ±lƒ±yor...');
                    await runMotorRotations(deviceId, parseInt(rot), dir);
                } else {
                    console.log('‚ùå deviceId yok! Motor Bluetooth komutu g√∂nderilemedi.');
                    console.log('   Motor cihazƒ±nƒ± √∂nce baƒülayƒ±n ve bloƒüu motor ikonundan s√ºr√ºkleyin.');
                }
            } else if (blockType === 'motor_run_to_angle') {
                const dir = block.getFieldValue('DIRECTION');
                const angle = block.getFieldValue('ANGLE');
                console.log(`üéØ Motor ${dir === 'CW' ? '‚Üª' : '‚Ü∫'} ${angle}¬∞ a√ßƒ±ya git (g√∂receli)`);

                // Bluetooth motor kontrol√º
                const deviceId = block.data;
                console.log('DEBUG: deviceId =', deviceId);

                if (deviceId) {
                    console.log('‚úÖ deviceId var, runMotorToAngle √ßaƒürƒ±lƒ±yor...');
                    await runMotorToAngle(deviceId, parseInt(angle), dir);
                } else {
                    console.log('‚ùå deviceId yok! Motor Bluetooth komutu g√∂nderilemedi.');
                }
            } else if (blockType === 'motor_go_to_position') {
                const position = block.getFieldValue('POSITION');
                console.log(`üìç Motor ${position}¬∞ pozisyonuna git (mutlak)`);

                // Bluetooth motor kontrol√º
                const deviceId = block.data;
                if (deviceId) {
                    await goToPosition(deviceId, parseInt(position));
                } else {
                    console.log('‚ùå deviceId yok!');
                }
            } else if (blockType === 'motor_start') {
                const dir = block.getFieldValue('DIRECTION');
                console.log(`‚ñ∂Ô∏è Motor ${dir === 'CW' ? '‚Üª' : '‚Ü∫'} ba≈ülatƒ±ldƒ±`);

                // Bluetooth motor kontrol√º
                const deviceId = block.data;
                if (deviceId) {
                    await startMotor(deviceId, dir);
                } else {
                    console.log('‚ùå deviceId yok!');
                }
            } else if (blockType === 'motor_stop') {
                console.log('‚èπÔ∏è Motor durduruldu');

                // Bluetooth motor kontrol√º
                const deviceId = block.data;
                if (deviceId) {
                    await stopMotor(deviceId);
                } else {
                    console.log('‚ùå deviceId yok!');
                }
            }

            // Matematik bloklarƒ±
            else if (blockType === 'math_number') {
                const num = parseFloat(block.getFieldValue('NUM'));
                return num;
            } else if (blockType === 'math_random') {
                const fromBlock = block.getInputTargetBlock('FROM');
                const toBlock = block.getInputTargetBlock('TO');
                const from = fromBlock ? await executeBlockPlay(fromBlock) : 1;
                const to = toBlock ? await executeBlockPlay(toBlock) : 10;
                return Math.floor(Math.random() * (to - from + 1)) + from;
            } else if (blockType === 'math_arithmetic') {
                const op = block.getFieldValue('OP');
                const aBlock = block.getInputTargetBlock('A');
                const bBlock = block.getInputTargetBlock('B');
                const a = aBlock ? await executeBlockPlay(aBlock) : 0;
                const b = bBlock ? await executeBlockPlay(bBlock) : 0;

                let result = 0;
                switch (op) {
                    case 'ADD': result = a + b; break;
                    case 'MINUS': result = a - b; break;
                    case 'MULTIPLY': result = a * b; break;
                    case 'DIVIDE': result = a / b; break;
                    case 'POWER': result = Math.pow(a, b); break;
                    case 'MOD': result = a % b; break;
                }
                return result;
            }

            // Controller kontrolleri
            else if (blockType === 'when_lever_position') {
                const lever = block.getFieldValue('LEVER');
                const position = block.getFieldValue('POSITION');
                console.log(`üïπÔ∏è When ${lever} lever is ${position}`);
            } else if (blockType === 'lever_position') {
                const lever = block.getFieldValue('LEVER');
                const position = block.getFieldValue('POSITION');

                // Mevcut controller durumunu kontrol et
                let currentPosition;
                if (lever === 'LEFT') {
                    currentPosition = controllerState.left;
                } else if (lever === 'RIGHT') {
                    currentPosition = controllerState.right;
                } else if (lever === 'ANY') {
                    currentPosition = controllerState.left !== 'RELEASED' ? controllerState.left : controllerState.right;
                } else if (lever === 'BOTH') {
                    if (controllerState.left === controllerState.right) {
                        currentPosition = controllerState.left;
                    } else {
                        currentPosition = 'RELEASED';
                    }
                }

                const result = currentPosition === position;
                console.log(`üïπÔ∏è Checking ${lever} lever is ${position}? Current: ${currentPosition}, Result: ${result}`);
                return result;
            }

            // Diƒüer bloklar i√ßin log
            else {
                console.log(`√áalƒ±≈ütƒ±rƒ±ldƒ±: ${blockType}`);
            }

            // Her blok arasƒ±nda k√º√ß√ºk bir gecikme (animasyon i√ßin)
            await sleep(100);
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Ko≈üul bloƒüunu deƒüerlendir
        function evaluateCondition(conditionBlock) {
            if (!conditionBlock) return false;

            const blockType = conditionBlock.type;

            // lever_position bloƒüu
            if (blockType === 'lever_position') {
                const lever = conditionBlock.getFieldValue('LEVER');
                const position = conditionBlock.getFieldValue('POSITION');

                // Mevcut controller durumunu kontrol et
                let currentPosition;
                if (lever === 'LEFT') {
                    currentPosition = controllerState.left;
                } else if (lever === 'RIGHT') {
                    currentPosition = controllerState.right;
                } else if (lever === 'ANY') {
                    currentPosition = controllerState.left !== 'RELEASED' ? controllerState.left : controllerState.right;
                } else if (lever === 'BOTH') {
                    // Her iki lever da aynƒ± pozisyonda mƒ±?
                    if (controllerState.left === controllerState.right) {
                        currentPosition = controllerState.left;
                    } else {
                        currentPosition = 'RELEASED';
                    }
                }

                const result = currentPosition === position;
                console.log(`üïπÔ∏è Ko≈üul kontrol√º: ${lever} lever is ${position}? Mevcut: ${currentPosition}, Sonu√ß: ${result}`);
                return result;
            }

            // Diƒüer boolean bloklarƒ± i√ßin
            console.log(`‚ö†Ô∏è Bilinmeyen ko≈üul bloƒüu: ${blockType}`);
            return false;
        }

        function stopCode() {
            alert('‚èπÔ∏è Durduruldu!');
        }

        function resetEverything() {
            if (confirm('üîÑ Her ≈üeyi sƒ±fƒ±rlamak istediƒüinize emin misiniz?\n\n‚Ä¢ RGB paneli sƒ±fƒ±rlanacak\n‚Ä¢ T√ºm LED\'ler s√∂necek\n‚Ä¢ Sayƒ± deƒüerleri 0 olacak\n‚Ä¢ Cihazlar baƒülƒ± kalacak')) {
                // RGB LED'leri s√∂nd√ºr
                rgbLedState = { red: false, green: false, blue: false };
                document.getElementById('rgbRedLed').classList.remove('active');
                document.getElementById('rgbGreenLed').classList.remove('active');
                document.getElementById('rgbBlueLed').classList.remove('active');

                // RGB sayƒ±larƒ± sƒ±fƒ±rla
                rgbNumberState = { red: 0, green: 0, blue: 0 };
                document.getElementById('rgbRedNum').textContent = '0';
                document.getElementById('rgbGreenNum').textContent = '0';
                document.getElementById('rgbBlueNum').textContent = '0';

                // Motor i≈ülem kilidini sƒ±fƒ±rla
                motorOperationInProgress = false;

                // Play butonunu aktif et
                const playBtn = document.querySelector('.play-btn');
                if (playBtn) {
                    playBtn.disabled = false;
                    playBtn.style.opacity = '1';
                    playBtn.style.cursor = 'pointer';
                    playBtn.style.background = '#FFBF00';
                }

                console.log('üîÑ Her ≈üey sƒ±fƒ±rlandƒ± (cihazlar hari√ß)');

                // G√∂rsel feedback
                const resetBtn = document.querySelector('.reset-btn');
                resetBtn.style.background = '#51cf66';
                setTimeout(() => {
                    resetBtn.style.background = '#FF6680';
                }, 300);
            }
        }

        // Global scope'a ekle
        window.resetEverything = resetEverything;

        function addDevice() {
            console.log('addDevice √ßaƒürƒ±ldƒ±');
            console.log('navigator.bluetooth:', navigator.bluetooth);

            const modal = document.getElementById('deviceModal');
            console.log('deviceModal element:', modal);

            if (modal) {
                // Hem class hem inline style ekle
                modal.classList.add('show');
                modal.style.display = 'flex';
                modal.style.zIndex = '10000';

                console.log('Modal a√ßƒ±ldƒ±');
                console.log('Modal classes:', modal.className);
                console.log('Modal display:', modal.style.display);
            } else {
                console.error('deviceModal bulunamadƒ±!');
                alert('Modal element bulunamadƒ±!');
            }
        }

        // Global scope'a ekle
        window.addDevice = addDevice;

        // RGB LED kontrol fonksiyonlarƒ±
        let bluetoothDevice = null;
        let bluetoothServer = null;
        let connectedCharacteristics = {};
        let connectedDevices = [];
        let selectedDeviceId = null;
        let deviceMenuOpen = null; // A√ßƒ±k cihaz men√ºs√º

        const DEVICE_SHAPES = ['triangle', 'square', 'rectangle', 'pentagon', 'hexagon', 'octagon', 'circle'];
        const DEVICE_COLORS = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B739'];

        // ===== BLUETOOTH MOTOR KONTROL FONKSƒ∞YONLARI =====

        // Hex string'i byte array'e √ßevir
        function hexToBytes(hexString) {
            const hex = hexString.replace(/:/g, '');
            const bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i < hex.length; i += 2) {
                bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
            }
            return bytes;
        }

        // Motor komut sabitleri
        const MOTOR_COMMANDS = {
            INIT: hexToBytes("30:31:30:32:30:33:30:34:30:35:30:36:30:37:30:38"),
            CONFIG: hexToBytes("02:00"),
            CMD_START: hexToBytes("00"),
            CMD_PREPARE: hexToBytes("1a"),
            CMD_MODE: hexToBytes("28:32:00"),
            CMD_CONTROL: hexToBytes("20:00"),
            // CMD_EXECUTE rotasyon sayƒ±sƒ±na g√∂re deƒüi≈üir, a≈üaƒüƒ±da fonksiyon var
            MOTOR_INIT_1: hexToBytes("01:01:00:31:00:01:00:3e:00:01:00:00:00:f7:00:00:02"),
            MOTOR_INIT_2: hexToBytes("1b:9d:4d:ce:36:00:4b:12:00"),
            MOTOR_INIT_3: hexToBytes("29:00"),
            MOTOR_BASE: hexToBytes("3c:12:00:00:46:00:0a:01:07:56:01:00:00:00:ef:ff:ff:ff:11:01:ff"), // capturing_rotasyon_sagvesol.pcap
            MOTOR_STOP_INIT: hexToBytes("7d:01:00"),
            // Alternatif durma komutlarƒ±
            MOTOR_BRAKE: hexToBytes("00:00"),  // Fren
            MOTOR_FLOAT: hexToBytes("7d:00:00"), // Serbest bƒ±rak
        };

        // Y√∂ne g√∂re motor base komutu olu≈ütur
        function createMotorBaseCommand(direction = 'CW') {
            // capturing_rotasyon_sagvesol.pcap ANALƒ∞Zƒ∞ (ROTASYON):
            // SAƒûA (CW): 3c 12 00 00 46 00 0a 01 07 56 01 00 00 00 ef ff ff ff 11 01 ff
            // SOLA (CCW): Motor base byte 8-9 deƒüi≈ümiyor, execute komutu y√∂n√º belirliyor
            //             SOLA i√ßin motor base SAƒûA ile aynƒ±

            // Rotasyon i√ßin her iki y√∂n de aynƒ± motor base kullanƒ±yor
            return hexToBytes("3c:12:00:00:46:00:0a:01:07:56:01:00:00:00:ef:ff:ff:ff:11:01:ff");
        }

        // Rotasyon/a√ßƒ±ya g√∂re CMD_EXECUTE olu≈ütur
        function createExecuteCommand(value, isRotation = true, direction = 'CW') {
            // Eƒüer rotasyon ise dereceye √ßevir
            let degrees = isRotation ? (value * 360) : value;

            // PCAP ANALƒ∞Zƒ∞ (capturing_rotasyon_sagvesol.pcap):
            // SAƒûA: 7c 01 68 01 00 00 00 (son byte = 0x00)
            // SOLA: 7c 01 68 01 00 00 01 (son byte = 0x01)
            // Y√∂n son byte'ta kodlanƒ±yor, derece deƒüeri pozitif kalƒ±yor!

            // Derece deƒüeri her zaman pozitif (negatif YOK)
            const posDegrees = Math.abs(degrees);

            // Signed 16-bit integer olarak encode et (little endian)
            const signed16 = posDegrees & 0xFFFF;
            const lowByte = signed16 & 0xFF;
            const highByte = (signed16 >> 8) & 0xFF;

            // Son byte y√∂n√º belirliyor: 0x00 = SAƒûA, 0x01 = SOLA
            const directionByte = direction === 'CW' ? 0x00 : 0x01;

            // 7c:01:[LOW]:[HIGH]:00:00:[DIR]
            const cmd = new Uint8Array([0x7c, 0x01, lowByte, highByte, 0x00, 0x00, directionByte]);

            const unit = isRotation ? 'rotasyon' : 'derece';
            const dirSymbol = direction === 'CW' ? '‚Üª' : '‚Ü∫';
            console.log(`CMD_EXECUTE i√ßin ${value} ${unit} ${dirSymbol} = ${posDegrees}¬∞ = 0x${signed16.toString(16)} = [${lowByte.toString(16)}, ${highByte.toString(16)}, dir=${directionByte.toString(16)}]`);

            return cmd;
        }

        const MOTOR_SPEED_CHANGES = [
            hexToBytes("3c:12:00:00:64:00:0a:01:07:2e:01:00:00:00:c6:ff:ff:ff:11:01:ff"),
            hexToBytes("3c:12:00:00:64:00:0a:01:01:31:01:75:09:00:c9:ff:ff:ff:11:01:ff"),
            hexToBytes("3c:12:00:00:64:00:0a:01:01:42:01:cb:13:04:da:ff:ff:ff:11:01:ff"),
            hexToBytes("3c:12:00:00:64:00:0a:01:01:60:01:a3:1e:09:f8:ff:ff:ff:11:01:ff"),
        ];

        const MOTOR_SLOWDOWN = [
            hexToBytes("3c:12:00:00:64:00:0a:01:07:2e:01:00:00:33:fe:03:00:00:11:01:ff"),
            hexToBytes("3c:12:00:00:64:00:0a:01:07:2e:01:00:00:2d:fe:03:00:00:11:01:ff"),
            hexToBytes("3c:12:00:00:64:00:0a:01:07:2e:01:00:00:28:fe:03:00:00:11:01:ff"),
            hexToBytes("3c:12:00:00:64:00:0a:01:07:2e:01:00:00:23:fe:03:00:00:11:01:ff"),
        ];

        // Cihazƒ±n karakteristiklerini al
        async function getMotorCharacteristics(deviceId) {
            console.log('getMotorCharacteristics √ßaƒürƒ±ldƒ±, deviceId:', deviceId);
            console.log('connectedDevices:', connectedDevices);

            const deviceData = connectedDevices.find(d => d.id === deviceId);
            console.log('Bulunan deviceData:', deviceData);

            if (!deviceData) {
                console.error('‚ùå Motor cihazƒ± connectedDevices i√ßinde bulunamadƒ±!');
                return null;
            }

            if (!deviceData.server) {
                console.error('‚ùå deviceData.server yok!');
                return null;
            }

            if (!deviceData.server.connected) {
                console.error('‚ùå GATT server baƒülƒ± deƒüil!');
                return null;
            }

            // Motor UUID'leri (PCAP analizinden)
            const MOTOR_SERVICE_UUIDS = [
                '0000fd02-0000-1000-8000-00805f9b34fb', // Ana motor servisi
                '00002a05-0000-1000-8000-00805f9b34fb', // INIT
                '00002b2a-0000-1000-8000-00805f9b34fb', // CONFIG
            ];

            const MOTOR_CHAR_UUIDS = {
                INIT: '00002a05-0000-1000-8000-00805f9b34fb',
                CONFIG: '00002b2a-0000-1000-8000-00805f9b34fb',
                COMMAND: '0000fd02-0001-1000-8000-00805f9b34fb',
                MOTOR: '0000fd02-0002-1000-8000-00805f9b34fb'
            };

            try {
                console.log('‚úì Server baƒülƒ±, belirli servisleri arƒ±yoruz...');
                const chars = {};

                // Her UUID'yi deneyelim
                for (const serviceUUID of MOTOR_SERVICE_UUIDS) {
                    try {
                        console.log(`  ‚Üí Servis ${serviceUUID} deneniyor...`);
                        const service = await deviceData.server.getPrimaryService(serviceUUID);
                        console.log(`    ‚úì Servis bulundu!`);

                        const characteristics = await service.getCharacteristics();
                        console.log(`    ${characteristics.length} karakteristik bulundu`);

                        for (const char of characteristics) {
                            console.log(`      - UUID: ${char.uuid}, Write: ${char.properties.write}, WriteNoResp: ${char.properties.writeWithoutResponse}`);

                            // T√ºm write karakteristiklerini kaydet
                            if (char.properties.write || char.properties.writeWithoutResponse) {
                                chars[char.uuid] = char;
                                console.log(`        ‚úì Yazƒ±labilir karakteristik kaydedildi`);
                            }
                        }
                    } catch (e) {
                        console.log(`    ‚ö†Ô∏è Servis ${serviceUUID} bulunamadƒ±: ${e.message}`);
                    }
                }

                // Eƒüer hi√ß karakteristik bulamadƒ±ysak, belirli karakteristikleri deneyelim
                if (Object.keys(chars).length === 0) {
                    console.log('  ‚Üí Hi√ß servis bulunamadƒ±, karakteristikleri direkt deniyoruz...');

                    for (const [name, uuid] of Object.entries(MOTOR_CHAR_UUIDS)) {
                        try {
                            // Ana servisten karakteristiƒüi almayƒ± dene
                            const service = await deviceData.server.getPrimaryService('0000fd02-0000-1000-8000-00805f9b34fb');
                            const char = await service.getCharacteristic(uuid);
                            chars[uuid] = char;
                            console.log(`    ‚úì ${name} karakteristiƒüi bulundu: ${uuid}`);
                        } catch (e) {
                            console.log(`    ‚ö†Ô∏è ${name} karakteristiƒüi bulunamadƒ±`);
                        }
                    }
                }

                console.log(`‚úÖ Toplam ${Object.keys(chars).length} yazƒ±labilir karakteristik bulundu`);

                if (Object.keys(chars).length === 0) {
                    console.error('‚ùå Hi√ß karakteristik bulunamadƒ±! Motor cihazƒ± Web Bluetooth ile uyumlu olmayabilir.');
                    return null;
                }

                return chars;
            } catch (error) {
                console.error('‚ùå Karakteristikler alƒ±namadƒ±:', error);
                console.error('   Error name:', error.name);
                console.error('   Error message:', error.message);
                return null;
            }
        }

        // Karakteristiƒüe veri yaz
        async function writeMotorCommand(characteristic, data, delay = 50) {
            if (!characteristic) return;
            try {
                await characteristic.writeValue(data);
                await new Promise(resolve => setTimeout(resolve, delay));
            } catch (error) {
                console.error('Motor komut yazma hatasƒ±:', error);
            }
        }

        // Motor initialize
        async function initializeMotor(deviceId) {
            const chars = await getMotorCharacteristics(deviceId);
            if (!chars) return false;

            console.log('Motor ba≈ülatƒ±lƒ±yor...');

            // ƒ∞lk eri≈üilebilir karakteristik √ºzerinden komutlarƒ± g√∂nder
            // Ger√ßek uygulamada doƒüru UUID'leri bulup kullanmalƒ±sƒ±nƒ±z
            const writeChar = Object.values(chars)[0];

            if (writeChar) {
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.INIT);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CONFIG);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_START);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_INIT_1);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_PREPARE);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_INIT_2);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_MODE);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_INIT_3);
            }

            console.log('‚úì Motor ba≈ülatƒ±ldƒ±');
            return true;
        }

        // Motor rotasyon √ßalƒ±≈ütƒ±r
        async function runMotorRotations(deviceId, rotations, direction = 'CW') {
            // Motor i≈ülemi devam ediyorsa bekle
            if (motorOperationInProgress) {
                console.log('‚è≥ Ba≈üka bir motor i≈ülemi devam ediyor, bekleniyor...');
                return;
            }

            motorOperationInProgress = true;

            try {
                const chars = await getMotorCharacteristics(deviceId);

                if (!chars) {
                    console.error('‚ùå Karakteristikler alƒ±namadƒ±!');
                    return;
                }

                console.log(`üîÑ ${rotations} rotasyon ba≈ülatƒ±lƒ±yor...`);

                const writeChar = Object.values(chars)[0];

                if (!writeChar) {
                    console.error('‚ùå Yazƒ±labilir karakteristik bulunamadƒ±');
                    return;
                }

                // Sabit hƒ±z komutlarƒ± (her zaman 43 - rotasyon CMD_EXECUTE ile belirlenir)
                const totalCommands = 43;

                for (let i = 0; i < totalCommands; i++) {
                    await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_BASE, 30);
                }

                // Kontrol noktasƒ±
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_CONTROL);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_BASE);

                // Rotasyon sayƒ±sƒ±na g√∂re execute komutu olu≈ütur
                const executeCmd = createExecuteCommand(rotations, true, direction);
                await writeMotorCommand(writeChar, executeCmd);

                // Hƒ±z deƒüi≈üimi
                for (const cmd of MOTOR_SPEED_CHANGES) {
                    await writeMotorCommand(writeChar, cmd);
                }

                // Rotasyon devam komutlarƒ±
                const rotationCommands = [
                    hexToBytes("3c:12:00:00:64:00:0a:01:01:21:00:97:22:11:22:00:00:00:11:01:ff"),
                    hexToBytes("3c:12:00:00:64:00:0a:01:01:50:00:60:22:18:51:00:00:00:11:01:ff"),
                    hexToBytes("3c:12:00:00:64:00:0a:01:01:7e:00:ee:21:1f:7f:00:00:00:11:01:ff"),
                ];

                for (const cmd of rotationCommands) {
                    await writeMotorCommand(writeChar, cmd);
                }

                // Durma ba≈ülangƒ±cƒ±
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_STOP_INIT);

                // Yava≈ülama
                for (const cmd of MOTOR_SLOWDOWN) {
                    await writeMotorCommand(writeChar, cmd);
                }

                // Final durma
                for (let i = 0; i < 20; i++) {
                    await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_BASE, 30);
                }

                console.log('‚úÖ Rotasyon tamamlandƒ±!');
            } finally {
                motorOperationInProgress = false;
            }
        }

        // Motor a√ßƒ±ya git
        async function runMotorToAngle(deviceId, angle, direction = 'CW') {
            // Motor i≈ülemi devam ediyorsa bekle
            if (motorOperationInProgress) {
                console.log('‚è≥ Ba≈üka bir motor i≈ülemi devam ediyor, bekleniyor...');
                return;
            }

            motorOperationInProgress = true;

            try {
                const chars = await getMotorCharacteristics(deviceId);

                if (!chars) {
                    console.error('‚ùå Karakteristikler alƒ±namadƒ±!');
                    return;
                }

                console.log(`üéØ ${angle}¬∞ a√ßƒ±ya ${direction} y√∂n√ºnde gidiliyor...`);

                const writeChar = Object.values(chars)[0];

                if (!writeChar) {
                    console.error('‚ùå Yazƒ±labilir karakteristik bulunamadƒ±');
                    return;
                }

                // Sabit hƒ±z komutlarƒ±
                const totalCommands = 43;

                for (let i = 0; i < totalCommands; i++) {
                    await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_BASE, 30);
                }

                // Kontrol noktasƒ±
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_CONTROL);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_BASE);

                // A√ßƒ±ya g√∂re execute komutu olu≈ütur
                const executeCmd = createExecuteCommand(angle, false, direction);
                await writeMotorCommand(writeChar, executeCmd);

                // Hƒ±z deƒüi≈üimi
                for (const cmd of MOTOR_SPEED_CHANGES) {
                    await writeMotorCommand(writeChar, cmd);
                }

                // Rotasyon devam komutlarƒ±
                const rotationCommands = [
                    hexToBytes("3c:12:00:00:64:00:0a:01:01:21:00:97:22:11:22:00:00:00:11:01:ff"),
                    hexToBytes("3c:12:00:00:64:00:0a:01:01:50:00:60:22:18:51:00:00:00:11:01:ff"),
                    hexToBytes("3c:12:00:00:64:00:0a:01:01:7e:00:ee:21:1f:7f:00:00:00:11:01:ff"),
                ];

                for (const cmd of rotationCommands) {
                    await writeMotorCommand(writeChar, cmd);
                }

                // Durma ba≈ülangƒ±cƒ±
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_STOP_INIT);

                // Yava≈ülama
                for (const cmd of MOTOR_SLOWDOWN) {
                    await writeMotorCommand(writeChar, cmd);
                }

                // Final durma
                for (let i = 0; i < 20; i++) {
                    await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_BASE, 30);
                }

                console.log(`‚úÖ ${angle}¬∞ a√ßƒ±ya varƒ±ldƒ±!`);
            } finally {
                motorOperationInProgress = false;
            }
        }


        // Motor mutlak pozisyona git (0¬∞ referansƒ±na g√∂re)
        // PCAP ANALƒ∞Zƒ∞ (capturing_bluetooth_67angle.pcap):
        // Frame 23: 20 00            ‚Üí Handle 0x000c (CMD char) - Ba≈ülatma komutu
        // Frame 25: 80 01 43 00 02   ‚Üí Handle 0x000c (CMD char) - 67¬∞ pozisyon komutu (0x43 = 67)
        // Frame 86: 20 01            ‚Üí Handle 0x000c (CMD char) - Tamamlama komutu (opsiyonel)
        async function goToPosition(deviceId, position) {
            // Motor i≈ülemi devam ediyorsa bekle
            if (motorOperationInProgress) {
                console.log('‚è≥ Ba≈üka bir motor i≈ülemi devam ediyor, bekleniyor...');
                return;
            }

            motorOperationInProgress = true;

            try {
                // Device'ƒ± bul
                const deviceData = connectedDevices.find(d => d.id === deviceId);
                if (!deviceData || !deviceData.server) {
                    console.error('‚ùå Device bulunamadƒ± veya baƒülƒ± deƒüil');
                    return;
                }

                console.log(`üìç ${position}¬∞ pozisyonuna gidiliyor...`);

                // Servisi al
                const service = await deviceData.server.getPrimaryService('0000fd02-0000-1000-8000-00805f9b34fb');

                // CMD karakteristiƒüini al (Handle 0x000c = 0000fd02-0001)
                const cmdChar = await service.getCharacteristic('0000fd02-0001-1000-8000-00805f9b34fb');

                // Pozisyon deƒüerini little-endian formatƒ±nda hazƒ±rla
                const posBytes = position & 0xFFFF;
                const lowByte = posBytes & 0xFF;
                const highByte = (posBytes >> 8) & 0xFF;

                // 1. Ba≈ülatma komutu: 20 00
                const startCmd = new Uint8Array([0x20, 0x00]);
                await cmdChar.writeValueWithoutResponse(startCmd);
                await new Promise(resolve => setTimeout(resolve, 50));

                // 2. Pozisyon komutu: 80 01 [LOW] [HIGH] 02
                const positionCmd = new Uint8Array([0x80, 0x01, lowByte, highByte, 0x02]);
                await cmdChar.writeValueWithoutResponse(positionCmd);

                // Motor hareket etmesi i√ßin bekle
                const waitTime = Math.max(500, Math.abs(position) * 30);
                await new Promise(resolve => setTimeout(resolve, waitTime));

                console.log(`‚úÖ ${position}¬∞ pozisyonuna gidildi!`);

            } catch (error) {
                console.error('‚ùå goToPosition hatasƒ±:', error);
            } finally {
                motorOperationInProgress = false;
            }
        }

        // Motor ba≈ülat (s√ºrekli d√∂nme)
        async function startMotor(deviceId, direction = 'CW') {
            // Motor i≈ülemi devam ediyorsa bekle
            if (motorOperationInProgress) {
                console.log('‚è≥ Ba≈üka bir motor i≈ülemi devam ediyor, bekleniyor...');
                return;
            }

            motorOperationInProgress = true;

            try {
                const chars = await getMotorCharacteristics(deviceId);

                if (!chars) {
                    console.error('‚ùå Karakteristikler alƒ±namadƒ±!');
                    return;
                }

                console.log(`‚ñ∂Ô∏è Motor ${direction === 'CW' ? 'saƒüa ‚Üª' : 'sola ‚Ü∫'} ba≈ülatƒ±lƒ±yor...`);

                const writeChar = Object.values(chars)[0];

                if (!writeChar) {
                    console.error('‚ùå Yazƒ±labilir karakteristik bulunamadƒ±');
                    return;
                }

                // Ba≈ülatma komutlarƒ±
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_START);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_INIT_1);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_PREPARE);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_INIT_2);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_MODE);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_INIT_3);

                // Y√∂ne g√∂re motor base komutu
                const motorBaseCmd = createMotorBaseCommand(direction);

                // Sabit hƒ±z komutlarƒ± (43 komut)
                for (let i = 0; i < 43; i++) {
                    await writeMotorCommand(writeChar, motorBaseCmd, 30);
                }

                // Kontrol ve execute
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_CONTROL);
                await writeMotorCommand(writeChar, motorBaseCmd);

                // S√ºrekli d√∂nme i√ßin y√ºksek rotasyon execute komutu
                const continuousRotations = 100;
                const executeCmd = createExecuteCommand(continuousRotations, true, direction);
                await writeMotorCommand(writeChar, executeCmd);

                console.log(`‚úÖ Motor ${direction === 'CW' ? 'saƒüa ‚Üª' : 'sola ‚Ü∫'} ba≈ülatƒ±ldƒ±!`);
            } finally {
                motorOperationInProgress = false;
            }
        }

        // Motor durdur
        async function stopMotor(deviceId) {
            // Stop komutu her zaman √ßalƒ±≈üabilmeli - kilidi temizle ve √ßalƒ±≈ütƒ±r
            motorOperationInProgress = false;

            try {
                const chars = await getMotorCharacteristics(deviceId);

                if (!chars) {
                    console.error('‚ùå Karakteristikler alƒ±namadƒ±!');
                    return;
                }

                console.log('‚èπÔ∏è Motor durduruluyor...');

                const writeChar = Object.values(chars)[0];

                if (!writeChar) {
                    console.error('‚ùå Yazƒ±labilir karakteristik bulunamadƒ±');
                    return;
                }

                // √áoklu durma yakla≈üƒ±mƒ±
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_STOP_INIT);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_STOP_INIT);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_STOP_INIT);

                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_CONTROL);
                const stopExecute = new Uint8Array([0x7c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00]);
                await writeMotorCommand(writeChar, stopExecute);

                for (const cmd of MOTOR_SLOWDOWN) {
                    await writeMotorCommand(writeChar, cmd, 50);
                }

                for (let i = 0; i < 30; i++) {
                    await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_BASE, 10);
                }

                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_STOP_INIT);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_BRAKE);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_FLOAT);

                console.log('‚úÖ Motor durduruldu!');
            } catch (error) {
                console.error('‚ùå stopMotor hatasƒ±:', error);
            }
        }

        // Cihaz tiplerini isimden algƒ±la
        function detectDeviceType(deviceName) {
            const name = deviceName.toLowerCase();
            if (name.includes('motor')) return 'motor';
            if (name.includes('controller') || name.includes('joystick') || name.includes('gamepad')) return 'controller';
            if (name.includes('sensor')) return 'sensor';
            return 'generic';
        }

        // Cihaz tipine g√∂re √∂zel bloklar
        const DEVICE_BLOCKS = {
            'motor': [
                {
                    type: 'motor_run_rotation',
                    icon: 'üîÑ',
                    label: 'run for [1] rotations',
                    color: '#4ECDC4'
                },
                {
                    type: 'motor_run_seconds',
                    icon: '‚è±Ô∏è',
                    label: 'run for [1] seconds',
                    color: '#4ECDC4'
                },
                {
                    type: 'motor_set_speed',
                    icon: '‚ö°',
                    label: 'set speed to [100]%',
                    color: '#4ECDC4'
                },
                {
                    type: 'motor_stop',
                    icon: '‚èπÔ∏è',
                    label: 'stop',
                    color: '#4ECDC4'
                }
            ],
            'controller': [
                {
                    type: 'when_lever_up',
                    icon: 'üïπÔ∏è',
                    label: 'when left lever is up',
                    color: '#45B7D1',
                    isEvent: true
                },
                {
                    type: 'when_lever_down',
                    icon: 'üïπÔ∏è',
                    label: 'when left lever is down',
                    color: '#45B7D1',
                    isEvent: true
                },
                {
                    type: 'when_button_pressed',
                    icon: 'üîò',
                    label: 'when button A pressed',
                    color: '#45B7D1',
                    isEvent: true
                }
            ],
            'generic': [
                {
                    type: 'device_command',
                    icon: 'üì°',
                    label: 'send command',
                    color: '#98D8C8'
                }
            ]
        };

        function getRandomShape() {
            return DEVICE_SHAPES[Math.floor(Math.random() * DEVICE_SHAPES.length)];
        }

        function getRandomColor() {
            return DEVICE_COLORS[Math.floor(Math.random() * DEVICE_COLORS.length)];
        }

        function addDeviceToSidebar(device) {
            const deviceType = detectDeviceType(device.name || '');

            const deviceData = {
                id: device.id,
                name: device.name || 'Motor',
                type: deviceType,
                shape: getRandomShape(),
                color: getRandomColor(),
                device: device,
                server: bluetoothServer,
                characteristics: { ...connectedCharacteristics },
                connected: true
            };

            connectedDevices.push(deviceData);

            // Ana device list'e ekle
            const deviceList = document.getElementById('deviceList');
            const deviceIcon = document.createElement('div');
            deviceIcon.className = `device-icon ${deviceData.shape}`;
            deviceIcon.style.borderColor = deviceData.color;
            deviceIcon.style.color = deviceData.color;
            deviceIcon.dataset.deviceId = deviceData.id;
            deviceIcon.title = deviceData.name;

            // Cihaz ID'nin son 4 karakteri
            const shortId = deviceData.id.split('-').pop().substring(0, 4).toUpperCase();
            deviceIcon.innerHTML = `${shortId}`;

            deviceIcon.onclick = (e) => {
                e.stopPropagation();
                // Eƒüer aynƒ± cihaza tekrar tƒ±klandƒ±ysa toolbox'ƒ± kapat
                if (currentToolboxDevice === deviceData.id && currentToolboxMode === 'device') {
                    hideAllToolboxes();
                    currentToolboxDevice = null;
                } else {
                    // Farklƒ± cihaz - cihaz bloklarƒ±nƒ± toolbox'ta g√∂ster
                    currentToolboxDevice = deviceData.id;
                    showDeviceToolbox(deviceData);
                }
            };

            deviceList.appendChild(deviceIcon);

            // Tabloyu g√ºncelle
            updateDevicesTable();

            console.log('Cihaz eklendi:', deviceData);
        }

        function toggleDeviceMenu(deviceData) {
            const sidebar = document.getElementById('sidebar');
            const panelTitle = document.getElementById('panelTitle');
            const panelContent = document.getElementById('panelContent');
            const icon = document.querySelector(`[data-device-id="${deviceData.id}"]`);

            // Aynƒ± cihaza tekrar tƒ±klanƒ±rsa kapat
            if (deviceMenuOpen === deviceData.id) {
                sidebar.classList.remove('expanded');
                icon.classList.remove('active');
                deviceMenuOpen = null;
                return;
            }

            // √ñnceki aktif ikonu temizle
            document.querySelectorAll('.device-icon').forEach(i => i.classList.remove('active'));
            icon.classList.add('active');

            // Panel i√ßeriƒüini olu≈ütur
            const blocks = DEVICE_BLOCKS[deviceData.type] || DEVICE_BLOCKS['generic'];
            panelTitle.textContent = `${deviceData.name} Bloklarƒ±`;
            panelContent.innerHTML = '';

            blocks.forEach(blockDef => {
                const blockDiv = document.createElement('div');
                blockDiv.className = 'device-menu-block';

                // Ge√ßici bir Blockly bloƒüu olu≈ütur
                const tempBlockType = `temp_${deviceData.id}_${blockDef.type}`;

                // Blok tipini tanƒ±mla
                if (!Blockly.Blocks[tempBlockType]) {
                    createDeviceBlock(tempBlockType, blockDef, deviceData);
                }

                try {
                    // Workspace'de ge√ßici blok olu≈ütur
                    const tempBlock = workspace.newBlock(tempBlockType);
                    tempBlock.initSvg();
                    tempBlock.render();

                    // Bloƒüun SVG'sini al
                    const blockSvg = tempBlock.getSvgRoot();
                    const bbox = blockSvg.getBBox();

                    // SVG wrapper olu≈ütur
                    const svgWrapper = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svgWrapper.setAttribute('width', bbox.width + 10);
                    svgWrapper.setAttribute('height', bbox.height + 10);
                    svgWrapper.setAttribute('viewBox', `${bbox.x - 5} ${bbox.y - 5} ${bbox.width + 10} ${bbox.height + 10}`);

                    // ƒ∞√ßeriƒüi clone'la
                    const clonedContent = blockSvg.cloneNode(true);
                    svgWrapper.appendChild(clonedContent);

                    blockDiv.appendChild(svgWrapper);

                    // Ge√ßici bloƒüu sil
                    tempBlock.dispose(false);

                } catch (error) {
                    console.error('Blok √∂nizleme hatasƒ±:', error);
                    // Hata durumunda basit g√∂sterim
                    blockDiv.innerHTML = `
                        <div style="background: ${blockDef.color}; color: white; padding: 10px 15px; border-radius: 8px; font-size: 13px; font-weight: 600;">
                            ${blockDef.icon} ${blockDef.label}
                        </div>
                    `;
                }

                // Drag and drop
                blockDiv.draggable = true;

                blockDiv.ondragstart = (e) => {
                    e.dataTransfer.effectAllowed = 'copy';
                    e.dataTransfer.setData('blockType', blockDef.type);
                    e.dataTransfer.setData('deviceId', deviceData.id);
                    blockDiv.style.opacity = '0.5';
                };

                blockDiv.ondragend = (e) => {
                    blockDiv.style.opacity = '1';
                };

                panelContent.appendChild(blockDiv);
            });

            // Sidebar'ƒ± geni≈ület
            sidebar.classList.add('expanded');
            deviceMenuOpen = deviceData.id;
        }

        function adjustColor(color, amount) {
            const num = parseInt(color.replace("#", ""), 16);
            const r = Math.max(0, Math.min(255, (num >> 16) + amount));
            const g = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amount));
            const b = Math.max(0, Math.min(255, (num & 0x0000FF) + amount));
            return "#" + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
        }

        // Workspace'e drop handler ekle
        function setupWorkspaceDrop() {
            const workspaceDiv = document.getElementById('blocklyDiv');

            workspaceDiv.ondragover = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            };

            workspaceDiv.ondrop = (e) => {
                e.preventDefault();
                const blockType = e.dataTransfer.getData('blockType');
                const deviceId = e.dataTransfer.getData('deviceId');

                if (blockType && deviceId) {
                    const deviceData = connectedDevices.find(d => d.id === deviceId);
                    const blockDef = Object.values(DEVICE_BLOCKS).flat()
                        .find(b => b.type === blockType);

                    if (deviceData && blockDef) {
                        // Mouse pozisyonunu Blockly koordinatlarƒ±na √ßevir
                        const metrics = workspace.getMetrics();
                        const scale = workspace.scale;

                        // Blockly canvas'ƒ±nƒ±n pozisyonunu al
                        const blocklyRect = workspaceDiv.getBoundingClientRect();

                        // Mouse pozisyonunu workspace koordinatlarƒ±na √ßevir
                        const x = (e.clientX - blocklyRect.left) / scale - metrics.viewLeft;
                        const y = (e.clientY - blocklyRect.top) / scale - metrics.viewTop;

                        addDeviceBlockToWorkspace(blockDef, deviceData, x, y);
                    }
                }
            };
        }

        function addDeviceBlockToWorkspace(blockDef, deviceData, x, y) {
            // Dinamik blok olu≈ütur
            const blockType = `${deviceData.id}_${blockDef.type}`;

            // Blok zaten tanƒ±mlƒ± deƒüilse olu≈ütur
            if (!Blockly.Blocks[blockType]) {
                createDeviceBlock(blockType, blockDef, deviceData);
            }

            // Workspace'e ekle
            const newBlock = workspace.newBlock(blockType);
            newBlock.initSvg();
            newBlock.render();

            // Pozisyon belirtilmi≈üse kullan, yoksa varsayƒ±lan
            if (x !== undefined && y !== undefined) {
                newBlock.moveBy(x, y);
            } else {
                newBlock.moveBy(200, 100);
            }

            console.log('Cihaz bloƒüu eklendi:', blockType, 'at', x, y);
        }

        function createDeviceBlock(blockType, blockDef, deviceData) {
            Blockly.Blocks[blockType] = {
                init: function () {
                    const input = this.appendDummyInput()
                        .appendField(blockDef.icon);

                    // Label'ƒ± par√ßala ve number field'larƒ± ekle
                    const parts = blockDef.label.split(/\[|\]/);
                    parts.forEach((part, index) => {
                        if (index % 2 === 0) {
                            // Normal text
                            if (part.trim()) input.appendField(part.trim());
                        } else {
                            // Number field
                            const value = parseInt(part) || 1;
                            input.appendField(new CustomNumberField(value, 1, 100), `VAL${index}`);
                        }
                    });

                    if (blockDef.isEvent) {
                        this.setNextStatement(true, null);
                    } else {
                        this.setPreviousStatement(true, null);
                        this.setNextStatement(true, null);
                    }

                    this.setColour(blockDef.color);
                    this.data = deviceData.id;
                }
            };

            // Kod √ºretici
            Blockly.Python[blockType] = function (block) {
                return `# ${deviceData.name}: ${blockDef.label}\n`;
            };
        }

        function updateDevicesTable() {
            const tbody = document.getElementById('devicesTableBody');

            if (connectedDevices.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="4" style="padding: 30px; text-align: center; color: #999;">
                            Hen√ºz baƒülƒ± cihaz yok. "Yeni Cihaz Ara & Baƒülan" butonuna tƒ±klayƒ±n.
                        </td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = '';

            connectedDevices.forEach((device, index) => {
                const row = document.createElement('tr');
                row.style.borderBottom = '1px solid #e0e0e0';
                row.style.background = index % 2 === 0 ? 'white' : '#f9f9f9';

                const statusIcon = device.connected ? 'üü¢' : 'üî¥';
                const statusText = device.connected ? 'Baƒülƒ±' : 'Kesildi';
                const statusColor = device.connected ? '#0FBD8C' : '#FF6680';

                row.innerHTML = `
                    <td style="padding: 12px; font-size: 14px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div style="width: 20px; height: 20px; border-radius: 50%; background: ${device.color}; border: 2px solid ${device.color};"></div>
                            <strong>${device.name}</strong>
                        </div>
                    </td>
                    <td style="padding: 12px; font-size: 12px; color: #666; font-family: monospace;">
                        ${device.id}
                    </td>
                    <td style="padding: 12px; text-align: center;">
                        <span style="background: ${statusColor}20; color: ${statusColor}; padding: 4px 12px; border-radius: 12px; font-size: 12px; font-weight: bold;">
                            ${statusIcon} ${statusText}
                        </span>
                    </td>
                    <td style="padding: 12px; text-align: center;">
                        <button onclick="removeDeviceFromTable('${device.id}')" style="background: #FF6680; color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: bold;">
                            üóëÔ∏è Kaldƒ±r
                        </button>
                    </td>
                `;

                tbody.appendChild(row);
            });
        }

        function removeDeviceFromTable(deviceId) {
            if (confirm('Bu cihazƒ± kaldƒ±rmak istediƒüinize emin misiniz?')) {
                removeDevice(deviceId);
            }
        }

        let selectedBlock = null;

        function handleBlockSelection(event) {
            const deleteOverlay = document.getElementById('deleteBlockOverlay');

            if (event.newElementId) {
                // Bir blok se√ßildi
                selectedBlock = workspace.getBlockById(event.newElementId);
                if (selectedBlock) {
                    deleteOverlay.classList.add('show');
                }
            } else {
                // Se√ßim kaldƒ±rƒ±ldƒ±
                selectedBlock = null;
                deleteOverlay.classList.remove('show');
            }
        }

        function deleteSelectedBlock() {
            if (selectedBlock) {
                selectedBlock.dispose(true);
                selectedBlock = null;
                document.getElementById('deleteBlockOverlay').classList.remove('show');
            }
        }

        function selectDevice(deviceId) {
            const icon = document.querySelector(`[data-device-id="${deviceId}"]`);

            // Toggle se√ßimi
            if (selectedDeviceId === deviceId) {
                // Aynƒ± cihaza basƒ±ldƒ± - se√ßimi kaldƒ±r
                if (icon) icon.classList.remove('selected');
                selectedDeviceId = null;
                document.getElementById('disconnectOverlay').classList.remove('show');
                console.log('Se√ßim iptal edildi');
            } else {
                // Farklƒ± cihaz se√ßildi
                document.querySelectorAll('.device-icon').forEach(i => {
                    i.classList.remove('selected');
                });

                if (icon) {
                    icon.classList.add('selected');
                    selectedDeviceId = deviceId;
                    document.getElementById('disconnectOverlay').classList.add('show');
                    console.log('Se√ßili cihaz:', deviceId);
                }
            }
        }

        function disconnectSelectedDevice() {
            if (selectedDeviceId) {
                removeDevice(selectedDeviceId);
            }
        }

        function removeDevice(deviceId, event) {
            if (event) event.stopPropagation();

            const device = connectedDevices.find(d => d.id === deviceId);
            if (device && device.device && device.device.gatt.connected) {
                device.device.gatt.disconnect();
            }

            connectedDevices = connectedDevices.filter(d => d.id !== deviceId);

            const icon = document.querySelector(`[data-device-id="${deviceId}"]`);
            if (icon) {
                icon.remove();
            }

            if (selectedDeviceId === deviceId) {
                selectedDeviceId = null;
                document.getElementById('disconnectOverlay').classList.remove('show');

                if (connectedDevices.length > 0) {
                    selectDevice(connectedDevices[0].id);
                }
            }

            // Tabloyu g√ºncelle
            updateDevicesTable();

            console.log('Cihaz kaldƒ±rƒ±ldƒ±:', deviceId);
        }

        function getSelectedDevice() {
            return connectedDevices.find(d => d.id === selectedDeviceId);
        }

        function getDeviceIcon(deviceId) {
            const device = connectedDevices.find(d => d.id === deviceId);
            if (!device) return '';

            // SVG shape generator - daha k√º√ß√ºk
            let shape = '';
            const size = 14;
            const color = device.color;

            switch (device.shape) {
                case 'triangle':
                    shape = `<svg width="${size}" height="${size}"><polygon points="${size / 2},0 0,${size} ${size},${size}" fill="${color}"/></svg>`;
                    break;
                case 'square':
                    shape = `<svg width="${size}" height="${size}"><rect width="${size}" height="${size}" rx="2" fill="${color}"/></svg>`;
                    break;
                case 'rectangle':
                    shape = `<svg width="${size}" height="${size * 0.7}"><rect width="${size}" height="${size * 0.7}" rx="2" fill="${color}"/></svg>`;
                    break;
                case 'pentagon':
                    shape = `<svg width="${size}" height="${size}"><polygon points="${size / 2},0 ${size},${size * 0.38} ${size * 0.82},${size} ${size * 0.18},${size} 0,${size * 0.38}" fill="${color}"/></svg>`;
                    break;
                case 'hexagon':
                    shape = `<svg width="${size}" height="${size}"><polygon points="${size / 2},0 ${size},${size * 0.25} ${size},${size * 0.75} ${size / 2},${size} 0,${size * 0.75} 0,${size * 0.25}" fill="${color}"/></svg>`;
                    break;
                case 'octagon':
                    shape = `<svg width="${size}" height="${size}"><polygon points="${size * 0.3},0 ${size * 0.7},0 ${size},${size * 0.3} ${size},${size * 0.7} ${size * 0.7},${size} ${size * 0.3},${size} 0,${size * 0.7} 0,${size * 0.3}" fill="${color}"/></svg>`;
                    break;
                case 'circle':
                    shape = `<svg width="${size}" height="${size}"><circle cx="${size / 2}" cy="${size / 2}" r="${size / 2}" fill="${color}"/></svg>`;
                    break;
            }

            return shape;
        }

        async function scanAndConnect() {
            // Bluetooth kontrol√º
            if (!navigator.bluetooth) {
                alert('‚ùå Tarayƒ±cƒ±nƒ±z Web Bluetooth desteklemiyor!\n\nChrome, Edge veya Opera kullanƒ±n.');
                return;
            }

            try {
                const scanStatus = document.getElementById('scanStatus');
                scanStatus.style.display = 'block';
                scanStatus.textContent = 'üîç Cihaz listesi a√ßƒ±lƒ±yor...';

                // Motor/cihaz tarama
                bluetoothDevice = await navigator.bluetooth.requestDevice({
                    acceptAllDevices: true,
                    optionalServices: [
                        // Standart servisler
                        'generic_access',
                        'generic_attribute',
                        'device_information',
                        'battery_service',
                        // Motor cihazƒ± servis UUID'leri (ger√ßek cihazdan bulundu)
                        '00002a05-0000-1000-8000-00805f9b34fb', // INIT handle
                        '00002b2a-0000-1000-8000-00805f9b34fb', // CONFIG handle
                        '0000fd02-0000-1000-8000-00805f9b34fb', // Ana servis (fd02)
                        '0000fd02-0001-1000-8000-00805f9b34fb', // COMMAND handle
                        '0000fd02-0002-1000-8000-00805f9b34fb', // MOTOR handle
                        // Hex servisler
                        0x1800, 0x1801, 0x180a, 0x180f,
                        0x2a05, 0x2b2a, 0xfd02,
                        0xffe0, 0xffe1, 0xffe2, 0xffe3, 0xffe4, 0xffe5, 0xffe6, 0xffe7, 0xffe8, 0xffe9,
                        0x1623, 0x1624, 0x1625, 0x1626,
                        // LEGO UUID'leri
                        '00001623-1212-efde-1623-785feabcd123',
                        '00001624-1212-efde-1623-785feabcd123',
                        '00001625-1212-efde-1623-785feabcd123',
                        // Genel motor UUID'leri
                        '0000ffe0-0000-1000-8000-00805f9b34fb',
                        '0000ffe1-0000-1000-8000-00805f9b34fb'
                    ]
                });

                scanStatus.textContent = `üì± Baƒülanƒ±yor: ${bluetoothDevice.name || 'Bilinmeyen'}...`;
                console.log('Se√ßilen cihaz:', bluetoothDevice.name, bluetoothDevice.id);

                // GATT sunucusuna baƒülan
                bluetoothServer = await bluetoothDevice.gatt.connect();

                scanStatus.textContent = `‚úÖ Baƒülandƒ±: ${bluetoothDevice.name || bluetoothDevice.id}`;

                console.log('GATT server connected');
                console.log('Server:', bluetoothServer);
                console.log('Server.connected:', bluetoothServer.connected);

                // Servisleri al ve logla
                try {
                    console.log('‚Üí getPrimaryServices() √ßaƒürƒ±lƒ±yor...');
                    const services = await bluetoothServer.getPrimaryServices();
                    console.log(`‚úì ${services.length} servis bulundu!`);

                    for (const service of services) {
                        console.log(`  Servis UUID: ${service.uuid}`);
                        try {
                            const chars = await service.getCharacteristics();
                            console.log(`    ${chars.length} karakteristik bulundu`);

                            let writeChar = null;
                            let notifyChar = null;

                            for (const char of chars) {
                                console.log(`      - ${char.uuid} (write: ${char.properties.write}, writeNoResp: ${char.properties.writeWithoutResponse}, notify: ${char.properties.notify})`);

                                // Write karakteristiƒüi sakla
                                if (char.properties.writeWithoutResponse) {
                                    writeChar = char;
                                }

                                // Notify karakteristiƒüi tespit et
                                if (char.properties.notify && !controllerMonitoring) {
                                    notifyChar = char;
                                }
                            }

                            // Eƒüer controller ise, √∂nce write ile ba≈ülat, sonra notify dinle
                            // Eƒüer controller ise, sadece notify dinle (write YOK)
                            if (notifyChar) {
                                console.log('      üéÆ Controller tespit edildi!');
                                console.log('      DEBUG: writeChar var mƒ±?', !!writeChar);
                                console.log('      DEBUG: writeChar UUID:', writeChar ? writeChar.uuid : 'YOK');

                                // Characteristic'leri kaydet
                                connectedCharacteristics[notifyChar.uuid] = notifyChar;
                                if (writeChar) {
                                    connectedCharacteristics[writeChar.uuid] = writeChar;

                                    // DENEME: Controller'a "wake up" ping g√∂nder
                                    try {
                                        console.log('      üì§ Controller wake-up ping g√∂nderiliyor...');
                                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x00]));
                                        console.log('      ‚úì Ping g√∂nderildi!');
                                        await new Promise(resolve => setTimeout(resolve, 100));
                                    } catch (e) {
                                        console.log('      ‚ö†Ô∏è Ping hatasƒ±:', e.message);
                                    }
                                }

                                // Monitoring ba≈ülat (periyodik ping ile)
                                console.log('      üéÆ Monitoring ba≈ülatƒ±lƒ±yor...');
                                await startControllerMonitoring(bluetoothDevice, notifyChar, writeChar);
                            }

                        } catch (e) {
                            console.log(`    Karakteristik hatasƒ±: ${e.message}`);
                        }
                    }

                    // connectedCharacteristics = {}; // KALDIRDIM - characteristic'leri silme!
                } catch (err) {
                    console.error('‚ùå Servis hatasƒ±:', err);
                    console.error('   Bu motor cihazƒ±nƒ±n servisleri Web Bluetooth izin listesinde olmayabilir.');
                    console.error('   Motor √ßalƒ±≈ümayabilir ama cihaz listeye eklendi.');
                }

                // Baƒülantƒ± kesilince
                bluetoothDevice.addEventListener('gattserverdisconnected', onDisconnected);

                // Cihazƒ± sidebar'a ekle
                addDeviceToSidebar(bluetoothDevice);

                scanStatus.textContent = '‚úÖ Cihaz eklendi!';

                // Scan status'u gizle
                setTimeout(() => {
                    scanStatus.style.display = 'none';
                }, 2000);

            } catch (error) {
                console.error('Bluetooth hatasƒ±:', error);
                const scanStatus = document.getElementById('scanStatus');
                scanStatus.style.display = 'block';
                scanStatus.style.background = '#FFE5E5';
                scanStatus.textContent = `‚ùå Hata: ${error.message}`;

                let errorMsg = `Bluetooth baƒülantƒ± hatasƒ±:\n${error.message}\n\n`;

                if (error.message.includes('User cancelled')) {
                    scanStatus.style.display = 'none';
                    return; // ƒ∞ptal - hata g√∂sterme
                } else if (error.message.includes('Bluetooth adapter not available')) {
                    errorMsg = '‚ùå Bluetooth a√ßƒ±k deƒüil!\n\nL√ºtfen Bluetooth\'u a√ßƒ±n ve tekrar deneyin.';
                } else {
                    errorMsg += 'Kontrol edin:\n‚úì Bluetooth a√ßƒ±k mƒ±?\n‚úì Cihaz a√ßƒ±k mƒ±?\n‚úì Cihaz menzilde mi?';
                }

                alert(errorMsg);

                setTimeout(() => {
                    scanStatus.style.display = 'none';
                    scanStatus.style.background = '#f0f0f0';
                }, 5000);
            }
        }

        function onDisconnected() {
            console.log('Bluetooth cihaz baƒülantƒ±sƒ± kesildi');

            // Controller monitoring'i durdur
            if (controllerMonitoring) {
                clearInterval(controllerMonitoring);
                controllerMonitoring = null;
            }

            // Controller ping'i durdur
            if (controllerPingInterval) {
                clearInterval(controllerPingInterval);
                controllerPingInterval = null;
            }

            activeControllerDevice = null;
            activeControllerCharacteristic = null;

            // Controller display'i gizle
            hideControllerDisplay();

            // Baƒülantƒ±sƒ± kesilen cihazƒ± bul ve durumunu g√ºncelle
            const device = connectedDevices.find(d => d.device === bluetoothDevice);
            if (device) {
                device.connected = false;
                updateDevicesTable();
            }

            bluetoothDevice = null;
            bluetoothServer = null;
            connectedCharacteristics = {};
        }

        // Controller'dan veri oku ve state g√ºncelle
        async function startControllerMonitoring(device, notifyChar, writeChar) {
            console.log('üéÆ Controller monitoring ba≈ülatƒ±lƒ±yor...');
            activeControllerDevice = device;
            activeControllerCharacteristic = notifyChar; // Global'e kaydet

            console.log('   DEBUG: Notify characteristic:', notifyChar.uuid);
            console.log('   DEBUG: Write characteristic:', writeChar ? writeChar.uuid : 'YOK');

            // Controller display'i g√∂ster
            showControllerDisplay();

            // Notification'larƒ± dinle
            try {
                await notifyChar.startNotifications();
                console.log('‚úÖ Notifications ba≈ülatƒ±ldƒ± - kollarƒ± hareket ettirin');
                console.log('   Characteristic UUID:', notifyChar.uuid);
                console.log('   Is notifying:', notifyChar.properties.notify);

                // Event listener ekle - notification'dan SONRA
                notifyChar.addEventListener('characteristicvaluechanged', (event) => {
                    const value = event.target.value;

                    // Format: 60, 10, 0, 0, 50, 0, 15, 1, 0, 50, 0, 248, 255
                    // Index:   0   1  2  3   4  5   6  7  8   9 10   11  12
                    // Index 7 = Sol lever byte
                    // Index 8 = Saƒü lever byte
                    // Deƒüerler: 0-1 = normal, 2-104 = up, 152-255 = down

                    if (value.byteLength >= 9) {
                        const leftByte = value.getUint8(7);   // Index 7 = Sol lever
                        const rightByte = value.getUint8(8);  // Index 8 = Saƒü lever

                        // Sadece deƒüer deƒüi≈ütiyse g√ºncelle
                        if (leftByte !== controllerState.leftValue || rightByte !== controllerState.rightValue) {
                            updateControllerState(leftByte, rightByte);
                        }
                    }
                });

                console.log('‚úì Event listener eklendi');

                // Controller'ƒ± ba≈ülat ve sensor stream'i a√ß
                if (writeChar) {
                    console.log('üîÑ Controller sensor stream ba≈ülatƒ±lƒ±yor...');

                    try {
                        // PCAP analizinden: Ba≈ülatma sƒ±rasƒ±
                        // Paket 403: 0x00 (reset/init)
                        // Paket 406: 0x1a (handshake)
                        // Paket 409: 0x28 0x32 0x00 (sensor data stream ba≈ülat)

                        // Adƒ±m 1: Reset/Init
                        console.log('   üì§ Adƒ±m 1: Reset komutu (0x00)...');
                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x00]));
                        await new Promise(resolve => setTimeout(resolve, 100));

                        // Adƒ±m 2: Handshake
                        console.log('   üì§ Adƒ±m 2: Handshake komutu (0x1a)...');
                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x1a]));
                        await new Promise(resolve => setTimeout(resolve, 100));

                        // Adƒ±m 3: Sensor data stream ba≈ülat (PCAP Paket 409)
                        // Bu komut g√∂nderildikten sonra cihaz S√úREKLƒ∞ notification g√∂nderir
                        const sensorStreamCmd = new Uint8Array([0x28, 0x32, 0x00]);
                        console.log('   üì§ Adƒ±m 3: Sensor stream ba≈ülat (0x28 0x32 0x00)...');
                        await writeChar.writeValueWithoutResponse(sensorStreamCmd);

                        console.log('   ‚úÖ Sensor stream ba≈ülatƒ±ldƒ±! Cihaz artƒ±k s√ºrekli veri g√∂nderecek.');

                    } catch (e) {
                        console.error('   ‚ùå Ba≈ülatma hatasƒ±:', e.message);
                    }

                    // NOT: Periyodik ping GEREKMEYOR - cihaz tek komutla s√ºrekli stream yapƒ±yor
                    // Eski periyodik ping kaldƒ±rƒ±ldƒ±
                }

                // TEST: Event listener ger√ßekten √ßalƒ±≈üƒ±yor mu?
                console.log('üß™ TEST: Event listener count:',
                    notifyChar.getAttributeNames ? 'Modern API' : 'Eski API');

                // Manuel bir test eventi tetikle
                setTimeout(() => {
                    console.log('üß™ 5 saniye ge√ßti, manuel test...');
                    console.log('   Characteristic hala var mƒ±?', !!activeControllerCharacteristic);
                    console.log('   Event listener sayƒ±sƒ± kontrol edilemiyor (Web Bluetooth API sƒ±nƒ±rlamasƒ±)');
                }, 5000);

                // ƒ∞lk deƒüeri okumayƒ± dene
                if (notifyChar.properties.read) {
                    try {
                        console.log('   üìñ ƒ∞lk deƒüer okunuyor...');
                        const initialValue = await notifyChar.readValue();
                        console.log('   üìñ ƒ∞lk deƒüer:', initialValue.byteLength, 'bytes');

                        // ƒ∞lk deƒüeri manuel olarak i≈üle
                        if (initialValue.byteLength >= 9) {
                            const leftByte = initialValue.getUint8(7);   // Index 7 = Sol
                            const rightByte = initialValue.getUint8(8);  // Index 8 = Saƒü
                            console.log(`   üìñ ƒ∞lk deƒüerler: Left=${leftByte}, Right=${rightByte}`);
                        }
                    } catch (e) {
                        console.log('   ‚ö†Ô∏è Read desteklenmiyor:', e.message);
                    }
                }

                // Test: 5 saniye sonra hala veri gelmediyse uyar
                setTimeout(() => {
                    console.log('‚è∞ 5 saniye ge√ßti - Eƒüer hala veri gelmediyse:');
                    console.log('   1. Kollarƒ± hareket ettirmeyi deneyin');
                    console.log('   2. Controller\'ƒ± yeniden baƒülayƒ±n');
                    console.log('   3. Controller\'ƒ±n pilini kontrol edin');
                }, 5000);

            } catch (err) {
                console.error('‚ùå Notification ba≈ülatma hatasƒ±:', err.message);
            }
        }

        function updateControllerState(leftByte, rightByte) {
            // √ñnceki state'i kaydet
            const prevLeft = controllerState.left;
            const prevRight = controllerState.right;

            // Y√ºzdeleri hesapla - her iki lever i√ßin aynƒ± mantƒ±k
            const leftPercent = calculateLeverPercent(leftByte);
            const rightPercent = calculateLeverPercent(rightByte);

            // State'i y√ºzdeye g√∂re belirle
            // >55%: UP, <45%: DOWN, 45-55%: RELEASED
            const newLeft = leftPercent > 55 ? 'UP' : (leftPercent < 45 ? 'DOWN' : 'RELEASED');
            const newRight = rightPercent > 55 ? 'UP' : (rightPercent < 45 ? 'DOWN' : 'RELEASED');

            controllerState.left = newLeft;
            controllerState.right = newRight;
            controllerState.leftValue = leftByte;
            controllerState.rightValue = rightByte;

            // G√∂rseli throttle ile g√ºncelle (100ms'de bir)
            const now = Date.now();
            if (now - lastVisualUpdate >= VISUAL_UPDATE_INTERVAL) {
                lastVisualUpdate = now;
                updateControllerVisualThrottled(leftPercent, rightPercent);
            }

            // State deƒüi≈üikliklerinde when bloklarƒ±nƒ± tetikle
            if (newLeft !== prevLeft) {
                triggerLeverEvents('LEFT', newLeft);
            }
            if (newRight !== prevRight) {
                triggerLeverEvents('RIGHT', newRight);
            }

            // Both ve Any kontrol√º
            if (newLeft !== prevLeft || newRight !== prevRight) {
                triggerLeverEvents('BOTH', newLeft === newRight ? newLeft : null);
                triggerLeverEvents('ANY', newLeft !== 'RELEASED' || newRight !== 'RELEASED' ?
                    (newLeft !== 'RELEASED' ? newLeft : newRight) : null);
            }
        }

        // Throttled g√∂rsel g√ºncelleme - dikey bar i√ßin height kullan
        function updateControllerVisualThrottled(leftPercent, rightPercent) {
            // Sol kol
            const leftFill = document.getElementById('leftLeverFill');
            const leftValue = document.getElementById('leftLeverValue');

            if (leftFill && leftValue) {
                const leftHeight = Math.round(leftPercent);
                leftFill.style.height = leftHeight + '%';
                leftValue.textContent = leftHeight + '%';
            }

            // Saƒü kol
            const rightFill = document.getElementById('rightLeverFill');
            const rightValueEl = document.getElementById('rightLeverValue');

            if (rightFill && rightValueEl) {
                const rightHeight = Math.round(rightPercent);
                rightFill.style.height = rightHeight + '%';
                rightValueEl.textContent = rightHeight + '%';
            }
        }

        // Lever y√ºzde hesaplama
        // 0-1 = normal (ortada) = %50
        // 2-104 = up (yukarƒ±) = %50-%100 (2‚Üí%50, 104‚Üí%100)
        // 152-255 = down (a≈üaƒüƒ±) = %0-%50 (255‚Üí%50, 152‚Üí%0)
        function calculateLeverPercent(byteValue) {
            let percent;

            if (byteValue <= 1) {
                // NORMAL - ortada
                percent = 50;
            } else if (byteValue >= 2 && byteValue <= 104) {
                // UP - yukarƒ±
                // 2 ‚Üí %50, 104 ‚Üí %100
                percent = 50 + ((byteValue - 2) / (104 - 2)) * 50;
            } else if (byteValue >= 152 && byteValue <= 255) {
                // DOWN - a≈üaƒüƒ±
                // 255 ‚Üí %50'ye yakƒ±n, 152 ‚Üí %0
                // 255'ten 152'ye gittik√ße a≈üaƒüƒ± iniyor
                percent = ((byteValue - 152) / (255 - 152)) * 50;
            } else {
                // Ara deƒüerler (105-151) - ge√ßi≈ü b√∂lgesi, ortada say
                percent = 50;
            }

            return Math.max(0, Math.min(100, percent));
        }

        // Lever angle deƒüerini d√∂nd√ºr (bloklar i√ßin)
        function getLeverAngle(lever) {
            if (lever === 'LEFT') {
                return Math.round(calculateLeverPercent(controllerState.leftValue));
            } else if (lever === 'RIGHT') {
                return Math.round(calculateLeverPercent(controllerState.rightValue));
            }
            return 50;
        }

        function triggerLeverEvents(lever, position) {
            if (!position) return;

            // Motor i≈ülemi devam ediyorsa yeni i≈ülem ba≈ülatma
            if (motorOperationInProgress) {
                return;
            }

            // Workspace'teki t√ºm when_lever_position bloklarƒ±nƒ± bul
            const allBlocks = workspace.getAllBlocks();
            allBlocks.forEach(block => {
                if (block.type === 'when_lever_position') {
                    const blockLever = block.getFieldValue('LEVER');
                    const blockPosition = block.getFieldValue('POSITION');

                    // Eƒüer blok parametreleri mevcut durumla e≈üle≈üiyorsa
                    if (blockLever === lever && blockPosition === position) {
                        // Bloƒüu vurgula
                        highlightBlock(block);

                        // Bloktan sonraki komutlarƒ± √ßalƒ±≈ütƒ±r
                        executeBlockChain(block);
                    }
                }
            });
        }

        function highlightBlock(block) {
            // Bloƒüu kƒ±sa s√ºreliƒüine vurgula
            const blockSvg = block.getSvgRoot();
            if (blockSvg) {
                blockSvg.style.filter = 'brightness(1.3)';
                setTimeout(() => {
                    blockSvg.style.filter = '';
                }, 300);
            }
        }

        async function executeBlockChain(startBlock) {
            // Bloƒüun altƒ±ndaki komut zincirini √ßalƒ±≈ütƒ±r
            let nextBlock = startBlock.getNextBlock();

            while (nextBlock) {
                await executeBlock(nextBlock);
                nextBlock = nextBlock.getNextBlock();
            }
        }

        async function executeBlock(block) {
            const blockType = block.type;
            console.log('  ‚Üí Executing block:', blockType);

            // RGB LED bloklarƒ±
            if (blockType === 'rgb_red_on') {
                rgbLedState.red = true;
                updateRGBDisplay();
            } else if (blockType === 'rgb_red_off') {
                rgbLedState.red = false;
                updateRGBDisplay();
            } else if (blockType === 'rgb_green_on') {
                rgbLedState.green = true;
                updateRGBDisplay();
            } else if (blockType === 'rgb_green_off') {
                rgbLedState.green = false;
                updateRGBDisplay();
            } else if (blockType === 'rgb_blue_on') {
                rgbLedState.blue = true;
                updateRGBDisplay();
            } else if (blockType === 'rgb_blue_off') {
                rgbLedState.blue = false;
                updateRGBDisplay();
            }
            // RGB sayƒ± g√∂nder bloklarƒ±
            else if (blockType === 'rgb_red_num') {
                const value = block.getFieldValue('NUM') || 1;
                rgbNumberState.red = parseInt(value);
                updateRGBNumberDisplay();
            } else if (blockType === 'rgb_green_num') {
                const value = block.getFieldValue('NUM') || 1;
                rgbNumberState.green = parseInt(value);
                updateRGBNumberDisplay();
            } else if (blockType === 'rgb_blue_num') {
                const value = block.getFieldValue('NUM') || 1;
                rgbNumberState.blue = parseInt(value);
                updateRGBNumberDisplay();
            }
            // Motor bloklarƒ± - Ger√ßek Bluetooth kontrol√º
            else if (blockType === 'motor_run_rotation') {
                const direction = block.getFieldValue('DIRECTION');
                const rotations = block.getFieldValue('ROTATIONS');
                console.log(`  ‚öôÔ∏è Motor: ${rotations} rotation ${direction}`);

                const deviceId = block.data;
                if (deviceId) {
                    await runMotorRotations(deviceId, parseInt(rotations), direction);
                } else {
                    console.log('  ‚ùå deviceId yok - motor √ßalƒ±≈ütƒ±rƒ±lamadƒ±');
                }
            } else if (blockType === 'motor_run_to_angle') {
                const direction = block.getFieldValue('DIRECTION');
                const angle = block.getFieldValue('ANGLE');
                console.log(`  ‚öôÔ∏è Motor: Go to ${angle}¬∞ ${direction}`);

                const deviceId = block.data;
                if (deviceId) {
                    await runMotorToAngle(deviceId, parseInt(angle), direction);
                } else {
                    console.log('  ‚ùå deviceId yok');
                }
            } else if (blockType === 'motor_go_to_position') {
                const position = block.getFieldValue('POSITION');
                console.log(`  ‚öôÔ∏è Motor: Go to position ${position}`);

                const deviceId = block.data;
                if (deviceId) {
                    await goToPosition(deviceId, parseInt(position));
                } else {
                    console.log('  ‚ùå deviceId yok');
                }
            } else if (blockType === 'motor_start') {
                const direction = block.getFieldValue('DIRECTION');
                console.log(`  ‚öôÔ∏è Motor: Start ${direction}`);

                const deviceId = block.data;
                if (deviceId) {
                    await startMotor(deviceId, direction);
                } else {
                    console.log('  ‚ùå deviceId yok');
                }
            } else if (blockType === 'motor_stop') {
                console.log(`  ‚öôÔ∏è Motor: Stop`);

                const deviceId = block.data;
                if (deviceId) {
                    await stopMotor(deviceId);
                } else {
                    console.log('  ‚ùå deviceId yok');
                }
            }
            // Wait bloƒüu
            else if (blockType === 'wait') {
                const seconds = block.getFieldValue('SECONDS') || 1;
                console.log(`  ‚Üí Waiting ${seconds} seconds...`);
                await new Promise(resolve => setTimeout(resolve, seconds * 1000));
            }
        }

        function showDeviceModal() {
            document.getElementById('deviceModal').classList.add('show');
        }

        function closeDeviceModal() {
            const modal = document.getElementById('deviceModal');
            if (modal) {
                modal.classList.remove('show');
                modal.style.display = 'none';
            }
        }

        function zoomIn() {
            workspace.zoomCenter(1.2);
        }

        function zoomOut() {
            workspace.zoomCenter(-1.2);
        }

        function resetView() {
            workspace.setScale(1);
            workspace.scrollCenter();
        }

        function clearWorkspace() {
            if (workspace.getAllBlocks().length > 0 && confirm('T√ºm bloklarƒ± sil?')) {
                workspace.clear();
            }
        }

        function toggleStartBlocks() {
            console.log('toggleStartBlocks √ßaƒürƒ±ldƒ±, currentMode:', currentToolboxMode);

            if (!workspace) {
                console.error('Workspace hen√ºz y√ºklenmedi!');
                return;
            }

            if (currentToolboxMode === 'start') {
                hideAllToolboxes();
            } else {
                showStartToolbox();
            }
        }

        function toggleControlBlocks() {
            console.log('toggleControlBlocks √ßaƒürƒ±ldƒ±, currentMode:', currentToolboxMode);

            if (!workspace) {
                console.error('Workspace hen√ºz y√ºklenmedi!');
                return;
            }

            if (currentToolboxMode === 'control') {
                hideAllToolboxes();
            } else {
                showControlToolbox();
            }
        }

        function toggleActionLedBlocks() {
            console.log('toggleActionLedBlocks √ßaƒürƒ±ldƒ±, currentMode:', currentToolboxMode);

            if (!workspace) {
                console.error('Workspace hen√ºz y√ºklenmedi!');
                return;
            }

            if (currentToolboxMode === 'action_led') {
                hideAllToolboxes();
            } else {
                showActionLedToolbox();
            }
        }

        function toggleActionNumBlocks() {
            console.log('toggleActionNumBlocks √ßaƒürƒ±ldƒ±, currentMode:', currentToolboxMode);

            if (!workspace) {
                console.error('Workspace hen√ºz y√ºklenmedi!');
                return;
            }

            if (currentToolboxMode === 'action_num') {
                hideAllToolboxes();
            } else {
                showActionNumToolbox();
            }
        }

        function toggleOperatorBlocks() {
            console.log('toggleOperatorBlocks √ßaƒürƒ±ldƒ±, currentMode:', currentToolboxMode);

            if (!workspace) {
                console.error('Workspace hen√ºz y√ºklenmedi!');
                return;
            }

            // Eƒüer zaten operator mode aktifse kapat, deƒüilse operator mode a√ß
            if (currentToolboxMode === 'operator') {
                hideAllToolboxes();
            } else {
                showOperatorToolbox();
            }
        }

        function toggleMotorControl() {
            console.log('toggleMotorControl √ßaƒürƒ±ldƒ±, currentMode:', currentToolboxMode);

            if (!workspace) {
                console.error('Workspace hen√ºz y√ºklenmedi!');
                return;
            }

            // Eƒüer zaten motor mode aktifse kapat, deƒüilse motor mode a√ß
            if (currentToolboxMode === 'motor') {
                hideAllToolboxes();
            } else {
                // Full veya kapalƒ± olabilir - her durumda motor a√ß
                showMotorToolbox();
            }
        }

        let currentToolboxMode = null;

        function showStartToolbox() {
            const startToolbox = `
                <xml xmlns="https://developers.google.com/blockly/xml">
                    <block type="start"></block>
                    <block type="when_condition"></block>
                    <block type="when_message_received">
                        <field name="MESSAGE">message1</field>
                    </block>
                    <block type="send_message">
                        <field name="MESSAGE">message1</field>
                    </block>
                </xml>
            `;

            workspace.updateToolbox(startToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'start';
            currentToolboxDevice = null;
            selectedDeviceId = null;

            updateToolboxButtons('startToggle');
            resetDeviceIcons();
            console.log('Start toolbox g√∂sterildi');
        }

        function showControlToolbox() {
            const controlToolbox = `
                <xml xmlns="https://developers.google.com/blockly/xml">
                    <block type="wait">
                        <value name="SECONDS">
                            <shadow type="math_number">
                                <field name="NUM">1</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="repeat">
                        <value name="TIMES">
                            <shadow type="math_number">
                                <field name="NUM">10</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="forever"></block>
                    <block type="if_then"></block>
                    <block type="if_then_else"></block>
                    <block type="wait_until"></block>
                    <block type="repeat_until"></block>
                </xml>
            `;

            workspace.updateToolbox(controlToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'control';
            currentToolboxDevice = null;
            selectedDeviceId = null;

            updateToolboxButtons('controlToggle');
            resetDeviceIcons();
            console.log('Control toolbox g√∂sterildi');
        }

        function showActionLedToolbox() {
            const actionLedToolbox = `
                <xml xmlns="https://developers.google.com/blockly/xml">
                    <block type="rgb_red_on"></block>
                    <block type="rgb_green_on"></block>
                    <block type="rgb_blue_on"></block>
                    <block type="rgb_red_off"></block>
                    <block type="rgb_green_off"></block>
                    <block type="rgb_blue_off"></block>
                    <block type="rgb_red_light_get"></block>
                    <block type="rgb_green_light_get"></block>
                    <block type="rgb_blue_light_get"></block>
                </xml>
            `;

            workspace.updateToolbox(actionLedToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'action_led';
            selectedDeviceId = null;
            currentToolboxDevice = null;

            updateToolboxButtons('actionLedToggle');
            resetDeviceIcons();
            console.log('Action LED toolbox g√∂sterildi');
        }

        function showActionNumToolbox() {
            const actionNumToolbox = `
                <xml xmlns="https://developers.google.com/blockly/xml">
                    <block type="rgb_red_num">
                        <value name="NUM">
                            <shadow type="math_number">
                                <field name="NUM">1</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="rgb_green_num">
                        <value name="NUM">
                            <shadow type="math_number">
                                <field name="NUM">1</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="rgb_blue_num">
                        <value name="NUM">
                            <shadow type="math_number">
                                <field name="NUM">1</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="rgb_red_get"></block>
                    <block type="rgb_green_get"></block>
                    <block type="rgb_blue_get"></block>
                </xml>
            `;

            workspace.updateToolbox(actionNumToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'action_num';
            selectedDeviceId = null;
            currentToolboxDevice = null;

            updateToolboxButtons('actionNumToggle');
            resetDeviceIcons();
            console.log('Action Num toolbox g√∂sterildi');
        }

        function showDeviceToolbox(deviceData) {
            // selectedDeviceId'yi set et - √ñNEMLI!
            selectedDeviceId = deviceData.id;
            console.log('selectedDeviceId set edildi:', selectedDeviceId);

            // Cihaz tipine g√∂re bloklarƒ± al
            const blocks = DEVICE_BLOCKS[deviceData.type] || DEVICE_BLOCKS['generic'];

            // Toolbox XML'i olu≈ütur
            let deviceToolboxXml = '<xml xmlns="https://developers.google.com/blockly/xml">';

            // Motor bloklarƒ± ekle
            if (deviceData.type === 'motor') {
                deviceToolboxXml += `
                    <block type="motor_run_rotation">
                        <field name="DIRECTION">CW</field>
                        <field name="ROTATIONS">1</field>
                    </block>
                    <block type="motor_run_to_angle">
                        <field name="DIRECTION">CW</field>
                        <field name="ANGLE">0</field>
                    </block>
                    <block type="motor_go_to_position">
                        <field name="POSITION">67</field>
                    </block>
                    <block type="motor_start">
                        <field name="DIRECTION">CW</field>
                    </block>
                    <block type="motor_stop"></block>
                `;
            }
            // Controller bloklarƒ± ekle
            else if (deviceData.type === 'controller') {
                deviceToolboxXml += `
                    <block type="when_lever_position">
                        <field name="LEVER">LEFT</field>
                        <field name="POSITION">UP</field>
                    </block>
                    <block type="lever_position">
                        <field name="LEVER">LEFT</field>
                        <field name="POSITION">UP</field>
                    </block>
                    <block type="lever_angle">
                        <field name="LEVER">LEFT</field>
                    </block>
                `;
            }
            // Generic bloklar
            else {
                deviceToolboxXml += '<block type="led_on"><field name="VAL">90</field></block>';
            }

            deviceToolboxXml += '</xml>';

            workspace.updateToolbox(deviceToolboxXml);
            isToolboxVisible = true;
            currentToolboxMode = 'device';
            currentToolboxDevice = deviceData.id; // Bu da ekleyelim

            // T√ºm butonlarƒ± pasif yap, cihaz ikonu aktif
            updateToolboxButtons(null);

            // Cihaz ikonunu aktif g√∂ster
            document.querySelectorAll('.device-icon').forEach(icon => {
                icon.style.background = 'white';
            });
            const activeIcon = document.querySelector(`[data-device-id="${deviceData.id}"]`);
            if (activeIcon) {
                activeIcon.style.background = '#0FBD8C';
            }

            console.log('Device toolbox g√∂sterildi:', deviceData.name);
            console.log('currentToolboxDevice:', currentToolboxDevice);
        }

        function showOperatorToolbox() {
            const operatorToolbox = `
                <xml xmlns="https://developers.google.com/blockly/xml">
                    <block type="math_number">
                        <field name="NUM">0</field>
                    </block>
                    <block type="math_arithmetic">
                        <field name="OP">ADD</field>
                        <value name="A">
                            <shadow type="math_number">
                                <field name="NUM">2</field>
                            </shadow>
                        </value>
                        <value name="B">
                            <shadow type="math_number">
                                <field name="NUM">1</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="math_random">
                        <value name="FROM">
                            <shadow type="math_number">
                                <field name="NUM">1</field>
                            </shadow>
                        </value>
                        <value name="TO">
                            <shadow type="math_number">
                                <field name="NUM">10</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="logic_compare">
                        <field name="OP">GT</field>
                        <value name="A">
                            <shadow type="math_number">
                                <field name="NUM">3</field>
                            </shadow>
                        </value>
                        <value name="B">
                            <shadow type="math_number">
                                <field name="NUM">2</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="logic_operation">
                        <field name="OP">AND</field>
                    </block>
                    <block type="logic_negate"></block>
                </xml>
            `;

            workspace.updateToolbox(operatorToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'operator';
            selectedDeviceId = null;
            currentToolboxDevice = null;

            updateToolboxButtons('operatorToggle');
            resetDeviceIcons();
            console.log('Operator toolbox g√∂sterildi');
        }

        function showMotorToolbox() {
            const motorToolbox = `
                <xml xmlns="https://developers.google.com/blockly/xml">
                    <block type="led_on"><field name="VAL">90</field></block>
                </xml>
            `;

            workspace.updateToolbox(motorToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'motor';
            selectedDeviceId = null;
            currentToolboxDevice = null;

            updateToolboxButtons('motorToggle');
            resetDeviceIcons();
            console.log('Motor toolbox g√∂sterildi');
        }

        function resetDeviceIcons() {
            document.querySelectorAll('.device-icon').forEach(icon => {
                icon.style.background = '';
            });
        }

        function updateToolboxButtons(activeButtonId) {
            const buttons = ['startToggle', 'controlToggle', 'actionLedToggle', 'actionNumToggle', 'operatorToggle'];

            buttons.forEach(buttonId => {
                const btn = document.getElementById(buttonId);
                if (btn) {
                    if (buttonId === activeButtonId) {
                        btn.style.background = '#0FBD8C';
                        btn.style.color = 'white';
                    } else {
                        btn.style.background = 'white';
                        btn.style.color = '#666';
                    }
                }
            });
        }

        function hideAllToolboxes() {
            const emptyToolbox = '<xml xmlns="https://developers.google.com/blockly/xml"></xml>';
            workspace.updateToolbox(emptyToolbox);
            isToolboxVisible = false;
            currentToolboxMode = null;
            currentToolboxDevice = null;

            updateToolboxButtons(null);
            resetDeviceIcons();

            console.log('Toolbox gizlendi');
        }

        function showToolbox() {
            showStartToolbox();
        }

        function hideToolbox() {
            hideAllToolboxes();
        }

        document.getElementById('codeModal').addEventListener('click', (e) => {
            if (e.target.id === 'codeModal') closeModal();
        });

        document.getElementById('deviceModal').addEventListener('click', (e) => {
            if (e.target.id === 'deviceModal') closeDeviceModal();
        });

        // Cihaz ekle butonu event listener
        window.addEventListener('load', () => {
            const addDeviceBtn = document.getElementById('addDeviceBtn');
            if (addDeviceBtn) {
                addDeviceBtn.addEventListener('click', addDevice);
                console.log('‚úì addDevice event listener eklendi');
            } else {
                console.error('‚ùå addDeviceBtn bulunamadƒ±!');
            }
        });

        window.addEventListener('load', initBlockly);
        window.addEventListener('resize', () => Blockly.svgResize(workspace));
    </script>
</body>

</html>
