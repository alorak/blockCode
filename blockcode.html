<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlockCode</title>
    <link rel="icon" type="image/png" href="img/favicon.png">
    <script src="https://unpkg.com/blockly@10.4.3/blockly.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background: #4C97FF;
            overflow: hidden;
        }

        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }

        .top-bar {
            height: 56px;
            background: linear-gradient(135deg, #4C97FF 0%, #3B82F6 100%);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px 0 20px;
            gap: 12px;
            box-shadow: 0 2px 12px rgba(59, 130, 246, 0.3);
            z-index: 100;
            position: relative;
            flex-shrink: 0;
        }

        /* Font Import for Logo */
        @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@800&display=swap');

        .logo {
            color: white;
            font-size: 26px;
            font-family: 'Nunito', 'Helvetica Neue', Arial, sans-serif;
            font-weight: 800;
            letter-spacing: -0.3px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);
        }

        .play-btn {
            width: 42px;
            height: 42px;
            background: linear-gradient(135deg, #FFBF00 0%, #F59E0B 100%);
            border: none;
            border-radius: 12px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.4);
        }

        .play-btn:hover {
            background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%);
            transform: translateY(-1px) scale(1.02);
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.5);
        }

        .play-btn:active {
            transform: translateY(0) scale(0.98);
            box-shadow: 0 1px 4px rgba(245, 158, 11, 0.3);
        }

        .play-btn svg {
            margin-left: 1px;
        }

        .info-btn {
            width: 42px;
            height: 42px;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 12px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 600;
            font-size: 20px;
            font-family: 'Georgia', serif;
            font-style: italic;
        }

        .info-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-1px) scale(1.02);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .info-btn:active {
            transform: translateY(0) scale(0.98);
            background: rgba(255, 255, 255, 0.2);
        }

        .reset-btn {
            width: 42px;
            height: 42px;
            background: linear-gradient(135deg, #FF6B6B 0%, #EF4444 100%);
            border: none;
            border-radius: 12px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.4);
        }

        .reset-btn:hover {
            background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
            transform: translateY(-1px) scale(1.02);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.5);
        }

        .reset-btn:active {
            transform: translateY(0) scale(0.98);
            box-shadow: 0 1px 4px rgba(239, 68, 68, 0.3);
        }

        .top-btn {
            padding: 10px 24px;
            border: none;
            border-radius: 20px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .run-btn {
            background: #0FBD8C;
            color: white;
        }

        .run-btn:hover {
            background: #0DA574;
            transform: translateY(-2px);
        }

        .stop-btn {
            background: #FF6680;
            color: white;
        }

        .code-btn {
            background: white;
            color: #4C97FF;
            margin-left: auto;
        }

        .tool-btn-small {
            width: 42px;
            height: 42px;
            border: 1px solid rgba(255, 255, 255, 0.25);
            background: rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .tool-btn-small:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-1px) scale(1.02);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .tool-btn-small:active {
            transform: translateY(0) scale(0.98);
            background: rgba(255, 255, 255, 0.2);
        }

        .tool-btn-small svg {
            stroke: white;
        }

        .sidebar {
            width: 70px;
            background: rgba(255, 255, 255, 0.98);
            display: flex;
            flex-direction: column;
            padding: 0;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.05);
            border-right: none;
            position: fixed;
            left: 0;
            top: 56px;
            bottom: 0;
            z-index: 50;
            transition: width 0.3s ease;
        }

        .sidebar.expanded {
            width: 280px;
        }

        .sidebar-content {
            width: 70px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
            padding: 15px 0;
            flex-shrink: 0;
            height: 100%;
        }

        .sidebar-divider {
            width: 40px;
            height: 2px;
            background: linear-gradient(90deg, transparent, #ccc, transparent);
            margin: 8px 0;
            flex-shrink: 0;
        }

        /* RGB Control Panel */
        .rgb-control-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 15px 25px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 100;
        }

        .rgb-panel-separator {
            width: 1px;
            height: 40px;
            background: linear-gradient(to bottom, transparent, #ccc, transparent);
            margin: 0 5px;
        }

        .rgb-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .rgb-group-items {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .rgb-group-label {
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        .rgb-led {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 3px solid #ddd;
            transition: all 0.2s;
            position: relative;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
            /* İç gölge ile derinlik */
        }

        .rgb-led.red {
            background: #fff;
            border-color: #ff6b6b;
        }

        .rgb-led.red.active {
            background: #ff6b6b;
            box-shadow: 0 0 15px #ff6b6b;
        }

        .rgb-led.green {
            background: #fff;
            border-color: #51cf66;
        }

        .rgb-led.green.active {
            background: #51cf66;
            box-shadow: 0 0 15px #51cf66;
        }

        .rgb-led.blue {
            background: #fff;
            border-color: #4dabf7;
        }

        .rgb-led.blue.active {
            background: #4dabf7;
            box-shadow: 0 0 15px #4dabf7;
        }

        .rgb-number-box {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            font-weight: bold;
            transition: all 0.2s;
            border: 3px solid #ddd;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
            /* Sayı kutularına da hafif derinlik */
        }

        .rgb-number-box.red {
            background: #ffb3b3;
            border-color: #ff6b6b;
            color: #c92a2a;
        }

        .rgb-number-box.green {
            background: #b3e0b3;
            border-color: #51cf66;
            color: #2b8a3e;
        }

        .rgb-number-box.blue {
            background: #b3d9ff;
            border-color: #4dabf7;
            color: #1971c2;
        }

        .rgb-triangle-btn {
            width: 44px;
            height: 44px;
            background: none;
            border: none;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            margin: 0 4px;
            overflow: visible;
            outline: none;
            -webkit-tap-highlight-color: transparent;
            /* 3D Efekt ve Gölge */
            filter: drop-shadow(0 4px 0px rgba(0, 0, 0, 0.15));
        }

        .rgb-triangle-btn polygon {
            transition: all 0.2s;
            stroke-width: 4px;
            stroke-linejoin: round;
        }

        .rgb-triangle-btn:hover {
            transform: translateY(-2px);
            /* Hoverda hafif yukarı */
            filter: drop-shadow(0 6px 0px rgba(0, 0, 0, 0.15));
        }

        .rgb-triangle-btn:active {
            transform: translateY(4px) scale(0.95);
            /* Basınca aşağı in */
            filter: drop-shadow(0 0px 0px rgba(0, 0, 0, 0.15));
            /* Gölge kaybolur */
        }

        /* Red Button */
        .rgb-triangle-btn.red polygon {
            fill: #ffb3b3;
            stroke: #ff6b6b;
        }

        .rgb-triangle-btn.red:hover polygon {
            fill: #ff9999;
        }

        .rgb-triangle-btn.red.active polygon {
            fill: #ff6b6b;
            /* Active: Fill matches stroke (Solid Vivid) */
        }

        /* Green Button */
        .rgb-triangle-btn.green polygon {
            fill: #b3e0b3;
            stroke: #51cf66;
        }

        .rgb-triangle-btn.green:hover polygon {
            fill: #99d999;
        }

        .rgb-triangle-btn.green.active polygon {
            fill: #51cf66;
        }

        /* Blue Button */
        .rgb-triangle-btn.blue polygon {
            fill: #b3d9ff;
            stroke: #4dabf7;
        }

        .rgb-triangle-btn.blue:hover polygon {
            fill: #99cfff;
        }

        .rgb-triangle-btn.blue.active polygon {
            fill: #4dabf7;
        }

        /* Flash Animation */
        @keyframes flash-glow {
            0% {
                filter: brightness(1) drop-shadow(0 0 0 rgba(255, 255, 255, 0));
                transform: scale(1);
            }

            50% {
                filter: brightness(1.5) drop-shadow(0 0 10px currentColor);
                transform: scale(1.2);
            }

            100% {
                filter: brightness(1) drop-shadow(0 0 0 rgba(255, 255, 255, 0));
                transform: scale(1);
            }
        }

        .rgb-triangle-btn.flash {
            animation: flash-glow 0.5s ease-out;
        }



        .sidebar-bottom-tools {
            margin-top: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
            padding-bottom: 15px;
        }

        /* Blockly toolbox gizle/göster */
        .blocklyToolboxDiv.hidden {
            display: none !important;
        }

        .blocklyMainBackground {
            transition: transform 0.3s ease;
        }

        .sidebar-panel {
            width: 210px;
            background: white;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.05) inset;
            overflow-y: auto;
            padding: 20px 15px;
            display: none;
            flex-shrink: 0;
        }

        .sidebar.expanded .sidebar-panel {
            display: block;
        }

        .sidebar-panel h3 {
            margin: 0 0 15px 0;
            font-size: 14px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tool-btn {
            width: 45px;
            height: 45px;
            border: none;
            background: white;
            border-radius: 50%;
            font-size: 22px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            flex-shrink: 0;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tool-btn:hover,
        .tool-btn.active {
            transform: scale(1.15);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        /* Sidebar butonlarına saydam renkli arka planlar */
        #startToggle {
            background: rgba(255, 193, 7, 0.15) !important;
            border: 2px solid rgba(255, 193, 7, 0.5) !important;
        }

        #startToggle:hover,
        #startToggle.active {
            background: rgba(255, 193, 7, 0.35) !important;
        }

        #controlToggle {
            background: rgba(230, 126, 34, 0.15) !important;
            border: 2px solid rgba(230, 126, 34, 0.5) !important;
        }

        #controlToggle:hover,
        #controlToggle.active {
            background: rgba(230, 126, 34, 0.35) !important;
        }

        #actionLedToggle {
            background: rgba(231, 76, 60, 0.15) !important;
            border: 2px solid rgba(231, 76, 60, 0.5) !important;
        }

        #actionLedToggle:hover,
        #actionLedToggle.active {
            background: rgba(231, 76, 60, 0.35) !important;
        }

        #actionNumToggle {
            background: rgba(156, 89, 182, 0.15) !important;
            border: 2px solid rgba(156, 89, 182, 0.5) !important;
        }

        #actionNumToggle:hover,
        #actionNumToggle.active {
            background: rgba(156, 89, 182, 0.35) !important;
        }

        #actionButtonToggle {
            background: rgba(52, 152, 219, 0.15) !important;
            border: 2px solid rgba(52, 152, 219, 0.5) !important;
        }

        #actionButtonToggle:hover,
        #actionButtonToggle.active {
            background: rgba(52, 152, 219, 0.35) !important;
        }

        #operatorToggle {
            background: rgba(39, 174, 96, 0.15) !important;
            border: 2px solid rgba(39, 174, 96, 0.5) !important;
        }

        #operatorToggle:hover,
        #operatorToggle.active {
            background: rgba(39, 174, 96, 0.35) !important;
        }

        /* Cihaz Ekleme butonu - Navbar mavi rengi */
        #addDeviceBtn {
            background: rgba(76, 151, 255, 0.15) !important;
            border: 2px solid rgba(76, 151, 255, 0.5) !important;
        }

        #addDeviceBtn:hover {
            background: rgba(76, 151, 255, 0.35) !important;
        }

        /* Zoom butonları - Hafif gri arka plan ve küçük boyut */
        .sidebar-bottom-tools .tool-btn {
            background: rgba(128, 128, 128, 0.12) !important;
            border: 2px solid rgba(128, 128, 128, 0.3) !important;
            width: 38px !important;
            height: 38px !important;
            font-size: 14px !important;
        }

        .sidebar-bottom-tools .tool-btn:hover {
            background: rgba(128, 128, 128, 0.25) !important;
        }

        #deviceList {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 10px 0;
            padding: 5px 0;
            width: 100%;
            align-items: center;
        }

        .device-icon {
            width: 40px;
            height: 40px;
            border: 3px solid;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 7px;
            font-weight: bold;
            flex-shrink: 0;
        }

        .device-icon:hover {
            transform: scale(1.15);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .device-icon.active {
            box-shadow: 0 0 0 4px rgba(76, 151, 255, 0.3);
            transform: scale(1.15);
            background-color: rgba(0, 0, 0, 0.08) !important;
        }

        .device-icon.controller.active,
        .device-icon.selected {
            background-color: rgba(0, 0, 0, 0.12) !important;
            transform: scale(1.15);
        }

        .device-icon svg {
            width: 16px;
            height: 16px;
        }

        .device-menu {
            display: none;
        }

        .device-menu-block {
            margin: 12px 0;
            cursor: grab;
            user-select: none;
            display: inline-block;
            transition: all 0.2s;
        }

        .device-menu-block svg {
            display: block;
        }

        .device-menu-block:hover {
            transform: translateY(-2px);
        }

        .device-menu-block:active {
            transform: translateY(1px);
            cursor: grabbing;
        }

        .device-menu-icon {
            font-size: 18px;
            flex-shrink: 0;
        }

        .disconnect-overlay {
            display: none;
            position: fixed;
            top: 70px;
            right: 10px;
            z-index: 1000;
        }

        .disconnect-overlay.show {
            display: block;
        }

        .disconnect-btn-overlay {
            padding: 12px 20px;
            background: #FF6680;
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 102, 128, 0.4);
            transition: all 0.2s;
        }

        .disconnect-btn-overlay:hover {
            background: #FF4466;
            transform: translateY(-2px);
        }

        .delete-block-overlay {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            flex-direction: row;
            gap: 10px;
        }

        .delete-block-overlay.show {
            display: flex;
        }

        .block-action-btn {
            background: #4C97FF;
            color: white;
            border: none;
            padding: 14px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(76, 151, 255, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            width: 50px;
            height: 50px;
        }

        .block-action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 151, 255, 0.5);
        }

        .block-action-btn.delete {
            background: #FF4466;
            box-shadow: 0 4px 15px rgba(255, 68, 102, 0.4);
        }

        .block-action-btn.delete:hover {
            box-shadow: 0 6px 20px rgba(255, 68, 102, 0.5);
        }

        .block-action-btn.help {
            background: #F5A623;
            box-shadow: 0 4px 15px rgba(245, 166, 35, 0.4);
        }

        .block-action-btn.help:hover {
            box-shadow: 0 6px 20px rgba(245, 166, 35, 0.5);
        }

        /* Help Sidebar */
        .help-sidebar {
            position: fixed;
            top: 80px;
            bottom: 80px;
            right: -400px;
            width: 350px;
            height: auto;
            background: white;
            box-shadow: -5px 0 30px rgba(0, 0, 0, 0.15);
            z-index: 20000;
            transition: right 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            display: flex;
            flex-direction: column;
            border-radius: 16px 0 0 16px;
        }

        .help-sidebar.open {
            right: 0;
        }

        .help-header {
            padding: 20px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #FAFAFA;
        }

        .help-header h3 {
            margin: 0;
            font-size: 18px;
            color: #333;
        }

        .help-content {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
            font-size: 14px;
            line-height: 1.6;
            color: #333;
        }

        .help-content h1 {
            font-size: 20px;
            margin-bottom: 15px;
            color: #333;
            font-weight: 700;
        }

        .help-content h2 {
            font-size: 16px;
            margin-top: 20px;
            margin-bottom: 10px;
            color: #444;
            font-weight: 600;
        }

        .help-content p {
            margin-bottom: 12px;
        }

        .help-content code {
            background: #f0f0f0;
            padding: 2px 5px;
            border-radius: 4px;
            font-family: 'Menlo', monospace;
            color: #E01E5A;
            font-size: 0.9em;
        }

        .help-content pre {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            overflow-x: auto;
            margin-bottom: 15px;
            border: 1px solid #eee;
        }

        .help-content ul {
            padding-left: 20px;
            margin-bottom: 15px;
        }

        .help-content li {
            margin-bottom: 5px;
        }

        .delete-block-btn {
            background: #FF4466;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 68, 102, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .delete-block-btn:hover {
            background: #FF4466;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 102, 128, 0.5);
        }

        /* Displays Container */
        .displays-container {
            position: fixed;
            top: 70px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 1000;
            align-items: flex-end;
            pointer-events: none;
            /* Container clicks pass through */
            max-height: calc(100vh - 90px);
            overflow-y: auto;
        }

        /* Controller Display Panel ve Motor Display */
        .controller-display,
        .motor-display,
        .color-sensor-display,
        .spike-essential-display,
        .remote-controller-display,
        .city-hub-display,
        .boost-hub-display {
            display: none;
            position: relative;
            width: 320px;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(0, 0, 0, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            pointer-events: auto;
            /* Enable clicks on panels */
        }

        .controller-header {
            padding: 10px 15px;
            color: white;
            font-weight: bold;
            font-size: 14px;
            border-radius: 12px 12px 0 0;
        }

        /* Collapsible Hub Header */
        .hub-header-collapsible {
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: border-radius 0.3s;
        }

        .hub-header-collapsible:hover {
            filter: brightness(1.05);
        }

        .hub-header-collapsible.collapsed {
            border-radius: 12px;
        }

        .hub-collapse-icon {
            font-size: 10px;
            margin-left: auto;
            transition: transform 0.3s ease;
        }

        .hub-header-collapsible.collapsed .hub-collapse-icon {
            transform: rotate(-90deg);
        }

        /* Collapsible Content */
        .hub-collapsible-content {
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease-out, opacity 0.2s ease;
            opacity: 1;
        }

        .hub-collapsible-content.collapsed {
            max-height: 0;
            opacity: 0;
        }

        .controller-display.active,
        .motor-display.active,
        .color-sensor-display.active,
        .spike-essential-display.active,
        .remote-controller-display.active,
        .city-hub-display.active,
        .boost-hub-display.active {
            display: block;
        }

        /* Remote Controller Button Styles */
        .remote-controller-display .remote-btn.active {
            transform: scale(0.95);
            filter: brightness(1.3);
            box-shadow: 0 0 10px currentColor;
        }

        .remote-controller-display .remote-plus.active {
            background: #51cf66 !important;
            border-color: #37b24d !important;
        }

        .remote-controller-display .remote-minus.active {
            background: #ff6b6b !important;
            border-color: #e03131 !important;
        }

        .remote-controller-display .remote-red.active {
            background: #fff !important;
            border-color: #e03131 !important;
            box-shadow: 0 0 12px #ff6b6b;
        }

        .remote-controller-display .remote-green.active {
            background: #fff !important;
            border-color: #37b24d !important;
            box-shadow: 0 0 12px #51cf66;
        }

        /* Spike Essential Hub Styles */
        .spike-hub-content {
            padding: 12px;
            font-size: 12px;
        }

        .spike-hub-ports {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .spike-hub-port {
            flex: 1;
            background: #f5f5f5;
            border-radius: 8px;
            padding: 8px;
            text-align: center;
        }

        .spike-hub-port.has-device {
            background: #e6ffec;
            border: 1px solid #69db7c;
        }

        .spike-hub-port-label {
            font-weight: bold;
            color: #666;
            font-size: 11px;
            margin-bottom: 4px;
        }

        .spike-hub-port-status {
            font-size: 10px;
            color: #999;
        }

        .spike-hub-port-status.connected {
            color: #37b24d;
            font-weight: 500;
        }

        .spike-hub-sensors {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .spike-hub-sensor {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 6px 8px;
        }

        .spike-hub-sensor-label {
            font-size: 9px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 2px;
        }

        .spike-hub-sensor-value {
            font-family: monospace;
            font-size: 11px;
            color: #333;
        }

        .spike-hub-tilt {
            grid-column: span 2;
            text-align: center;
        }

        .spike-hub-tilt-icon {
            font-size: 24px;
            margin-bottom: 2px;
        }

        /* Hub Footer - Compact Tilt + Details Button */
        .spike-hub-footer {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #eee;
        }

        .spike-hub-tilt-compact {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .spike-hub-tilt-compact .spike-hub-tilt-icon {
            font-size: 20px;
            margin: 0;
        }

        .hub-details-btn {
            background: #f1f3f4;
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            color: #666;
        }

        .hub-details-btn:hover {
            background: #e0e0e0;
            color: #333;
        }

        /* Hub Sensor Modal */
        .hub-sensor-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }

        .hub-sensor-modal.active {
            display: flex;
        }

        .hub-sensor-modal-content {
            background: white;
            border-radius: 16px;
            padding: 24px;
            min-width: 380px;
            max-width: 420px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.2s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .hub-sensor-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-radius: 16px 16px 0 0;
            margin: -24px -24px 20px -24px;
            color: white;
        }

        .hub-sensor-modal-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .hub-sensor-modal-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            opacity: 0.9;
        }

        .hub-sensor-modal-title {
            font-size: 18px;
            font-weight: 600;
            color: white;
        }

        .hub-sensor-modal-body {
            padding: 0;
        }

        .hub-sensor-modal-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .hub-sensor-modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
            color: white;
        }

        .hub-sensor-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .hub-sensor-row:last-child {
            border-bottom: none;
        }

        .hub-sensor-label {
            font-weight: 600;
            color: #666;
            font-size: 14px;
        }

        .hub-sensor-value {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 14px;
            color: #333;
            background: #f8f9fa;
            padding: 6px 12px;
            border-radius: 8px;
        }

        /* Spike Prime Hub 6-Port Display */
        .spike-prime-display {
            display: none;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: none;
            min-width: 320px;
            width: 320px;
            border: 1px solid #9B59B6;
            pointer-events: auto;
        }

        .spike-prime-display.active {
            display: block;
        }

        .spike-prime-ports {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 10px;
        }

        .spike-prime-port {
            background: #f5f5f5;
            border-radius: 8px;
            padding: 8px 6px;
            text-align: center;
            min-height: 50px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .spike-prime-port.has-device {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border: 1px solid #81c784;
        }

        .spike-prime-port-label {
            font-weight: bold;
            color: #666;
            font-size: 11px;
            margin-bottom: 3px;
        }

        .spike-prime-port.has-device .spike-prime-port-label {
            color: #2e7d32;
        }

        .spike-prime-port-status {
            font-size: 9px;
            color: #999;
        }

        .spike-prime-port-status.connected {
            color: #37b24d;
            font-weight: 500;
        }

        .spike-prime-port-device {
            font-size: 9px;
            color: #2e7d32;
            font-weight: 500;
            margin-top: 2px;
        }

        .spike-prime-port-icon {
            font-size: 16px;
            margin-bottom: 2px;
        }

        .controller-levers {
            display: flex;
            gap: 15px;
            align-items: center;
            padding: 12px 15px;
            justify-content: center;
        }

        .lever-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .lever-label-mini {
            font-size: 10px;
            font-weight: bold;
            color: #666;
        }

        .lever-bar {
            width: 8px;
            height: 60px;
            background: #e0e0e0;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .lever-bar-fill {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 4px;
            transition: height 0.1s ease-out;
        }

        .lever-bar-fill.left {
            background: linear-gradient(to top, #ff6b6b, #ff8787);
        }

        .lever-bar-fill.right {
            background: linear-gradient(to top, #4C97FF, #7BB3FF);
        }

        .lever-value-mini {
            font-size: 11px;
            font-weight: bold;
            color: #333;
        }

        /* Color Sensor Display Styles */
        .color-sensor-content {
            padding: 15px;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 15px;
        }

        .color-sensor-circle {
            width: 70px;
            height: 70px;
            min-width: 70px;
            border-radius: 50%;
            border: 4px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            background: #f5f5f5;
            position: relative;
        }

        .color-sensor-circle.no-color {
            background: linear-gradient(135deg, #f5f5f5 45%, transparent 45%, transparent 55%, #f5f5f5 55%),
                linear-gradient(45deg, #f5f5f5 45%, #ff4444 45%, #ff4444 55%, #f5f5f5 55%);
            background-size: 100% 100%;
        }

        .color-sensor-circle.color-red {
            background: #FF0000;
            border-color: #CC0000;
        }

        .color-sensor-circle.color-yellow {
            background: #FFD700;
            border-color: #CCB000;
        }

        .color-sensor-circle.color-blue {
            background: #0066FF;
            border-color: #0052CC;
        }

        .color-sensor-circle.color-green {
            background: #00CC00;
            border-color: #009900;
        }

        .color-sensor-circle.color-purple {
            background: #9B59B6;
            border-color: #7D3C98;
        }

        .color-sensor-circle.color-cyan {
            background: #00BCD4;
            border-color: #0097A7;
        }

        .color-sensor-circle.color-white {
            background: #FFFFFF;
            border-color: #CCCCCC;
        }

        .color-sensor-label {
            font-size: 14px;
            font-weight: bold;
            color: #333;
            text-transform: capitalize;
        }

        .color-sensor-details {
            font-size: 11px;
            color: #888;
            text-align: center;
        }

        .workspace-container {
            flex: 1;
            margin-left: 70px;
            position: relative;
            background: white;
            /* Sidebar panel artık workspace'in üstüne overlay oluyor, itmiyor */
            /* transition: margin-left 0.3s ease; */
        }

        /* Sidebar açıldığında workspace'i itme - KALDIRILDI
           Bunun yerine sidebar panel overlay olarak çalışıyor */
        /*
        .sidebar.expanded~.workspace-container {
            margin-left: 280px;
        }
        */

        /* Blockly toolbox'ı sola taşımak için ek margin */
        #blocklyDiv {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        /* Blockly toolbox stilini özelleştir */
        /* Flyout'un workspace'i itmemesi için absolute positioning */
        .blocklyToolboxDiv {
            background-color: white !important;
            border-right: none !important;
            position: absolute !important;
            z-index: 40 !important;
        }

        .blocklyFlyout {
            fill: white !important;
            position: absolute !important;
        }

        /* Flyout background - açıkken çok hafif gri, kapalıyken beyaz görünsün */
        .blocklyFlyoutBackground {
            fill: white !important;
        }

        /* Blockly flyout SVG'sini workspace'in üstüne overlay yap */
        .blocklySvg>g.blocklyFlyout {
            z-index: 35;
        }

        /* Workspace'in flyout açılıp kapanmasından etkilenmemesi için */
        /* Main workspace'i sabit tut */
        .blocklyMainBackground {
            transform: none !important;
        }

        /* Block canvas geçişini yumuşat - flyout açılıp kapanırken ani kayma görünmesin */
        .blocklyBlockCanvas,
        .blocklyBubbleCanvas {
            transition: transform 0.15s ease-out;
        }


        /* Blockly SVG ve ana div arka planını beyaz yap - flyout kapalıyken gri alan sorunu için */
        .blocklySvg {
            background-color: white !important;
        }

        #blocklyDiv {
            background-color: white !important;
        }

        /* Blockly main workspace background - gri çizgi için */
        .blocklyMainBackground {
            fill: white !important;
            stroke: none !important;
        }

        /* Scrollbar track alanı da beyaz olsun */
        .blocklyScrollbarBackground {
            fill: white !important;
        }

        /* Blockly grid pattern arka planı */
        .blocklyGridPattern {
            stroke: #f0f0f0 !important;
        }

        /* Workspace scrollbar horizontal/vertical */
        .blocklyScrollbarHorizontal,
        .blocklyScrollbarVertical {
            fill: #ddd !important;
        }

        /* Tüm Blockly SVG rect elementleri - gri arka plan olabilecekler */
        .blocklySvg>rect {
            fill: white !important;
        }

        /* Flyout scrollbar arka planı */
        .blocklyFlyoutScrollbar {
            fill: transparent !important;
        }

        /* Pixel Matrix Panel for Color Light Matrix */
        .pixel-panel {
            display: none;
            position: fixed;
            background: #7C3AED;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
            z-index: 10000;
            min-width: 280px;
        }

        .pixel-panel.active {
            display: flex;
            flex-direction: row;
            gap: 15px;
        }

        .pixel-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .pixel-cell {
            width: 54px;
            height: 54px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            border: 3px solid rgba(255, 255, 255, 0.3);
        }

        .pixel-cell:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .pixel-color-picker {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .pixel-color-btn {
            width: 36px;
            height: 20px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.1s, border-color 0.2s;
        }

        .pixel-color-btn:hover {
            transform: scale(1.1);
        }

        .pixel-color-btn.selected {
            border-color: white;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.6);
        }

        .pixel-actions {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }

        .pixel-preset-btn {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.4);
            background: rgba(255, 255, 255, 0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .pixel-preset-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Number Panel Popup */
        .number-panel {
            display: none;
            position: fixed;
            background: #4C97FF;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
            z-index: 10000;
            min-width: 200px;
        }

        .number-panel.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .number-display {
            background: white;
            border: 4px solid #4C97FF;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            font-weight: bold;
            color: #4C97FF;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .number-controls {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .num-btn {
            width: 60px;
            height: 60px;
            border: 3px solid white;
            background: transparent;
            border-radius: 50%;
            color: white;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .num-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .num-btn:active {
            transform: scale(0.95);
        }

        /* Angle Panel Popup */
        .angle-panel {
            display: none;
            position: fixed;
            background: #4C97FF;
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            z-index: 10000;
        }

        .angle-panel.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .angle-display-container {
            position: relative;
            width: 200px;
            height: 200px;
        }

        .angle-circle {
            width: 100%;
            height: 100%;
            background: white;
            border-radius: 50%;
            position: relative;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .angle-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 90px;
            background: #667eea;
            transform-origin: bottom center;
            transform: translate(-50%, -100%) rotate(0deg);
            border-radius: 2px 2px 0 0;
            transition: transform 0.1s ease-out;
            pointer-events: none;
        }

        .angle-center-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 16px;
            height: 16px;
            background: #667eea;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            pointer-events: none;
        }

        .angle-degrees {
            font-size: 32px;
            font-weight: bold;
            color: white;
            min-width: 80px;
            text-align: center;
        }

        /* Fix Number Field Alignment - Targeted via JS Class */
        .number-field-styled>rect {
            fill: white !important;
            stroke: none !important;
            rx: 12px;
            ry: 12px;
        }

        .number-field-styled>text {
            fill: #4C97FF !important;
            font-weight: bold !important;
            dominant-baseline: central !important;
        }

        .angle-markers {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .angle-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 12px;
            background: #ddd;
            transform-origin: bottom center;
        }

        .angle-marker.major {
            height: 18px;
            width: 3px;
            background: #999;
        }

        .angle-marker-label {
            position: absolute;
            font-size: 11px;
            font-weight: bold;
            color: white;
        }

        .angle-controls {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .angle-btn {
            width: 60px;
            height: 60px;
            border: 3px solid white;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            color: white;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .angle-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .angle-btn:active {
            transform: scale(0.95);
        }

        .code-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .code-modal.show {
            display: flex;
        }

        .code-content {
            background: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .code-header h2 {
            color: #4C97FF;
        }

        .close-btn {
            background: #FF6680;
            color: white;
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .close-btn:hover {
            background: #FF4466;
        }

        .code-display {
            background: #F9F9F9;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            white-space: pre-wrap;
            max-height: 400px;
            overflow: auto;
            border: 2px solid #E0E0E0;
        }

        .copy-btn {
            margin-top: 15px;
            padding: 12px 24px;
            background: #4C97FF;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .copy-btn:hover {
            background: #3A7FDF;
        }

        .copy-btn:hover {
            background: #3A7FDF;
        }

        /* Reset Modal Styling */
        .reset-modal {
            display: none;
            position: fixed;
            z-index: 10001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(2px);
            align-items: center;
            justify-content: center;
        }

        .reset-modal.active {
            display: flex;
        }

        .reset-modal-content {
            background-color: #ffffff;
            margin: auto;
            padding: 30px;
            border-radius: 20px;
            width: 420px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            text-align: left;
            color: #333333;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            border: 1px solid #e0e0e0;
        }

        .reset-modal-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 25px;
            font-size: 18px;
            font-weight: 600;
            color: #333333;
        }

        .reset-modal-header svg {
            stroke: #4C97FF;
        }

        .reset-modal-body ul {
            list-style-type: none;
            padding-left: 0;
            margin-bottom: 30px;
            color: #555555;
            font-size: 15px;
            line-height: 2;
        }

        .reset-modal-body ul li {
            position: relative;
            padding-left: 20px;
        }

        .reset-modal-body ul li::before {
            content: "•";
            position: absolute;
            left: 0;
            color: #4C97FF;
            font-weight: bold;
        }

        .reset-modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .reset-modal-btn {
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            outline: none;
            transition: all 0.2s;
        }

        .reset-modal-btn.cancel {
            background-color: #f5f5f5;
            color: #666666;
            border: 2px solid #e0e0e0;
        }

        .reset-modal-btn.cancel:hover {
            background-color: #eeeeee;
            border-color: #cccccc;
        }

        .reset-modal-btn.confirm {
            background-color: #4C97FF;
            color: #ffffff;
        }

        .reset-modal-btn.confirm:hover {
            background-color: #3A7FDF;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(76, 151, 255, 0.3);
        }

        .blocklyMainBackground {
            stroke: none !important;
            fill: #FAFAFA !important;
        }

        .blocklyToolboxDiv {
            background: #F9F9F9 !important;
            border-top: 3px solid #CCCCCC !important;
        }

        .blocklyFlyoutBackground {
            fill: #EFEFEF !important;
            fill-opacity: 0.98 !important;
            stroke: #e0e0e0 !important;
            stroke-width: 1 !important;
            filter: drop-shadow(4px 0 8px rgba(0, 0, 0, 0.08)) !important;
        }

        .blocklyPath {
            stroke-width: 1.5px !important;
        }

        .blocklyText {
            font-size: 18px !important;
            font-weight: 500 !important;
        }

        .blocklyEditableText .blocklyText {
            font-size: 20px !important;
            font-weight: bold !important;
        }

        /* Field kutularına padding ekle */
        .blocklyEditableText>rect {
            rx: 4 !important;
            ry: 4 !important;
        }

        /* Dropdown içindeki metinleri dikey ortala */
        .blocklyDropdownText {
            dominant-baseline: middle !important;
            alignment-baseline: middle !important;
        }

        /* Dropdown ok simgesine boşluk ekle */
        .blocklyDropDownArrow {
            transform: translateX(5px);
        }

        /* Tüm field text'leri ortala */
        .blocklyText {
            dominant-baseline: middle !important;
        }

        /* Pulsing animation for active running state */
        @keyframes pulse-green {
            0% {
                box-shadow: 0 0 0 0 rgba(76, 201, 112, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(76, 201, 112, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(76, 201, 112, 0);
            }
        }

        .status-running {
            animation: pulse-green 1.5s infinite;
        }

        .play-btn {
            transition: all 0.3s;
        }
    </style>
</head>

<body>
    <div class="app">
        <div class="top-bar">
            <div class="logo"><a href="#" style="color: inherit; cursor: pointer; text-decoration:none;">BlockCode</a>
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
                <!-- Zoom Buttons -->
                <button class="tool-btn-small" onclick="zoomIn()" title="Yakınlaştır">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"
                        stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="11" cy="11" r="8"></circle>
                        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                        <line x1="11" y1="8" x2="11" y2="14"></line>
                        <line x1="8" y1="11" x2="14" y2="11"></line>
                    </svg>
                </button>
                <button class="tool-btn-small" onclick="zoomOut()" title="Uzaklaştır">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"
                        stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="11" cy="11" r="8"></circle>
                        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                        <line x1="8" y1="11" x2="14" y2="11"></line>
                    </svg>
                </button>

                <!-- Divider -->
                <div style="width: 1px; height: 28px; background: rgba(255,255,255,0.2); margin: 0 4px;"></div>

                <!-- Language Button -->
                <button class="tool-btn-small" onclick="toggleLanguage()" id="langBtn" title="Dil / Language"
                    style="font-weight: 600; font-size: 13px; letter-spacing: 0.5px;">TR</button>

                <!-- Divider -->
                <div style="width: 1px; height: 28px; background: rgba(255,255,255,0.2); margin: 0 4px;"></div>

                <!-- Import/Export Group -->
                <input type="file" id="importInput" style="display: none;" onchange="importWorkspace(this)"
                    accept=".xml">
                <button class="tool-btn-small" onclick="document.getElementById('importInput').click()"
                    title="İçe Aktar (Import)">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                        stroke-width="2.5">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                </button>
                <button class="tool-btn-small" onclick="exportWorkspace()" title="Dışa Aktar (Export)">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                        stroke-width="2.5">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                </button>

                <!-- Divider -->
                <div style="width: 1px; height: 28px; background: rgba(255,255,255,0.2); margin: 0 4px;"></div>

                <!-- Action Buttons -->
                <button class="info-btn" onclick="openInfoModal()" title="Bilgi / Info">i</button>
                <button class="reset-btn" onclick="resetEverything()" title="Sıfırla">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                        stroke-width="2.5">
                        <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
                        <path d="M21 3v5h-5" />
                        <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" />
                        <path d="M3 21v-5h5" />
                    </svg>
                </button>
                <button class="play-btn" onclick="runCode()" title="Kodu Çalıştır">
                    <svg width="20" height="20" viewBox="0 0 24 24">
                        <path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z" fill="#4CC970" stroke="#FFFFFF"
                            stroke-width="1.5" />
                    </svg>
                </button>
            </div>
        </div>

        <div class="sidebar" id="sidebar">
            <div class="sidebar-content">
                <button class="tool-btn device-add" id="addDeviceBtn" title="Cihaz Ekle">➕</button>
                <div id="deviceList"></div>
                <div class="sidebar-divider"></div>
                <button class="tool-btn" id="startToggle" onclick="toggleStartBlocks()" title="Başlangıç">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="5 3 19 12 5 21 5 3"></polygon>
                    </svg>
                </button>
                <button class="tool-btn" id="controlToggle" onclick="toggleControlBlocks()" title="Kontrol">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <path
                            d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z">
                        </path>
                    </svg>
                </button>
                <button class="tool-btn" id="actionLedToggle" onclick="toggleActionLedBlocks()" title="LED Kontrol">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <circle cx="12" cy="12" r="3"></circle>
                    </svg>
                </button>
                <button class="tool-btn" id="actionNumToggle" onclick="toggleActionNumBlocks()" title="Sayı Kontrol">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                        <line x1="9" y1="9" x2="15" y2="15"></line>
                        <line x1="15" y1="9" x2="9" y2="15"></line>
                    </svg>
                </button>
                <button class="tool-btn" id="actionButtonToggle" onclick="toggleActionButtonBlocks()"
                    title="Tuş Kontrol">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <!-- Üçgen ikonu -->
                        <path d="M12 3L20 20H4L12 3Z"></path>
                    </svg>
                </button>
                <button class="tool-btn" id="operatorToggle" onclick="toggleOperatorBlocks()" title="Operatörler">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <path d="M4 7V4h16v3"></path>
                        <path d="M9 20h6"></path>
                        <path d="M12 4v16"></path>
                    </svg>
                </button>
                <div class="sidebar-divider"></div>

            </div>
            <div class="sidebar-panel" id="sidebarPanel">
                <h3 id="panelTitle">Cihaz Blokları</h3>
                <div id="panelContent"></div>
            </div>
        </div>

        <div class="workspace-container">
            <div id="blocklyDiv"></div>

            <!-- RGB Control Panel -->
            <div class="rgb-control-panel">
                <div class="rgb-group">
                    <div class="rgb-group-items">
                        <div class="rgb-led red" id="rgbRedLed" title="Kırmızı LED"></div>
                        <div class="rgb-led green" id="rgbGreenLed" title="Yeşil LED"></div>
                        <div class="rgb-led blue" id="rgbBlueLed" title="Mavi LED"></div>
                    </div>
                    <span class="rgb-group-label" id="panelLedsLabel">LEDs</span>
                </div>

                <div class="rgb-panel-separator"></div>

                <div class="rgb-group">
                    <div class="rgb-group-items">
                        <div class="rgb-number-box red" id="rgbRedNum">0</div>
                        <div class="rgb-number-box green" id="rgbGreenNum">0</div>
                        <div class="rgb-number-box blue" id="rgbBlueNum">0</div>
                    </div>
                    <span class="rgb-group-label" id="panelNumbersLabel">Numbers</span>
                </div>

                <div class="rgb-panel-separator"></div>

                <div class="rgb-group">
                    <div class="rgb-group-items">
                        <svg id="rgbRedBtn" class="rgb-triangle-btn red" viewBox="0 0 44 44"
                            onmousedown="handleBtnDown('red')" onmouseup="handleBtnUp('red')"
                            onmouseleave="handleBtnUp('red')" ontouchstart="handleBtnDown('red')"
                            ontouchend="handleBtnUp('red')">
                            <polygon points="22,4 4,40 40,40"></polygon>
                        </svg>
                        <svg id="rgbGreenBtn" class="rgb-triangle-btn green" viewBox="0 0 44 44"
                            onmousedown="handleBtnDown('green')" onmouseup="handleBtnUp('green')"
                            onmouseleave="handleBtnUp('green')" ontouchstart="handleBtnDown('green')"
                            ontouchend="handleBtnUp('green')">
                            <polygon points="22,4 4,40 40,40"></polygon>
                        </svg>
                        <svg id="rgbBlueBtn" class="rgb-triangle-btn blue" viewBox="0 0 44 44"
                            onmousedown="handleBtnDown('blue')" onmouseup="handleBtnUp('blue')"
                            onmouseleave="handleBtnUp('blue')" ontouchstart="handleBtnDown('blue')"
                            ontouchend="handleBtnUp('blue')">
                            <polygon points="22,4 4,40 40,40"></polygon>
                        </svg>
                    </div>
                    <span class="rgb-group-label" id="panelButtonsLabel">Buttons</span>
                </div>
            </div>
        </div>

        <!-- Disconnect Button Overlay -->
        <div class="disconnect-overlay" id="disconnectOverlay">
            <button class="disconnect-btn-overlay" onclick="disconnectSelectedDevice()">
                🔌 Bağlantıyı Kes
            </button>
        </div>

        <!-- Blok işlem butonları (sağ alt) -->
        <div class="delete-block-overlay" id="deleteBlockOverlay">
            <button class="block-action-btn help" id="helpBlockBtn" onclick="showBlockHelp()" title="Yardım">
                <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="#FFFFFF">
                    <path
                        d="M11 18h2v-2h-2v2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4z" />
                </svg>
            </button>
            <button class="block-action-btn" id="duplicateBlockBtn" onclick="duplicateSelectedBlock()" title="Kopyala">
                <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="#FFFFFF">
                    <path
                        d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" />
                </svg>
            </button>
            <button class="block-action-btn delete" id="deleteBlockBtn" onclick="deleteSelectedBlock()" title="Sil">
                <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="#FFFFFF">
                    <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z" />
                </svg>
            </button>
        </div>

        <!-- Controller Display Panel - Kompakt -->
        <div class="displays-container">
            <div class="controller-display" id="controllerDisplay">
                <div class="controller-header" id="controllerHeader"
                    style="display: flex; align-items: center; padding: 10px;">
                    <img id="controllerHeaderIcon" src="img/remote_controller_icon.png"
                        style="height: 20px; width: auto; vertical-align: middle; margin-right: 8px; filter: drop-shadow(0 1px 2px rgba(0,0,0,0.2));">
                    <span id="controllerTitleText">Controller</span>
                </div>
                <!-- Pil göstergesi -->
                <div id="controllerBatteryInfo"
                    style="position: absolute; top: 38px; right: 10px; font-size: 11px; color: #37b24d; font-family: monospace; display: flex; align-items: center; gap: 3px;">
                    <svg width="18" height="12" viewBox="0 0 24 14" fill="none" stroke="currentColor"
                        stroke-width="1.5">
                        <rect x="1" y="1" width="18" height="12" rx="2" ry="2"></rect>
                        <rect x="19" y="4" width="3" height="6" rx="1" ry="1" fill="currentColor"></rect>
                        <rect id="controllerBatteryFill" x="3" y="3" width="14" height="8" rx="1" ry="1"
                            fill="currentColor" opacity="0.7"></rect>
                    </svg>
                    <span id="controllerBatteryPercent">--%</span>
                </div>
                <div class="controller-levers">
                    <!-- Sol Kol -->
                    <div class="lever-container">
                        <div class="lever-label-mini">L</div>
                        <div class="lever-bar">
                            <div class="lever-bar-fill left" id="leftLeverFill"></div>
                        </div>
                        <div class="lever-value-mini" id="leftLeverValue">50%</div>
                    </div>
                    <!-- Sağ Kol -->
                    <div class="lever-container">
                        <div class="lever-label-mini">R</div>
                        <div class="lever-bar">
                            <div class="lever-bar-fill right" id="rightLeverFill"></div>
                        </div>
                        <div class="lever-value-mini" id="rightLeverValue">50%</div>
                    </div>
                </div>
            </div>

            <div class="motor-display" id="motorDisplay">
                <div class="controller-header" id="motorHeader" onclick="toggleMotorDisplay()"
                    style="cursor: pointer; display: flex; justify-content: space-between; align-items: center; padding: 8px 10px;">
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <img src="img/single-motor.png" style="height: 20px; width: auto; vertical-align: middle;">
                        <span id="motorTitleText">Single Motor</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div id="motorBatteryInfo"
                            style="font-size: 11px; color: white; font-family: monospace; display: flex; align-items: center; gap: 3px;">
                            <svg width="18" height="12" viewBox="0 0 24 14" fill="none" stroke="currentColor"
                                stroke-width="1.5">
                                <rect x="1" y="1" width="18" height="12" rx="2" ry="2"></rect>
                                <rect x="19" y="4" width="3" height="6" rx="1" ry="1" fill="currentColor"></rect>
                                <rect id="motorBatteryFill" x="3" y="3" width="14" height="8" rx="1" ry="1"
                                    fill="currentColor" opacity="0.7"></rect>
                            </svg>
                            <span id="motorBatteryPercent">--%</span>
                        </div>
                        <span id="motorCollapseIcon">▼</span>
                    </div>
                </div>
                <div id="motorContentWrapper"
                    style="transition: max-height 0.3s ease-out; max-height: 500px; overflow: hidden; background: white;">
                    <div style="padding: 10px; display: flex; align-items: center; justify-content: center; gap: 20px;">
                        <div style="position: relative; width: 60px; height: 62px;">
                            <img id="motorBodyImage" src="img/single-motor-body.png"
                                style="width: 100%; height: 100%; object-fit: contain;">
                            <img id="motorShaft" src="img/single-motor-shaft.png"
                                style="position: absolute; top: 12%; left: 0; width: 100%; height: 80%; object-fit: contain; transition: transform 0.1s linear;">
                        </div>
                        <div id="motorAngleInfo"
                            style="text-align: left; color: #333; font-size: 18px; font-weight: bold; font-family: monospace; min-width: 50px;">
                            0°</div>
                    </div>
                </div>
            </div>

            <!-- Double Motor Display Panel -->
            <div class="motor-display" id="doubleMotorDisplay">
                <div class="controller-header" id="doubleMotorHeader" onclick="toggleDoubleMotorDisplay()"
                    style="cursor: pointer; display: flex; justify-content: space-between; align-items: center; padding: 8px 10px;">
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <img src="img/double-motor.png" style="height: 20px; width: auto; vertical-align: middle;">
                        <span id="doubleMotorTitleText">Double Motor</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div id="doubleMotorBatteryInfo"
                            style="font-size: 11px; color: white; font-family: monospace; display: flex; align-items: center; gap: 3px;">
                            <svg width="18" height="12" viewBox="0 0 24 14" fill="none" stroke="currentColor"
                                stroke-width="1.5">
                                <rect x="1" y="1" width="18" height="12" rx="2" ry="2"></rect>
                                <rect x="19" y="4" width="3" height="6" rx="1" ry="1" fill="currentColor"></rect>
                                <rect id="doubleMotorBatteryFill" x="3" y="3" width="14" height="8" rx="1" ry="1"
                                    fill="currentColor" opacity="0.7"></rect>
                            </svg>
                            <span id="doubleMotorBatteryPercent">--%</span>
                        </div>
                        <span id="doubleMotorCollapseIcon">▼</span>
                    </div>
                </div>
                <div id="doubleMotorContentWrapper"
                    style="transition: max-height 0.3s ease-out; max-height: 500px; overflow: hidden; background: white;">
                    <div style="padding: 10px; display: flex; justify-content: space-around; gap: 10px;">
                        <!-- Motor 1 -->
                        <div style="display: flex; flex-direction: column; align-items: center;">
                            <div style="font-size: 10px; font-weight: bold; margin-bottom: 5px; color: #666;">MOTOR 1
                            </div>
                            <div style="position: relative; width: 50px; height: 52px;">
                                <img src="img/single-motor-body.png"
                                    style="width: 100%; height: 100%; object-fit: contain;">
                                <img id="doubleMotorShaft1" src="img/single-motor-shaft.png"
                                    style="position: absolute; top: 12%; left: 0; width: 100%; height: 80%; object-fit: contain; transition: transform 0.1s linear;">
                            </div>
                            <div id="doubleMotorAngle1"
                                style="color: #333; font-size: 14px; font-weight: bold; font-family: monospace; margin-top: 5px;">
                                0°</div>
                        </div>
                        <!-- Divider -->
                        <div style="width: 1px; background: #eee;"></div>
                        <!-- Motor 2 -->
                        <div style="display: flex; flex-direction: column; align-items: center;">
                            <div style="font-size: 10px; font-weight: bold; margin-bottom: 5px; color: #666;">MOTOR 2
                            </div>
                            <div style="position: relative; width: 50px; height: 52px;">
                                <img src="img/single-motor-body.png"
                                    style="width: 100%; height: 100%; object-fit: contain;">
                                <img id="doubleMotorShaft2" src="img/single-motor-shaft.png"
                                    style="position: absolute; top: 12%; left: 0; width: 100%; height: 80%; object-fit: contain; transition: transform 0.1s linear;">
                            </div>
                            <div id="doubleMotorAngle2"
                                style="color: #333; font-size: 14px; font-weight: bold; font-family: monospace; margin-top: 5px;">
                                0°</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Color Sensor Display Panel -->
            <div class="color-sensor-display" id="colorSensorDisplay">
                <div class="controller-header" id="colorSensorHeader"
                    style="background: #9B59B6; cursor: pointer; display: flex; justify-content: space-between; align-items: center;"
                    onclick="toggleColorSensorDisplay()">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <img id="colorSensorHeaderIcon" src="img/color-sensor.png"
                            style="height: 20px; width: auto; filter: drop-shadow(0 1px 2px rgba(0,0,0,0.2));">
                        <span id="colorSensorHeaderTitle">Color Sensor</span>
                    </div>
                    <span id="colorSensorCollapseIcon">▼</span>
                </div>

                <!-- Collapsible Content Wrapper -->
                <div id="colorSensorContentWrapper"
                    style="transition: max-height 0.3s ease-out; overflow: hidden; max-height: 500px; position: relative;">
                    <!-- Pil göstergesi -->
                    <div id="colorSensorBatteryInfo"
                        style="position: absolute; top: 10px; right: 10px; font-size: 11px; color: #37b24d; font-family: monospace; display: flex; align-items: center; gap: 3px; z-index: 10;">
                        <svg width="18" height="12" viewBox="0 0 24 14" fill="none" stroke="currentColor"
                            stroke-width="1.5">
                            <rect x="1" y="1" width="18" height="12" rx="2" ry="2"></rect>
                            <rect x="19" y="4" width="3" height="6" rx="1" ry="1" fill="currentColor"></rect>
                            <rect id="colorSensorBatteryFill" x="3" y="3" width="14" height="8" rx="1" ry="1"
                                fill="currentColor" opacity="0.7"></rect>
                        </svg>
                        <span id="colorSensorBatteryPercent">--%</span>
                    </div>
                    <div class="color-sensor-content"
                        style="display: flex; align-items: center; gap: 15px; padding: 15px;">
                        <!-- Renk gösterge dairesi -->
                        <div class="color-sensor-circle no-color" id="colorSensorCircle"
                            style="width: 70px; height: 70px; min-width: 70px;">
                            <svg id="noColorIcon" width="30" height="30" viewBox="0 0 40 40">
                                <circle cx="20" cy="20" r="18" fill="none" stroke="#ccc" stroke-width="3" />
                                <line x1="8" y1="8" x2="32" y2="32" stroke="#ff4444" stroke-width="3"
                                    stroke-linecap="round" />
                            </svg>
                        </div>
                        <!-- Sağ taraf: Renk adı ve detaylar -->
                        <div style="flex: 1; text-align: left;">
                            <div class="color-sensor-label" id="colorSensorLabel"
                                style="font-size: 18px; font-weight: bold; margin-bottom: 4px;">No Color</div>
                            <div class="color-sensor-details" id="colorSensorDetails"
                                style="font-size: 12px; color: #666;">
                                <span id="colorSensorReflectionLabel">Reflection</span>: <span
                                    id="colorSensorReflectionValue">--%</span> | <span
                                    id="colorSensorHueLabel">Hue</span>: <span id="colorSensorHueValue">--°</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Remote Controller (88010) Display Panel -->
            <div class="remote-controller-display" id="remoteControllerDisplay">
                <div class="controller-header" id="remoteControllerHeader"
                    style="background: #00A3DA; cursor: pointer; display: flex; justify-content: space-between; align-items: center;"
                    onclick="toggleRemoteDisplay()">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <img src="img/remote_controller_icon.png"
                            style="height: 20px; width: auto; filter: drop-shadow(0 1px 2px rgba(0,0,0,0.2));">
                        <span>Remote Controller</span>
                    </div>
                    <span id="remoteCollapseIcon">▼</span>
                </div>

                <!-- Collapsible Content Wrapper -->
                <div id="remoteContentWrapper"
                    style="transition: max-height 0.3s ease-out; overflow: hidden; max-height: 500px;">
                    <!-- Pil göstergesi - Wrapper içinde relative pozisyonlanacak -->
                    <div id="remoteControllerBatteryInfo"
                        style="position: absolute; top: 10px; right: 10px; font-size: 11px; color: #37b24d; font-family: monospace; display: flex; align-items: center; gap: 3px; z-index: 10;">
                        <svg width="18" height="12" viewBox="0 0 24 14" fill="none" stroke="currentColor"
                            stroke-width="1.5">
                            <rect x="1" y="1" width="18" height="12" rx="2" ry="2"></rect>
                            <rect x="19" y="4" width="3" height="6" rx="1" ry="1" fill="currentColor"></rect>
                            <rect id="remoteControllerBatteryFill" x="3" y="3" width="14" height="8" rx="1" ry="1"
                                fill="currentColor" opacity="0.7"></rect>
                        </svg>
                        <span id="remoteControllerBatteryPercent">--%</span>
                    </div>
                    <div class="remote-controller-buttons"
                        style="display: flex; justify-content: center; gap: 30px; padding: 15px 10px; position: relative;">
                        <!-- Sol Taraf Butonları -->
                        <div class="remote-side"
                            style="display: flex; flex-direction: column; align-items: center; gap: 6px;">
                            <div style="font-size: 11px; color: #666; font-weight: bold; margin-bottom: 4px;">LEFT</div>
                            <div class="remote-btn remote-plus" id="remoteLeftPlus"
                                style="width: 36px; height: 24px; border-radius: 6px; background: #e0e0e0; border: 2px solid #bbb; display: flex; align-items: center; justify-content: center; transition: all 0.15s;">
                                <span style="font-size: 18px; font-weight: bold; color: #666;">+</span>
                            </div>
                            <div class="remote-btn remote-red" id="remoteLeftRed"
                                style="width: 28px; height: 28px; border-radius: 50%; background: #ff6b6b; border: 2px solid #e03131; display: flex; align-items: center; justify-content: center; transition: all 0.15s;">
                            </div>
                            <div class="remote-btn remote-minus" id="remoteLeftMinus"
                                style="width: 36px; height: 24px; border-radius: 6px; background: #e0e0e0; border: 2px solid #bbb; display: flex; align-items: center; justify-content: center; transition: all 0.15s;">
                                <span style="font-size: 18px; font-weight: bold; color: #666;">−</span>
                            </div>
                            <div class="remote-state-label" id="remoteLeftState"
                                style="font-size: 10px; color: #999; margin-top: 4px;">RELEASED</div>
                        </div>
                        <!-- Orta Yeşil Buton -->
                        <div class="remote-center"
                            style="display: flex; flex-direction: column; align-items: center; justify-content: center;">
                            <!-- LED Color Indicator -->
                            <div id="remoteLedIndicator"
                                style="width: 20px; height: 20px; border-radius: 50%; background: #FFFFFF; border: 2px solid rgba(0,0,0,0.2); margin-bottom: 8px; box-shadow: 0 0 12px #FFFFFF; transition: all 0.3s;">
                            </div>
                            <div style="font-size: 9px; color: #666; margin-bottom: 4px;">LED</div>
                            <div class="remote-btn remote-green" id="remoteGreenBtn"
                                style="width: 32px; height: 32px; border-radius: 6px; background: #51cf66; border: 2px solid #37b24d; transition: all 0.15s;">
                            </div>
                            <div class="remote-state-label" id="remoteGreenState"
                                style="font-size: 10px; color: #999; margin-top: 4px;">OFF</div>
                        </div>
                        <!-- Sağ Taraf Butonları -->
                        <div class="remote-side"
                            style="display: flex; flex-direction: column; align-items: center; gap: 6px;">
                            <div style="font-size: 11px; color: #666; font-weight: bold; margin-bottom: 4px;">RIGHT
                            </div>
                            <div class="remote-btn remote-plus" id="remoteRightPlus"
                                style="width: 36px; height: 24px; border-radius: 6px; background: #e0e0e0; border: 2px solid #bbb; display: flex; align-items: center; justify-content: center; transition: all 0.15s;">
                                <span style="font-size: 18px; font-weight: bold; color: #666;">+</span>
                            </div>
                            <div class="remote-btn remote-red" id="remoteRightRed"
                                style="width: 28px; height: 28px; border-radius: 50%; background: #ff6b6b; border: 2px solid #e03131; display: flex; align-items: center; justify-content: center; transition: all 0.15s;">
                            </div>
                            <div class="remote-btn remote-minus" id="remoteRightMinus"
                                style="width: 36px; height: 24px; border-radius: 6px; background: #e0e0e0; border: 2px solid #bbb; display: flex; align-items: center; justify-content: center; transition: all 0.15s;">
                                <span style="font-size: 18px; font-weight: bold; color: #666;">−</span>
                            </div>
                            <div class="remote-state-label" id="remoteRightState"
                                style="font-size: 10px; color: #999; margin-top: 4px;">RELEASED</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- City Hub Display Panel -->
            <div class="city-hub-display" id="cityHubDisplay">
                <div class="controller-header" id="cityHubHeader"
                    style="background: #3498DB; cursor: pointer; display: flex; justify-content: space-between; align-items: center;"
                    onclick="toggleCityHubDisplay()">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <img id="cityHubHeaderIcon" src="img/city-hub.png"
                            style="height: 20px; width: auto; filter: drop-shadow(0 1px 2px rgba(0,0,0,0.2));">
                        <span id="cityHubHeaderTitle">City Hub</span>
                    </div>
                    <span id="cityHubCollapseIcon">▼</span>
                </div>
                <div id="cityHubContentWrapper"
                    style="transition: max-height 0.3s ease-out; overflow: hidden; max-height: 500px; position: relative;">
                    <div id="cityHubBatteryInfo"
                        style="position: absolute; top: 10px; right: 10px; font-size: 11px; color: #37b24d; font-family: monospace; display: flex; align-items: center; gap: 3px; z-index: 10;">
                        <svg width="18" height="12" viewBox="0 0 24 14" fill="none" stroke="currentColor"
                            stroke-width="1.5">
                            <rect x="1" y="1" width="18" height="12" rx="2" ry="2"></rect>
                            <rect x="19" y="4" width="3" height="6" rx="1" ry="1" fill="currentColor"></rect>
                            <rect id="cityHubBatteryFill" x="3" y="3" width="14" height="8" rx="1" ry="1"
                                fill="currentColor" opacity="0.7"></rect>
                        </svg>
                        <span id="cityHubBatteryPercent">--%</span>
                    </div>
                    <div style="padding: 15px; text-align: center;">
                        <div id="cityHubLedIndicator"
                            style="width: 24px; height: 24px; border-radius: 50%; background: #FFFFFF; border: 2px solid rgba(0,0,0,0.2); margin: 0 auto 10px; box-shadow: 0 0 12px #FFFFFF; transition: all 0.3s;">
                        </div>
                        <div style="font-size: 10px; color: #666; margin-bottom: 10px;">Hub LED</div>
                        <div style="display: flex; justify-content: center; gap: 15px;">
                            <div style="text-align: center;">
                                <div style="font-size: 10px; color: #888; margin-bottom: 4px;">Port A</div>
                                <div id="cityHubPortA"
                                    style="width: 40px; height: 40px; border-radius: 8px; background: #e0e0e0; border: 2px solid #bbb; display: flex; align-items: center; justify-content: center; font-size: 18px;">
                                    -</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 10px; color: #888; margin-bottom: 4px;">Port B</div>
                                <div id="cityHubPortB"
                                    style="width: 40px; height: 40px; border-radius: 8px; background: #e0e0e0; border: 2px solid #bbb; display: flex; align-items: center; justify-content: center; font-size: 18px;">
                                    -</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Boost Move Hub Display Panel -->
            <div class="boost-hub-display" id="boostHubDisplay">
                <div class="controller-header" id="boostHubHeader"
                    style="background: #E74C3C; cursor: pointer; display: flex; justify-content: space-between; align-items: center;"
                    onclick="toggleBoostHubDisplay()">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <img id="boostHubHeaderIcon" src="img/boost-hub.png"
                            style="height: 20px; width: auto; filter: drop-shadow(0 1px 2px rgba(0,0,0,0.2));">
                        <span id="boostHubHeaderTitle">Boost Move Hub</span>
                    </div>
                    <span id="boostHubCollapseIcon">▼</span>
                </div>
                <div id="boostHubContentWrapper"
                    style="transition: max-height 0.3s ease-out; overflow: hidden; max-height: 500px; position: relative;">
                    <div id="boostHubBatteryInfo"
                        style="position: absolute; top: 10px; right: 10px; font-size: 11px; color: #37b24d; font-family: monospace; display: flex; align-items: center; gap: 3px; z-index: 10;">
                        <svg width="18" height="12" viewBox="0 0 24 14" fill="none" stroke="currentColor"
                            stroke-width="1.5">
                            <rect x="1" y="1" width="18" height="12" rx="2" ry="2"></rect>
                            <rect x="19" y="4" width="3" height="6" rx="1" ry="1" fill="currentColor"></rect>
                            <rect id="boostHubBatteryFill" x="3" y="3" width="14" height="8" rx="1" ry="1"
                                fill="currentColor" opacity="0.7"></rect>
                        </svg>
                        <span id="boostHubBatteryPercent">--%</span>
                    </div>
                    <div style="padding: 15px; text-align: center;">
                        <div id="boostHubLedIndicator"
                            style="width: 24px; height: 24px; border-radius: 50%; background: #FFFFFF; border: 2px solid rgba(0,0,0,0.2); margin: 0 auto 10px; box-shadow: 0 0 12px #FFFFFF; transition: all 0.3s;">
                        </div>
                        <div style="font-size: 10px; color: #666; margin-bottom: 10px;">Hub LED</div>
                        <div style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
                            <div style="text-align: center;">
                                <div style="font-size: 9px; color: #888; margin-bottom: 4px;">Port A</div>
                                <div id="boostHubPortA"
                                    style="width: 36px; height: 36px; border-radius: 6px; background: #e0e0e0; border: 2px solid #bbb; display: flex; align-items: center; justify-content: center; font-size: 14px;">
                                    -</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 9px; color: #888; margin-bottom: 4px;">Port B</div>
                                <div id="boostHubPortB"
                                    style="width: 36px; height: 36px; border-radius: 6px; background: #e0e0e0; border: 2px solid #bbb; display: flex; align-items: center; justify-content: center; font-size: 14px;">
                                    -</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 9px; color: #888; margin-bottom: 4px;">Port C</div>
                                <div id="boostHubPortC"
                                    style="width: 36px; height: 36px; border-radius: 6px; background: #e0e0e0; border: 2px solid #bbb; display: flex; align-items: center; justify-content: center; font-size: 14px;">
                                    -</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 9px; color: #888; margin-bottom: 4px;">Port D</div>
                                <div id="boostHubPortD"
                                    style="width: 36px; height: 36px; border-radius: 6px; background: #e0e0e0; border: 2px solid #bbb; display: flex; align-items: center; justify-content: center; font-size: 14px;">
                                    -</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Spike Essential Hub Display Panel - LEGACY (hidden, dynamic displays are used instead) -->
            <div class="spike-essential-display" id="spikeEssentialDisplay" style="display: none !important;">
                <div class="controller-header" id="spikeEssentialHeader" style="background: #F5A623;">Spike
                    Essential
                    Hub</div>
                <!-- Pil göstergesi -->
                <div id="spikeEssentialBatteryInfo"
                    style="position: absolute; top: 38px; right: 10px; font-size: 11px; color: #37b24d; font-family: monospace; display: flex; align-items: center; gap: 3px;">
                    <svg width="18" height="12" viewBox="0 0 24 14" fill="none" stroke="currentColor"
                        stroke-width="1.5">
                        <rect x="1" y="1" width="18" height="12" rx="2" ry="2"></rect>
                        <rect x="19" y="4" width="3" height="6" rx="1" ry="1" fill="currentColor"></rect>
                        <rect id="spikeEssentialBatteryFill" x="3" y="3" width="14" height="8" rx="1" ry="1"
                            fill="currentColor" opacity="0.7"></rect>
                    </svg>
                    <span id="spikeEssentialBatteryPercent">--%</span>
                </div>
                <div class="spike-hub-content">
                    <!-- Port durumları -->
                    <div class="spike-hub-ports">
                        <div class="spike-hub-port">
                            <div class="spike-hub-port-label">Port A</div>
                            <div class="spike-hub-port-status" id="spikePortAStatus">Empty</div>
                        </div>
                        <div class="spike-hub-port">
                            <div class="spike-hub-port-label">Port B</div>
                            <div class="spike-hub-port-status" id="spikePortBStatus">Empty</div>
                        </div>
                        <div class="spike-hub-port">
                            <div class="spike-hub-port-label">Port C</div>
                            <div class="spike-hub-port-status" id="spikePortCStatus">Empty</div>
                        </div>
                        <div class="spike-hub-port">
                            <div class="spike-hub-port-label">Port D</div>
                            <div class="spike-hub-port-status" id="spikePortDStatus">Empty</div>
                        </div>
                    </div>
                    <!-- Sensör verileri -->
                    <div class="spike-hub-sensors">
                        <div class="spike-hub-sensor">
                            <div class="spike-hub-sensor-label">Gyro</div>
                            <div class="spike-hub-sensor-value" id="spikeGyroValue">X:-- Y:-- Z:--</div>
                        </div>
                        <div class="spike-hub-sensor">
                            <div class="spike-hub-sensor-label">Accel</div>
                            <div class="spike-hub-sensor-value" id="spikeAccelValue">X:-- Y:-- Z:--</div>
                        </div>
                        <div class="spike-hub-sensor spike-hub-tilt">
                            <div class="spike-hub-sensor-label">Tilt</div>
                            <div class="spike-hub-tilt-icon" id="spikeTiltIcon">⬛</div>
                            <div class="spike-hub-sensor-value" id="spikeTiltValue">--</div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Spike Prime Hub Display (6 ports: A-F) -->
            <div class="spike-prime-display" id="spikePrimeDisplay">
                <div class="controller-header hub-header-collapsible" id="spikePrimeHeader"
                    style="background: linear-gradient(135deg, #9B59B6 0%, #8E44AD 100%);"
                    onclick="toggleSpikePrimeCollapse()">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <img src="img/spike_prime_icon.png" style="width: 24px; height: 24px; object-fit: contain;">
                        <span id="spikePrimeHeaderText">Spike Prime Hub</span>
                    </div>
                    <span class="hub-collapse-icon" id="spikePrimeCollapseIcon">▼</span>
                </div>
                <div class="hub-collapsible-content" id="spikePrimeContent">
                    <div class="spike-hub-content">
                        <!-- Port durumları (3x2 grid) -->
                        <div class="spike-prime-ports">
                            <div class="spike-prime-port" id="spikePrimePortA">
                                <div class="spike-prime-port-label">Port A</div>
                                <div class="spike-prime-port-status" id="spikePrimePortAStatus">Empty</div>
                            </div>
                            <div class="spike-prime-port" id="spikePrimePortB">
                                <div class="spike-prime-port-label">Port B</div>
                                <div class="spike-prime-port-status" id="spikePrimePortBStatus">Empty</div>
                            </div>
                            <div class="spike-prime-port" id="spikePrimePortC">
                                <div class="spike-prime-port-label">Port C</div>
                                <div class="spike-prime-port-status" id="spikePrimePortCStatus">Empty</div>
                            </div>
                            <div class="spike-prime-port" id="spikePrimePortD">
                                <div class="spike-prime-port-label">Port D</div>
                                <div class="spike-prime-port-status" id="spikePrimePortDStatus">Empty</div>
                            </div>
                            <div class="spike-prime-port" id="spikePrimePortE">
                                <div class="spike-prime-port-label">Port E</div>
                                <div class="spike-prime-port-status" id="spikePrimePortEStatus">Empty</div>
                            </div>
                            <div class="spike-prime-port" id="spikePrimePortF">
                                <div class="spike-prime-port-label">Port F</div>
                                <div class="spike-prime-port-status" id="spikePrimePortFStatus">Empty</div>
                            </div>
                        </div>
                        <!-- Force Sensor Display -->
                        <div id="spikePrimeForceContainer"
                            style="display: none; padding: 8px 12px; background: #f8f9fa; border-radius: 8px; margin: 8px 0;">
                            <div
                                style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px;">
                                <span style="font-size: 11px; font-weight: 600; color: #666;">🤜 Force Sensor</span>
                                <span id="spikePrimeForceValue"
                                    style="font-size: 14px; font-weight: bold; color: #333;">0</span>
                            </div>
                            <div style="background: #e0e0e0; border-radius: 4px; height: 8px; overflow: hidden;">
                                <div id="spikePrimeForceBar"
                                    style="background: #51cf66; height: 100%; width: 0%; transition: all 0.15s ease;">
                                </div>
                            </div>
                        </div>
                        <!-- Footer: Tilt, Battery, Sensor Modal Button -->
                        <div class="spike-hub-footer">
                            <div class="spike-hub-tilt-compact">
                                <div class="spike-hub-tilt-icon" id="spikePrimeTiltIcon">🔘</div>
                            </div>
                            <div id="spikePrimeBatteryInfo"
                                style="display: flex; align-items: center; gap: 3px; font-size: 11px; color: #37b24d; font-family: monospace;">
                                <svg width="18" height="12" viewBox="0 0 24 14" fill="none" stroke="currentColor"
                                    stroke-width="1.5">
                                    <rect x="1" y="1" width="18" height="12" rx="2" ry="2"></rect>
                                    <rect x="19" y="4" width="3" height="6" rx="1" ry="1" fill="currentColor"></rect>
                                    <rect id="spikePrimeBatteryFill" x="3" y="3" width="14" height="8" rx="1" ry="1"
                                        fill="currentColor" opacity="0.7"></rect>
                                </svg>
                                <span id="spikePrimeBatteryPercent">--%</span>
                            </div>
                            <button class="hub-details-btn" onclick="showSpikePrimeSensorModal()"
                                title="Sensör Detayları">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    stroke-width="2">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="12" y1="16" x2="12" y2="12"></line>
                                    <line x1="12" y1="8" x2="12.01" y2="8"></line>
                                </svg>
                            </button>
                        </div>
                        <!-- Hidden sensor values for modal -->
                        <div style="display:none;">
                            <span id="spikePrimeGyroValue">X:0 Y:0 Z:0</span>
                            <span id="spikePrimeAccelValue">X:0 Y:0 Z:0</span>
                            <span id="spikePrimeTiltValue">Y:0° P:0° R:0°</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Custom Reset Modal -->
    <div id="resetModal" class="reset-modal">
        <div class="reset-modal-content">
            <div class="reset-modal-header">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
                    <path d="M21 3v5h-5" />
                    <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" />
                    <path d="M3 21v-5h5" />
                </svg>
                <span id="resetModalTitle">Her şeyi sıfırlamak istediğinize emin misiniz?</span>
            </div>
            <div class="reset-modal-body">
                <ul id="resetModalList">
                    <!-- List items will be populated by JS -->
                </ul>
            </div>
            <div class="reset-modal-footer">
                <button class="reset-modal-btn cancel" id="resetModalCancelBtn"
                    onclick="closeResetModal()">İptal</button>
                <button class="reset-modal-btn confirm" id="resetModalConfirmBtn"
                    onclick="performReset()">Sıfırla</button>
            </div>
        </div>
    </div>

    <!-- Import Error Modal -->
    <div id="importErrorModal" class="reset-modal">
        <div class="reset-modal-content" style="max-width: 500px;">
            <div class="reset-modal-header" style="color: #e74c3c;">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10" />
                    <line x1="12" y1="8" x2="12" y2="12" />
                    <line x1="12" y1="16" x2="12.01" y2="16" />
                </svg>
                <span id="importErrorTitle">Dosya Yükleme Hatası</span>
            </div>
            <div class="reset-modal-body">
                <p id="importErrorMessage" style="margin-bottom: 10px; color: #666;"></p>
                <pre id="importErrorDetails"
                    style="background: #f5f5f5; padding: 10px; border-radius: 8px; font-size: 12px; max-height: 150px; overflow: auto; white-space: pre-wrap; word-break: break-word; color: #c0392b;"></pre>
            </div>
            <div class="reset-modal-footer">
                <button class="reset-modal-btn confirm" id="importErrorOkBtn"
                    onclick="closeImportErrorModal()">Tamam</button>
            </div>
        </div>
    </div>

    <!-- Runtime Error Modal -->
    <div id="runtimeErrorModal" class="reset-modal">
        <div class="reset-modal-content">
            <div class="reset-modal-header" style="color: #e74c3c;">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="12"></line>
                    <line x1="12" y1="16" x2="12.01" y2="16"></line>
                </svg>
                <span id="runtimeErrorTitle">Hata</span>
            </div>
            <div class="reset-modal-body">
                <p id="runtimeErrorMessage" style="color: #666; font-size: 15px; margin: 0; padding-bottom: 10px;">
                </p>
            </div>
            <div class="reset-modal-footer">
                <button class="reset-modal-btn confirm" id="runtimeErrorOkBtn" onclick="closeRuntimeErrorModal()"
                    style="background-color: #e74c3c;">Tamam</button>
            </div>
        </div>
    </div>

    <!-- Import Confirmation Modal -->
    <div id="importConfirmModal" class="reset-modal">
        <div class="reset-modal-content" style="max-width: 420px;">
            <div class="reset-modal-header">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" />
                    <polyline points="14 2 14 8 20 8" />
                    <line x1="12" y1="18" x2="12" y2="12" />
                    <line x1="9" y1="15" x2="15" y2="15" />
                </svg>
                <span id="importConfirmTitle">Dosya Yükleme</span>
            </div>
            <div class="reset-modal-body" style="text-align: center;">
                <p id="importConfirmMessage" style="margin-bottom: 8px; font-weight: 500;">Mevcut blokları
                    temizleyip yüklensin mi?</p>
                <p id="importConfirmHint" style="font-size: 13px; color: #888;">(İptal'e tıklayarak mevcut
                    bloklara
                    ekleyebilirsiniz)</p>
            </div>
            <div class="reset-modal-footer">
                <button class="reset-modal-btn cancel" id="importConfirmCancelBtn"
                    onclick="confirmImport(false)">İptal</button>
                <button class="reset-modal-btn confirm" id="importConfirmOkBtn" onclick="confirmImport(true)">Temizle ve
                    Yükle</button>
            </div>
        </div>
    </div>

    <!-- Device Mapping Modal -->
    <div id="deviceMappingModal" class="reset-modal">
        <div class="reset-modal-content" style="max-width: 500px;">
            <div class="reset-modal-header" style="color: #4C97FF;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 2L2 7l10 5 10-5-10-5z" />
                    <path d="M2 17l10 5 10-5" />
                    <path d="M2 12l10 5 10-5" />
                </svg>
                <span id="deviceMappingTitle">Cihaz Eşleştirme</span>
            </div>
            <div class="reset-modal-body">
                <p id="deviceMappingMessage" style="margin-bottom: 15px; color: #666;">
                    İçe aktarılan dosyada bağlı olmayan cihazlara ait bloklar bulundu. Lütfen bu blokları mevcut
                    cihazlarla eşleştirin:
                </p>
                <div id="deviceMappingList" style="max-height: 250px; overflow-y: auto;">
                    <!-- Device mapping rows will be inserted here -->
                </div>
            </div>
            <div class="reset-modal-footer">
                <button class="reset-modal-btn cancel" id="deviceMappingSkipBtn"
                    onclick="skipDeviceMapping()">Eşleştirmeden Devam Et</button>
                <button class="reset-modal-btn confirm" id="deviceMappingApplyBtn"
                    onclick="applyDeviceMapping()">Eşleştir ve Yükle</button>
            </div>
        </div>
    </div>

    </div>
    </div>

    <!-- Device Remove Confirmation Modal -->
    <div id="removeDeviceModal" class="reset-modal">
        <div class="reset-modal-content" style="width: 380px;">
            <div class="reset-modal-header">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 6h18" />
                    <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" />
                    <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" />
                    <line x1="10" y1="11" x2="10" y2="17" />
                    <line x1="14" y1="11" x2="14" y2="17" />
                </svg>
                <span id="removeDeviceModalTitle">Bu cihazı kaldırmak istediğinize emin misiniz?</span>
            </div>
            <div class="reset-modal-footer">
                <button class="reset-modal-btn cancel" id="removeDeviceCancelBtn"
                    onclick="closeRemoveDeviceModal()">İptal</button>
                <button class="reset-modal-btn confirm" id="removeDeviceConfirmBtn" style="background-color: #FF4466;"
                    onclick="confirmRemoveDevice()">Kaldır</button>
            </div>
        </div>
    </div>

    <!-- Device Settings Modal -->
    <div id="deviceSettingsModal" class="reset-modal">
        <div class="reset-modal-content" style="width: 420px;">
            <div class="reset-modal-header" style="background: #4C97FF;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                    <circle cx="12" cy="12" r="3" />
                    <path
                        d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z" />
                </svg>
                <span id="deviceSettingsTitle" style="color: white;">Device Settings</span>
            </div>
            <div style="padding: 20px;">
                <!-- Nickname Setting -->
                <div style="margin-bottom: 16px;">
                    <label
                        style="display: block; font-size: 12px; font-weight: bold; color: #666; margin-bottom: 6px;">Hub
                        Nickname</label>
                    <div style="display: flex; gap: 8px;">
                        <input type="text" id="deviceNicknameInput" maxlength="14" placeholder="Enter nickname..."
                            style="flex: 1; padding: 10px 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px; outline: none; transition: border-color 0.2s;"
                            onfocus="this.style.borderColor='#4C97FF'" onblur="this.style.borderColor='#e0e0e0'">
                        <button onclick="saveDeviceNickname()"
                            style="background: #4C97FF; color: white; border: none; padding: 10px 16px; border-radius: 8px; cursor: pointer; font-weight: bold;">
                            Save
                        </button>
                    </div>
                    <div style="font-size: 11px; color: #999; margin-top: 4px;">Max 14 characters</div>
                </div>
                <!-- LED Color Setting -->
                <div>
                    <label
                        style="display: block; font-size: 12px; font-weight: bold; color: #666; margin-bottom: 6px;">Hub
                        LED Color</label>
                    <div id="ledColorPicker" style="display: flex; flex-wrap: wrap; gap: 8px;">
                        <!-- Colors will be generated by JS -->
                    </div>
                </div>
            </div>
            <div class="reset-modal-footer">
                <button class="reset-modal-btn cancel" onclick="closeDeviceSettings()">Close</button>
            </div>
        </div>
    </div>
    </div>

    <!-- Number Panel Popup -->
    <div class="number-panel" id="numberPanel">
        <div class="number-display" id="numberDisplay">1</div>
        <div class="number-controls">
            <button class="num-btn" id="decrementBtn">−</button>
            <button class="num-btn" id="incrementBtn">+</button>
        </div>
    </div>

    <!-- Angle Panel Popup -->
    <div class="angle-panel" id="anglePanel">
        <div class="angle-display-container">
            <div class="angle-circle" id="angleCircle">
                <div class="angle-markers" id="angleMarkers"></div>
                <div class="angle-indicator" id="angleIndicator"></div>
                <div class="angle-center-dot"></div>
            </div>
        </div>
        <div class="angle-controls">
            <button class="angle-btn" id="angleDecrementBtn">−</button>
            <div class="angle-degrees" id="angleDegrees">0°</div>
            <button class="angle-btn" id="angleIncrementBtn">+</button>
        </div>
    </div>

    <!-- Message Input Panel -->
    <div class="number-panel" id="messagePanel" style="width: 300px;">
        <div
            style="background: white; border: 4px solid #4C97FF; border-radius: 15px; padding: 20px; box-shadow: 0 4px 10px rgba(0,0,0,0.2);">
            <input type="text" id="messageInput" placeholder="Mesaj adı..."
                style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #4C97FF; border-radius: 8px; outline: none; font-weight: bold;">
            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button onclick="saveMessage()"
                    style="flex: 1; padding: 10px; background: #0FBD8C; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer;">
                    ✓ Kaydet
                </button>
                <button onclick="closeMessagePanel()"
                    style="flex: 1; padding: 10px; background: #FF6680; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer;">
                    × İptal
                </button>
            </div>
        </div>
    </div>

    <!-- Pixel Matrix Panel for Color Light Matrix -->
    <div class="pixel-panel" id="pixelPanel">
        <div>
            <div class="pixel-grid" id="pixelGrid">
                <!-- 9 pixel cells will be generated by JS -->
            </div>
            <div class="pixel-actions">
                <button class="pixel-preset-btn" onclick="clearPixelGrid()" title="Clear All">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="white">
                        <path d="M3 3h18v18H3V3zm2 2v14h14V5H5z" />
                    </svg>
                </button>
                <button class="pixel-preset-btn" onclick="fillPixelGrid()" title="Fill All">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="white">
                        <path d="M3 3h18v18H3V3z" />
                    </svg>
                </button>
            </div>
        </div>
        <div class="pixel-color-picker" id="pixelColorPicker">
            <!-- Color buttons will be generated by JS -->
        </div>
    </div>

    <!-- Help Sidebar -->
    <div class="help-sidebar" id="helpSidebar">
        <div class="help-header">
            <h3 id="helpTitle">Block Help</h3>
            <button class="close-btn" onclick="closeBlockHelp()"
                style="width: 30px; height: 30px; font-size: 20px;">×</button>
        </div>
        <div class="help-content" id="helpContent">
            <!-- Content will be injected here -->
        </div>
    </div>

    <div class="code-modal" id="codeModal">
        <div class="code-content">
            <div class="code-header">
                <h2>📝 MicroPython</h2>
                <button class="close-btn" onclick="closeModal()">×</button>
            </div>
            <div class="code-display" id="codeDisplay"></div>
            <button class="copy-btn" onclick="copyCode()">📋 Kopyala</button>
        </div>
    </div>

    <!-- Device Connection Modal -->
    <!-- Info Modal -->
    <div class="code-modal" id="infoModal">
        <div class="code-content"
            style="max-width: 700px; height: 80vh; max-height: 700px; display: flex; flex-direction: column; overflow: hidden; padding: 15px;">
            <div class="code-header" style="margin-bottom: 8px; padding-bottom: 8px;">
                <h2 id="infoModalTitle" style="margin: 0; font-size: 20px;">ℹ️ Sistem Bilgisi</h2>
                <button class="close-btn" onclick="closeInfoModal()">×</button>
            </div>

            <div class="info-tabs" style="display: flex; border-bottom: 2px solid #eee; margin-bottom: 8px;">
                <div class="info-tab active" onclick="switchInfoTab('starters')" id="tab-btn-starters"
                    style="padding: 8px 16px; cursor: pointer; font-weight: bold; border-bottom: 3px solid #4C97FF; color: #4C97FF; transition: all 0.2s; font-size: 14px;">
                    Başlangıç</div>
                <div class="info-tab" onclick="switchInfoTab('executions')" id="tab-btn-executions"
                    style="padding: 8px 16px; cursor: pointer; font-weight: bold; color: #888; transition: all 0.2s; font-size: 14px;">
                    Çalıştırmalar</div>
                <div class="info-tab" onclick="switchInfoTab('devices')" id="tab-btn-devices"
                    style="padding: 8px 16px; cursor: pointer; font-weight: bold; color: #888; transition: all 0.2s; font-size: 14px;">
                    Cihazlar</div>
                <div class="info-tab" onclick="switchInfoTab('graphs')" id="tab-btn-graphs"
                    style="padding: 8px 16px; cursor: pointer; font-weight: bold; color: #888; transition: all 0.2s; font-size: 14px;">
                    <span id="tab-label-graphs">Graphs</span>
                </div>
            </div>

            <div class="info-tab-content" id="tab-starters" style="flex: 1; overflow-y: auto; margin: 0;">
                <ul id="startersList" style="list-style: none; padding: 0; margin: 0;"></ul>
            </div>
            <div class="info-tab-content" id="tab-executions"
                style="display: none; flex: 1; overflow-y: auto; padding: 8px; margin: 0;">
                <div id="executionLogs">
                    <div style="padding: 30px; text-align: center; color: #999;">Henüz çalıştırma kaydı yok.</div>
                </div>
            </div>
            <div class="info-tab-content" id="tab-devices" style="display: none; flex: 1; overflow-y: auto; margin: 0;">
                <ul id="deviceLogsList" style="list-style: none; padding: 0; margin: 0;"></ul>
            </div>
            <div class="info-tab-content" id="tab-graphs"
                style="display: none; flex: 1; overflow-y: auto; margin: 0; padding: 10px;">
                <div style="display: flex; gap: 8px; margin-bottom: 12px; align-items: center; flex-wrap: wrap;">
                    <button onclick="refreshLedGraph()" id="refreshGraphBtn"
                        style="padding: 6px 12px; border: 1px solid #ddd; background: #4C97FF; color: white; border-radius: 16px; cursor: pointer; font-size: 12px;">🔄
                        Yenile</button>
                    <button onclick="cancelGraphZoom()" id="cancelZoomBtn"
                        style="padding: 6px 12px; border: 1px solid #ddd; background: #f5f5f5; border-radius: 16px; cursor: pointer; font-size: 12px; display: none;">↩️
                        Zoom İptal</button>
                </div>

                <!-- LED On/Off Graph -->
                <div style="margin-bottom: 15px;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 6px;">
                        <span id="graph-title-led" style="font-weight: bold; font-size: 12px; color: #333;">LED
                            On/Off</span>
                        <div style="flex: 1;"></div>
                        <span style="display: flex; align-items: center; gap: 4px; font-size: 10px;"><span
                                style="width: 8px; height: 8px; background: #ff4444; border-radius: 2px;"></span>
                            <span id="legend-led-red">Red LED</span></span>
                        <span style="display: flex; align-items: center; gap: 4px; font-size: 10px;"><span
                                style="width: 8px; height: 8px; background: #44bb44; border-radius: 2px;"></span>
                            <span id="legend-led-green">Green LED</span></span>
                        <span style="display: flex; align-items: center; gap: 4px; font-size: 10px;"><span
                                style="width: 8px; height: 8px; background: #4488ff; border-radius: 2px;"></span>
                            <span id="legend-led-blue">Blue LED</span></span>
                    </div>
                    <div
                        style="background: #fafafa; border: 1px solid #eee; border-radius: 8px; padding: 10px; position: relative;">
                        <canvas id="ledGraphCanvas" width="620" height="60"
                            style="width: 100%; max-width: 620px; cursor: crosshair;"></canvas>
                        <div id="graphSelectionOverlay"
                            style="position: absolute; top: 10px; height: 60px; background: rgba(76, 151, 255, 0.2); border: 1px solid #4C97FF; display: none; pointer-events: none;">
                        </div>
                    </div>
                </div>

                <!-- Numbers Graph -->
                <div style="margin-bottom: 10px;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 6px;">
                        <span id="graph-title-numbers"
                            style="font-weight: bold; font-size: 12px; color: #333;">Numbers</span>
                        <div style="flex: 1;"></div>
                        <span style="display: flex; align-items: center; gap: 4px; font-size: 10px;"><span
                                style="width: 8px; height: 8px; background: #ff4444; border-radius: 2px;"></span>
                            <span id="legend-num-red">Red</span></span>
                        <span style="display: flex; align-items: center; gap: 4px; font-size: 10px;"><span
                                style="width: 8px; height: 8px; background: #44bb44; border-radius: 2px;"></span>
                            <span id="legend-num-green">Green</span></span>
                        <span style="display: flex; align-items: center; gap: 4px; font-size: 10px;"><span
                                style="width: 8px; height: 8px; background: #4488ff; border-radius: 2px;"></span>
                            <span id="legend-num-blue">Blue</span></span>
                    </div>
                    <div
                        style="background: #fafafa; border: 1px solid #eee; border-radius: 8px; padding: 10px; position: relative;">
                        <canvas id="numbersGraphCanvas" width="620" height="120"
                            style="width: 100%; max-width: 620px; cursor: crosshair;"></canvas>
                        <div id="numbersSelectionOverlay"
                            style="position: absolute; top: 10px; height: 120px; background: rgba(76, 151, 255, 0.2); border: 1px solid #4C97FF; display: none; pointer-events: none;">
                        </div>
                    </div>
                </div>

                <!-- Buttons Graph -->
                <div style="margin-bottom: 15px;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 6px;">
                        <span id="graph-title-buttons"
                            style="font-weight: bold; font-size: 12px; color: #333;">Buttons</span>
                        <div style="flex: 1;"></div>
                        <span style="display: flex; align-items: center; gap: 4px; font-size: 10px;"><span
                                style="width: 8px; height: 8px; background: #E74C3C; border-radius: 2px;"></span>
                            <span id="legend-btn-red">Red</span></span>
                        <span style="display: flex; align-items: center; gap: 4px; font-size: 10px;"><span
                                style="width: 8px; height: 8px; background: #2ECC71; border-radius: 2px;"></span>
                            <span id="legend-btn-green">Green</span></span>
                        <span style="display: flex; align-items: center; gap: 4px; font-size: 10px;"><span
                                style="width: 8px; height: 8px; background: #3498DB; border-radius: 2px;"></span>
                            <span id="legend-btn-blue">Blue</span></span>
                    </div>
                    <div
                        style="background: #fafafa; border: 1px solid #eee; border-radius: 8px; padding: 10px; position: relative;">
                        <canvas id="buttonsGraphCanvas" width="620" height="60"
                            style="width: 100%; max-width: 620px; cursor: crosshair;"></canvas>
                        <div id="buttonsSelectionOverlay"
                            style="position: absolute; top: 10px; height: 60px; background: rgba(76, 151, 255, 0.2); border: 1px solid #4C97FF; display: none; pointer-events: none;">
                        </div>
                    </div>
                </div>
                <!-- Shared Time Labels -->
                <div
                    style="display: flex; justify-content: space-between; font-size: 11px; color: #666; margin-top: 4px; padding: 0 10px;">
                    <span id="graphTimeStart">--:--:--</span>
                    <span id="graphTimeEnd">--:--:--</span>
                </div>
                <div id="graphStatus" style="text-align: center; color: #999; font-size: 12px; margin-top: 6px;">Son
                    1
                    saat gösteriliyor</div>
            </div>
        </div>
    </div>

    <div class="code-modal" id="deviceModal">
        <div class="code-content" style="max-width: 800px;">
            <div class="code-header">
                <h2 id="deviceModalTitle">📱 Bluetooth Cihaz Yönetimi</h2>
                <button class="close-btn" onclick="closeDeviceModal()">×</button>
            </div>

            <div style="display: flex; gap: 15px; margin-bottom: 25px; align-items: stretch;">
                <!-- Modernized Add Specific Device Button (Prominent Green, Left, Wide) -->
                <button class="copy-btn" id="addSpecificBtn" onclick="openSpecificDeviceModal()"
                    style="flex: 4; margin: 0; background-color: #10b981; color: white; padding: 20px; font-size: 18px; border-radius: 12px; box-shadow: 0 4px 10px rgba(16, 185, 129, 0.3); transition: transform 0.2s, box-shadow 0.2s; display: flex; align-items: center; justify-content: center; gap: 10px; border: none;"
                    onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 15px rgba(16, 185, 129, 0.4)'"
                    onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 10px rgba(16, 185, 129, 0.3)'">
                    <span style="font-size: 24px;">➕</span> <span style="font-weight: 600;">Özel Cihaz Ekle</span>
                </button>

                <!-- Modernized Scan Button (Secondary Orange, Right, Narrow) -->
                <button class="copy-btn" id="scanDeviceBtn" onclick="scanAndConnect()"
                    style="flex: 1; margin: 0; background-color: #f59e0b; color: white; padding: 10px; font-size: 14px; border-radius: 12px; box-shadow: 0 2px 5px rgba(245, 158, 11, 0.2); transition: all 0.2s; border: none; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 5px; opacity: 0.9;"
                    onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.9'">
                    <span style="font-size: 22px;">🔍</span>
                    <span style="font-size: 11px; text-align: center; line-height: 1.2; font-weight: 500;">Tara
                        &<br>Bağlan</span>
                </button>
            </div>

            <div
                style="background: white; border-radius: 8px; border: 2px solid #e0e0e0; overflow: hidden; margin-bottom: 20px;">
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: #4C97FF; color: white;">
                            <th id="thDeviceName" style="padding: 12px; text-align: left; font-size: 14px;">Cihaz
                                Adı
                            </th>
                            <th id="thDeviceId" style="padding: 12px; text-align: left; font-size: 14px;">Cihaz ID
                            </th>
                            <th id="thDeviceStatus" style="padding: 12px; text-align: center; font-size: 14px;">
                                Durum
                            </th>
                            <th id="thDeviceAction" style="padding: 12px; text-align: center; font-size: 14px;">
                                İşlem
                            </th>
                        </tr>
                    </thead>
                    <tbody id="devicesTableBody">
                        <tr>
                            <td id="noDeviceMsg" colspan="4" style="padding: 30px; text-align: center; color: #999;">
                                Henüz bağlı cihaz yok. "Yeni Cihaz Ara & Bağlan" butonuna tıklayın.
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div id="scanStatus"
                style="display: none; background: #f0f0f0; padding: 15px; border-radius: 8px; margin-bottom: 20px; text-align: center; font-size: 14px;">
                🔍 Tarama yapılıyor...
            </div>
        </div>
    </div>

    <!-- Specific Device Selection Modal -->
    <div class="code-modal" id="specificDeviceModal" style="z-index: 10000;" onclick="closeSpecificDeviceModal()">
        <div class="code-content" style="max-width: 700px; z-index: 10001;" onclick="event.stopPropagation()">
            <div class="code-header">
                <h2 id="specificModalTitle">Cihaz Tipi Seçin</h2>
                <button class="close-btn" onclick="closeSpecificDeviceModal()">×</button>
            </div>
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; padding: 20px;">
                <div onclick="scanSpecificDevice('controller')"
                    style="cursor: pointer; padding: 20px; border: 2px solid #ddd; border-radius: 12px; text-align: center; transition: all 0.2s; background: white;"
                    onmouseover="this.style.background='#f5f5f5'; this.style.borderColor='#4C97FF'"
                    onmouseout="this.style.background='white'; this.style.borderColor='#ddd'">
                    <img src="img/controller.png" alt="Controller"
                        style="width: 80px; height: 80px; object-fit: contain; margin-bottom: 10px;">
                    <div id="specificLabelController" style="font-weight: bold; font-size: 16px;">Controller</div>
                </div>
                <div onclick="scanSpecificDevice('single_motor')"
                    style="cursor: pointer; padding: 20px; border: 2px solid #ddd; border-radius: 12px; text-align: center; transition: all 0.2s; background: white;"
                    onmouseover="this.style.background='#f5f5f5'; this.style.borderColor='#4C97FF'"
                    onmouseout="this.style.background='white'; this.style.borderColor='#ddd'">
                    <img src="img/single-motor.png" alt="Single Motor"
                        style="width: 80px; height: 80px; object-fit: contain; margin-bottom: 10px;">
                    <div id="specificLabelSingleMotor" style="font-weight: bold; font-size: 16px;">Single Motor
                    </div>
                </div>
                <div onclick="scanSpecificDevice('double_motor')"
                    style="cursor: pointer; padding: 20px; border: 2px solid #ddd; border-radius: 12px; text-align: center; transition: all 0.2s; background: white;"
                    onmouseover="this.style.background='#f5f5f5'; this.style.borderColor='#4C97FF'"
                    onmouseout="this.style.background='white'; this.style.borderColor='#ddd'">
                    <img src="img/double-motor.png" alt="Double Motor"
                        style="width: 80px; height: 80px; object-fit: contain; margin-bottom: 10px;">
                    <div id="specificLabelDoubleMotor" style="font-weight: bold; font-size: 16px;">Double Motor
                    </div>
                </div>
                <div onclick="scanSpecificDevice('color_sensor')"
                    style="cursor: pointer; padding: 20px; border: 2px solid #ddd; border-radius: 12px; text-align: center; transition: all 0.2s; background: white;"
                    onmouseover="this.style.background='#f5f5f5'; this.style.borderColor='#9B59B6'"
                    onmouseout="this.style.background='white'; this.style.borderColor='#ddd'">
                    <img src="img/color-sensor.png" alt="Color Sensor"
                        style="width: 80px; height: 80px; object-fit: contain; margin-bottom: 10px;">
                    <div id="specificLabelColorSensor" style="font-weight: bold; font-size: 16px;">Color Sensor
                    </div>
                </div>
                <div onclick="scanSpecificDevice('spike_essential')"
                    style="cursor: pointer; padding: 20px; border: 2px solid #ddd; border-radius: 12px; text-align: center; transition: all 0.2s; background: white;"
                    onmouseover="this.style.background='#f5f5f5'; this.style.borderColor='#F5A623'"
                    onmouseout="this.style.background='white'; this.style.borderColor='#ddd'">
                    <img src="img/spike_essential_icon.png" alt="Essential Hub"
                        style="width: 80px; height: 80px; object-fit: contain; margin-bottom: 10px;">
                    <div id="specificLabelEssentialHub" style="font-weight: bold; font-size: 16px;">Essential Hub
                    </div>
                </div>
                <div onclick="scanSpecificDevice('spike_prime')"
                    style="cursor: pointer; padding: 20px; border: 2px solid #ddd; border-radius: 12px; text-align: center; transition: all 0.2s; background: white;"
                    onmouseover="this.style.background='#f5f5f5'; this.style.borderColor='#F5A623'"
                    onmouseout="this.style.background='white'; this.style.borderColor='#ddd'">
                    <img src="img/spike_prime_icon.png" alt="Prime Hub"
                        style="width: 80px; height: 80px; object-fit: contain; margin-bottom: 10px;">
                    <div id="specificLabelPrimeHub" style="font-weight: bold; font-size: 16px;">Prime Hub</div>
                </div>
                <div onclick="scanSpecificDevice('technic_medium_hub')"
                    style="cursor: pointer; padding: 20px; border: 2px solid #ddd; border-radius: 12px; text-align: center; transition: all 0.2s; background: white;"
                    onmouseover="this.style.background='#f5f5f5'; this.style.borderColor='#27AE60'"
                    onmouseout="this.style.background='white'; this.style.borderColor='#ddd'">
                    <img src="img/technic-hub.png" alt="Technic Hub"
                        style="width: 80px; height: 80px; object-fit: contain; margin-bottom: 10px;">
                    <div id="specificLabelTechnicHub" style="font-weight: bold; font-size: 16px;">Technic Hub</div>
                </div>
                <div onclick="scanSpecificDevice('city_hub')"
                    style="cursor: pointer; padding: 20px; border: 2px solid #ddd; border-radius: 12px; text-align: center; transition: all 0.2s; background: white;"
                    onmouseover="this.style.background='#f5f5f5'; this.style.borderColor='#3498DB'"
                    onmouseout="this.style.background='white'; this.style.borderColor='#ddd'">
                    <img src="img/city-hub.png" alt="City Hub"
                        style="width: 80px; height: 80px; object-fit: contain; margin-bottom: 10px;">
                    <div id="specificLabelCityHub" style="font-weight: bold; font-size: 16px;">City Hub</div>
                </div>
                <div onclick="scanSpecificDevice('boost_move_hub')"
                    style="cursor: pointer; padding: 20px; border: 2px solid #ddd; border-radius: 12px; text-align: center; transition: all 0.2s; background: white;"
                    onmouseover="this.style.background='#f5f5f5'; this.style.borderColor='#E74C3C'"
                    onmouseout="this.style.background='white'; this.style.borderColor='#ddd'">
                    <img src="img/boost-hub.png" alt="Boost Move Hub"
                        style="width: 80px; height: 80px; object-fit: contain; margin-bottom: 10px;">
                    <div id="specificLabelBoostHub" style="font-weight: bold; font-size: 16px;">Boost Move Hub</div>
                </div>
                <div onclick="scanSpecificDevice('remote_controller')"
                    style="cursor: pointer; padding: 20px; border: 2px solid #ddd; border-radius: 12px; text-align: center; transition: all 0.2s; background: white;"
                    onmouseover="this.style.background='#f5f5f5'; this.style.borderColor='#00A3DA'"
                    onmouseout="this.style.background='white'; this.style.borderColor='#ddd'">
                    <img src="img/remote_controller_icon.png" alt="Remote Controller"
                        style="width: 80px; height: 80px; object-fit: contain; margin-bottom: 10px;">
                    <div id="specificLabelRemoteController" style="font-weight: bold; font-size: 16px;">Remote
                        Controller</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let workspace;
        let currentNumberField = null;
        let currentValue = 1;
        let minValue = 1;
        let maxValue = 100;
        let messages = ['message1', 'message2']; // Varsayılan mesajlar
        let currentMessageField = null;
        let currentMessageBlock = null;
        let isToolboxVisible = false;
        let currentToolboxDevice = null;

        // RGB kontrol değişkenleri
        let rgbLedState = { red: false, green: false, blue: false };
        let rgbNumberState = { red: 0, green: 0, blue: 0 };

        // Açı seçici değişkenleri
        let currentAngleField = null;
        let currentAngle = 0;

        // Motor işlem kilidi - aynı anda sadece bir motor işlemi yapılabilir
        let motorOperationInProgress = false;

        // Görsel güncelleme throttle - 100ms'de bir güncelle
        let lastVisualUpdate = 0;
        const VISUAL_UPDATE_INTERVAL = 100;

        // Controller state tracking
        let controllerState = {
            left: 'RELEASED',  // UP, DOWN, RELEASED
            right: 'RELEASED',
            leftValue: 0,
            rightValue: 0,
            leftPercent: 50,   // 0-100 arası yüzdelik değer
            rightPercent: 50   // 0-100 arası yüzdelik değer
        };

        // Color Sensor state tracking
        let colorSensorState = {
            detectedColor: 'NONE',   // RED, YELLOW, GREEN, BLUE, PURPLE, ORANGE, BLACK, WHITE, CYAN, NONE
            colorIndex: -1,          // Renk indeksi (0-9)
            reflection: 0,           // Yansıma değeri (0-100)
            hue: 0,                  // Renk tonu (0-360)
            saturation: 0,           // Doygunluk (0-100)
            value: 0,                // Parlaklık (0-100)
            red: 0,                  // RGB kırmızı (0-255)
            green: 0,                // RGB yeşil (0-255)
            blue: 0,                 // RGB mavi (0-255)
            deviceId: null           // Hangi cihaza ait
        };

        // Remote Controller (88010) state tracking
        // LWP3 protocol - Device Type 0x42
        // Button values: Plus=1, Minus=255(-1 signed), Red/Stop=127, Released=0
        let remoteControllerState = {
            leftButton: 'RELEASED',   // PLUS, MINUS, RED, RELEASED
            rightButton: 'RELEASED',  // PLUS, MINUS, RED, RELEASED
            leftValue: 0,             // Raw byte value (0, 1, 127, 255)
            rightValue: 0,            // Raw byte value (0, 1, 127, 255)
            greenButton: false,       // Center green button state
            deviceId: null            // Which device this belongs to
        };

        // Color name mapping (Gerçek cihaz verilerinden - Index 7)
        const COLOR_INDEX_MAP = {
            0: 'NONE',      // No color / Renk yok
            2: 'PURPLE',    // Mor
            3: 'BLUE',      // Mavi
            5: 'CYAN',      // Açık Mavi / Cyan  
            6: 'GREEN',     // Yeşil
            7: 'YELLOW',    // Sarı
            9: 'RED',       // Kırmızı
            10: 'WHITE',    // Beyaz (0x0a)
            0xff: 'NONE',   // ff = Renk yok
            255: 'NONE'     // Alternate no color / Unknown
        };

        // Motor state tracking (PCAP analizinden: Index 8-9 = anlık açı, Index 13-14 = hedef açı)
        let motorState = {
            currentAngle: 0,      // Anlık motor açısı (derece)
            targetAngle: 0,       // Hedef açı
            mode: 0,              // Mode byte (0x00=idle, 0x01=moving, 0x07=holding)
            isMoving: false,      // Motor hareket halinde mi
            deviceId: null        // Hangi cihaza ait
        };

        // Double Motor state tracking (PCAP analizinden: 59 byte mesaj)
        // Kısa mesaj (17 byte): Byte 7 = batarya yüzdesi
        // Uzun mesaj (59 byte): Byte 32-35 = Motor 1 pozisyon (int32 LE), Byte 44-47 = Motor 2 pozisyon (int32 LE)
        let doubleMotorState = {
            motor1Angle: 0,       // Motor 1 açısı (derece) - Port 0
            motor2Angle: 0,       // Motor 2 açısı (derece) - Port 1
            battery: 0,           // Batarya yüzdesi
            deviceId: null        // Hangi cihaza ait
        };

        // Double Motor monitoring değişkenleri
        let doubleMotorMonitoringActive = false;
        let activeDoubleMotorDevice = null;
        let activeDoubleMotorCharacteristic = null;
        let doubleMotorLastVisualUpdate = 0;

        // Motor monitoring değişkenleri
        let motorMonitoringActive = false;
        let activeMotorDevice = null;
        let activeMotorCharacteristic = null;
        let motorLastVisualUpdate = 0;
        const MOTOR_VISUAL_UPDATE_INTERVAL = 50; // 50ms'de bir güncelle (daha akıcı animasyon)

        // --- ICONS (Simple White SVGs) ---
        const ICON_START = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMTQuNCA2TDE0IDRINXYxN2gydi03aDUuNmwuNCAyaDdWNnoiIGZpbGw9IiM0Q0M5NzAiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIxLjUiLz48L3N2Zz4='; // Green Flag with white outline
        const ICON_BOLT = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNNyAydjExaDN2OWw3LTEyaC00bDQtOHoiLz48L3N2Zz4=';
        const ICON_MSG_IN = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNMjAgNEg0Yy0xLjEgMC0xLjk5LjktMS45OSAyTDIgMThjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY2YzAtMS4xLS45LTItMi0yem0wIDRsLTggNS04LTVWNmw4IDUgOC01djJ6Ii8+PC9zdmc+';
        const ICON_MSG_OUT = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNOSAxNmg2di02aDRsLTctNy03IDdoNHptLTQgMmgxNHYySDV6Ii8+PC9zdmc+';
        const ICON_CLOCK = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNMTIgMkM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptMCAxOGMtNC40MSAwLTgtMy41OS04LThzMy41OS04IDgtOHw4IDMuNTkgOCA4LTMuNTkgOC04IDh6bS41LTExSDExdjZsNS4yIDMuMi44LTEuMy00LjUtMi41ek03IDEyYzAgMi43NiAyLjI0IDUgNSA1czUtMi4yNCA1LTVIN3oiLz48L3N2Zz4='; // Hand/Stop-like icon (using a simplified pause/stop metaphor or just keeping clock but trying to make it look like "duration" or "stop"). Actually user asked for "durma veya stop", so let's use a Hand (Pause/Stop) icon.
        // Better "Stop"/"Hand" icon for Wait:
        const ICON_STOP_HAND = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNMTIgMkM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptLTEgMTRoLTJ2LTZoMnY2em00IDBoLTJ2LTZoMnY2eiIvPjwvc3ZnPg=='; // Pause/Stop circle

        const ICON_LOOP = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNNy41IDE4QTMuNSAzLjUgMCAwIDEgNCAxNC41VjUuNWw0LjIgMi44YTMuNSAzLjUgMCAwIDEgNC4yIDIuOGw2LTUuNkEzLjUgMy41IDAgMCAwIDIwIDUuNUgxNlYyaC0ydjZIMjJ2LTJtLTIgMTMuMkEzLjUgMy41IDAgMCAwIDE2IDE4LjVIMjJWMjJoLTJ2LTZIMTZ2MiIvPjwvc3ZnPg=='; // Trying to find a visually simpler "refresh" or "repeat" icon. Let's use standard Material refresh.
        const ICON_REFRESH = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNMTcuNjUgNi4zNUMxNi4yIDQuOSAxNC4yMSA0IDEyIDRjLTQuNDIgMC03Ljk5IDMuNTgtNy45OSA4czMuNTcgOCA3Ljk5IDhjMy43MyAwIDYuODQtMi41NSA3LjczLTYtMmgtMi4wOGMtLjgyIDIuMzMtMy4wNCA0LTUuNjUgNC0zLjMxIDAtNi0yLjY5LTYtNnMvbS42OS02IDYtNmMgMS42NiAwIDMuMTQuNjkgNC4yMiAxLjc4TDEzIDExaDdWNWwtMi4zNSAyLjM1eiIvPjwvc3ZnPg==';

        const ICON_INFINITY = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNMTguNiA2LjYyYy0xLjQ0IDAtMi44LjU2LTMuNzcgMS41M0wxMiAxMC42NiA5LjE3IDguMTVjLS45Ny0uOTctMi4zMy0xLjUzLTMuNzctMS41My0yLjk0IDAtNS4zMyAyLjM4LTUuMzMyIDUuMzE1UzIuNCAxNy4yNSA1LjQgMTcuMjVjMS40NCAwIDIuOC0uNTYgMy43Ny0xLjUzTDEyIDEzLjM0bDguMDMgOC4wM2MuOTcuOTcgMi41MyAxLjUzIDMuNzcgMS41MyAyLjk0IDAgNS4zMy0yLjM5IDUuMzMtNS4zMyAwLTIuOTMtMi4zOS01LjMzLTUuMzMtNS4zM3ptMCA4LjU1Yy0uNTEgMC0xLjAxLS4yLTEuMzktLjU5TDEyIDEwLjAybDguNDEgOC40MWMtLjM4LjM5LS44OC41OS0xLjQxLjU5em0tOS45Ni05LjgyYy41MSAwIDEuMDEuMiAxLjM5LjU5TDEyIDEwLjM0bC0yLjI5IDIuMjlMOC42NCA5LjY1Yy0uMzgtLjM5LS44OS0uNTktMS40MS0uNTktMS45NiAwLTMuNTUgMS41OS0zLjU1IDMuNTUgMCAxLjk2IDEuNTkgMy41NSAzLjU1IDMuNTUuNTEgMCAxLjAxLS4yIDEuMzktLjU5bDMuMTItMy4xMi01LjEzLTUuMTNjLjM4LS40Mi44OS0uNjMgMS40MS0uNjN6Ii8+PC9zdmc+';
        const ICON_DIAMOND = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNOS4xNyA2bDItMmMyIC44MiAyLjgyIDEuNjQgNC44MyAzLjY0bDMuNjQgNC44M2MtLjgyIDItMS42NCAyLjgyLTMuNjQgNC44M2wtMiAyLTIgLTIgLTMuNjMtNC44M2MuODItMiAxLjY0LTIuODIgMy42My00Ljgzek0xMiAyTDQgMTJsOCAxMCA4LTEwTDExIDJ6Ii8+PHBhdGggZD0iTTE5IDNsLTUgNWgydi00bDQtNGg2eSgiIHRyYW5zZm9ybT0icm90YXRlKDQ1IDEyIDEyKSIvPjwvc3ZnPg=='; // Generic Diamond for Logic, replaced with a filled rhombus or similar if needed. Using a simple rhombus here:
        const ICON_COND_TRUE = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNMTkgM0g1Yy0xLjEgMC0yIC45LTIgMnYxNGMwIDEuMS45IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6bTAgMTZINVY1aDE0djE0em0tNy0yaC0ydi01aDVsLTEgMWg0bC02LTZ6Ii8+PC9zdmc+'; // Placeholder if needed, but let's use a simple diamond shape for logic conditions.
        const ICON_RHOMBUS = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNMTIgMkwyIDEybDEwIDEwIDEwLTEwTDExIDJ6Ii8+PC9zdmc+';
        const ICON_HOURGLASS = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48cGF0aCBkPSJNNiAydjZoLjAxTCA2IDguMDFWMTBsNiA2IDYgNnYybC4wMSAySDZ2NmgxMnYtNmgtLjAxTDE4IDE2di0ybC02LTYgNi02VjZMNT44di02aC0uMDFMNiAyeiIvPjwvc3ZnPg==';

        // Colored Square Icons for RGB blocks (Red, Green, Blue) - No gradients, solid colors.
        // Using slight shadow/bevel effect for "button" look if desired, or flat. User said "kare şeklinde ikonlar".
        const ICON_SQUARE_RED = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IjBmaWxsPSIjRkYwMDAwIj48cmVjdCB4PSI0IiB5PSI0IiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHJ4PSIyIiByeT0iMiIgLz48L3N2Zz4='; // #FF0000 Rounded Rect
        const ICON_SQUARE_GREEN = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IjBmaWxsPSIjMDBGRjAwIj48cmVjdCB4PSI0IiB5PSI0IiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHJ4PSIyIiByeT0iMiIgLz48L3N2Zz4='; // #00FF00
        const ICON_SQUARE_BLUE = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IjBmaWxsPSIjMDAwMEZGIj48cmVjdCB4PSI0IiB5PSI0IiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHJ4PSIyIiByeT0iMiIgLz48L3N2Zz4='; // #0000FF

        // Updating with specific colors requested normally found in blocks (e.g. Red #FF3333, etc) or just pure RGB.
        // Let's use darker shades to stand out on pastel blocks if necessary, or vivid standard colors.
        // Red: #D32F2F, Green: #388E3C, Blue: #1976D2
        const ICON_SQ_RED = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRDMyRjJGIj48cmVjdCB4PSI0IiB5PSI0IiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHJ4PSI0IiByeT0iNCIgLz48L3N2Zz4=';
        const ICON_SQ_GREEN = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjMzg4RTNDIj48cmVjdCB4PSI0IiB5PSI0IiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHJ4PSI0IiByeT0iNCIgLz48L3N2Zz4=';
        const ICON_SQ_BLUE = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjMTk3NkQyIj48cmVjdCB4PSI0IiB5PSI0IiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHJ4PSI0IiByeT0iNCIgLz48L3N2Zz4=';

        // Solid Colored Circle Icons (Red, Green, Blue) - No gradient
        const ICON_CIRCLE_RED = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkYwMDAwIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI4IiAvPjwvc3ZnPg==';
        const ICON_CIRCLE_GREEN = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjMDBGRjAwIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI4IiAvPjwvc3ZnPg==';
        const ICON_CIRCLE_BLUE = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjMDAwMEZGIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI4IiAvPjwvc3ZnPg==';

        // Using specific darker shades if preferred for better contrast on blocks
        const ICON_CIRC_RED = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRDMyRjJGIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI3IiAvPjwvc3ZnPg==';
        const ICON_CIRC_GREEN = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjMzg4RTNDIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI3IiAvPjwvc3ZnPg==';
        const ICON_CIRC_BLUE = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjMTk3NkQyIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI3IiAvPjwvc3ZnPg==';
        // White circle for "Off" state (same size as On state)
        const ICON_CIRC_WHITE = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZGRkZGIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI3IiAvPjwvc3ZnPg==';

        // Color Sensor Icon
        const ICON_COLOR_SENSOR = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI4IiBmaWxsPSIjZmZmIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMiIvPjxjaXJjbGUgY3g9IjEyIiBjeT0iOCIgcj0iMi41IiBmaWxsPSIjZmYwMDAwIi8+PGNpcmNsZSBjeD0iOCIgY3k9IjE0IiByPSIyLjUiIGZpbGw9IiMwMGZmMDAiLz48Y2lyY2xlIGN4PSIxNiIgY3k9IjE0IiByPSIyLjUiIGZpbGw9IiMwMDAwZmYiLz48L3N2Zz4=';
        // Yellow circle for color sensor blocks
        const ICON_CIRC_YELLOW = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkZEOTAwIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI3IiAvPjwvc3ZnPg==';
        // Orange circle
        const ICON_CIRC_ORANGE = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjRkY5ODAwIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI3IiAvPjwvc3ZnPg==';
        // Cyan circle
        const ICON_CIRC_CYAN = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjMDBCQ0Q0Ij48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI3IiAvPjwvc3ZnPg==';
        // Purple/Violet circle
        const ICON_CIRC_PURPLE = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjOUIyN0IwIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI3IiAvPjwvc3ZnPg==';
        // Black circle
        const ICON_CIRC_BLACK = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBmaWxsPSIjMjEyMTIxIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI3IiAvPjwvc3ZnPg==';


        let controllerMonitoring = null;  // Interval ID for monitoring
        let activeControllerDevice = null; // Aktif controller cihazı
        let activeControllerCharacteristic = null; // DEBUG için
        let controllerPingInterval = null; // Periyodik ping için

        // DEBUG: Manuel test fonksiyonu
        window.testControllerCharacteristic = async function () {
            console.log('🧪 Controller characteristic test başlatılıyor...');

            if (!activeControllerCharacteristic) {
                console.log('❌ activeControllerCharacteristic yok!');
                return;
            }
        };

        // --- VISUAL FIXES ---
        // Safely style Number Fields without breaking Dropdowns
        if (typeof Blockly !== 'undefined') {
            // 1. Add a specific class to Number Fields during initialization
            const originalInitView = Blockly.FieldNumber.prototype.initView;
            Blockly.FieldNumber.prototype.initView = function () {
                originalInitView.call(this);
                if (this.fieldGroup_) {
                    Blockly.utils.dom.addClass(this.fieldGroup_, 'number-field-styled');
                }
            };

            // 2. Add padding to single digits to make them look like circles/pills
            const originalGetText = Blockly.FieldNumber.prototype.getText;
            Blockly.FieldNumber.prototype.getText = function () {
                const text = originalGetText.call(this);
                if (text && text.length === 1) {
                    return ' ' + text + ' '; // Add spaces for visual centering
                }
                return text;
            };
        }

        // --- LANGUAGE SUPPORT ---
        let currentLanguage = 'tr';

        const TRANSLATIONS = {
            tr: {
                lang: "TR",
                import: "İçe Aktar (Import)",
                export: "Dışa Aktar (Export)",
                reset: "Sıfırla",
                run: "Kodu Çalıştır",
                add_device: "Cihaz Ekle",

                start_tooltip: "Başlangıç",
                control_tooltip: "Kontrol",
                led_tooltip: "LED Kontrol",
                num_tooltip: "Sayı Kontrol",
                btn_tooltip: "Tuş Kontrol",
                op_tooltip: "Operatörler",
                zoom_in: "Yakınlaştır",
                zoom_out: "Uzaklaştır",
                reset_view: "Görünümü Ortala",

                block_random_pre: " rastgele sayı  ",
                block_random_mid: " ile ",
                delete_block: "Bloğu Sil",

                modal_reset_title: "Her şeyi sıfırlamak istediğinize emin misiniz?",
                modal_reset_list: "RGB paneli sıfırlanacak|Tüm LED'ler sönecek|Sayı değerleri 0 olacak|Cihazlar bağlı kalacak",
                btn_cancel: "İptal",
                btn_reset: "Sıfırla",

                block_wait_pre: "⏱️ ",
                block_wait_post: " saniye bekle  ",
                block_repeat_pre: "🔄 ",
                block_repeat_post: " kez tekrarla  ",
                block_forever: "♾️ sürekli tekrarla  ",
                block_if: "🔶 eğer",
                block_then: "ise  ",
                block_then: "ise  ",
                block_else: "değilse  ",
                block_wait_until_pre: "⏳ ",
                block_start: "play tıklandığında  ",

                block_wait_pre: " ",
                block_wait_post: " saniye bekle  ",
                block_repeat_pre: " ",
                block_repeat_post: " kez tekrarla  ",
                block_forever: " sürekli tekrarla  ",
                block_if: " eğer",
                block_then: "ise  ",
                block_then: "ise  ",
                block_else: "değilse  ",
                block_wait_until_pre: " ",
                block_wait_until_post: " olana kadar bekle  ",
                block_repeat_until_pre: " ",
                block_repeat_until_post: " olana kadar tekrarla  ",

                block_when_pre: "olduğunda  ",
                block_when_post: "  ",
                block_message_pre: "alındığında  ",
                block_message_post: "  ",
                block_send_mobile_pre: "gönder  ",
                block_send_mobile_post: "  ",

                block_light_get_pre: " ",
                block_light_get_post: " ışık getir  ",

                block_red_light_on: "  kırmızı ışık yak    ",
                block_red_light_off: "  kırmızı ışık söndür    ",
                block_green_light_on: "  yeşil ışık yak    ",
                block_green_light_off: "  yeşil ışık söndür    ",
                block_blue_light_on: "  mavi ışık yak    ",
                block_blue_light_off: "  mavi ışık söndür    ",

                block_red_num: "  kırmızı sayı yap  ",
                block_green_num: "  yeşil sayı yap  ",
                block_blue_num: "  mavi sayı yap  ",
                block_red_get: "  kırmızı sayı öğren  ",
                block_green_get: "  yeşil sayı öğren  ",
                block_blue_get: "  mavi sayı öğren  ",

                block_rgb_red_btn_get: " tuş getir  ",
                block_rgb_green_btn_get: " tuş getir  ",
                block_rgb_blue_btn_get: " tuş getir  ",

                block_logic_and: " ve ",
                block_logic_or: " veya ",
                block_logic_not: "değil ",

                panel_leds: "LEDler",
                panel_numbers: "Sayılar",
                panel_buttons: "Butonlar",
                legend_red: "Kırmızı",
                legend_green: "Yeşil",
                legend_blue: "Mavi",

                // Hub & Device Blocks
                block_set_hub_led: "hub ışığını ayarla",
                block_hub_is: "hub",
                block_hub_up: "yüzü yukarı dönük mü?",
                block_matrix_off: "tüm pikselleri söndür",
                block_matrix_on: "deseni yak",
                block_matrix_brightness: "parlaklık seviyesini",
                block_matrix_pixel_at: "pikseli ayarla: x",
                block_matrix_to: "rengi",
                block_matrix_at: "parlaklığı",
                block_matrix_rotate: "deseni döndür",
                block_force_is: "kuvvet sensörü",
                block_force_pressure: "basınç değeri",
                block_distance_is: "mesafe",
                block_distance_value: "mesafe değeri",
                block_color_is: "rengi",
                block_color_value: "renk değeri",
                block_lever_when: "kol",
                block_lever_is: "konumu",
                block_lever_angle: "kol açısı",

                confirm_reset: "Her şeyi sıfırlamak istediğinize emin misiniz?", // Deprecated but kept for safety
                alert_no_play: "❌ Play bloğu bulunamadı!\n\n\"🚩 play tıklandığında\" bloğunu ekleyin.",
                alert_stopped: "⏹️ Durduruldu!",
                alert_import_error: "Dosya yüklenirken bir hata oluştu! Geçerli bir XML dosyası seçtiğinizden emin olun.",
                alert_export_error: "Dışa aktarma sırasında bir hata oluştu!",
                confirm_import: "Mevcut çalışma alanı temizlenip, dosya yüklensin mi?\n(İptal derseniz mevcut blokların üzerine eklenir)",

                scan_btn: "🔍 Yeni Cihaz Ara & Bağlan",
                tbl_name: "Cihaz Adı",
                tbl_id: "Cihaz ID",
                tbl_status: "Durum",
                tbl_action: "İşlem",
                no_device: "Henüz bağlı cihaz yok. \"Yeni Cihaz Ara & Bağlan\" butonuna tıklayın.",
                scan_status: "🔍 Tarama yapılıyor...",
                status_connected: "Bağlı",
                status_disconnected: "Kesildi",
                btn_remove: "Kaldır",
                confirm_remove_device: "Bu cihazı kaldırmak istediğinize emin misiniz?",
                connecting_to: "📱 Bağlanıyor:",
                connected_to: "✅ Bağlandı:",
                device_added: "✅ Cihaz eklendi!",
                unknown_device: "Bilinmeyen",
                device_list_opening: "🔍 Cihaz listesi açılıyor...",
                modal_title: "📱 Bluetooth Cihaz Yönetimi",
                add_specific_btn: "➕ Özel Cihaz Ekle",
                specific_modal_title: "Cihaz Tipi Seçin",
                specific_type_controller: "Controller",
                specific_type_single_motor: "Single Motor",
                specific_type_remote_controller: "Remote Controller",
                coming_soon: "Yakında",
                block_set_remote_led: "LED rengini",
                remote_left_plus: "sol +",
                remote_left_minus: "sol -",
                remote_left_red: "sol kırmızı",
                remote_right_plus: "sağ +",
                remote_right_minus: "sağ -",
                remote_right_red: "sağ kırmızı",
                remote_pressed: "basılı",
                remote_released: "bırakılmış",
                block_remote_is: " ",
                block_remote_qm: "mı?",

                // Graphs Tab
                graphs_tab: "Grafikler",
                graph_refresh: "Yenile",
                graph_cancel_zoom: "Zoom İptal",
                graph_led_title: "LED Açık/Kapalı",
                graph_numbers_title: "Sayılar",
                led_red: "Kırmızı LED",
                led_green: "Yeşil LED",
                led_blue: "Mavi LED",
                val_red: "Kırmızı",
                val_green: "Yeşil",
                val_blue: "Mavi"
            },
            en: {
                lang: "EN",
                import: "Import",
                export: "Export",
                reset: "Reset",
                run: "Run Code",
                add_device: "Add Device",

                start_tooltip: "Start",
                control_tooltip: "Control",
                led_tooltip: "LED Control",
                num_tooltip: "Number Control",
                btn_tooltip: "Button Control",
                op_tooltip: "Operators",
                zoom_in: "Zoom In",
                zoom_out: "Zoom Out",
                reset_view: "Reset View",

                block_random_pre: " pick random  ",
                block_random_mid: " to ",
                delete_block: "Delete Block",

                modal_reset_title: "Are you sure you want to reset everything?",
                modal_reset_list: "RGB panel will be reset|All LEDs will turn off|Number values will be 0|Devices will stay connected",
                btn_cancel: "Cancel",
                btn_reset: "Reset",

                block_start: "when play clicked  ",

                block_wait_pre: " wait ",
                block_wait_post: " seconds  ",
                block_repeat_pre: " repeat ",
                block_repeat_post: " times  ",
                block_forever: " repeat forever  ",
                block_if: " if",
                block_then: "then  ",
                block_then: "then  ",
                block_else: "else  ",
                block_wait_until_pre: " wait until ",
                block_wait_until_post: "  ",
                block_repeat_until_pre: " repeat until ",
                block_repeat_until_post: "  ",

                block_when_pre: "when ",
                block_when_post: "  ",
                block_message_pre: "when ",
                block_message_post: " received  ",
                block_send_mobile_pre: "send ",
                block_send_mobile_post: "  ",

                block_light_get_pre: " ",
                block_light_get_post: " get light  ",

                block_red_light_on: "  turn red light on    ",
                block_red_light_off: "  turn red light off    ",
                block_green_light_on: "  turn green light on    ",
                block_green_light_off: "  turn green light off    ",
                block_blue_light_on: "  turn blue light on    ",
                block_blue_light_off: "  turn blue light off    ",

                block_red_num: "  set red number to  ",
                block_green_num: "  set green number to  ",
                block_blue_num: "  set blue number to  ",
                block_blue_num: "  set blue number to  ",
                block_red_get: "  get red number  ",

                // Hub & Device Blocks
                block_set_hub_led: "set hub LED to",
                block_hub_is: "is",
                block_hub_up: "up?",
                block_matrix_off: "turn off pixels",
                block_matrix_on: "turn on",
                block_matrix_brightness: "set pixel brightness to",
                block_matrix_pixel_at: "set pixel at",
                block_matrix_to: "to",
                block_matrix_at: "at",
                block_matrix_rotate: "rotate",
                block_force_is: "is",
                block_force_pressure: "pressure in",
                block_distance_is: "is",
                block_distance_value: "distance in",
                block_color_is: "is color",
                block_color_value: "color",
                block_lever_when: "when",
                block_lever_is: "lever is",
                block_lever_angle: "lever angle",
                block_green_get: "  get green number  ",
                block_blue_get: "  get blue number  ",

                block_rgb_red_btn_get: " get button  ",
                block_rgb_green_btn_get: " get button  ",
                block_rgb_blue_btn_get: " get button  ",

                block_logic_and: " and ",
                block_logic_or: " or ",
                block_logic_not: "not ",

                panel_leds: "LEDs",
                panel_numbers: "Numbers",
                panel_buttons: "Buttons",
                legend_red: "Red",
                legend_green: "Green",
                legend_blue: "Blue",

                confirm_reset: "🔄 Are you sure you want to reset everything?\n\n• RGB panel will be reset\n• All LEDs will turn off\n• Number values will be 0\n• Devices will stay connected",
                alert_no_play: "❌ Play block not found!\n\nAdd \"🚩 when play clicked\" block.",
                alert_stopped: "⏹️ Stopped!",
                alert_import_error: "Error loading file! Make sure you selected a valid XML file.",
                alert_export_error: "Error exporting workspace!",
                confirm_import: "Clear current workspace before loading?\n(Cancel to append to existing blocks)",

                scan_btn: "🔍 Scan & Connect New Device",
                tbl_name: "Device Name",
                tbl_id: "Device ID",
                tbl_status: "Status",
                tbl_action: "Action",
                no_device: "No connected devices. Click \"Scan & Connect New Device\".",
                scan_status: "🔍 Scanning...",
                status_connected: "Online",
                status_disconnected: "Offline",
                btn_remove: "Remove",
                confirm_remove_device: "Are you sure you want to remove this device?",
                connecting_to: "📱 Connecting:",
                connected_to: "✅ Connected:",
                device_added: "✅ Device added!",
                unknown_device: "Unknown",
                device_list_opening: "🔍 Opening device list...",
                modal_title: "📱 Bluetooth Device Management",
                add_specific_btn: "➕ Add Specific Device",
                specific_modal_title: "Select Device Type",
                specific_type_controller: "Controller",
                specific_type_single_motor: "Single Motor",
                specific_type_remote_controller: "Remote Controller",
                coming_soon: "Coming Soon",
                block_set_remote_led: "set LED to",
                remote_left_plus: "left +",
                remote_left_minus: "left -",
                remote_left_red: "left red",
                remote_right_plus: "right +",
                remote_right_minus: "right -",
                remote_right_red: "right red",
                remote_pressed: "pressed",
                remote_released: "released",
                block_remote_is: "is",
                block_remote_qm: "?",

                // Graphs Tab
                graphs_tab: "Graphs",
                graph_refresh: "Refresh",
                graph_cancel_zoom: "Cancel Zoom",
                graph_led_title: "LED On/Off",
                graph_numbers_title: "Numbers",
                led_red: "Red LED",
                led_green: "Green LED",
                led_blue: "Blue LED",
                val_red: "Red",
                val_green: "Green",
                val_blue: "Blue"
            }
        };

        function toggleLanguage() {
            setLanguage(currentLanguage === 'tr' ? 'en' : 'tr');
        }

        function setLanguage(lang) {
            if (!TRANSLATIONS[lang]) return;
            currentLanguage = lang;
            const t = TRANSLATIONS[lang];

            const langBtn = document.getElementById('langBtn');
            if (langBtn) langBtn.textContent = t.lang;

            const addDeviceBtn = document.getElementById('addDeviceBtn');
            if (addDeviceBtn) addDeviceBtn.title = t.add_device;

            const startToggle = document.getElementById('startToggle');
            if (startToggle) startToggle.title = t.start_tooltip;

            const controlToggle = document.getElementById('controlToggle');
            if (controlToggle) controlToggle.title = t.control_tooltip;

            const actionLedToggle = document.getElementById('actionLedToggle');
            if (actionLedToggle) actionLedToggle.title = t.led_tooltip;

            const actionNumToggle = document.getElementById('actionNumToggle');
            if (actionNumToggle) actionNumToggle.title = t.num_tooltip;

            const actionButtonToggle = document.getElementById('actionButtonToggle');
            if (actionButtonToggle) actionButtonToggle.title = t.btn_tooltip;

            const operatorToggle = document.getElementById('operatorToggle');
            if (operatorToggle) operatorToggle.title = t.op_tooltip;

            const resetBtn = document.querySelector('.reset-btn');
            if (resetBtn) resetBtn.title = t.reset;

            const playBtn = document.querySelector('.play-btn');
            if (playBtn) playBtn.title = t.run;

            const importBtn = document.querySelector('button[onclick*="importInput"]');
            if (importBtn) importBtn.title = t.import;

            const exportBtn = document.querySelector('button[onclick="exportWorkspace()"]');
            if (exportBtn) exportBtn.title = t.export;

            const zoomInBtn = document.querySelector('button[onclick="zoomIn()"]');
            if (zoomInBtn) zoomInBtn.title = t.zoom_in;

            const zoomOutBtn = document.querySelector('button[onclick="zoomOut()"]');
            if (zoomOutBtn) zoomOutBtn.title = t.zoom_out;

            const resetViewBtn = document.querySelector('button[onclick="resetView()"]');
            if (resetViewBtn) resetViewBtn.title = t.reset_view;

            // Update Device Modal Texts
            const modalTitle = document.getElementById('deviceModalTitle');
            if (modalTitle) modalTitle.textContent = t.modal_title;

            const scanBtn = document.getElementById('scanDeviceBtn');
            if (scanBtn) scanBtn.textContent = t.scan_btn;

            const thName = document.getElementById('thDeviceName');
            if (thName) thName.textContent = t.tbl_name;

            const thId = document.getElementById('thDeviceId');
            if (thId) thId.textContent = t.tbl_id;

            const thStatus = document.getElementById('thDeviceStatus');
            if (thStatus) thStatus.textContent = t.tbl_status;

            const thAction = document.getElementById('thDeviceAction');
            if (thAction) thAction.textContent = t.tbl_action;

            const noDeviceMsg = document.getElementById('noDeviceMsg');
            if (noDeviceMsg) noDeviceMsg.textContent = t.no_device;

            const scanStatus = document.getElementById('scanStatus');
            if (scanStatus) scanStatus.textContent = t.scan_status;

            // Update Remove Device Modal Translations
            const removeDeviceTitle = document.getElementById('removeDeviceModalTitle');
            if (removeDeviceTitle) removeDeviceTitle.textContent = t.confirm_remove_device;

            const removeDeviceCancelBtn = document.getElementById('removeDeviceCancelBtn');
            if (removeDeviceCancelBtn) removeDeviceCancelBtn.textContent = t.btn_cancel;

            const removeDeviceConfirmBtn = document.getElementById('removeDeviceConfirmBtn');
            if (removeDeviceConfirmBtn) removeDeviceConfirmBtn.textContent = t.btn_remove;

            // Refresh devices table if open to update translations
            updateDevicesTable();

            // Update Reset Modal Translations
            const resetTitle = document.getElementById('resetModalTitle');
            if (resetTitle) resetTitle.textContent = t.modal_reset_title;

            // Populate list from split string
            const resetList = document.getElementById('resetModalList');
            if (resetList && t.modal_reset_list) {
                resetList.innerHTML = t.modal_reset_list.split('|').map(item => `<li>${item}</li>`).join('');
            }

            const resetCancel = document.getElementById('resetModalCancelBtn');
            if (resetCancel) resetCancel.textContent = t.btn_cancel;

            const resetConfirm = document.getElementById('resetModalConfirmBtn');
            if (resetConfirm) resetConfirm.textContent = t.btn_reset;

            const deleteBlockBtn = document.getElementById('deleteBlockBtn');
            if (deleteBlockBtn) {
                deleteBlockBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="#FFFFFF"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>`;
            }

            // Update RGB panel labels
            const panelLedsLabel = document.getElementById('panelLedsLabel');
            if (panelLedsLabel) panelLedsLabel.textContent = t.panel_leds;

            const panelNumbersLabel = document.getElementById('panelNumbersLabel');
            if (panelNumbersLabel) panelNumbersLabel.textContent = t.panel_numbers;

            const panelButtonsLabel = document.getElementById('panelButtonsLabel');
            if (panelButtonsLabel) panelButtonsLabel.textContent = t.panel_buttons;

            const graphTitleButtons = document.getElementById('graph-title-buttons');
            if (graphTitleButtons) graphTitleButtons.textContent = t.panel_buttons;

            const graphTitleNumbers = document.getElementById('graph-title-numbers');
            if (graphTitleNumbers) graphTitleNumbers.textContent = t.panel_numbers;

            const legendIds = ['legend-num-red', 'legend-num-green', 'legend-num-blue', 'legend-btn-red', 'legend-btn-green', 'legend-btn-blue'];
            const legendKeys = ['legend_red', 'legend_green', 'legend_blue', 'legend_red', 'legend_green', 'legend_blue'];

            legendIds.forEach((id, index) => {
                const el = document.getElementById(id);
                if (el) el.textContent = t[legendKeys[index]];
            });

            // Specific Device Modal Translations
            const addSpecificBtn = document.getElementById('addSpecificBtn');
            if (addSpecificBtn) addSpecificBtn.textContent = t.add_specific_btn;

            const specificModalTitle = document.getElementById('specificModalTitle');
            if (specificModalTitle) specificModalTitle.textContent = t.specific_modal_title;

            const specificLabelController = document.getElementById('specificLabelController');
            if (specificLabelController) specificLabelController.textContent = t.specific_type_controller;

            const specificLabelSingleMotor = document.getElementById('specificLabelSingleMotor');
            if (specificLabelSingleMotor) specificLabelSingleMotor.textContent = t.specific_type_single_motor;

            const specificLabelRemoteController = document.getElementById('specificLabelRemoteController');
            if (specificLabelRemoteController) specificLabelRemoteController.textContent = t.specific_type_remote_controller;

            const specificLabelComingSoon = document.getElementById('specificLabelComingSoon');
            if (specificLabelComingSoon) specificLabelComingSoon.textContent = t.coming_soon || 'Coming Soon';

            // Graphs Tab Translations
            const tabLabelGraphs = document.getElementById('tab-label-graphs');
            if (tabLabelGraphs) tabLabelGraphs.textContent = t.graphs_tab;

            const graphLedTitle = document.getElementById('graph-title-led');
            if (graphLedTitle) graphLedTitle.textContent = t.graph_led_title;

            const graphNumbersTitle = document.getElementById('graph-title-numbers');
            if (graphNumbersTitle) graphNumbersTitle.textContent = t.graph_numbers_title;

            if (document.getElementById('legend-led-red')) document.getElementById('legend-led-red').textContent = t.led_red;
            if (document.getElementById('legend-led-green')) document.getElementById('legend-led-green').textContent = t.led_green;
            if (document.getElementById('legend-led-blue')) document.getElementById('legend-led-blue').textContent = t.led_blue;

            if (document.getElementById('legend-num-red')) document.getElementById('legend-num-red').textContent = t.val_red;
            if (document.getElementById('legend-num-green')) document.getElementById('legend-num-green').textContent = t.val_green;
            if (document.getElementById('legend-num-blue')) document.getElementById('legend-num-blue').textContent = t.val_blue;

            // Update Blockly Messages
            if (typeof Blockly !== 'undefined') {
                Blockly.Msg.BLOCK_START = t.block_start;

                Blockly.Msg.BLOCK_WAIT_PRE = t.block_wait_pre;
                Blockly.Msg.BLOCK_WAIT_POST = t.block_wait_post;

                Blockly.Msg.BLOCK_REPEAT_PRE = t.block_repeat_pre;
                Blockly.Msg.BLOCK_REPEAT_PRE = t.block_repeat_pre;
                Blockly.Msg.BLOCK_REPEAT_POST = t.block_repeat_post;

                Blockly.Msg.BLOCK_RANDOM_PRE = t.block_random_pre;
                Blockly.Msg.BLOCK_RANDOM_MID = t.block_random_mid;

                Blockly.Msg.BLOCK_FOREVER = t.block_forever;
                Blockly.Msg.BLOCK_IF = t.block_if;
                Blockly.Msg.BLOCK_THEN = t.block_then;
                Blockly.Msg.BLOCK_ELSE = t.block_else;

                Blockly.Msg.BLOCK_WAIT_UNTIL_PRE = t.block_wait_until_pre;
                Blockly.Msg.BLOCK_WAIT_UNTIL_POST = t.block_wait_until_post;

                Blockly.Msg.BLOCK_REPEAT_UNTIL_PRE = t.block_repeat_until_pre;
                Blockly.Msg.BLOCK_REPEAT_UNTIL_POST = t.block_repeat_until_post;

                Blockly.Msg.BLOCK_WHEN_PRE = t.block_when_pre;
                Blockly.Msg.BLOCK_WHEN_POST = t.block_when_post;
                Blockly.Msg.BLOCK_MESSAGE_PRE = t.block_message_pre;
                Blockly.Msg.BLOCK_MESSAGE_POST = t.block_message_post;
                Blockly.Msg.BLOCK_SEND_MOBILE_PRE = t.block_send_mobile_pre;
                Blockly.Msg.BLOCK_SEND_MOBILE_POST = t.block_send_mobile_post;

                Blockly.Msg.BLOCK_LIGHT_GET_PRE = t.block_light_get_pre;
                Blockly.Msg.BLOCK_LIGHT_GET_POST = t.block_light_get_post;

                Blockly.Msg.BLOCK_RED_ON = t.block_red_light_on;
                Blockly.Msg.BLOCK_RED_OFF = t.block_red_light_off;
                Blockly.Msg.BLOCK_GREEN_ON = t.block_green_light_on;
                Blockly.Msg.BLOCK_GREEN_OFF = t.block_green_light_off;
                Blockly.Msg.BLOCK_BLUE_ON = t.block_blue_light_on;
                Blockly.Msg.BLOCK_BLUE_OFF = t.block_blue_light_off;

                Blockly.Msg.BLOCK_RED_NUM = t.block_red_num;
                Blockly.Msg.BLOCK_GREEN_NUM = t.block_green_num;
                Blockly.Msg.BLOCK_BLUE_NUM = t.block_blue_num;
                Blockly.Msg.BLOCK_RED_GET = t.block_red_get;
                Blockly.Msg.BLOCK_GREEN_GET = t.block_green_get;
                Blockly.Msg.BLOCK_BLUE_GET = t.block_blue_get;

                Blockly.Msg.BLOCK_RED_BTN_GET = t.block_rgb_red_btn_get;
                Blockly.Msg.BLOCK_GREEN_BTN_GET = t.block_rgb_green_btn_get;
                Blockly.Msg.BLOCK_BLUE_BTN_GET = t.block_rgb_blue_btn_get;

                Blockly.Msg.BLOCK_LOGIC_AND = t.block_logic_and;
                Blockly.Msg.BLOCK_LOGIC_OR = t.block_logic_or;

                Blockly.Msg.BLOCK_SET_REMOTE_LED = t.block_set_remote_led;
                Blockly.Msg.BLOCK_REMOTE_IS = t.block_remote_is;
                Blockly.Msg.BLOCK_REMOTE_QM = t.block_remote_qm;
                Blockly.Msg.BLOCK_LOGIC_NOT = t.block_logic_not;

                // New Block Messages
                Blockly.Msg.BLOCK_SET_HUB_LED = t.block_set_hub_led;
                Blockly.Msg.BLOCK_HUB_IS = t.block_hub_is;
                Blockly.Msg.BLOCK_HUB_UP = t.block_hub_up;
                Blockly.Msg.BLOCK_MATRIX_OFF = t.block_matrix_off;
                Blockly.Msg.BLOCK_MATRIX_ON = t.block_matrix_on;
                Blockly.Msg.BLOCK_MATRIX_BRIGHTNESS = t.block_matrix_brightness;
                Blockly.Msg.BLOCK_MATRIX_PIXEL_AT = t.block_matrix_pixel_at;
                Blockly.Msg.BLOCK_MATRIX_TO = t.block_matrix_to;
                Blockly.Msg.BLOCK_MATRIX_AT = t.block_matrix_at;
                Blockly.Msg.BLOCK_MATRIX_ROTATE = t.block_matrix_rotate;
                Blockly.Msg.BLOCK_FORCE_IS = t.block_force_is;
                Blockly.Msg.BLOCK_FORCE_PRESSURE = t.block_force_pressure;
                Blockly.Msg.BLOCK_DISTANCE_IS = t.block_distance_is || 'is';
                Blockly.Msg.BLOCK_DISTANCE_VALUE = t.block_distance_value || 'distance in';
                Blockly.Msg.BLOCK_LEVER_WHEN = t.block_lever_when;
                Blockly.Msg.BLOCK_LEVER_IS = t.block_lever_is;
                Blockly.Msg.BLOCK_LEVER_ANGLE = t.block_lever_angle;
                Blockly.Msg.BLOCK_COLOR_IS = t.block_color_is || 'is color';
                Blockly.Msg.BLOCK_COLOR_VALUE = t.block_color_value || 'color';
            }

            // Refresh Toolboxes if active
            if (typeof showStartToolbox !== 'undefined') {
                if (currentToolboxMode === 'start') showStartToolbox();
                else if (currentToolboxMode === 'control') showControlToolbox();
                else if (currentToolboxMode === 'action_led') showActionLedToolbox();
                else if (currentToolboxMode === 'action_num') showActionNumToolbox();
                else if (currentToolboxMode === 'action_button') showActionButtonToolbox();
                else if (currentToolboxMode === 'operator') showOperatorToolbox();

                if (workspace) {
                    const xml = Blockly.Xml.workspaceToDom(workspace);
                    workspace.clear();
                    Blockly.Xml.domToWorkspace(xml, workspace);
                }
            }
        }

        function updateControllerVisual() {
            const leftValue = controllerState.leftValue;
            const rightValue = controllerState.rightValue;

            const leftPercent = calculateLeverPercent(leftValue);
            const rightPercent = calculateLeverPercent(rightValue);

            // controllerState'e yüzdelikleri kaydet
            controllerState.leftPercent = Math.round(leftPercent);
            controllerState.rightPercent = Math.round(rightPercent);

            // Sol kol
            const leftFill = document.getElementById('leftLeverFill');
            const leftValueEl = document.getElementById('leftLeverValue');
            if (leftFill && leftValueEl) {
                leftFill.style.height = Math.round(leftPercent) + '%';
                leftValueEl.textContent = Math.round(leftPercent) + '%';
            }

            // Sağ kol
            const rightFill = document.getElementById('rightLeverFill');
            const rightValueEl = document.getElementById('rightLeverValue');
            if (rightFill && rightValueEl) {
                rightFill.style.height = Math.round(rightPercent) + '%';
                rightValueEl.textContent = Math.round(rightPercent) + '%';
            }
        }

        function showControllerDisplay(deviceName, deviceColor) {
            // hideMotorDisplay(); // ARTIK GİZLEMİYORUZ - Side by side
            const display = document.getElementById('controllerDisplay');
            const header = document.getElementById('controllerHeader');
            const titleText = document.getElementById('controllerTitleText');

            if (display) {
                display.classList.add('active');
            }

            if (header) {
                header.style.background = deviceColor || '#4C97FF';
                const name = deviceName || 'Controller';

                if (titleText) {
                    titleText.textContent = name;
                } else {
                    // Fallback
                    header.innerHTML = `<img src="img/remote_controller_icon.png" style="height: 20px; width: auto; vertical-align: middle; margin-right: 5px; filter: drop-shadow(0 1px 2px rgba(0,0,0,0.2));"> ${name}`;
                }
            }
        }

        function hideControllerDisplay() {
            const display = document.getElementById('controllerDisplay');
            if (display) {
                display.classList.remove('active');
            }
        }

        // Remote Controller (88010) Display Functions
        function showRemoteControllerDisplay(deviceName, deviceColor) {
            const display = document.getElementById('remoteControllerDisplay');
            const header = document.getElementById('remoteControllerHeader');

            if (display) {
                display.classList.add('active');
            }

            if (header) {
                header.textContent = deviceName || 'Remote Controller';
                header.style.background = deviceColor || '#00A3DA';
            }
        }

        function hideRemoteControllerDisplay() {
            const display = document.getElementById('remoteControllerDisplay');
            if (display) {
                display.classList.remove('active');
            }
        }

        function updateRemoteControllerVisual() {
            const leftState = remoteControllerState.leftButton;
            const rightState = remoteControllerState.rightButton;
            const greenState = remoteControllerState.greenButton;

            // Sol taraf butonları
            const leftPlus = document.getElementById('remoteLeftPlus');
            const leftRed = document.getElementById('remoteLeftRed');
            const leftMinus = document.getElementById('remoteLeftMinus');
            const leftLabel = document.getElementById('remoteLeftState');

            if (leftPlus) leftPlus.classList.toggle('active', leftState === 'PLUS');
            if (leftRed) leftRed.classList.toggle('active', leftState === 'RED');
            if (leftMinus) leftMinus.classList.toggle('active', leftState === 'MINUS');
            if (leftLabel) leftLabel.textContent = leftState;

            // Sağ taraf butonları
            const rightPlus = document.getElementById('remoteRightPlus');
            const rightRed = document.getElementById('remoteRightRed');
            const rightMinus = document.getElementById('remoteRightMinus');
            const rightLabel = document.getElementById('remoteRightState');

            if (rightPlus) rightPlus.classList.toggle('active', rightState === 'PLUS');
            if (rightRed) rightRed.classList.toggle('active', rightState === 'RED');
            if (rightMinus) rightMinus.classList.toggle('active', rightState === 'MINUS');
            if (rightLabel) rightLabel.textContent = rightState;

            // Yeşil buton
            const greenBtn = document.getElementById('remoteGreenBtn');
            const greenLabel = document.getElementById('remoteGreenState');

            if (greenBtn) greenBtn.classList.toggle('active', greenState);
            if (greenLabel) greenLabel.textContent = greenState ? 'ON' : 'OFF';
        }

        // Convert raw byte to button state name
        function getRemoteButtonState(rawValue) {
            // LWP3 Remote button values:
            // Plus = 1, Minus = 255 (-1 signed), Red/Stop = 127, Released = 0
            if (rawValue === 1) return 'PLUS';
            if (rawValue === 255 || rawValue === -1) return 'MINUS';
            if (rawValue === 127) return 'RED';
            return 'RELEASED';
        }

        // Update remote controller state from raw data
        function updateRemoteControllerState(leftByte, rightByte, greenPressed = false) {
            const prevLeft = remoteControllerState.leftButton;
            const prevRight = remoteControllerState.rightButton;

            const newLeft = getRemoteButtonState(leftByte);
            const newRight = getRemoteButtonState(rightByte);

            remoteControllerState.leftButton = newLeft;
            remoteControllerState.rightButton = newRight;
            remoteControllerState.leftValue = leftByte;
            remoteControllerState.rightValue = rightByte;
            remoteControllerState.greenButton = greenPressed;

            // Log state changes
            if (prevLeft !== newLeft) {
                console.log(`🎮 Remote Left: ${prevLeft} → ${newLeft}`);
            }
            if (prevRight !== newRight) {
                console.log(`🎮 Remote Right: ${prevRight} → ${newRight}`);
            }

            updateRemoteControllerVisual();
        }

        // Setup LWP3 notifications for Remote Controller
        async function setupRemoteControllerNotifications(device, deviceColor) {
            console.log('🎮 Setting up Remote Controller notifications...');

            // Small delay to ensure device is fully registered
            await new Promise(resolve => setTimeout(resolve, 500));

            try {
                // LWP3 Service and Characteristic UUIDs
                const LWP3_SERVICE_UUID = '00001623-1212-efde-1623-785feabcd123';
                const LWP3_CHAR_UUID = '00001624-1212-efde-1623-785feabcd123';

                // Find device data in connectedDevices
                const deviceData = connectedDevices.find(d => d.device === device || d.id === device.id);
                let lwp3Char = null;

                // First try cache
                if (deviceData && deviceData.characteristics && deviceData.characteristics[LWP3_CHAR_UUID]) {
                    lwp3Char = deviceData.characteristics[LWP3_CHAR_UUID];
                    console.log('✅ LWP3 characteristic found in cache');
                }

                // If not in cache, get from GATT server directly
                if (!lwp3Char && device.gatt && device.gatt.connected) {
                    console.log('🔄 Getting LWP3 characteristic from GATT server...');
                    try {
                        const service = await device.gatt.getPrimaryService(LWP3_SERVICE_UUID);
                        lwp3Char = await service.getCharacteristic(LWP3_CHAR_UUID);
                        console.log('✅ LWP3 characteristic obtained from GATT');

                        // Save to device data for future use
                        if (deviceData) {
                            if (!deviceData.characteristics) deviceData.characteristics = {};
                            deviceData.characteristics[LWP3_CHAR_UUID] = lwp3Char;
                        }
                    } catch (serviceError) {
                        console.error('❌ Could not get LWP3 service/characteristic:', serviceError);
                        return;
                    }
                }

                if (!lwp3Char) {
                    console.warn('⚠️ LWP3 characteristic not available');
                    return;
                }

                // Start notifications
                await lwp3Char.startNotifications();
                console.log('✅ Remote Controller notifications started');

                // Add event listener
                lwp3Char.addEventListener('characteristicvaluechanged', (event) => {
                    const value = event.target.value;
                    const bytes = new Uint8Array(value.buffer);

                    // LWP3 Message format:
                    // Byte 0: Message length
                    // Byte 1: Hub ID (usually 0)
                    // Byte 2: Message Type (0x45 = Port Value)
                    // Byte 3: Port ID
                    // Byte 4+: Data

                    if (bytes.length >= 5 && bytes[2] === 0x45) {
                        const portId = bytes[3];
                        const buttonValue = bytes[4];

                        // Port 0 = Left side, Port 1 = Right side
                        // Port 59 (0x3B) = Green button (on some firmwares)
                        if (portId === 0) {
                            // Left button
                            const prevState = remoteControllerState.leftButton;
                            const newState = getRemoteButtonState(buttonValue);
                            if (prevState !== newState) {
                                console.log(`🎮 Remote Left Button: ${buttonValue} (${newState})`);
                            }
                            remoteControllerState.leftButton = newState;
                            remoteControllerState.leftValue = buttonValue;
                            updateRemoteControllerVisual();
                        } else if (portId === 1) {
                            // Right button
                            const prevState = remoteControllerState.rightButton;
                            const newState = getRemoteButtonState(buttonValue);
                            if (prevState !== newState) {
                                console.log(`🎮 Remote Right Button: ${buttonValue} (${newState})`);
                            }
                            remoteControllerState.rightButton = newState;
                            remoteControllerState.rightValue = buttonValue;
                            updateRemoteControllerVisual();
                        } else if (portId === 59 || portId === 60) {
                            // Green button (center)
                            const pressed = buttonValue === 1;
                            console.log(`🎮 Remote Green Button: ${pressed ? 'PRESSED' : 'RELEASED'}`);
                            remoteControllerState.greenButton = pressed;
                            updateRemoteControllerVisual();
                        }
                    }

                    // Hub Property Update (Message Type 0x01)
                    // Property 0x06 = Battery Voltage Percentage
                    if (bytes.length >= 5 && bytes[2] === 0x01) {
                        const propertyId = bytes[3];
                        if (propertyId === 0x06) {
                            // Battery percentage
                            const batteryPercent = bytes[4];
                            console.log(`🔋 Remote Battery: ${batteryPercent}%`);
                            updateRemoteControllerBattery(batteryPercent);
                        }
                    }
                });

                // Enable port value notifications for button ports
                // Port 0 (Left), Port 1 (Right) need to be subscribed
                const writeChar = deviceData.characteristics[LWP3_CHAR_UUID];
                if (writeChar) {
                    // Subscribe to Port 0 (Left buttons)
                    // Message: [length, 0x00, 0x41, port, mode, delta(4 bytes), enable]
                    const subscribeLeft = new Uint8Array([0x0A, 0x00, 0x41, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01]);
                    await writeChar.writeValue(subscribeLeft);
                    console.log('📡 Subscribed to Left button (Port 0)');

                    // Subscribe to Port 1 (Right buttons)
                    const subscribeRight = new Uint8Array([0x0A, 0x00, 0x41, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01]);
                    await writeChar.writeValue(subscribeRight);
                    console.log('📡 Subscribed to Right button (Port 1)');

                    // Request battery level - Hub Property (0x01) with Property ID 0x06 (Battery)
                    // Message: [length, 0x00, 0x01, property, operation]
                    // Operation: 0x05 = Request update, 0x02 = Enable updates
                    const requestBattery = new Uint8Array([0x05, 0x00, 0x01, 0x06, 0x05]);
                    await writeChar.writeValue(requestBattery);
                    console.log('🔋 Requested battery level');

                    // Enable battery updates
                    const enableBatteryUpdates = new Uint8Array([0x05, 0x00, 0x01, 0x06, 0x02]);
                    await writeChar.writeValue(enableBatteryUpdates);
                    console.log('🔋 Enabled battery level updates');

                    // Save writeChar for LED control
                    remoteControllerState.writeChar = writeChar;
                }

                console.log('✅ Remote Controller fully initialized');

            } catch (error) {
                console.error('❌ Remote Controller notification setup failed:', error);
            }
        }

        // Update Remote Controller battery display
        function updateRemoteControllerBattery(percent) {
            const batteryEl = document.getElementById('remoteControllerBatteryPercent');
            const batteryFill = document.getElementById('remoteControllerBatteryFill');

            if (batteryEl) {
                batteryEl.textContent = `${percent}%`;

                // Update fill width
                if (batteryFill) {
                    const fillWidth = Math.round((percent / 100) * 14);
                    batteryFill.setAttribute('width', fillWidth);
                }

                // Color based on level
                if (percent < 20) {
                    batteryEl.parentElement.style.color = '#e03131';
                } else if (percent < 50) {
                    batteryEl.parentElement.style.color = '#fab005';
                } else {
                    batteryEl.parentElement.style.color = '#37b24d';
                }
            }
        }

        // LEGO Color palette for Remote Controller LED (name to index map)
        const REMOTE_LED_COLOR_MAP = {
            'off': 0,
            'pink': 1,
            'purple': 2,
            'blue': 3,
            'light_blue': 4,
            'cyan': 5,
            'green': 6,
            'yellow': 7,
            'orange': 8,
            'red': 9,
            'white': 10
        };

        // Set Remote Controller LED color
        async function setRemoteControllerLEDColor(colorNameOrIndex) {
            if (!remoteControllerState.writeChar) {
                console.warn('⚠️ Remote Controller not connected or writeChar not available');
                return false;
            }

            let colorIndex;
            if (typeof colorNameOrIndex === 'string') {
                colorIndex = REMOTE_LED_COLOR_MAP[colorNameOrIndex.toLowerCase()] ?? 0;
            } else {
                colorIndex = colorNameOrIndex;
            }

            try {
                // LWP3 Port Output Command
                // Message: [length, 0x00, 0x81, port, startup_completion, subcommand, payload...]
                // Port 52 (0x34) = RGB LED on Remote Controller
                // Subcommand 0x51 = WriteDirectModeData
                // Mode 0x00 = Color Index mode
                const ledCommand = new Uint8Array([
                    0x08,       // Length
                    0x00,       // Hub ID
                    0x81,       // Message Type: Port Output Command
                    0x34,       // Port 52 (RGB LED)
                    0x11,       // Startup and Completion info
                    0x51,       // Subcommand: WriteDirectModeData
                    0x00,       // Mode 0
                    colorIndex  // Color index
                ]);

                await remoteControllerState.writeChar.writeValue(ledCommand);
                console.log(`💡 Remote LED set to: ${colorNameOrIndex} (${colorIndex})`);

                // Update state
                remoteControllerState.ledColor = colorIndex;

                return true;
            } catch (error) {
                console.error('❌ Failed to set Remote LED color:', error);
                return false;
            }
        }

        // Make function globally accessible
        window.setRemoteControllerLEDColor = setRemoteControllerLEDColor;

        // Update Remote Controller LED display indicator
        function updateRemoteControllerLedDisplay(colorHex, isOff = false) {
            const ledIndicator = document.getElementById('remoteLedIndicator');
            if (ledIndicator) {
                if (isOff) {
                    ledIndicator.style.background = '#333';
                    ledIndicator.style.boxShadow = 'none';
                } else {
                    ledIndicator.style.background = colorHex;
                    ledIndicator.style.boxShadow = `0 0 12px ${colorHex}`;
                }
            }
        }

        // Toggle Remote Controller Display
        function toggleRemoteDisplay() {
            const wrapper = document.getElementById('remoteContentWrapper');
            const icon = document.getElementById('remoteCollapseIcon');

            if (wrapper.style.maxHeight === '0px') {
                wrapper.style.maxHeight = '500px';
                icon.textContent = '▼';
            } else {
                wrapper.style.maxHeight = '0px';
                icon.textContent = '▶';
            }
        }

        function toggleMotorDisplay() {
            const wrapper = document.getElementById('motorContentWrapper');
            const icon = document.getElementById('motorCollapseIcon');

            if (wrapper && icon) {
                if (wrapper.style.maxHeight === '0px') {
                    wrapper.style.maxHeight = '500px';
                    icon.textContent = '▼';
                } else {
                    wrapper.style.maxHeight = '0px';
                    icon.textContent = '▶';
                }
            }
        }

        function showMotorDisplay(device, color, displayName = null) {
            // hideControllerDisplay(); // ARTIK GİZLEMİYORUZ - Side by side
            const display = document.getElementById('motorDisplay');
            const header = document.getElementById('motorHeader');
            const bodyImg = document.getElementById('motorBodyImage');
            const shaft = document.getElementById('motorShaft');
            const info = document.getElementById('motorAngleInfo');

            if (display && header) {
                header.style.background = color || '#4ecca3';
                const name = displayName || device.name || 'Single Motor';

                const titleText = document.getElementById('motorTitleText');
                if (titleText) {
                    titleText.textContent = name;
                } else {
                    // Fallback for safety
                    header.innerHTML = `<img src="img/single-motor.png" style="height: 20px; width: auto; vertical-align: middle; margin-right: 5px;"> ${name}`;
                }

                // Single Motor Image Logic (Only Single Motor)
                if (bodyImg) {
                    bodyImg.src = 'img/single-motor-body.png';
                    if (shaft) shaft.style.display = 'block';
                }

                display.classList.add('active');

                // Reset visual
                if (shaft) shaft.style.transform = `rotate(0deg)`;
                if (info) info.innerText = "0°";
            }
        }

        function toggleDoubleMotorDisplay() {
            const wrapper = document.getElementById('doubleMotorContentWrapper');
            const icon = document.getElementById('doubleMotorCollapseIcon');

            if (wrapper && icon) {
                if (wrapper.style.maxHeight === '0px') {
                    wrapper.style.maxHeight = '500px';
                    icon.textContent = '▼';
                } else {
                    wrapper.style.maxHeight = '0px';
                    icon.textContent = '▶';
                }
            }
        }

        function showDoubleMotorDisplay(device, color, displayName = null) {
            const display = document.getElementById('doubleMotorDisplay');
            const header = document.getElementById('doubleMotorHeader');

            if (display && header) {
                header.style.background = color || '#FF9F43'; // Turuncu (Double Motor için farklı varsayılan)
                const name = displayName || device.name || 'Double Motor';

                const titleText = document.getElementById('doubleMotorTitleText');
                if (titleText) {
                    titleText.textContent = name;
                }

                display.classList.add('active');
            }
        }

        function hideMotorDisplay() {
            const display = document.getElementById('motorDisplay');
            if (display) display.classList.remove('active');
            const doubleDisplay = document.getElementById('doubleMotorDisplay');
            if (doubleDisplay) doubleDisplay.classList.remove('active');
        }

        // ===== COLOR SENSOR DISPLAY FUNCTIONS =====
        let isColorSensorCollapsed = false;

        function toggleColorSensorDisplay() {
            const wrapper = document.getElementById('colorSensorContentWrapper');
            const icon = document.getElementById('colorSensorCollapseIcon');

            if (!wrapper || !icon) return;

            isColorSensorCollapsed = !isColorSensorCollapsed;

            if (isColorSensorCollapsed) {
                wrapper.style.maxHeight = '0';
                icon.textContent = '▶';
            } else {
                wrapper.style.maxHeight = '500px';
                icon.textContent = '▼';
            }
        }

        function showColorSensorDisplay(device, color) {
            const display = document.getElementById('colorSensorDisplay');
            const header = document.getElementById('colorSensorHeader');
            const titleSpan = document.getElementById('colorSensorHeaderTitle');
            const wrapper = document.getElementById('colorSensorContentWrapper');
            const icon = document.getElementById('colorSensorCollapseIcon');

            if (display && header) {
                header.style.background = color || '#9B59B6';
                if (titleSpan) {
                    titleSpan.textContent = device.name || 'Color Sensor';
                }
                display.classList.add('active');

                // Reset collapse state
                isColorSensorCollapsed = false;
                if (wrapper) wrapper.style.maxHeight = '500px';
                if (icon) icon.textContent = '▼';

                // Reset to no color state
                updateColorSensorVisual('NONE', 0, 0);
            }
        }

        function hideColorSensorDisplay() {
            const display = document.getElementById('colorSensorDisplay');
            if (display) display.classList.remove('active');
        }

        // ===== CITY HUB DISPLAY FUNCTIONS =====
        let isCityHubCollapsed = false;

        function toggleCityHubDisplay() {
            const wrapper = document.getElementById('cityHubContentWrapper');
            const icon = document.getElementById('cityHubCollapseIcon');

            if (!wrapper || !icon) return;

            isCityHubCollapsed = !isCityHubCollapsed;

            if (isCityHubCollapsed) {
                wrapper.style.maxHeight = '0';
                icon.textContent = '▶';
            } else {
                wrapper.style.maxHeight = '500px';
                icon.textContent = '▼';
            }
        }

        function showCityHubDisplay(device, color) {
            const display = document.getElementById('cityHubDisplay');
            const header = document.getElementById('cityHubHeader');
            const titleSpan = document.getElementById('cityHubHeaderTitle');
            const wrapper = document.getElementById('cityHubContentWrapper');
            const icon = document.getElementById('cityHubCollapseIcon');

            if (display && header) {
                header.style.background = color || '#3498DB';
                if (titleSpan) {
                    titleSpan.textContent = device.name || 'City Hub';
                }
                display.classList.add('active');

                // Reset collapse state
                isCityHubCollapsed = false;
                if (wrapper) wrapper.style.maxHeight = '500px';
                if (icon) icon.textContent = '▼';
            }
        }

        function hideCityHubDisplay() {
            const display = document.getElementById('cityHubDisplay');
            if (display) display.classList.remove('active');
        }

        // ===== BOOST MOVE HUB DISPLAY FUNCTIONS =====
        let isBoostHubCollapsed = false;

        function toggleBoostHubDisplay() {
            const wrapper = document.getElementById('boostHubContentWrapper');
            const icon = document.getElementById('boostHubCollapseIcon');

            if (!wrapper || !icon) return;

            isBoostHubCollapsed = !isBoostHubCollapsed;

            if (isBoostHubCollapsed) {
                wrapper.style.maxHeight = '0';
                icon.textContent = '▶';
            } else {
                wrapper.style.maxHeight = '500px';
                icon.textContent = '▼';
            }
        }

        function showBoostHubDisplay(device, color) {
            const display = document.getElementById('boostHubDisplay');
            const header = document.getElementById('boostHubHeader');
            const titleSpan = document.getElementById('boostHubHeaderTitle');
            const wrapper = document.getElementById('boostHubContentWrapper');
            const icon = document.getElementById('boostHubCollapseIcon');

            if (display && header) {
                header.style.background = color || '#E74C3C';
                if (titleSpan) {
                    titleSpan.textContent = device.name || 'Boost Move Hub';
                }
                display.classList.add('active');

                // Reset collapse state
                isBoostHubCollapsed = false;
                if (wrapper) wrapper.style.maxHeight = '500px';
                if (icon) icon.textContent = '▼';
            }
        }

        function hideBoostHubDisplay() {
            const display = document.getElementById('boostHubDisplay');
            if (display) display.classList.remove('active');
        }

        function updateColorSensorVisual(colorName, reflection, hue) {
            const circle = document.getElementById('colorSensorCircle');
            const label = document.getElementById('colorSensorLabel');
            const noColorIcon = document.getElementById('noColorIcon');
            const reflectionLabel = document.getElementById('colorSensorReflectionLabel');
            const reflectionValue = document.getElementById('colorSensorReflectionValue');
            const hueLabel = document.getElementById('colorSensorHueLabel');
            const hueValue = document.getElementById('colorSensorHueValue');

            if (!circle || !label) return;

            // Tüm renk sınıflarını temizle
            circle.className = 'color-sensor-circle';

            const isTr = currentLanguage === 'tr';

            // Renk isimleri dile göre
            const colorNames = {
                'NONE': isTr ? 'Renk Yok' : 'No Color',
                'RED': isTr ? 'Kırmızı' : 'Red',
                'YELLOW': isTr ? 'Sarı' : 'Yellow',
                'BLUE': isTr ? 'Mavi' : 'Blue',
                'GREEN': isTr ? 'Yeşil' : 'Green',
                'PURPLE': isTr ? 'Mor' : 'Purple',
                'CYAN': isTr ? 'Açık Mavi' : 'Cyan',
                'WHITE': isTr ? 'Beyaz' : 'White'
            };

            if (colorName === 'NONE' || !colorName) {
                circle.classList.add('no-color');
                if (noColorIcon) noColorIcon.style.display = 'block';
                label.textContent = colorNames['NONE'];
                label.style.color = '#888';
            } else {
                circle.classList.add('color-' + colorName.toLowerCase());
                if (noColorIcon) noColorIcon.style.display = 'none';
                label.textContent = colorNames[colorName] || colorName;

                // Label rengini ayarla
                const labelColors = {
                    'RED': '#CC0000',
                    'YELLOW': '#B8860B',
                    'BLUE': '#0052CC',
                    'GREEN': '#009900',
                    'PURPLE': '#7D3C98',
                    'CYAN': '#0097A7',
                    'WHITE': '#666666'
                };
                label.style.color = labelColors[colorName] || '#333';
            }

            // Detay etiketlerini güncelle (dil desteği)
            if (reflectionLabel) reflectionLabel.textContent = isTr ? 'Yansıma' : 'Reflection';
            if (hueLabel) hueLabel.textContent = isTr ? 'Ton' : 'Hue';

            // Değerleri güncelle
            if (reflectionValue) reflectionValue.textContent = reflection !== undefined ? reflection + '%' : '--%';
            if (hueValue) hueValue.textContent = hue !== undefined ? hue + '°' : '--°';

            // State'i güncelle
            colorSensorState.detectedColor = colorName;
            colorSensorState.reflection = reflection || 0;
            colorSensorState.hue = hue || 0;
        }

        // Color Sensor notification handler
        function handleColorSensorNotification(event) {
            const value = event.target.value;

            if (value.byteLength < 8) return;

            const data = new Uint8Array(value.buffer);

            // RAW VERİYİ CONSOLE'A YAZDIR (Debug için devre dışı)
            // const hexString = Array.from(data).map(b => b.toString(16).padStart(2, '0')).join(' ');
            // console.log(`🎨 [Color Sensor RAW] (${data.length} bytes): ${hexString}`);

            // Paket yapısı (19 bytes):
            // [0-3]: 3c 10 00 00 - Header
            // [4]: BATTERY - Batarya yüzdesi (5a = 90%)
            // [5]: 00
            // [6]: 0c - Sabit marker
            // [7]: COLOR CODE - RENK KODU!
            //      02=Mor, 03=Mavi, 05=Cyan, 06=Yeşil, 07=Sarı, 09=Kırmızı, 0a=Beyaz, ff=Yok
            // [8-18]: Diğer sensör verileri (reflection, RGB vs.)

            let colorIndex = 0;
            let reflection = 0;
            let battery = 0;

            // Batarya değeri Index 4'te
            if (data.length >= 5) {
                battery = data[4];
            }

            // Index 6'da 0x0c marker'ı kontrol et
            if (data.length >= 8 && data[6] === 0x0c) {
                colorIndex = data[7];

                // Reflection değeri (Index 8 olabilir)
                if (data.length >= 10) {
                    reflection = data[8];
                }
            }

            // Batarya göstergesini güncelle
            if (battery > 0 && battery <= 100) {
                updateColorSensorBattery(battery);
            }

            // Renk indeksini isme çevir
            const colorName = COLOR_INDEX_MAP[colorIndex] || 'NONE';

            // Görsel güncelle (throttle)
            const now = Date.now();
            if (now - lastVisualUpdate > VISUAL_UPDATE_INTERVAL) {
                lastVisualUpdate = now;

                // Renk değişimi kontrolü (ÖNCE kontrol et, SONRA güncelle)
                const colorChanged = colorSensorState.detectedColor !== colorName;

                // Görseli güncelle
                updateColorSensorVisual(colorName, reflection, 0);

                // Eğer renk değiştiyse
                if (colorChanged) {
                    console.log(`🎨 Color Sensor: ${colorName} (index: ${colorIndex}, battery: ${battery}%)`);

                    // Event bloklarını tetikle (renk değiştiğinde)
                    triggerColorEvents(colorName);
                }
            }
        }

        // Color Sensor batarya göstergesini güncelle
        function updateColorSensorBattery(percent) {
            const batteryFill = document.getElementById('colorSensorBatteryFill');
            const batteryPercent = document.getElementById('colorSensorBatteryPercent');
            const batteryInfo = document.getElementById('colorSensorBatteryInfo');

            if (batteryPercent) {
                batteryPercent.textContent = percent + '%';
            }

            if (batteryFill) {
                // Batarya doluluk genişliği (max 14px)
                const fillWidth = Math.round((percent / 100) * 14);
                batteryFill.setAttribute('width', fillWidth);
            }

            if (batteryInfo) {
                // Renk ayarla
                let color = '#37b24d'; // Yeşil
                if (percent <= 20) {
                    color = '#ff4444'; // Kırmızı
                } else if (percent <= 40) {
                    color = '#ffa500'; // Turuncu
                }
                batteryInfo.style.color = color;
            }
        }

        async function startColorSensorMonitoring(device, notifyChar, deviceId, deviceColor) {
            console.log('🎨 Color Sensor monitoring başlatılıyor...');

            colorSensorState.deviceId = deviceId;

            try {
                // Notification'ları başlat
                await notifyChar.startNotifications();
                console.log('✅ Color Sensor notifications başlatıldı');

                // Event listener ekle
                notifyChar.addEventListener('characteristicvaluechanged', handleColorSensorNotification);

                console.log('✅ Color Sensor monitoring aktif!');

                // Display panelini göster
                showColorSensorDisplay(device, deviceColor);

            } catch (err) {
                console.error('❌ Color Sensor notification başlatma hatası:', err);
            }
        }


        // ===== SPIKE PRIME PROTOCOL 1.0 (App 3) FUNCTIONS =====
        // Based on official LEGO documentation: https://lego.github.io/spike-prime-docs/

        // Protocol Constants (from official LEGO cobs.py)
        const SPIKE_DELIMITER = 0x02;        // Frame delimiter (end of message)
        const SPIKE_PRIORITY = 0x01;         // High priority message prefix
        const SPIKE_NO_DELIMITER = 0xFF;     // Code word for no delimiter in block
        const SPIKE_COBS_OFFSET = 0x02;      // Offset added to code word
        const SPIKE_MAX_BLOCK_SIZE = 84;     // Max block size including code word
        const SPIKE_XOR = 0x03;              // XOR mask for encoding

        // Legacy COBS decode (for backwards compatibility with standard COBS)
        function cobsDecode(data) {
            const output = [];
            let i = 0;
            while (i < data.length) {
                const code = data[i++];
                if (code === 0) break;
                for (let j = 1; j < code && i < data.length; j++) {
                    output.push(data[i++]);
                }
                if (code < 0xFF && i < data.length && data[i] !== 0) {
                    output.push(0);
                }
            }
            if (output.length > 0 && output[output.length - 1] === 0) {
                output.pop();
            }
            return new Uint8Array(output);
        }

        // Legacy COBS encode (backwards compatibility)
        function cobsEncode(data) {
            const output = [];
            let codeIndex = 0;
            let code = 1;
            output.push(0);

            for (let i = 0; i < data.length; i++) {
                if (data[i] === 0) {
                    output[codeIndex] = code;
                    codeIndex = output.length;
                    output.push(0);
                    code = 1;
                } else {
                    output.push(data[i]);
                    code++;
                    if (code === 0xFF) {
                        output[codeIndex] = code;
                        codeIndex = output.length;
                        output.push(0);
                        code = 1;
                    }
                }
            }
            output[codeIndex] = code;
            output.push(0);
            return new Uint8Array(output);
        }

        // ===== SPIKE App 3 Protocol - Official COBS Implementation =====

        /**
         * Encode data using SPIKE App 3 COBS algorithm.
         * This escapes 0x00, 0x01, and 0x02 bytes.
         * Based on official LEGO implementation.
         */
        function spikeApp3CobsEncode(data) {
            const buffer = [];
            let codeIndex = 0;
            let block = 1;

            // Begin first block with placeholder
            buffer.push(SPIKE_NO_DELIMITER);

            for (let i = 0; i < data.length; i++) {
                const byte = data[i];

                if (byte > SPIKE_DELIMITER) {
                    // Non-delimiter value, write as-is
                    buffer.push(byte);
                    block++;
                }

                if (byte <= SPIKE_DELIMITER || block > SPIKE_MAX_BLOCK_SIZE) {
                    // Block completed - delimiter found or size limit reached
                    if (byte <= SPIKE_DELIMITER) {
                        // Update code word to reflect block size and delimiter
                        const delimiterBase = byte * SPIKE_MAX_BLOCK_SIZE;
                        const blockOffset = block + SPIKE_COBS_OFFSET;
                        buffer[codeIndex] = delimiterBase + blockOffset;
                    }
                    // Begin new block
                    codeIndex = buffer.length;
                    buffer.push(SPIKE_NO_DELIMITER);
                    block = 1;
                }
            }

            // Update final code word
            buffer[codeIndex] = block + SPIKE_COBS_OFFSET;

            return new Uint8Array(buffer);
        }

        /**
         * Decode SPIKE App 3 COBS encoded data.
         * Based on official LEGO implementation.
         */
        function spikeApp3CobsDecode(data) {
            const buffer = [];

            function unescape(code) {
                if (code === 0xFF) {
                    return { value: null, block: SPIKE_MAX_BLOCK_SIZE + 1 };
                }
                const adjusted = code - SPIKE_COBS_OFFSET;
                let block = adjusted % SPIKE_MAX_BLOCK_SIZE;
                let value = Math.floor(adjusted / SPIKE_MAX_BLOCK_SIZE);
                if (block === 0) {
                    block = SPIKE_MAX_BLOCK_SIZE;
                    value -= 1;
                }
                return { value, block };
            }

            let { value, block } = unescape(data[0]);

            for (let i = 1; i < data.length; i++) {
                block--;
                if (block > 0) {
                    buffer.push(data[i]);
                    continue;
                }

                // Block completed
                if (value !== null) {
                    buffer.push(value);
                }

                const result = unescape(data[i]);
                value = result.value;
                block = result.block;
            }

            return new Uint8Array(buffer);
        }

        /**
         * Pack message for transmission - applies COBS + XOR + delimiter.
         * This is the main function to use when sending to SPIKE Prime.
         */
        function spikeApp3Pack(data) {
            // 1. COBS encode
            const encoded = spikeApp3CobsEncode(data);

            // 2. XOR all bytes with 0x03 to avoid ctrl+C issues
            const buffer = new Uint8Array(encoded.length + 1);
            for (let i = 0; i < encoded.length; i++) {
                buffer[i] = encoded[i] ^ SPIKE_XOR;
            }

            // 3. Add frame delimiter
            buffer[encoded.length] = SPIKE_DELIMITER;

            return buffer;
        }

        /**
         * Unpack received frame - removes framing + XOR + COBS decode.
         * This is the main function to use when receiving from SPIKE Prime.
         */
        function spikeApp3Unpack(frame) {
            let start = 0;

            // Skip priority byte if present
            if (frame[0] === SPIKE_PRIORITY) {
                start = 1;
            }

            // Remove delimiter and apply XOR
            const unframed = new Uint8Array(frame.length - start - 1);
            for (let i = start; i < frame.length - 1; i++) {
                unframed[i - start] = frame[i] ^ SPIKE_XOR;
            }

            // COBS decode
            return spikeApp3CobsDecode(unframed);
        }

        // ===== SPIKE App 3 Message Builders =====

        /**
         * Build InfoRequest message (0x00)
         */
        function buildInfoRequest() {
            return spikeApp3Pack(new Uint8Array([0x00]));
        }

        /**
         * Build DeviceNotificationRequest message (0x28)
         * @param intervalMs - notification interval in milliseconds (0 = disable)
         */
        function buildDeviceNotificationRequest(intervalMs = 100) {
            const msg = new Uint8Array(3);
            msg[0] = 0x28;  // Message type
            msg[1] = intervalMs & 0xFF;  // Low byte
            msg[2] = (intervalMs >> 8) & 0xFF;  // High byte
            return spikeApp3Pack(msg);
        }

        /**
         * Build GetHubNameRequest message (0x18)
         */
        function buildGetHubNameRequest() {
            return spikeApp3Pack(new Uint8Array([0x18]));
        }

        /**
         * Build DeviceUuidRequest message (0x1A)
         */
        function buildDeviceUuidRequest() {
            return spikeApp3Pack(new Uint8Array([0x1A]));
        }

        /**
         * Build ProgramFlowRequest message (0x1E)
         * @param stop - true to stop, false to start
         * @param slot - program slot (0-19)
         */
        function buildProgramFlowRequest(stop, slot = 0) {
            return spikeApp3Pack(new Uint8Array([0x1E, stop ? 0x01 : 0x00, slot]));
        }

        async function setHubLedColor(colorIndex, deviceId = null) {
            // Find specific device or fallback to active/monitored hub
            let targetDevice = null;
            if (deviceId) {
                targetDevice = connectedDevices.find(d => d.id === deviceId);
            }

            // Fallback strategy
            if (!targetDevice && activeMotorDevice) targetDevice = { id: activeMotorDevice.id, server: activeMotorDevice.gattServer || (activeMotorDevice.device ? activeMotorDevice.device.gatt : null) };
            if (!targetDevice && spikeHubState.deviceId) targetDevice = connectedDevices.find(d => d.id === spikeHubState.deviceId);

            if (!targetDevice) {
                console.log('⚠️ Hub LED değişimi için hedef cihaz bulunamadı.');
                return;
            }

            console.log(`💡 Hub LED (${targetDevice.name}) renk değiştiriliyor: ${colorIndex}`);

            // Get characteristic freshly
            try {
                // If we have stored characteristics in deviceData, use them? 
                // Better to fetch from service if possible or use cached one if reliable.
                // Using LPF2 service logic similar to sendMotorPositionCommand
                const LPF2_SERVICE_UUID = '0000fd02-0000-1000-8000-00805f9b34fb';
                const LPF2_CHAR_UUID = '0000fd02-0001-1000-8000-00805f9b34fb';

                let service = null;
                // If server is available
                if (targetDevice.server) {
                    service = await targetDevice.server.getPrimaryService(LPF2_SERVICE_UUID);
                } else if (targetDevice.device && targetDevice.device.gatt) {
                    service = await targetDevice.device.gatt.getPrimaryService(LPF2_SERVICE_UUID);
                }

                if (!service) {
                    console.error('❌ Service alınamadı');
                    return;
                }

                const characteristic = await service.getCharacteristic(LPF2_CHAR_UUID);

                // Color command: Port 50 (RGB LED typically port 50 on most hubs, check if variable)
                // Essential/Prime Hub internal LED is usually port 50?
                // Command: 0x81 (Direct Write), 0x32 (Port), 0x11 (Execute immediately), 0x51 (Write), 0x00 (Mode 0), ColorIndex
                const command = new Uint8Array([0x81, 50, 0x11, 0x51, 0x00, colorIndex]);
                await characteristic.writeValueWithoutResponse(command);

            } catch (e) {
                console.error('❌ LED renk değişimi hatası:', e);
            }
        }
        // SPIKE Prime Protocol - InfoRequest gönder (0x00)
        async function sendSpikePrimeInfoRequest() {
            const writeChar = spikeHubState.writeChar;
            if (!writeChar) {
                console.error('❌ writeChar yok!');
                return;
            }

            console.log('🕵️ --- PROTOKOL TARAMASI BAŞLIYOR (v2) ---');

            try {
                // 1. TEST: JSON-RPC (Chunked 20 bytes - MTU Safe)
                console.log('👉 TEST 1: Sending JSON-RPC (Chunked 20b)');
                const jsonStr_t1 = '{"m":"get_hub_info","i":"s1"}\r';
                const enc_t1 = new TextEncoder();
                const jsonAll = enc_t1.encode(jsonStr_t1);

                for (let i = 0; i < jsonAll.length; i += 20) {
                    const chunk = jsonAll.slice(i, i + 20);
                    await writeChar.writeValueWithoutResponse(chunk);
                    await new Promise(r => setTimeout(r, 50));
                }
                await new Promise(r => setTimeout(r, 800));

                // 2. TEST: Enter keys (REPL wake up)
                console.log('👉 TEST 2: Sending Enter keys (\\r\\n)');
                await writeChar.writeValueWithoutResponse(new Uint8Array([0x0D, 0x0A]));
                await new Promise(r => setTimeout(r, 800));

                // 3. TEST: Ctrl-C (REPL interrupt) - Aggressive
                console.log('👉 TEST 3: Sending Ctrl-C (0x03) x 3');
                await writeChar.writeValueWithoutResponse(new Uint8Array([0x03]));
                await new Promise(r => setTimeout(r, 150));
                await writeChar.writeValueWithoutResponse(new Uint8Array([0x03]));
                await new Promise(r => setTimeout(r, 150));
                await writeChar.writeValueWithoutResponse(new Uint8Array([0x03]));
                await new Promise(r => setTimeout(r, 800));

                // 4. TEST: LWP3 over COBS
                console.log('👉 TEST 4: Sending LWP3 Info Request (COBS Encoded)');
                const lwpMsg = new Uint8Array([0x05, 0x00, 0x01, 0x02, 0x05]);
                const cobsMsg = cobsEncode(lwpMsg);
                console.log('   Data:', [...cobsMsg].map(b => b.toString(16).padStart(2, '0')).join(' '));
                await writeChar.writeValueWithoutResponse(cobsMsg);
                await new Promise(r => setTimeout(r, 800));

                // 5. TEST: Raw Binary 0x00 (COBS Encoded)
                console.log('👉 TEST 5: Sending Raw 0x00 (COBS Encoded)');
                const rawMsg = cobsEncode(new Uint8Array([0x00]));
                await writeChar.writeValueWithoutResponse(rawMsg);
                await new Promise(r => setTimeout(r, 800));

                // 6. TEST: Header 0x06 + JSON (PCAP Experiment)
                console.log('👉 TEST 6: Header 0x06 + JSON');
                const jsonStr = JSON.stringify({ "m": "get_hub_info", "p": {}, "i": "scan2" }) + '\r';
                const enc2 = new TextEncoder();
                const jsonBytes = enc2.encode(jsonStr);
                const headerMsg = new Uint8Array(jsonBytes.length + 1);
                headerMsg[0] = 0x06;
                headerMsg.set(jsonBytes, 1);
                await writeChar.writeValueWithoutResponse(headerMsg);



                console.log('🏁 Tarama bitti. Cevap bekleniyor...');

            } catch (e) {
                console.error('❌ Tarama hatası:', e);
            }
        }


        // SPIKE Prime Protocol - DeviceNotificationRequest gönder (0x28)
        async function sendSpikePrimeDeviceNotificationRequest() {
            const writeChar = spikeHubState.writeChar;
            if (!writeChar) return;

            try {
                const msg = cobsEncode(new Uint8Array([0x28, 0x14, 0x00]));
                // console.log('📤 DeviceNotificationRequest gönderiliyor:', [...msg].map(b => b.toString(16).padStart(2, '0')).join(' '));
                await writeChar.writeValueWithoutResponse(msg);
            } catch (e) {
                // console.error('❌ DeviceNotificationRequest hatası:', e);
            }
        }

        // SPIKE Prime Protocol mesaj handler
        function handleSpikePrimeProtocolMessage(data) {
            if (data.length < 1) return;

            const msgType = data[0];

            // Legacy Protocol - DeviceInfo (0x54)
            // Format: 54 00 07 2c 54 [device1] [device2] ...
            // Byte 5: First device type (0x06=Motor)
            // Byte 6: Second device type (0x0B=Force Sensor)
            if (msgType === 0x54 && data.length >= 7) {
                const device1 = data[5];
                const device2 = data[6];

                // İlk kez log
                if (!window._spikeDeviceInfoLogged) {
                    console.log(`📋 DeviceInfo (0x54): device1=0x${device1.toString(16)}, device2=0x${device2.toString(16)}`);
                    window._spikeDeviceInfoLogged = true;
                }

                // DeviceInfo'dan tespit edilen cihazları kaydet
                if (!window._spikeDeviceInfoDetected) {
                    window._spikeDeviceInfoDetected = { motor: false, forceSensor: false };
                }

                // Force Sensor tespiti (0x0B)
                const hasForceSensor = device1 === 0x0B || device2 === 0x0B;

                if (hasForceSensor && !window._spikeDeviceInfoDetected.forceSensor) {
                    console.log('🤜 Force Sensor tespit edildi! (DeviceInfo)');
                    window._spikeDeviceInfoDetected.forceSensor = true;

                    // Force Sensor state
                    if (!window.spikePrimeForceState) {
                        window.spikePrimeForceState = { value: 0, port: '?', detected: true };
                    }
                    window.spikePrimeForceState.detected = true;

                    // Force container göster (port bilgisi olmadan)
                    const forceContainer = document.getElementById('spikePrimeForceContainer');
                    if (forceContainer) {
                        forceContainer.style.display = 'block';
                    }
                }

                // Force Sensor yoksa kaldır
                if (!hasForceSensor && window._spikeDeviceInfoDetected.forceSensor) {
                    console.log('🤜 Force Sensor çıkarıldı!');
                    window._spikeDeviceInfoDetected.forceSensor = false;

                    const forceContainer = document.getElementById('spikePrimeForceContainer');
                    if (forceContainer) {
                        forceContainer.style.display = 'none';
                    }
                }

                // Motor tespiti (0x06)
                if ((device1 === 0x06 || device2 === 0x06) && !window._spikeDeviceInfoDetected.motor) {
                    console.log('⚙️ Motor tespit edildi! (DeviceInfo)');
                    window._spikeDeviceInfoDetected.motor = true;
                }

                // DeviceInfo mesajını telemetri olarak işleme
                return;
            }

            // SPIKE App 3 Protocol - InfoResponse (0x01)
            // Format (per official docs):
            // uint8 msgType, uint8 rpcMajor, uint8 rpcMinor, uint16 rpcBuild,
            // uint8 fwMajor, uint8 fwMinor, uint16 fwBuild,
            // uint16 maxPacketSize, uint16 maxMessageSize, uint16 maxChunkSize, uint16 productGroup
            if (msgType === 0x01 && data.length >= 15) {
                const dv = new DataView(data.buffer, data.byteOffset);
                const rpcMajor = data[1];
                const rpcMinor = data[2];
                const rpcBuild = dv.getUint16(3, true);
                const fwMajor = data[5];
                const fwMinor = data[6];
                const fwBuild = dv.getUint16(7, true);
                const maxPacketSize = dv.getUint16(9, true);
                const maxMessageSize = dv.getUint16(11, true);
                const maxChunkSize = dv.getUint16(13, true);

                // console.log('📋 InfoResponse (0x01) received!');
                // console.log(`   RPC Version: ${rpcMajor}.${rpcMinor}.${rpcBuild}`);
                // console.log(`   Firmware: ${fwMajor}.${fwMinor}.${fwBuild}`);
                // console.log(`   Max Packet: ${maxPacketSize}, Max Message: ${maxMessageSize}, Max Chunk: ${maxChunkSize}`);

                window._spikePrimeInfo = {
                    rpcVersion: `${rpcMajor}.${rpcMinor}.${rpcBuild}`,
                    fwVersion: `${fwMajor}.${fwMinor}.${fwBuild}`,
                    maxPacketSize,
                    maxMessageSize,
                    maxChunkSize
                };

                // InfoResponse received - DeviceNotificationRequest should already be sent
                // No need to send again here
            }

            // SPIKE App 3 Protocol - DeviceNotificationResponse (0x29)
            if (msgType === 0x29) {
                // console.log('✅ DeviceNotificationResponse - sensör bildirimleri aktif!');
            }

            // SPIKE App 3 Protocol - DeviceNotification (0x3C)
            // Format: 0x3C + uint16 payload_size + device_messages[]
            if (msgType === 0x3C && data.length >= 3) {
                const payloadSize = data[1] | (data[2] << 8);
                const deviceData = data.slice(3);

                // Debug log (ilk 3 mesaj)
                if (!window._spike3CLogCount) window._spike3CLogCount = 0;
                if (window._spike3CLogCount < 3) {
                    // console.log(`📦 DeviceNotification (0x3C): payloadSize=${payloadSize}, data=${[...deviceData.slice(0, 20)].map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
                    window._spike3CLogCount++;
                }

                // Track which ports have devices in this message
                // This allows detecting disconnected devices
                const portsInMessage = new Set();

                // Device messages'ları parse et
                let offset = 0;
                while (offset < deviceData.length) {
                    const devType = deviceData[offset];

                    // 0x00 DeviceBattery
                    if (devType === 0x00 && offset + 1 < deviceData.length) {
                        const percent = deviceData[offset + 1];
                        updateSpikePrimeBattery(percent);
                        offset += 2;
                    }
                    // 0x01 DeviceImuValues (20 bytes total)
                    else if (devType === 0x01 && offset + 19 < deviceData.length) {
                        const dv = new DataView(deviceData.buffer, deviceData.byteOffset + offset + 1);
                        // Skip face bytes (2), get orientation and accel/gyro
                        const yaw = dv.getInt16(2, true);
                        const pitch = dv.getInt16(4, true);
                        const roll = dv.getInt16(6, true);
                        const accelX = dv.getInt16(8, true);
                        const accelY = dv.getInt16(10, true);
                        const accelZ = dv.getInt16(12, true);
                        const gyroX = dv.getInt16(14, true);
                        const gyroY = dv.getInt16(16, true);
                        const gyroZ = dv.getInt16(18, true);

                        updateSpikePrimeTilt(yaw, pitch, roll);
                        updateSpikePrimeAccel(accelX, accelY, accelZ);
                        updateSpikePrimeGyro(gyroX, gyroY, gyroZ);
                        offset += 20;
                    }
                    // 0x0A DeviceMotor (12 bytes)
                    else if (devType === 0x0A && offset + 11 < deviceData.length) {
                        const port = deviceData[offset + 1];
                        const motorType = deviceData[offset + 2];
                        const dv = new DataView(deviceData.buffer, deviceData.byteOffset + offset + 3);
                        const absPos = dv.getInt16(0, true);
                        const power = dv.getInt16(2, true);
                        const speed = dv.getInt8(4);
                        const position = dv.getInt32(5, true);

                        // Port'u güncelle
                        const portLetter = ['A', 'B', 'C', 'D', 'E', 'F'][port];
                        if (portLetter) {
                            portsInMessage.add(portLetter);
                            // absPos is 0-360 degrees
                            updateSpikePrimePortStatus(portLetter, 0x0A, absPos); // Motor type with angle
                        }

                        offset += 12;
                    }
                    // 0x0B DeviceForceSensor (4 bytes)
                    // Format: 0x0B + port + value + pressed
                    else if (devType === 0x0B && offset + 3 < deviceData.length) {
                        const port = deviceData[offset + 1];
                        const value = deviceData[offset + 2];  // 0-100 (percentage)
                        const pressed = deviceData[offset + 3];

                        const portLetter = ['A', 'B', 'C', 'D', 'E', 'F'][port];

                        // İlk tespit log'u
                        if (!window._forceSensorFirstLog) {
                            // console.log(`🤜 Force Sensor FOUND! Port ${portLetter} (${port}), value=${value}, pressed=${pressed === 1}`);
                            window._forceSensorFirstLog = true;
                        }

                        // Port'u güncelle
                        if (portLetter) {
                            portsInMessage.add(portLetter);

                            // Convert to Newtons (0-100% → 0-10N)
                            const forceNewtons = (value / 10).toFixed(1);

                            updateSpikePrimePortStatus(portLetter, 0x0B, forceNewtons); // Force sensor type with value

                            // Force state güncelle
                            if (!window.spikePrimeForceState) {
                                window.spikePrimeForceState = { value: 0, port: portLetter, newtons: 0 };
                            }
                            window.spikePrimeForceState.port = portLetter;
                            window.spikePrimeForceState.value = value;
                            window.spikePrimeForceState.newtons = parseFloat(forceNewtons);
                            window.spikePrimeForceState.pressed = pressed === 1;

                            // UI güncelle
                            updateSpikePrimeForceSensor(value);

                            // Force container göster
                            const forceContainer = document.getElementById('spikePrimeForceContainer');
                            if (forceContainer) forceContainer.style.display = 'block';
                        }

                        offset += 4;
                    }
                    // 0x0C DeviceColorSensor (9 bytes)
                    else if (devType === 0x0C && offset + 8 < deviceData.length) {
                        const port = deviceData[offset + 1];
                        const color = deviceData[offset + 2]; // Color code 0-10
                        // RGB values at offset 3-8

                        const portLetter = ['A', 'B', 'C', 'D', 'E', 'F'][port];
                        if (portLetter) {
                            portsInMessage.add(portLetter);
                            // Pass color code to show detected color in UI
                            updateSpikePrimePortStatus(portLetter, 0x0C, color);
                        }

                        offset += 9;
                    }
                    // 0x0D DeviceDistanceSensor (4 bytes)
                    else if (devType === 0x0D && offset + 3 < deviceData.length) {
                        const port = deviceData[offset + 1];
                        const dv = new DataView(deviceData.buffer, deviceData.byteOffset + offset + 2);
                        const distance = dv.getInt16(0, true); // Distance in cm

                        const portLetter = ['A', 'B', 'C', 'D', 'E', 'F'][port];
                        if (portLetter) {
                            portsInMessage.add(portLetter);
                            // Pass distance value to show in UI
                            updateSpikePrimePortStatus(portLetter, 0x0D, distance); // Distance sensor with cm value
                        }

                        offset += 4;
                    }
                    // 0x0E Device3x3ColorMatrix (11 bytes)
                    else if (devType === 0x0E && offset + 10 < deviceData.length) {
                        const port = deviceData[offset + 1];

                        const portLetter = ['A', 'B', 'C', 'D', 'E', 'F'][port];
                        if (portLetter) {
                            portsInMessage.add(portLetter);
                            updateSpikePrimePortStatus(portLetter, 0x0E); // 3x3 Matrix type (SPIKE App 3)
                        }

                        offset += 11;
                    }
                    else {
                        // Bilinmeyen device type - atla
                        offset++;
                    }
                }

                // Hot-swap detection RE-ENABLED with HIGH THRESHOLD
                // This ensures we detect disconnects even if Attached IO message is missed
                if (!window._portMissingCounter) {
                    window._portMissingCounter = { A: 0, B: 0, C: 0, D: 0, E: 0, F: 0 };
                }

                const DISCONNECT_THRESHOLD = 100; // Need 100 consecutive misses (approx 5-10 sec) to mark as detached
                const allPorts = ['A', 'B', 'C', 'D', 'E', 'F'];

                for (const port of allPorts) {
                    if (portsInMessage.has(port)) {
                        // Port found in message - reset counter
                        window._portMissingCounter[port] = 0;
                    } else {
                        // Port not in message - increment counter
                        window._portMissingCounter[port]++;

                        // Only mark as disconnected after threshold
                        const portKey = `port${port}`;
                        if (window._portMissingCounter[port] >= DISCONNECT_THRESHOLD) {
                            if (spikePrimeHubState[portKey] && spikePrimeHubState[portKey].connected) {
                                console.log(`🔌 Port ${port}: Auto-disconnect due to timeout (${DISCONNECT_THRESHOLD} misses)`);
                                updateSpikePrimePortStatus(port, null, true); // Mark as Empty (FORCE = true)
                                window._portMissingCounter[port] = 0; // Reset after disconnect
                            }
                        }
                    }
                }
            }

            // ===== SPIKE Prime Telemetri Mesajı - COBS Decoded Format =====
            // COBS decode sonrası format (80 byte):
            // Byte 0: Batarya yüzdesi (0x3f = 63%)
            // Byte 1-2: Header/Flags (0x4f 0xa8)
            // Byte 3: Port A cihaz tipi
            // Byte 6: Port D cihaz tipi  
            // Byte 10: Force Sensor varlık göstergesi
            // Byte 13-16: Force Sensor değeri (int32)
            //
            // Cihaz tipleri: 0x06=Motor, 0x04=Matrix, 0x67=Empty

            // İlk byte batarya (0-100 arası) ve uzunluk yeterli ise telemetri mesajı
            if (msgType >= 0 && msgType <= 100 && data.length >= 18) {
                // Batarya (byte 0)
                const battery = data[0];
                updateSpikePrimeBattery(battery);

                // SPIKE Prime cihaz tipleri (PCAP'tan):
                // 0x04 = Color Light Matrix (3x3)
                // 0x06 = Medium Angular Motor
                // 0x3F = Force Sensor (LWP3 tipi)
                // 0x67 = Empty / No Device
                // 0x00 = Empty (alternatif)

                const getDeviceTypeName = (typeCode) => {
                    if (typeCode === 0x04) return 'Matrix';
                    if (typeCode === 0x06) return 'Motor';
                    if (typeCode === 0x3F) return 'Force';
                    if (typeCode === 0x67 || typeCode === 0x00) return null; // Empty
                    if (typeCode === 0x07 || typeCode === 0x0e) return null; // Initializing/Unknown
                    // Diğer bilinen olmayan tipler için de null döndür
                    return null;
                };

                // Port durumları - COBS decoded format
                // PCAP analizi (bağlı): 3f 4f a8 06 67 00 04 67 67 67 06 67 67 00 00 00 00 07
                //                       bat -- -- A  B  -- D  E  -- -- F? -- -- force_value
                // 
                // Port offsets (COBS decoded, byte 0 = batarya):
                // Port A: byte 3 (0x06=Motor, 0x00/0x07=empty/init)
                // Port B: byte 4 (0x67=empty)
                // Port C: byte 5 (0x00=empty) 
                // Port D: byte 6 (0x04=Matrix, 0x07=init)
                // Port E: byte 7 (0x67=empty)
                // Port F: byte 8 (0x67=empty)
                // Force Sensor: byte 10 (0x06=present)

                const portOffsets = { A: 3, B: 4, C: 5, D: 6, E: 7, F: 8 };
                const ports = ['A', 'B', 'C', 'D', 'E', 'F'];

                for (const port of ports) {
                    const offset = portOffsets[port];
                    if (offset < data.length) {
                        const portByte = data[offset];
                        const deviceName = getDeviceTypeName(portByte);

                        if (deviceName) {
                            updateSpikePrimePortStatus(port, portByte);
                        } else {
                            updateSpikePrimePortStatus(port, null);
                        }
                    }
                }

                // Force Sensor algılama
                // PCAP'ta byte 10 = 0x06 ise Force Sensor bağlı
                // Force değeri byte 13-16'da (int32 little-endian)
                const forceSensorIndicator = data.length > 10 ? data[10] : 0;
                const hasForceSensor = forceSensorIndicator === 0x06 || forceSensorIndicator === 0x3F;
                const forceContainer = document.getElementById('spikePrimeForceContainer');

                if (hasForceSensor && data.length >= 17) {
                    const dv = new DataView(data.buffer, data.byteOffset);
                    const forceValue = dv.getInt32(13, true);

                    // Force değeri 0-100 arası normalize et
                    const normalizedForce = Math.max(0, Math.min(100, forceValue));

                    // Force sensör state'ini güncelle
                    if (!window.spikePrimeForceState) {
                        window.spikePrimeForceState = { value: 0, port: 'F' };
                    }
                    window.spikePrimeForceState.value = normalizedForce;

                    // Force sensör UI güncellemesi
                    updateSpikePrimeForceSensor(normalizedForce);

                    // Force Sensor container'ı göster
                    if (forceContainer) {
                        forceContainer.style.display = 'block';
                    }

                    // F portunu Force olarak güncelle
                    const portFStatus = document.getElementById('spikePrimePortFStatus');
                    if (portFStatus && (portFStatus.textContent === 'Empty' || portFStatus.textContent === '')) {
                        portFStatus.textContent = 'Force';
                        portFStatus.classList.add('connected');
                        const portF = document.getElementById('spikePrimePortF');
                        if (portF) portF.classList.add('has-device');
                        // State'i de güncelle
                        if (spikePrimeHubState.portF) {
                            spikePrimeHubState.portF.connected = true;
                            spikePrimeHubState.portF.type = 0x3F;
                            spikePrimeHubState.portF.typeName = 'Force';
                        }
                    }
                } else if (forceContainer) {
                    forceContainer.style.display = 'none';
                }

                // Debug log (ilk 5 mesaj)
                if (!window._spikeTelemetryLogCount) window._spikeTelemetryLogCount = 0;
                if (window._spikeTelemetryLogCount < 5) {
                    const hex = [...data.slice(0, 20)].map(b => b.toString(16).padStart(2, '0')).join(' ');
                    const portA = data[3], portD = data[6];
                    // console.log(`📊 SPIKE Telemetry: bat=${battery}%, portA=0x${portA?.toString(16)}, portD=0x${portD?.toString(16)}, force=${hasForceSensor}`);
                    // console.log(`   Raw: ${hex}...`);
                    window._spikeTelemetryLogCount++;
                }

                // IMU verileri (80 byte mesajlarda offset 31-42 arası)
                if (data.length >= 44) {
                    try {
                        const dv = new DataView(data.buffer, data.byteOffset);
                        const v1 = dv.getInt16(31, true);
                        const v2 = dv.getInt16(33, true);
                        const v3 = dv.getInt16(35, true);
                        const v4 = dv.getInt16(37, true);
                        const v5 = dv.getInt16(39, true);
                        const v6 = dv.getInt16(41, true);

                        // Accel ve Gyro olarak yorumla
                        updateSpikePrimeAccel(v1, v2, v3);
                        updateSpikePrimeGyro(v4, v5, v6);
                    } catch (e) {
                        // DataView hatası - görmezden gel
                    }
                }
            }
        }

        // Force Sensor güncelleme fonksiyonu
        function updateSpikePrimeForceSensor(value) {
            // Force değeri 0-100 arası normalize et (veya raw değer göster)
            const normalizedValue = Math.min(100, Math.max(0, value));

            // UI element varsa güncelle
            const forceEl = document.getElementById('spikePrimeForceValue');
            const forceBar = document.getElementById('spikePrimeForceBar');

            if (forceEl) {
                forceEl.textContent = `${normalizedValue}`;
            }
            if (forceBar) {
                forceBar.style.width = `${normalizedValue}%`;
                // Renk değişimi: yeşil -> sarı -> kırmızı
                if (normalizedValue < 30) {
                    forceBar.style.background = '#51cf66';
                } else if (normalizedValue < 70) {
                    forceBar.style.background = '#fcc419';
                } else {
                    forceBar.style.background = '#ff6b6b';
                }
            }

            // State'i de güncelle (bloklar için)
            if (window.spikePrimeForceState) {
                window.spikePrimeForceState.value = normalizedValue;
            }
        }

        // RX Buffer for COBS frames
        window._spikeRxBuffer = [];


        // ===== SPIKE ESSENTIAL HUB DISPLAY FUNCTIONS =====
        // Hub state tracking
        // Multi-hub state management - each hub has its own state
        const hubStates = new Map();

        // Create a new hub state object
        function createHubState(deviceId) {
            return {
                deviceId: deviceId,
                writeChar: null,
                notifyChar: null,
                matrix: {
                    A: { pixels: [0, 0, 0, 0, 0, 0, 0, 0, 0], brightness: 10 },
                    B: { pixels: [0, 0, 0, 0, 0, 0, 0, 0, 0], brightness: 10 }
                },
                battery: 0,
                hubColor: 0,
                hubType: null,
                portA: { connected: false, type: null, typeName: 'Empty' },
                portB: { connected: false, type: null, typeName: 'Empty' },
                portC: { connected: false, type: null, typeName: 'Empty' },
                portD: { connected: false, type: null, typeName: 'Empty' },
                gyro: { x: 0, y: 0, z: 0 },
                accel: { x: 0, y: 0, z: 0 },
                tilt: 0,
                tiltName: '--'
            };
        }

        // Get or create hub state for a device
        function getHubState(deviceId) {
            if (!hubStates.has(deviceId)) {
                hubStates.set(deviceId, createHubState(deviceId));
            }
            return hubStates.get(deviceId);
        }

        // Legacy single hub state (for backward compatibility)
        // Points to the most recently connected hub
        const spikeHubState = {
            deviceId: null,
            writeChar: null,
            notifyChar: null,
            // Matrix State: Stores current pixels and brightness (0-10) for each port
            matrix: {
                A: { pixels: [0, 0, 0, 0, 0, 0, 0, 0, 0], brightness: 10 },
                B: { pixels: [0, 0, 0, 0, 0, 0, 0, 0, 0], brightness: 10 }
            },
            battery: 0,
            hubColor: 0,
            hubType: null,
            portA: { connected: false, type: null, typeName: 'Empty' },
            portB: { connected: false, type: null, typeName: 'Empty' },
            portC: { connected: false, type: null, typeName: 'Empty' },
            portD: { connected: false, type: null, typeName: 'Empty' },
            gyro: { x: 0, y: 0, z: 0 },
            accel: { x: 0, y: 0, z: 0 },
            tilt: 0,
            tiltName: '--'
        };

        // IO Type names
        const IO_TYPE_NAMES = {
            // SPIKE App 3 Protocol Device Types (from DeviceNotification 0x3C)
            0x0A: 'Motor',            // DeviceMotor
            0x0B: 'Force Sensor',     // DeviceForceSensor
            0x0C: 'Color Sensor',     // DeviceColorSensor
            0x0D: 'Distance Sensor',  // DeviceDistanceSensor
            0x0E: '3x3 Matrix',       // Device3x3ColorMatrix

            // LWP3 / Legacy Device Types
            0x0001: 'Medium Linear Motor',
            0x0002: 'Train Motor',
            0x0004: 'Matrix',           // SPIKE Prime Color Light Matrix (from PCAP)
            0x0006: 'Motor',            // SPIKE Prime Medium Angular Motor (from PCAP)
            0x0008: 'Light',
            0x0017: 'RGB Light',
            0x0026: 'BOOST Interactive Motor',
            0x002E: 'Control+ Large Motor',
            0x002F: 'Control+ XL Motor',
            0x0039: 'Gyroscope',
            0x003A: 'Accelerometer',
            0x003B: 'Tilt Sensor',
            0x003D: 'Color Sensor',
            0x003E: 'Distance Sensor',
            0x003F: 'Force Sensor',
            0x0040: 'Color Light Matrix',
            0x0041: 'Small Motor',
            0x0042: 'Large Motor',
            0x004B: 'Medium Motor', // Updated from Small to Medium
            0x004C: 'Large Motor',
            0x0060: 'Light Matrix'
        };


        // LEGO Hub LED Color Index
        const LEGO_COLORS = {
            0: { name: 'Off', hex: '#333333' },
            1: { name: 'Pink', hex: '#FF69B4' },
            2: { name: 'Purple', hex: '#9932CC' },
            3: { name: 'Blue', hex: '#0000FF' },
            4: { name: 'Light Blue', hex: '#00BFFF' },
            5: { name: 'Cyan', hex: '#00FFFF' },
            6: { name: 'Green', hex: '#00FF00' },
            7: { name: 'Yellow', hex: '#FFFF00' },
            8: { name: 'Orange', hex: '#FFA500' },
            9: { name: 'Red', hex: '#FF0000' },
            10: { name: 'White', hex: '#FFFFFF' }
        };

        // Tilt orientation names and icons
        const TILT_ORIENTATIONS = {
            0: { name: 'Bottom', icon: '⬇️' },
            1: { name: 'Front', icon: '⬆️' },
            2: { name: 'Back', icon: '↩️' },
            3: { name: 'Right', icon: '➡️' },
            4: { name: 'Left', icon: '⬅️' },
            5: { name: 'Top', icon: '⬆️' }
        };

        // Track created hub displays by device ID
        const hubDisplays = new Map();

        // Create dynamic hub display HTML
        function createHubDisplayHTML(deviceId, hubType, color, displayName, portCount) {
            const is4Port = portCount === 4;
            const is6Port = portCount === 6;
            const isEssential = hubType === 'spike-essential' || hubType === 'spike_essential';

            // Hub tipine göre ikon belirle
            const hubIcons = {
                'spike-essential': 'img/spike_essential_icon.png',
                'spike-prime': 'img/spike_prime_icon.png',
                'technic-medium-hub': 'img/technic-hub.png',
                'city-hub': 'img/city-hub.png',
                'boost-move-hub': 'img/move-hub.png',
                'mario': 'img/mario.png'
            };
            const iconSrc = hubIcons[hubType] || 'img/spike_essential_icon.png';
            const containerStyle = isEssential ? `style="box-shadow: none !important; border: 1px solid ${color};"` : '';

            return `
                <div class="spike-essential-display active" id="hubDisplay_${deviceId}" data-device-id="${deviceId}" ${containerStyle}>
                    <div class="controller-header hub-header-collapsible" id="hubHeader_${deviceId}" style="background: ${color};" onclick="toggleHubCollapse('${deviceId}')">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <img src="${iconSrc}" style="width: 24px; height: 24px; object-fit: contain;">
                            <span>${displayName}</span>
                        </div>
                        <span class="status-circle connected"></span>
                        <span class="hub-collapse-icon" id="hubCollapseIcon_${deviceId}">▼</span>
                    </div>
                    <div class="hub-collapsible-content" id="hubContent_${deviceId}">
                        <div class="spike-hub-content">
                        <div class="spike-hub-ports">
                            <div class="spike-hub-port">
                                <div class="spike-hub-port-label">Port A</div>
                                <div class="spike-hub-port-status" id="hubPortAStatus_${deviceId}">Empty</div>
                            </div>
                            <div class="spike-hub-port">
                                <div class="spike-hub-port-label">Port B</div>
                                <div class="spike-hub-port-status" id="hubPortBStatus_${deviceId}">Empty</div>
                            </div>
                            ${is4Port || is6Port ? `
                            <div class="spike-hub-port">
                                <div class="spike-hub-port-label">Port C</div>
                                <div class="spike-hub-port-status" id="hubPortCStatus_${deviceId}">Empty</div>
                            </div>
                            <div class="spike-hub-port">
                                <div class="spike-hub-port-label">Port D</div>
                                <div class="spike-hub-port-status" id="hubPortDStatus_${deviceId}">Empty</div>
                            </div>` : ''}
                            ${is6Port ? `
                            <div class="spike-hub-port">
                                <div class="spike-hub-port-label">Port E</div>
                                <div class="spike-hub-port-status" id="hubPortEStatus_${deviceId}">Empty</div>
                            </div>
                            <div class="spike-hub-port">
                                <div class="spike-hub-port-label">Port F</div>
                                <div class="spike-hub-port-status" id="hubPortFStatus_${deviceId}">Empty</div>
                            </div>` : ''}
                        </div>
                        <div class="spike-hub-footer">
                            <div class="spike-hub-tilt-compact">
                                <div class="spike-hub-tilt-icon" id="hubTiltIcon_${deviceId}">🔘</div>
                            </div>
                            <div id="hubBatteryInfo_${deviceId}" style="display: flex; align-items: center; gap: 3px; font-size: 11px; color: #37b24d; font-family: monospace;">
                                <svg width="18" height="12" viewBox="0 0 24 14" fill="none" stroke="currentColor" stroke-width="1.5">
                                    <rect x="1" y="1" width="18" height="12" rx="2" ry="2"></rect>
                                    <rect x="19" y="4" width="3" height="6" rx="1" ry="1" fill="currentColor"></rect>
                                    <rect id="hubBatteryFill_${deviceId}" x="3" y="3" width="14" height="8" rx="1" ry="1" fill="currentColor" opacity="0.7"></rect>
                                </svg>
                                <span id="hubBatteryPercent_${deviceId}">--%</span>
                            </div>
                            <button class="hub-details-btn" onclick="showHubSensorModal('${deviceId}')" title="Sensör Detayları">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="12" y1="16" x2="12" y2="12"></line>
                                    <line x1="12" y1="8" x2="12.01" y2="8"></line>
                                </svg>
                            </button>
                        </div>
                        <!-- Hidden sensor values for modal -->
                        <div style="display:none;">
                            <span id="hubGyroValue_${deviceId}">X:0 Y:0 Z:0</span>
                            <span id="hubAccelValue_${deviceId}">X:0 Y:0 Z:0</span>
                            <span id="hubTiltValue_${deviceId}">Y:0° P:0° R:0°</span>
                        </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function showSpikeEssentialDisplay(device, color, displayName = null, hubType = 'spike_essential') {
            const deviceId = device.id;

            // Determine port count
            let portCount = 2;
            if (hubType === 'spike_prime') {
                portCount = 6;
            } else if (hubType === 'technic_medium_hub' || hubType === 'city_hub' || hubType === 'boost_move_hub') {
                portCount = 4;
            }

            // Check if display already exists for this device
            if (hubDisplays.has(deviceId)) {
                // Just update the header
                const header = document.getElementById(`hubHeader_${deviceId}`);
                if (header) {
                    header.style.background = color || '#F5A623';
                    header.innerHTML = (displayName || device.name || 'Hub') + ' <span class="status-circle connected"></span>';
                }
                return;
            }

            // Create new display
            const container = document.querySelector('.displays-container');
            if (!container) return;

            const displayHTML = createHubDisplayHTML(
                deviceId,
                hubType,
                color || '#F5A623',
                displayName || device.name || 'Hub',
                portCount
            );

            // Insert at beginning of container
            container.insertAdjacentHTML('afterbegin', displayHTML);

            // Track this display
            hubDisplays.set(deviceId, {
                hubType,
                portCount,
                element: document.getElementById(`hubDisplay_${deviceId}`)
            });

            // console.log(`✅ Created display for hub: ${deviceId} (${hubType}, ${portCount} ports)`);
        }

        function hideSpikeEssentialDisplay(deviceId = null) {
            if (deviceId) {
                // Remove specific hub display
                const display = document.getElementById(`hubDisplay_${deviceId}`);
                if (display) {
                    display.remove();
                    hubDisplays.delete(deviceId);
                    // console.log(`🗑️ Removed display for hub: ${deviceId}`);
                }
            } else {
                // Legacy: hide the static display
                const display = document.getElementById('spikeEssentialDisplay');
                if (display) display.classList.remove('active');
            }
        }

        // Toggle hub display collapse/expand
        function toggleHubCollapse(deviceId) {
            const header = document.getElementById(`hubHeader_${deviceId}`);
            const content = document.getElementById(`hubContent_${deviceId}`);

            if (header && content) {
                header.classList.toggle('collapsed');
                content.classList.toggle('collapsed');
            }
        }

        // Hub Sensor Modal Functions
        let hubSensorModalInterval = null;

        function createHubSensorModal() {
            // Check if modal already exists
            if (document.getElementById('hubSensorModal')) return;

            const modal = document.createElement('div');
            modal.id = 'hubSensorModal';
            modal.className = 'hub-sensor-modal';
            modal.innerHTML = `
                <div class="hub-sensor-modal-content">
                    <div class="hub-sensor-modal-header" id="modalHubHeader" style="background: #888;">
                        <div class="hub-sensor-modal-info">
                            <div class="hub-sensor-modal-icon" id="modalHubIcon">
                                <svg width="40" height="40" viewBox="0 0 48 48" fill="currentColor">
                                    <rect x="8" y="12" width="32" height="24" rx="4" fill="currentColor"/>
                                    <circle cx="16" cy="24" r="4" fill="white"/>
                                    <circle cx="32" cy="24" r="4" fill="white"/>
                                    <rect x="12" y="8" width="8" height="6" rx="2" fill="currentColor"/>
                                    <rect x="28" y="8" width="8" height="6" rx="2" fill="currentColor"/>
                                </svg>
                            </div>
                            <span class="hub-sensor-modal-title" id="modalHubName">Hub</span>
                        </div>
                        <button class="hub-sensor-modal-close" onclick="hideHubSensorModal()">&times;</button>
                    </div>
                    <div class="hub-sensor-modal-body">
                        <div class="hub-sensor-row">
                            <span class="hub-sensor-label">🌀 Gyro (°/s)</span>
                            <span class="hub-sensor-value" id="modalGyroValue">X:0 Y:0 Z:0</span>
                        </div>
                        <div class="hub-sensor-row">
                            <span class="hub-sensor-label">📐 Accel (mG)</span>
                            <span class="hub-sensor-value" id="modalAccelValue">X:0 Y:0 Z:0</span>
                        </div>
                        <div class="hub-sensor-row">
                            <span class="hub-sensor-label">🔄 Tilt (°)</span>
                            <span class="hub-sensor-value" id="modalTiltValue">Y:0° P:0° R:0°</span>
                        </div>
                        <!-- System Info Container (Initially Hidden) -->
                        <div class="hub-sensor-row" id="modalSystemInfoRow" style="display:none; flex-direction:column; align-items:flex-start; border-top:1px solid #eee; margin-top:10px; padding-top:10px;">
                            <span class="hub-sensor-label" style="width:100%; margin-bottom:5px;">ℹ️ System Info</span>
                            <div id="modalSystemInfoContent" style="width:100%; font-size:12px; color:#555; font-family:monospace; white-space: pre-line;">Waiting...</div>
                        </div>
                    </div>
                </div>
            `;

            // Close on backdrop click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) hideHubSensorModal();
            });

            document.body.appendChild(modal);
        }

        function showHubSensorModal(deviceId) {
            createHubSensorModal();

            const modal = document.getElementById('hubSensorModal');
            modal.classList.add('active');
            modal.dataset.deviceId = deviceId;

            // Get hub info from the display
            const hubDisplay = document.getElementById(`hubDisplay_${deviceId}`);
            const hubHeader = document.getElementById(`hubHeader_${deviceId}`);

            if (hubHeader) {
                const hubName = hubHeader.textContent.trim();
                const hubColor = hubHeader.style.background || hubHeader.style.backgroundColor || '#888';

                // Update modal header
                const modalHeader = document.getElementById('modalHubHeader');
                const modalTitle = document.getElementById('modalHubName');

                if (modalHeader) modalHeader.style.background = hubColor;
                if (modalTitle) modalTitle.textContent = hubName;
            }

            // Update values immediately
            updateHubSensorModal(deviceId);

            // Start live updates
            if (hubSensorModalInterval) clearInterval(hubSensorModalInterval);
            hubSensorModalInterval = setInterval(() => {
                if (modal.classList.contains('active')) {
                    updateHubSensorModal(deviceId);
                }
            }, 100);
        }

        function hideHubSensorModal() {
            const modal = document.getElementById('hubSensorModal');
            if (modal) modal.classList.remove('active');

            if (hubSensorModalInterval) {
                clearInterval(hubSensorModalInterval);
                hubSensorModalInterval = null;
            }
            if (typeof spikePrimeSensorModalInterval !== 'undefined' && spikePrimeSensorModalInterval) {
                clearInterval(spikePrimeSensorModalInterval);
                spikePrimeSensorModalInterval = null;
            }
        }

        function updateHubSensorModal(deviceId) {
            const gyroEl = document.getElementById(`hubGyroValue_${deviceId}`);
            const accelEl = document.getElementById(`hubAccelValue_${deviceId}`);
            const tiltEl = document.getElementById(`hubTiltValue_${deviceId}`);

            const modalGyro = document.getElementById('modalGyroValue');
            const modalAccel = document.getElementById('modalAccelValue');
            const modalTilt = document.getElementById('modalTiltValue');

            if (gyroEl && modalGyro) modalGyro.textContent = gyroEl.textContent;
            if (accelEl && modalAccel) modalAccel.textContent = accelEl.textContent;
            if (tiltEl && modalTilt) modalTilt.textContent = tiltEl.textContent;
        }

        // Helper to update hub-specific elements
        function getHubElementId(baseId, deviceId) {
            // If we have a dynamic display, use hub-specific IDs
            if (deviceId && hubDisplays.has(deviceId)) {
                return `hub${baseId}_${deviceId}`;
            }
            // Fallback to legacy static IDs
            return `spike${baseId}`;
        }

        // Spike Prime Hub State (6 ports)
        const spikePrimeHubState = {
            battery: 0,
            portA: { connected: false, type: null, typeName: 'Empty' },
            portB: { connected: false, type: null, typeName: 'Empty' },
            portC: { connected: false, type: null, typeName: 'Empty' },
            portD: { connected: false, type: null, typeName: 'Empty' },
            portE: { connected: false, type: null, typeName: 'Empty' },
            portF: { connected: false, type: null, typeName: 'Empty' },
            gyro: { x: 0, y: 0, z: 0 },
            accel: { x: 0, y: 0, z: 0 },
            tilt: { yaw: 0, pitch: 0, roll: 0 },
            hubColor: 0
        };

        function showSpikePrimeDisplay(device, color, displayName = null) {
            const display = document.getElementById('spikePrimeDisplay');
            const header = document.getElementById('spikePrimeHeader');
            const headerText = document.getElementById('spikePrimeHeaderText');

            if (display && header) {
                const headerColor = color || '#9B59B6';
                header.style.background = headerColor;
                display.style.borderColor = headerColor; // Border rengini de hub rengi yap

                if (headerText) headerText.textContent = displayName || device.name || 'Spike Prime Hub';
                display.classList.add('active');

                // Reset display values
                updateSpikePrimeBattery(0);
                ['A', 'B', 'C', 'D', 'E', 'F'].forEach(port => updateSpikePrimePortStatus(port, null));
            }
        }

        function hideSpikePrimeDisplay() {
            const display = document.getElementById('spikePrimeDisplay');
            if (display) display.classList.remove('active');
        }

        // Toggle Spike Prime display collapse/expand
        function toggleSpikePrimeCollapse() {
            const header = document.getElementById('spikePrimeHeader');
            const content = document.getElementById('spikePrimeContent');
            const icon = document.getElementById('spikePrimeCollapseIcon');

            if (header && content) {
                header.classList.toggle('collapsed');
                content.classList.toggle('collapsed');
                if (icon) {
                    icon.textContent = content.classList.contains('collapsed') ? '▶' : '▼';
                }
            }
        }

        // Spike Prime Sensor Modal
        let spikePrimeSensorModalInterval = null;

        function showSpikePrimeSensorModal() {
            createHubSensorModal();

            const modal = document.getElementById('hubSensorModal');
            modal.classList.add('active');
            modal.dataset.deviceId = 'spike-prime';

            // Update modal header with Spike Prime info
            const modalHeader = document.getElementById('modalHubHeader');
            const modalTitle = document.getElementById('modalHubName');
            const modalIcon = document.getElementById('modalHubIcon');

            if (modalHeader) modalHeader.style.background = 'linear-gradient(135deg, #9B59B6 0%, #8E44AD 100%)';
            if (modalTitle) {
                const headerText = document.getElementById('spikePrimeHeaderText');
                modalTitle.textContent = headerText ? headerText.textContent : 'Spike Prime Hub';
            }
            if (modalIcon) {
                modalIcon.innerHTML = '<img src="img/spike_prime_icon.png" style="width: 40px; height: 40px; object-fit: contain;">';
            }

            // Update values immediately
            updateSpikePrimeSensorModal();

            // Start live updates
            if (spikePrimeSensorModalInterval) clearInterval(spikePrimeSensorModalInterval);
            spikePrimeSensorModalInterval = setInterval(() => {
                if (modal.classList.contains('active')) {
                    updateSpikePrimeSensorModal();
                }
            }, 100);
        }

        function updateSpikePrimeSensorModal() {
            const gyroEl = document.getElementById('spikePrimeGyroValue');
            const accelEl = document.getElementById('spikePrimeAccelValue');
            const tiltEl = document.getElementById('spikePrimeTiltValue');

            const modalGyro = document.getElementById('modalGyroValue');
            const modalAccel = document.getElementById('modalAccelValue');
            const modalTilt = document.getElementById('modalTiltValue');

            if (gyroEl && modalGyro) modalGyro.textContent = gyroEl.textContent;
            if (accelEl && modalAccel) modalAccel.textContent = accelEl.textContent;
            if (tiltEl && modalTilt) modalTilt.textContent = tiltEl.textContent;

            // Update System Info
            const infoRow = document.getElementById('modalSystemInfoRow');
            const infoContent = document.getElementById('modalSystemInfoContent');
            if (infoRow && infoContent) {
                infoRow.style.display = 'flex';
                const info = window._spikePrimeInfo || {};
                const rpc = info.rpcVersion || '-';
                const fw = info.fwVersion || '-';
                let content = `RPC Ver: ${rpc}\nFirmware: ${fw}`;
                if (info.maxPacketSize) content += `\nPkt: ${info.maxPacketSize}, Msg: ${info.maxMessageSize}`;
                infoContent.textContent = content;
            }
        }

        function updateSpikePrimeBattery(percent) {
            spikePrimeHubState.battery = percent;
            const percentEl = document.getElementById('spikePrimeBatteryPercent');
            const fillEl = document.getElementById('spikePrimeBatteryFill');
            const infoEl = document.getElementById('spikePrimeBatteryInfo');

            if (percentEl) percentEl.textContent = percent + '%';
            if (fillEl) fillEl.setAttribute('width', Math.round(14 * percent / 100));
            if (infoEl) {
                if (percent > 50) infoEl.style.color = '#37b24d';
                else if (percent > 20) infoEl.style.color = '#f59f00';
                else infoEl.style.color = '#e03131';
            }
        }

        function updateSpikePrimePortStatus(port, ioType, sensorValue = null) {
            const portKey = `port${port}`;
            if (!spikePrimeHubState[portKey]) return;
            const portState = spikePrimeHubState[portKey];
            const portEl = document.getElementById(`spikePrimePort${port}`);
            const statusEl = document.getElementById(`spikePrimePort${port}Status`);

            if (ioType === null) {
                // Force disconnect if sensorValue is true (timeout)
                if (portState.connected && sensorValue !== true) return;
                portState.connected = false; portState.type = null; portState.typeName = 'Empty'; portState.sensorValue = null;
                if (portEl) portEl.classList.remove('has-device');
                if (statusEl) { statusEl.textContent = 'Empty'; statusEl.className = 'spike-prime-port-status'; }
                return;
            }

            const previousType = portState.type;
            const isNewDevice = previousType !== ioType;
            portState.connected = true; portState.type = ioType; portState.sensorValue = sensorValue;
            let displayName = IO_TYPE_NAMES[ioType] || `Type ${ioType.toString(16)}`;

            if ((ioType === 0x0B || ioType === 0x3F) && sensorValue !== null) displayName = `${sensorValue} N`;
            if (ioType === 0x0D && sensorValue !== null) displayName = (sensorValue < 0 || sensorValue > 2000) ? `35+ cm` : `${(sensorValue / 10).toFixed(1)} cm`;

            // Color Sensor Logic
            if (ioType === 0x0C && sensorValue !== null) {
                const colors = { [-1]: '--', 0: 'Black', 1: 'Violet', 3: 'Blue', 4: 'Cyan', 5: 'Green', 7: 'Yellow', 9: 'Red', 10: 'White' };
                const hex = { [-1]: '#888', 0: '#333', 1: '#9B59B6', 3: '#3498DB', 4: '#00BCD4', 5: '#27AE60', 7: '#F1C40F', 9: '#E74C3C', 10: '#FAFAFA' };
                const name = colors[sensorValue] || `#${sensorValue}`;
                const color = hex[sensorValue] || '#888';
                displayName = name;
                if (statusEl) {
                    if (!statusEl.querySelector('.color-indicator')) {
                        statusEl.innerHTML = `<div class="color-indicator" style="display:flex;align-items:center;justify-content:center;gap:6px"><span class="color-dot" style="width:14px;height:14px;border-radius:50%;background-color:${color};border:2px solid rgba(0,0,0,0.2)"></span><span class="color-name" style="font-size:11px">${name}</span></div>`;
                    } else {
                        const dot = statusEl.querySelector('.color-dot');
                        const text = statusEl.querySelector('.color-name');
                        if (dot) dot.style.backgroundColor = color;
                        if (text) text.textContent = name;
                    }
                }
            }

            // Motor Logic
            if (ioType === 0x0A && sensorValue !== null) {
                displayName = `Motor`;
                if (statusEl) {
                    if (!statusEl.querySelector('.motor-angle-indicator')) {
                        statusEl.innerHTML = `<div class="motor-angle-indicator" style="display:flex;align-items:center;justify-content:center;gap:6px"><svg width="20" height="20" viewBox="0 0 20 20"><circle cx="10" cy="10" r="8" fill="none" stroke="#666" stroke-width="2"/><line x1="10" y1="10" x2="10" y2="2" stroke="#37b24d" stroke-width="2" stroke-linecap="round" class="motor-needle"/></svg><span class="motor-angle-text" style="font-size:11px">${sensorValue}°</span></div>`;
                    } else {
                        const needle = statusEl.querySelector('.motor-needle');
                        const text = statusEl.querySelector('.motor-angle-text');
                        if (needle) needle.setAttribute("transform", `rotate(${sensorValue}, 10, 10)`);
                        if (text) text.textContent = `${sensorValue}°`;
                    }
                }
            } else {
                // Ensure text update for non-visual types immediately
                if (statusEl && ioType !== 0x0A && ioType !== 0x0C) {
                    statusEl.textContent = displayName;
                }
            }

            portState.typeName = displayName;
            if (ioType === 0x08 && typeof currentLanguage !== 'undefined' && currentLanguage === 'tr') portState.typeName = 'Işık';
            if (portEl) portEl.classList.add('has-device');
            if (isNewDevice) // console.log(`🔌 Port ${port}: Device Connected -> ${displayName}`);

                if (statusEl) {
                    const hasCustomVisual = (ioType === 0x0A || ioType === 0x0C) && sensorValue !== null;
                    // Double check to prevent overwrite
                    if (!hasCustomVisual) statusEl.textContent = portState.typeName;
                    statusEl.className = 'spike-prime-port-status' + (portState.connected ? ' connected' : '');
                }

            const forceContainer = document.getElementById('spikePrimeForceContainer');
            if (forceContainer) {
                const hasForce = Object.values(spikePrimeHubState).some(p => p && p.connected && (p.type === 0x3F || p.type === 0x0B));
                forceContainer.style.display = hasForce ? 'block' : 'none';
            }
        }

        function updateSpikePrimeGyro(x, y, z) {
            spikePrimeHubState.gyro = { x, y, z };
            const el = document.getElementById('spikePrimeGyroValue');
            if (el) el.textContent = `X:${x} Y:${y} Z:${z}`;
        }

        function updateSpikePrimeAccel(x, y, z) {
            spikePrimeHubState.accel = { x, y, z };
            const el = document.getElementById('spikePrimeAccelValue');
            if (el) el.textContent = `X:${x} Y:${y} Z:${z}`;
        }

        function updateSpikePrimeTilt(yaw, pitch, roll) {
            spikePrimeHubState.tilt = { yaw, pitch, roll };

            // Determine icon based on dominant tilt
            let icon = '⬛';
            if (Math.abs(pitch) > 30) icon = pitch > 0 ? '⬆️' : '⬇️';
            else if (Math.abs(roll) > 30) icon = roll > 0 ? '➡️' : '⬅️';
            else icon = '🔘';

            const iconEl = document.getElementById('spikePrimeTiltIcon');
            const valueEl = document.getElementById('spikePrimeTiltValue');
            if (iconEl) iconEl.textContent = icon;
            if (valueEl) valueEl.textContent = `Y:${yaw}° P:${pitch}° R:${roll}°`;
        }

        function updateSpikeHubBattery(percent, deviceId = null) {
            const devId = deviceId || spikeHubState.deviceId;
            spikeHubState.battery = percent;

            // Try dynamic display first, then fallback to static
            let percentEl = devId ? document.getElementById(`hubBatteryPercent_${devId}`) : null;
            let fillEl = devId ? document.getElementById(`hubBatteryFill_${devId}`) : null;
            let infoEl = devId ? document.getElementById(`hubBatteryInfo_${devId}`) : null;

            // Fallback to static IDs
            if (!percentEl) percentEl = document.getElementById('spikeEssentialBatteryPercent');
            if (!fillEl) fillEl = document.getElementById('spikeEssentialBatteryFill');
            if (!infoEl) infoEl = document.getElementById('spikeEssentialBatteryInfo');

            if (percentEl) percentEl.textContent = percent + '%';
            if (fillEl) fillEl.setAttribute('width', Math.round(14 * percent / 100));
            if (infoEl) {
                if (percent > 50) infoEl.style.color = '#37b24d';
                else if (percent > 20) infoEl.style.color = '#f59f00';
                else infoEl.style.color = '#e03131';
            }
        }

        function updateHubMotorGraphics(container, angle) {
            if (!container) return;
            const rotation = angle % 360;
            const svg = `
                <div style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" style=\"flex-shrink:0;\">
                        <circle cx=\"12\" cy=\"12\" r=\"10\" fill=\"none\" stroke=\"#666\" stroke-width=\"2\"/>
                        <line x1=\"12\" y1=\"12\" x2=\"12\" y2=\"2\" stroke=\"#2ecc71\" stroke-width=\"2\" transform=\"rotate(${rotation} 12 12)\"/>
                    </svg>
                    <span style=\"font-weight: bold; font-family: monospace; font-size: 14px; color: #2ecc71;\">${angle}°</span>
                </div>
            `;
            container.innerHTML = svg;
            if (container.parentElement) {
                container.parentElement.classList.add('has-device');
                container.parentElement.style.background = '#e6ffec';
                container.parentElement.style.border = '1px solid #69db7c';
            }
        }

        function updateSpikePortStatus(port, ioType, deviceId = null) {
            const devId = deviceId || spikeHubState.deviceId;

            // Support 4 ports (A, B, C, D) for Technic Hub
            let portState;
            switch (port) {
                case 'A': portState = spikeHubState.portA; break;
                case 'B': portState = spikeHubState.portB; break;
                case 'C': portState = spikeHubState.portC; break;
                case 'D': portState = spikeHubState.portD; break;
                default: return;
            }

            // Try dynamic display first, then fallback to static
            let statusEl = devId ? document.getElementById(`hubPort${port}Status_${devId}`) : null;
            if (!statusEl) statusEl = document.getElementById(`spikePort${port}Status`);

            if (ioType === null) {
                portState.connected = false;
                portState.type = null;
                portState.typeName = 'Empty';
            } else {
                portState.connected = true;
                portState.type = ioType;
                portState.typeName = IO_TYPE_NAMES[ioType] || `Type ${ioType.toString(16)}`;
                if (ioType === 0x08 && typeof currentLanguage !== 'undefined' && currentLanguage === 'tr') portState.typeName = 'Işık';
            }

            if (statusEl) {
                statusEl.textContent = portState.typeName;
                statusEl.className = 'spike-hub-port-status' + (portState.connected ? ' connected' : '');

                // Update parent container style
                const portContainer = statusEl.parentElement;
                if (portContainer && portContainer.classList.contains('spike-hub-port')) {
                    if (portState.connected) {
                        portContainer.classList.add('has-device');
                        portContainer.style.background = '#e6ffec';
                        portContainer.style.border = '1px solid #69db7c';
                    } else {
                        portContainer.classList.remove('has-device');
                        portContainer.style.background = '';
                        portContainer.style.border = '';
                    }
                }
            }
        }

        function updateSpikeGyro(x, y, z, deviceId = null) {
            const devId = deviceId || spikeHubState.deviceId;
            spikeHubState.gyro = { x, y, z };

            let el = devId ? document.getElementById(`hubGyroValue_${devId}`) : null;
            if (!el) el = document.getElementById('spikeGyroValue');
            if (el) el.textContent = `X:${x} Y:${y} Z:${z}`;
        }

        function updateSpikeAccel(x, y, z, deviceId = null) {
            const devId = deviceId || spikeHubState.deviceId;
            spikeHubState.accel = { x, y, z };

            let el = devId ? document.getElementById(`hubAccelValue_${devId}`) : null;
            if (!el) el = document.getElementById('spikeAccelValue');
            if (el) el.textContent = `X:${x} Y:${y} Z:${z}`;
        }

        function updateSpikeTilt(yaw, pitch, roll, deviceId = null) {
            const devId = deviceId || spikeHubState.deviceId;
            spikeHubState.tilt = { yaw, pitch, roll };
            spikeHubState.tiltName = `Y:${yaw} P:${pitch} R:${roll}`;

            // Determine icon based on dominant tilt
            let icon = '⬛';
            if (Math.abs(pitch) > 30) icon = pitch > 0 ? '⬆️' : '⬇️';
            else if (Math.abs(roll) > 30) icon = roll > 0 ? '➡️' : '⬅️';
            else icon = '🔘';

            let iconEl = devId ? document.getElementById(`hubTiltIcon_${devId}`) : null;
            let valueEl = devId ? document.getElementById(`hubTiltValue_${devId}`) : null;
            if (!iconEl) iconEl = document.getElementById('spikeTiltIcon');
            if (!valueEl) valueEl = document.getElementById('spikeTiltValue');

            if (iconEl) iconEl.textContent = icon;
            if (valueEl) valueEl.textContent = `Y:${yaw}° P:${pitch}° R:${roll}°`;
        }

        function updateSpikeHubColor(colorIndex, deviceId = null) {
            const devId = deviceId || spikeHubState.deviceId;
            spikeHubState.hubColor = colorIndex;
            const colorData = LEGO_COLORS[colorIndex] || { name: `Color ${colorIndex}`, hex: '#888888' };

            // Update the header with a color indicator
            let header = devId ? document.getElementById(`hubHeader_${devId}`) : null;
            if (!header) header = document.getElementById('spikeEssentialHeader');

            if (header) {
                // Add/update color indicator dot
                const dotId = devId ? `hubColorDot_${devId}` : 'spikeHubColorDot';
                let colorDot = document.getElementById(dotId);
                if (!colorDot) {
                    colorDot = document.createElement('span');
                    colorDot.id = dotId;
                    colorDot.style.cssText = 'display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-left: 8px; border: 2px solid rgba(255,255,255,0.5); vertical-align: middle;';
                    header.appendChild(colorDot);
                }
                colorDot.style.background = colorData.hex;
                colorDot.title = colorData.name;
            }
        }

        let lastExternalPortLog = 0;
        const externalPortData = { portA: null, portB: null, portC: null, portD: null };

        function handleSpikeHubNotification(event, hubTypeParam, deviceId = null) {
            // Get hub-specific state or fall back to legacy state
            const hubState = deviceId ? getHubState(deviceId) : spikeHubState;

            // Hub type'ı önce parametreden, yoksa hub state'den, o da yoksa varsayılan olarak al
            const hubType = hubTypeParam || hubState.hubType || 'spike_essential';

            const value = event.target.value;
            const rawData = new Uint8Array(value.buffer);

            // Debug: Her notification'ı logla
            if (!window._spikeMessageCount) window._spikeMessageCount = 0;
            window._spikeMessageCount++;

            if (window.SPIKE_DEBUG && window._spikeMessageCount <= 100) {
                const hex = [...rawData].map(b => b.toString(16).padStart(2, '0')).join(' ');
                console.log(`📥 RAW #${window._spikeMessageCount} [${rawData.length} bytes] (${deviceId || 'legacy'}): ${hex}`);
            }

            // FD02 servisi için SPIKE Prime Protocol 1.0 kullan
            const serviceUUID = hubState.notifyChar?.service?.uuid || '';
            const isFD02Service = serviceUUID.includes('fd02');

            if (isFD02Service) {
                // Debug: RAW veriyi logla
                if (!window._spikeFd02RawLogCount) window._spikeFd02RawLogCount = 0;
                if (window._spikeFd02RawLogCount < 5) {
                    const rawHex = [...rawData].map(b => b.toString(16).padStart(2, '0')).join(' ');
                    // console.log(`📨 FD02 RAW #${window._spikeFd02RawLogCount + 1} [${rawData.length}B]: ${rawHex.substring(0, 80)}...`);
                    window._spikeFd02RawLogCount++;
                }

                // ========== SPIKE App 3 Protocol Frame Detection ==========
                // New protocol frames end with 0x02 delimiter
                // Check if this is a new protocol frame
                const lastByte = rawData[rawData.length - 1];
                const isNewProtocolFrame = lastByte === SPIKE_DELIMITER;

                if (isNewProtocolFrame && rawData.length > 2) {
                    try {
                        // Use official SPIKE App 3 unpack (XOR + COBS decode)
                        const decoded = spikeApp3Unpack(rawData);

                        if (decoded.length > 0) {
                            // Debug: İlk 10 mesajı logla
                            if (!window._spikeFd02LogCount) window._spikeFd02LogCount = 0;
                            if (window._spikeFd02LogCount < 10) {
                                const hex = [...decoded].map(b => b.toString(16).padStart(2, '0')).join(' ');
                                // console.log(`📨 FD02 App3 DECODED #${window._spikeFd02LogCount + 1} [${decoded.length}B]: ${hex.substring(0, 60)}...`);
                                window._spikeFd02LogCount++;
                            }

                            // Parse the decoded message
                            handleSpikePrimeProtocolMessage(decoded);
                        }
                        return; // Processed
                    } catch (e) {
                        // If App 3 unpack fails, try other methods
                        if (window.SPIKE_DEBUG) {
                            console.log('⚠️ App 3 unpack failed, trying legacy methods:', e.message);
                        }
                    }
                }

                // ========== Legacy Format Detection ==========
                // PCAP formatı: 20-byte mesajlar, ilk byte COBS code (0x06)
                // Eğer RAW veri 20 byte ve ilk byte 0x06 ise, bu PCAP formatı
                if (rawData.length === 20 && rawData[0] === 0x06) {
                    // PCAP formatı - COBS encoded telemetri
                    // RAW format: 06 3f 4f a8 [portA] [portB] [portC] [portD] [portE] [portF] ...
                    const battery = rawData[1];
                    const portA = rawData[4];
                    const portB = rawData[5];
                    const portC = rawData[6];
                    const portD = rawData[7];
                    const portE = rawData[8];
                    const portF = rawData[9];

                    // Batarya güncelle
                    if (battery >= 0 && battery <= 100) {
                        updateSpikePrimeBattery(battery);
                    }

                    // Port güncelle
                    const updatePort = (port, value) => {
                        if (value === 0x67 || value === 0x00) {
                            updateSpikePrimePortStatus(port, null);
                        } else {
                            updateSpikePrimePortStatus(port, value);
                        }
                    };

                    updatePort('A', portA);
                    updatePort('B', portB);
                    updatePort('C', portC);
                    updatePort('D', portD);
                    updatePort('E', portE);
                    updatePort('F', portF);

                    // Force Sensor (byte 12 = 0x06 ise var, değer byte 15-18)
                    if (rawData[12] === 0x06 || rawData[12] === 0x3F) {
                        const dv = new DataView(rawData.buffer, rawData.byteOffset);
                        const forceValue = dv.getInt32(15, true);
                        updateSpikePrimeForceSensor(Math.max(0, Math.min(100, forceValue)));

                        // Force Sensor container göster
                        const forceContainer = document.getElementById('spikePrimeForceContainer');
                        if (forceContainer) forceContainer.style.display = 'block';
                    }

                    // Debug log
                    if (!window._spikeRawTelemetryLog) window._spikeRawTelemetryLog = 0;
                    if (window._spikeRawTelemetryLog < 3) {
                        console.log(`📊 Legacy Telemetry: bat=${battery}%, A=0x${portA.toString(16)}, D=0x${portD.toString(16)}`);
                        window._spikeRawTelemetryLog++;
                    }

                    return; // İşlendi
                }

                // ========== Standard COBS Fallback ==========
                // COBS decode dene (80-byte mesajlar için)
                try {
                    const decoded = cobsDecode(rawData);

                    if (decoded.length > 0) {
                        // Debug: İlk 10 mesajı logla
                        if (!window._spikeFd02LegacyLogCount) window._spikeFd02LegacyLogCount = 0;
                        if (window._spikeFd02LegacyLogCount < 10) {
                            const hex = [...decoded].map(b => b.toString(16).padStart(2, '0')).join(' ');
                            console.log(`📨 FD02 Legacy COBS #${window._spikeFd02LegacyLogCount + 1} [${decoded.length}B]: ${hex.substring(0, 60)}...`);
                            window._spikeFd02LegacyLogCount++;
                        }

                        // Parse et
                        handleSpikePrimeProtocolMessage(decoded);
                    }
                } catch (e) {
                    // COBS decode başarısız - belki farklı format
                    if (window.SPIKE_DEBUG) {
                        console.log('⚠️ Legacy COBS decode failed:', e.message);
                    }
                }

                return; // FD02 için burada bitir, LWP3 koduna gitme
            }

            // LWP3 protokolü (1623 servisi) için eski kod
            if (rawData.length < 3) return;

            const data = rawData;
            const msgType = data[2];

            // Determine if this is a 6-port hub (Spike Prime)
            const is6PortHub = hubType === 'spike_prime';
            const is4PortHub = (hubType === 'technic_medium_hub' || hubType === 'city_hub' || hubType === 'boost_move_hub');

            // Port ID to Letter mapping
            const getPortLetter = (portId) => {
                if (is6PortHub) {
                    // Spike Prime: A=0, B=1, C=2, D=3, E=4, F=5
                    const letters = ['A', 'B', 'C', 'D', 'E', 'F'];
                    return letters[portId] || null;
                } else if (is4PortHub) {
                    // Technic/City/Boost: A=0, B=1, C=2, D=3
                    const letters = ['A', 'B', 'C', 'D'];
                    return letters[portId] || null;
                } else {
                    // Essential: A=0, B=1
                    return portId === 0x00 ? 'A' : portId === 0x01 ? 'B' : null;
                }
            };

            // Hub Property (0x01)
            if (msgType === 0x01 && data.length > 5) {
                const property = data[3];
                // Property 0x01 = Advertising Name
                if (property === 0x01) {
                    let name = "";
                    for (let i = 5; i < data.length; i++) {
                        if (data[i] === 0) break;
                        name += String.fromCharCode(data[i]);
                    }
                    if (name) {
                        // console.log("🏷️ Hub Adı Güncellendi:", name);

                        // Update Panel Header (choose correct header based on hub type)
                        const headerId = is6PortHub ? 'spikePrimeHeader' : 'spikeEssentialHeader';
                        const header = document.getElementById(headerId);
                        if (header) {
                            // Keep the status circle
                            const statusCircle = header.querySelector('.status-circle');
                            header.textContent = name + ' ';
                            if (statusCircle) header.appendChild(statusCircle);
                        }

                        // Update Connected Device List
                        const device = connectedDevices.find(d => d.id === spikeHubState.deviceId);
                        if (device) {
                            device.name = name;
                            updateDevicesTable();
                        }

                        // Update Nickname Input if not focused
                        const nameInput = document.getElementById('spikeHubNicknameInput');
                        if (nameInput && document.activeElement !== nameInput) {
                            nameInput.value = name;
                        }
                    }
                }
            }

            // Port Output Command Feedback (0x82)
            if (msgType === 0x82) {
                console.log("↩️ CMD Feedback:", [...data].map(b => b.toString(16).padStart(2, '0')).join(' '));
            }

            // Port Mode Information (0x44)
            if (msgType === 0x44 && data.length >= 6) {
                const port = data[3];
                const mode = data[4];
                const infoType = data[5];

                // Mode Name (0x00)
                if (infoType === 0x00) {
                    let name = "";
                    for (let i = 6; i < data.length; i++) {
                        if (data[i] === 0) break;
                        name += String.fromCharCode(data[i]);
                    }
                    // console.log(`ℹ️ Mode ${mode} Name: ${name}`);
                }
                // Mode Format (0x80)
                else if (infoType === 0x80) {
                    const numValues = data[6];
                    const dataType = data[7]; // 0=8bit, 1=16bit...
                    // console.log(`ℹ️ Mode ${mode} Format: ${numValues} values, Type=${dataType}`);
                }
            }

            // Hub Attached I/O (0x04)
            if (msgType === 0x04 && data.length >= 5) {
                const portId = data[3];
                const attachEvent = data[4];

                // Check if this is an external port we care about
                // 6-port (Spike Prime): 0-5, 4-port (Technic/City/Boost): 0-3, 2-port (Essential): 0-1
                const maxPort = is6PortHub ? 5 : is4PortHub ? 3 : 1;

                if (portId >= 0x00 && portId <= maxPort) {
                    const portLetter = getPortLetter(portId);
                    if (!portLetter) return;

                    if (attachEvent === 0x00) {
                        // Detached - GERÇEK detach mesajı
                        console.log(`🔌 Port ${portLetter}: Detached (Attached IO message)`);
                        if (is6PortHub) {
                            // Doğrudan state'i güncelle
                            const portKey = `port${portLetter}`;
                            if (spikePrimeHubState[portKey]) {
                                spikePrimeHubState[portKey].connected = false;
                                spikePrimeHubState[portKey].type = null;
                                spikePrimeHubState[portKey].typeName = 'Empty';
                                spikePrimeHubState[portKey].sensorValue = null;
                            }
                            const portEl = document.getElementById(`spikePrimePort${portLetter}`);
                            const statusEl = document.getElementById(`spikePrimePort${portLetter}Status`);
                            if (portEl) portEl.classList.remove('has-device');
                            if (statusEl) {
                                statusEl.textContent = 'Empty';
                                statusEl.className = 'spike-prime-port-status';
                            }
                        } else {
                            updateSpikePortStatus(portLetter, null, deviceId);
                        }
                        if (portLetter === 'A') externalPortData.portA = null;
                        else if (portLetter === 'B') externalPortData.portB = null;
                        else if (portLetter === 'C') externalPortData.portC = null;
                        else if (portLetter === 'D') externalPortData.portD = null;
                    } else if (attachEvent === 0x01 && data.length >= 7) {
                        // Attached
                        const ioType = data[5] | (data[6] << 8);
                        // console.log(`🔌 Port ${portLetter}: Attached, IO Type: 0x${ioType.toString(16)} (${ioType}) [Device: ${deviceId || 'legacy'}]`);
                        if (is6PortHub) {
                            updateSpikePrimePortStatus(portLetter, ioType);
                        } else {
                            updateSpikePortStatus(portLetter, ioType, deviceId);
                        }

                        // Subscribe to the attached device using hub-specific writeChar
                        if (hubState.writeChar) {
                            subscribeToExternalPort(hubState.writeChar, portId, ioType);
                        }
                    }
                }
            }

            // Port Value (0x45) - Sensor data
            if (msgType === 0x45 && data.length >= 4) {
                const portId = data[3];

                // Debug: Port Value mesajlarını logla
                if (window.SPIKE_DEBUG) {
                    const hex = [...data].map(b => b.toString(16).padStart(2, '0')).join(' ');
                    const portNames = {
                        0x3C: 'Battery', 0x3D: 'Gyro(Prime)', 0x3E: 'Accel(Prime)', 0x3F: 'Tilt(Prime)',
                        0x31: 'StatusLED(Ess)', 0x61: is6PortHub ? 'StatusLED(Prime)' : 'Gyro(Ess)',
                        0x62: 'Accel(Ess)', 0x63: 'Tilt(Ess)'
                    };
                    const portName = portNames[portId] || `Port${portId}`;
                    console.log(`📊 [0x45] ${portName} (0x${portId.toString(16)}): ${hex}`);
                }

                // External Ports - check based on hub type
                // 6-port: 0-5, 4-port: 0-3, 2-port: 0-1
                const maxExternalPort = is6PortHub ? 5 : is4PortHub ? 3 : 1;
                if (portId >= 0x00 && portId <= maxExternalPort) {
                    const portLetter = getPortLetter(portId);
                    if (!portLetter) return;

                    // Force Sensor (0x003F) - value is in decinewtons, divide by 10
                    if (data.length >= 5) {
                        // Get port state based on hub type
                        let portState;
                        if (is6PortHub) {
                            portState = spikePrimeHubState[`port${portLetter}`];
                        } else {
                            // Support 4 ports (A, B, C, D) for Technic Hub
                            portState = spikeHubState[`port${portLetter}`];
                        }

                        if (portState && portState.type === 0x003F) { // Force Sensor
                            const forceRaw = data[4];
                            // Store raw value (0-100 decinewtons) in state for blocks to use
                            portState.value = forceRaw;

                            const forceN = (forceRaw / 10).toFixed(1);

                            // Try dynamic display first, then fallback to static
                            const devId = deviceId || spikeHubState.deviceId;
                            let statusEl = devId ? document.getElementById(`hubPort${portLetter}Status_${devId}`) : null;
                            if (!statusEl) {
                                const statusElId = is6PortHub ? `spikePrimePort${portLetter}Status` : `spikePort${portLetter}Status`;
                                statusEl = document.getElementById(statusElId);
                            }
                            if (statusEl) {
                                const isTr = currentLanguage === 'tr';
                                const label = isTr ? 'Kuvvet' : 'Force';
                                statusEl.textContent = `${label}: ${forceN}N`;
                            }
                        }

                        // Distance Sensor (0x003E) - value is in mm (16-bit), convert to cm
                        if (portState && portState.type === 0x003E) { // Distance Sensor
                            let distanceCm = 0;
                            // Ensure we have enough data bytes (need 5 and 6)
                            if (data.length >= 6) {
                                const distanceMm = data[4] | (data[5] << 8);
                                distanceCm = distanceMm / 10.0;
                            } else {
                                // Fallback for short packets (unlikely for valid sensor data)
                                distanceCm = data[4] || 0;
                            }

                            // Store calibrated value (cm) in state for blocks to use
                            portState.value = distanceCm;

                            const isTr = currentLanguage === 'tr';

                            // Try dynamic display first, then fallback to static
                            const devId = deviceId || spikeHubState.deviceId;
                            let statusEl = devId ? document.getElementById(`hubPort${portLetter}Status_${devId}`) : null;
                            if (!statusEl) {
                                const statusElId = is6PortHub ? `spikePrimePort${portLetter}Status` : `spikePort${portLetter}Status`;
                                statusEl = document.getElementById(statusElId);
                            }
                            if (statusEl) {
                                const label = isTr ? 'Mesafe' : 'Distance';
                                // Show cleanly formatted value (e.g. 4.0 cm)
                                // If value is very large (error/inf), assume max 200
                                let displayVal = distanceCm;
                                if (displayVal > 400) displayVal = 200; // Cap visual artifacts if any

                                if (displayVal >= 200) {
                                    statusEl.textContent = `${label}: 35+ cm`;
                                } else {
                                    statusEl.textContent = `${label}: ${displayVal.toFixed(1)} cm`;
                                }
                            }
                        }

                        // Motor Visual (Essential/Prime/Technic)
                        // IDs: 48(0x30), 49(0x31), 75(0x4B), 76(0x4C), 38(0x26), 39(0x27), 46(0x2E), 47(0x2F), 65(0x41), 66(0x42)
                        const motorTypes = [48, 49, 75, 76, 38, 39, 46, 47, 65, 66];
                        if (portState && motorTypes.includes(portState.type)) {
                            let angle = 0;
                            if (data.length >= 8) {
                                const dv = new DataView(data.buffer, data.byteOffset);
                                angle = dv.getInt32(4, true);
                            } else if (data.length >= 6) {
                                const dv = new DataView(data.buffer, data.byteOffset);
                                angle = dv.getInt16(4, true);
                            }
                            portState.value = angle;

                            const devId = deviceId || spikeHubState.deviceId;
                            let statusEl = devId ? document.getElementById(`hubPort${portLetter}Status_${devId}`) : null;
                            if (!statusEl) {
                                const statusElId = is6PortHub ? `spikePrimePort${portLetter}Status` : `spikePort${portLetter}Status`;
                                statusEl = document.getElementById(statusElId);
                            }

                            if (statusEl && typeof updateHubMotorGraphics === 'function') {
                                updateHubMotorGraphics(statusEl, angle);
                            }
                        }

                        // Color Sensor (0x003D - Type 61)
                        if (portState && (portState.type === 61 || portState.type === 0x3D)) {
                            const colorIndex = data[4];
                            // -1: No Object, 0: Black, 1: Violet, 3: Blue, 4: Azure, 5: Teal, 6: Green, 7: Yellow, 9: Red, 10: White
                            portState.value = colorIndex; // Store for blocks

                            const isTr = currentLanguage === 'tr';
                            const colorNames = {
                                255: isTr ? 'Yok' : 'None', // -1 usually comes as 255
                                0: isTr ? 'Siyah' : 'Black',
                                1: isTr ? 'Mor' : 'Violet',
                                3: isTr ? 'Mavi' : 'Blue',
                                4: isTr ? 'A.Mavi' : 'Azure',
                                5: isTr ? 'Turkuaz' : 'Teal',
                                6: isTr ? 'Yeşil' : 'Green',
                                7: isTr ? 'Sarı' : 'Yellow',
                                9: isTr ? 'Kırmızı' : 'Red',
                                10: isTr ? 'Beyaz' : 'White'
                            };

                            const colorName = colorNames[colorIndex] || (isTr ? 'Bilinmeyen' : 'Unknown');

                            const devId = deviceId || spikeHubState.deviceId;
                            let statusEl = devId ? document.getElementById(`hubPort${portLetter}Status_${devId}`) : null;
                            if (!statusEl) {
                                const statusElId = is6PortHub ? `spikePrimePort${portLetter}Status` : `spikePort${portLetter}Status`;
                                statusEl = document.getElementById(statusElId);
                            }

                            if (statusEl) {
                                const label = isTr ? 'Renk' : 'Color';
                                // Create a colored dot
                                let dotColor = '#ccc';
                                if (colorIndex === 0) dotColor = 'black';
                                else if (colorIndex === 1) dotColor = '#be00fe';
                                else if (colorIndex === 3) dotColor = '#2465d6';
                                else if (colorIndex === 4) dotColor = '#4dbeea';
                                else if (colorIndex === 5) dotColor = '#00857d';
                                else if (colorIndex === 6) dotColor = '#00a831';
                                else if (colorIndex === 7) dotColor = '#ffc90f';
                                else if (colorIndex === 9) dotColor = '#d30006';
                                else if (colorIndex === 10) dotColor = 'white';

                                // Reset to text content to avoid append loops, but use HTML for the dot
                                statusEl.innerHTML = `${label}: <span style="display:inline-block;width:10px;height:10px;border-radius:50%;background-color:${dotColor};border:1px solid #666;margin-right:4px;"></span>${colorName}`;
                            }
                        }

                    }
                }

                // Voltage Sensor (Port 0x3C = 60) - Battery
                if (portId === 0x3C && data.length >= 6) {
                    const rawValue = data[4] | (data[5] << 8); // ADC value (0-4095 typically)

                    // Default to Spike Essential/Prime (Lipo 2S) divisor ~83 for conservative estimate
                    let divisor = 83;

                    let deviceType = null;
                    const devData = connectedDevices.find(d => d.id === deviceId);
                    if (devData) {
                        deviceType = devData.type;
                    } else if (spikeHubState.deviceId && connectedDevices[spikeHubState.deviceId]) {
                        deviceType = connectedDevices[spikeHubState.deviceId].type;
                    }

                    // Technic Hub & Boost Hub use AA batteries (~9V), so use 47
                    if (deviceType === 'technic_medium_hub' || deviceType === 'boost_move_hub') {
                        divisor = 47;
                    }

                    const percent = Math.min(100, Math.max(0, Math.round(rawValue / divisor)));
                    if (is6PortHub) {
                        updateSpikePrimeBattery(percent);
                    } else {
                        updateSpikeHubBattery(percent, deviceId);
                    }
                }

                // RGB Status Light - SPIKE Prime: 0x61 (97), Essential: 0x31 (49)
                const statusLedPort = is6PortHub ? 0x61 : 0x31;
                if (portId === statusLedPort && data.length >= 5) {
                    const colorIndex = data[4];
                    updateSpikeHubColor(colorIndex, deviceId);
                }

                // Gyroscope - SPIKE Prime: 0x3D (61), Essential: 0x61 (97)
                const gyroPort = is6PortHub ? 0x3D : 0x61;
                if (portId === gyroPort && data.length >= 10) {
                    const x = new DataView(data.buffer).getInt16(4, true);
                    const y = new DataView(data.buffer).getInt16(6, true);
                    const z = new DataView(data.buffer).getInt16(8, true);
                    if (is6PortHub) {
                        updateSpikePrimeGyro(x, y, z);
                    } else {
                        updateSpikeGyro(x, y, z, deviceId);
                    }
                }

                // Accelerometer - SPIKE Prime: 0x3E (62), Essential: 0x62 (98)
                const accelPort = is6PortHub ? 0x3E : 0x62;
                if (portId === accelPort && data.length >= 10) {
                    const x = new DataView(data.buffer).getInt16(4, true);
                    const y = new DataView(data.buffer).getInt16(6, true);
                    const z = new DataView(data.buffer).getInt16(8, true);
                    if (is6PortHub) {
                        updateSpikePrimeAccel(x, y, z);
                    } else {
                        updateSpikeAccel(x, y, z, deviceId);
                    }
                }

                // Tilt - SPIKE Prime: 0x3F (63), Essential: 0x63 (99)
                const tiltPort = is6PortHub ? 0x3F : 0x63;
                if (portId === tiltPort && data.length >= 10) {
                    const yaw = new DataView(data.buffer).getInt16(4, true);
                    const pitch = new DataView(data.buffer).getInt16(6, true);
                    const roll = new DataView(data.buffer).getInt16(8, true);
                    if (is6PortHub) {
                        updateSpikePrimeTilt(yaw, pitch, roll);
                    } else {
                        updateSpikeTilt(yaw, pitch, roll, deviceId);
                    }
                }
            }
        }

        // Subscription Queue System - prevents race conditions
        const subscriptionQueue = [];
        let isProcessingQueue = false;

        async function processSubscriptionQueue() {
            if (isProcessingQueue || subscriptionQueue.length === 0) return;

            isProcessingQueue = true;

            while (subscriptionQueue.length > 0) {
                const { writeChar, portId, ioType } = subscriptionQueue.shift();

                try {
                    // Determine best mode for device
                    let mode = 0x00; // Default
                    let delta = 1;   // Default delta

                    // Motors: Use Mode 3 (Absolute Position) for accurate angle
                    // IDs: 48, 49, 75, 76, 38, 39, 46, 47
                    const motorTypes = [48, 49, 75, 76, 38, 39, 46, 47];
                    if (motorTypes.includes(ioType)) {
                        mode = 0x03;
                        delta = 2;
                    }

                    // Port Input Format Setup (0x41)
                    const d1 = delta & 0xFF;
                    const d2 = (delta >> 8) & 0xFF;
                    await writeChar.writeValueWithoutResponse(new Uint8Array([0x0A, 0x00, 0x41, portId, mode, d1, d2, 0x00, 0x00, 0x01]));

                    const portLetters = ['A', 'B', 'C', 'D', 'E', 'F'];
                    const portLetter = portLetters[portId] || portId.toString();
                    // console.log(`✅ Port ${portLetter} subscription sent (IO Type: 0x${ioType.toString(16)})`);

                    // Wait between subscriptions to let Hub process
                    await new Promise(r => setTimeout(r, 250));
                } catch (e) {
                    console.error('❌ External port subscription error:', e);
                }
            }

            isProcessingQueue = false;
        }

        // Subscribe to external port device (queued)
        function subscribeToExternalPort(writeChar, portId, ioType) {
            if (!writeChar) return;

            // Add to queue
            subscriptionQueue.push({ writeChar, portId, ioType });

            // Start processing if not already running
            processSubscriptionQueue();
        }

        // Subscribe to sensor notifications
        async function subscribeSpikeHubSensors(writeChar, hubType = 'spike_essential') {
            if (!writeChar) return;

            try {
                const isPrime = hubType === 'spike_prime';
                const serviceUUID = spikeHubState.notifyChar?.service?.uuid || '';
                const isFD02Service = serviceUUID.includes('fd02');

                // console.log(`🔧 Service UUID: ${serviceUUID}`);
                // console.log(`🔧 Hub Type: ${hubType}, isFD02: ${isFD02Service}`);

                // FD02 servisi SPIKE Prime Protocol kullanıyor
                if (isFD02Service) {
                    // console.log('📤 FD02 Service - SPIKE App 3 Protocol (Hybrid Mode)');

                    try {
                        // ========== SPIKE App 3 Protocol (New - Correct) ==========
                        // Based on official LEGO documentation
                        // Uses COBS encoding with XOR 0x03 and 0x02 delimiter

                        // // console.log('🔷 Starting SPIKE App 3 Protocol initialization...');

                        // Step 1: InfoRequest (0x00) - Get hub capabilities
                        // This should return InfoResponse (0x01) with max_packet_size, etc.
                        const infoReq = buildInfoRequest();
                        // console.log('📤 [1] InfoRequest (0x00):', [...infoReq].map(b => b.toString(16).padStart(2, '0')).join(' '));
                        await writeChar.writeValueWithoutResponse(infoReq);
                        await new Promise(r => setTimeout(r, 300));

                        // Step 2: GetHubNameRequest (0x18)
                        const hubNameReq = buildGetHubNameRequest();
                        // console.log('📤 [2] GetHubNameRequest (0x18):', [...hubNameReq].map(b => b.toString(16).padStart(2, '0')).join(' '));
                        await writeChar.writeValueWithoutResponse(hubNameReq);
                        await new Promise(r => setTimeout(r, 200));

                        // Step 3: DeviceUuidRequest (0x1A)
                        const uuidReq = buildDeviceUuidRequest();
                        // console.log('📤 [3] DeviceUuidRequest (0x1A):', [...uuidReq].map(b => b.toString(16).padStart(2, '0')).join(' '));
                        await writeChar.writeValueWithoutResponse(uuidReq);
                        await new Promise(r => setTimeout(r, 200));

                        // Step 4: DeviceNotificationRequest (0x28) - 100ms interval
                        // This enables continuous sensor/device notifications
                        const notifReq = buildDeviceNotificationRequest(100);
                        // console.log('📤 [4] DeviceNotificationRequest (0x28, 100ms):', [...notifReq].map(b => b.toString(16).padStart(2, '0')).join(' '));
                        await writeChar.writeValueWithoutResponse(notifReq);
                        await new Promise(r => setTimeout(r, 300));

                        // console.log('✅ SPIKE App 3 Protocol init complete!');

                        // ========== Legacy Fallback (for older firmware) ==========
                        // Some hubs may still respond to legacy commands
                        // These use different framing (0x02 delimiter without XOR)

                        // console.log('🔶 Sending legacy fallback commands...');

                        // Legacy: 00 00 02 (triggers 0x54 DeviceInfo on old firmware)
                        // console.log('📤 [5] Legacy init: 00 00 02');
                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x00, 0x00, 0x02]));
                        await new Promise(r => setTimeout(r, 300));

                        // Legacy: Streaming start (103ms interval)
                        // console.log('📤 [6] Legacy streaming: 06 2b 67 00 02');
                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x06, 0x2b, 0x67, 0x00, 0x02]));
                        await new Promise(r => setTimeout(r, 200));

                        // console.log('✅ Hybrid initialization complete (App 3 + Legacy)!');

                    } catch (e) {
                        console.error('⚠️ SPIKE Prime init hatası:', e.message);
                    }

                    // FD02 için LWP3 komutları ÇALIŞMAZ, atla
                    return;
                }

                // SPIKE Prime ve Essential farklı internal port numaraları kullanıyor
                const ports = {
                    voltage: 0x3C,  // Her ikisinde de aynı
                    gyro: isPrime ? 0x3D : 0x61,
                    accel: isPrime ? 0x3E : 0x62,
                    tilt: isPrime ? 0x3F : 0x63,
                    statusLed: isPrime ? 0x61 : 0x31
                };

                // console.log(`🔧 ${isPrime ? 'SPIKE Prime' : 'SPIKE Essential'} sensor ports:`, ports);

                // Hub Properties Request - response tetiklemeli
                // Hub Properties Request - response tetiklemeli
                // console.log('📤 Hub Properties Request gönderiliyor...');
                await writeChar.writeValueWithoutResponse(new Uint8Array([0x05, 0x00, 0x01, 0x01, 0x05]));
                await new Promise(r => setTimeout(r, 100));

                // Port Input Format Setup (0x41): Subscribe to sensor data
                const subscribeToPort = async (portId, portName) => {
                    const msg = new Uint8Array([0x0A, 0x00, 0x41, portId, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01]);
                    // console.log(`📤 Subscribing to ${portName} (Port 0x${portId.toString(16)}): ${[...msg].map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
                    await writeChar.writeValueWithoutResponse(msg);
                    await new Promise(r => setTimeout(r, 100));
                };

                await subscribeToPort(ports.voltage, 'Voltage/Battery');
                await subscribeToPort(ports.gyro, 'Gyroscope');
                await subscribeToPort(ports.accel, 'Accelerometer');
                await subscribeToPort(ports.tilt, 'Tilt');
                await subscribeToPort(ports.statusLed, 'Status LED');

                // Hub Alerts Enable
                // console.log('📤 Hub Alerts Enable gönderiliyor...');
                await writeChar.writeValueWithoutResponse(new Uint8Array([0x05, 0x00, 0x03, 0x01, 0x01]));
                await new Promise(r => setTimeout(r, 50));

                // console.log('✅ Spike Hub sensor subscriptions sent');
                // console.log(`📡 Subscribed ports: Voltage=0x${ports.voltage.toString(16)}, Gyro=0x${ports.gyro.toString(16)}, Accel=0x${ports.accel.toString(16)}, Tilt=0x${ports.tilt.toString(16)}, LED=0x${ports.statusLed.toString(16)}`);
            } catch (e) {
                console.error('❌ Spike Hub sensor subscription error:', e);
            }
        }


        async function startSpikeHubMonitoring(device, notifyChar, writeChar, deviceColor, friendlyName, hubType = 'spike_essential') {
            const hubName = hubType === 'spike_prime' ? 'Spike Prime' :
                hubType === 'technic_medium_hub' ? 'Technic Medium' :
                    hubType === 'city_hub' ? 'City' :
                        hubType === 'boost_move_hub' ? 'Boost Move' : 'Spike Essential';
            // console.log(`🔌 ${hubName} Hub monitoring başlatılıyor... (Device: ${device.id})`);

            // Get or create hub-specific state
            const hubState = getHubState(device.id);
            hubState.hubType = hubType;
            hubState.deviceId = device.id;
            hubState.notifyChar = notifyChar;
            hubState.writeChar = writeChar;

            // Also update legacy spikeHubState for backward compatibility (points to last connected hub)
            spikeHubState.hubType = hubType;
            spikeHubState.deviceId = device.id;
            spikeHubState.notifyChar = notifyChar;
            spikeHubState.writeChar = writeChar;

            try {
                // 1. Define Handler FIRST - capture deviceId in closure
                const deviceId = device.id;
                const notificationHandler = (event) => {
                    // Critical Debug for Silent Hub
                    if (window.SPIKE_DEBUG) {
                        console.log('🔔🔔🔔 NOTIFICATION RECEIVED! 🔔🔔🔔');
                        if (event.target && event.target.value) {
                            const data = new Uint8Array(event.target.value.buffer);
                            console.log('🔔 Data bytes:', [...data].map(b => b.toString(16).padStart(2, '0')).join(' '));
                        }
                    }
                    // Pass deviceId to notification handler
                    handleSpikeHubNotification(event, hubType, deviceId);
                };

                // Save for debug
                window._spikeNotifyChar = notifyChar;
                window._spikeNotifyHandler = notificationHandler;

                // 2. Add Listeners BEFORE starting notifications (Best Practice)
                // console.log('🔔 Event listener eklendi (pre-start).');
                notifyChar.addEventListener('characteristicvaluechanged', notificationHandler);

                // Backup: Direct assignment for compatibility
                notifyChar.oncharacteristicvaluechanged = notificationHandler;

                // 3. Start notifications
                // console.log('🔔 startNotifications() çağrılıyor...');
                // console.log('🔔 notifyChar.properties:', notifyChar.properties);

                await notifyChar.startNotifications();
                // console.log(`✅ ${hubName} Hub notifications başlatıldı`);

                // 4. Verify Active
                // console.log('🔔 Notifications aktif mi:', notifyChar.properties.notify);

                // --- OLD CODE BELOW REMOVED/REORDERED ---
                // Notification'ın gerçekten aktif olduğunu doğrula ve readValue denemesi
                /* 
                try {
                    const initialValue = await notifyChar.readValue(); // Genelde hata verir
                } catch (e) {}
                */

                // Show appropriate display based on hub type
                if (hubType === 'spike_prime') {
                    showSpikePrimeDisplay(device, deviceColor, friendlyName);
                } else if (hubType === 'city_hub') {
                    showCityHubDisplay(device, deviceColor);
                } else if (hubType === 'boost_move_hub') {
                    showBoostHubDisplay(device, deviceColor);
                } else {
                    showSpikeEssentialDisplay(device, deviceColor, friendlyName, hubType);
                }

                // Subscribe to sensors after a short delay
                await new Promise(r => setTimeout(r, 200));
                await subscribeSpikeHubSensors(writeChar, hubType);

                // console.log(`✅ ${hubName} Hub monitoring aktif!`);

                // Check for silence after a few seconds
                setTimeout(() => {
                    if (!notifyChar.value && (!window._spikeMessageCount || window._spikeMessageCount === 0)) {
                        console.warn('⚠️ HİÇ MESAJ GELMEDİ! Notification çalışmıyor olabilir.');
                        console.log('💡 Deneme: Hub üzerindeki butona bas veya hub\'ı hareket ettir');
                    }
                }, 2000);

            } catch (err) {
                console.error(`❌ ${hubName} Hub notification başlatma hatası:`, err);
            }
        }


        // Motor notification verisi formatı:
        // Payload[7] = mode byte (0x00=idle, 0x01=moving, 0x07=holding)
        // Payload[8-9] = Anlık açı (little-endian signed 16-bit)
        // Payload[13-14] = Hedef açı (little-endian signed 16-bit)

        async function startMotorAngleMonitoring(device, notifyChar, deviceId, deviceColor) {
            console.log('⚙️ Motor açı monitoring başlatılıyor...');

            activeMotorDevice = device;
            activeMotorCharacteristic = notifyChar;
            motorState.deviceId = deviceId;
            motorMonitoringActive = true;

            try {
                // Notification'ları başlat
                await notifyChar.startNotifications();
                console.log('✅ Motor notifications başlatıldı');

                // Event listener ekle
                notifyChar.addEventListener('characteristicvaluechanged', handleMotorNotification);

                console.log('✅ Motor angle monitoring aktif!');

            } catch (err) {
                console.error('❌ Motor notification başlatma hatası:', err);
                motorMonitoringActive = false;
            }
        }

        function handleMotorNotification(event) {
            const value = event.target.value;

            // Minimum byte gereksinimi
            if (value.byteLength < 4) {
                return;
            }

            // RAW HEX DUMP (Debug için devre dışı)
            // const bytes = new Uint8Array(value.buffer);
            // const hexDump = [...bytes].map(b => b.toString(16).padStart(2, '0')).join(' ');
            // if (!handleMotorNotification.logCount) handleMotorNotification.logCount = 0;
            // if (handleMotorNotification.logCount < 20) {
            //     console.log(`📦 Motor RAW [${value.byteLength} bytes]: ${hexDump}`);
            //     handleMotorNotification.logCount++;
            // }

            let currentAngle = 0;
            let targetAngle = 0;
            let mode = 0;

            // PCAP ANALİZİ sonucu (21 byte paket):
            // 90°:  3c 12 00 00 5a 00 0a 01 07 [5a] 00 00 00 00 5a 00 00 00 11 01 ff
            // 240°: 3c 12 00 00 5a 00 0a 01 07 [f0] 00 00 00 00 ef 00 00 00 11 01 ff
            // Index 9 = Mevcut açı (0x5a=90, 0xf0=240)
            // Index 14 = Hedef açı (yaklaşık)
            // Index 8 = Mode byte (0x07 = holding)

            if (value.byteLength >= 15) {
                // Mode byte at index 8
                mode = value.getUint8(8);

                // Açı index 9-10'da (little-endian int16 olarak deneyelim önce)
                // Eğer 360'tan büyük değerler varsa int16 kullan
                const angleInt16 = value.getInt16(9, true);
                const angleUint8 = value.getUint8(9);

                // 360'tan küçükse uint8, büyükse int16 kullan
                if (Math.abs(angleInt16) > 360 && angleUint8 <= 255) {
                    // Muhtemelen tek byte
                    currentAngle = angleUint8;
                } else {
                    // int16 olarak dene
                    currentAngle = angleInt16;
                }

                // Hedef açı index 14-15
                if (value.byteLength >= 16) {
                    targetAngle = value.getInt16(14, true);
                    // Aynı mantık
                    if (Math.abs(targetAngle) > 360) {
                        targetAngle = value.getUint8(14);
                    }
                }
            }
            // Daha kısa paketler için fallback
            else if (value.byteLength >= 10) {
                currentAngle = value.getUint8(9);
            }

            // State güncelle
            const prevAngle = motorState.currentAngle;
            motorState.currentAngle = currentAngle;
            motorState.targetAngle = targetAngle;
            motorState.mode = mode;
            motorState.isMoving = (mode === 0x01);

            // Pil yüzdesini al (index 4)
            let batteryPercent = 0;
            if (value.byteLength >= 5) {
                batteryPercent = value.getUint8(4);
                // 0-100 arasına normalize et (bazı cihazlar farklı aralık kullanabilir)
                if (batteryPercent > 100) {
                    // Belki 0-255 aralığında, yüzdeye çevir
                    batteryPercent = Math.round((batteryPercent / 255) * 100);
                }
                motorState.battery = batteryPercent;
            }

            // Görsel güncelleme (throttled)
            const now = Date.now();
            if (now - motorLastVisualUpdate >= MOTOR_VISUAL_UPDATE_INTERVAL) {
                motorLastVisualUpdate = now;
                updateMotorAngleDisplay(currentAngle);

                // Pil göstergesini güncelle
                const batteryEl = document.getElementById('motorBatteryPercent');
                const batteryFill = document.getElementById('motorBatteryFill');
                if (batteryEl) {
                    batteryEl.textContent = `${batteryPercent}%`;

                    // Pil doluluk göstergesini güncelle (max genişlik: 14px)
                    if (batteryFill) {
                        const fillWidth = Math.round((batteryPercent / 100) * 14);
                        batteryFill.setAttribute('width', fillWidth);
                    }

                    // Pil düşükse rengi değiştir
                    if (batteryPercent < 20) {
                        batteryEl.parentElement.style.color = '#e03131';
                    } else if (batteryPercent < 50) {
                        batteryEl.parentElement.style.color = '#fab005';
                    } else {
                        batteryEl.parentElement.style.color = '#37b24d';
                    }
                }
            }

            // Debug log (sadece değişiklik varsa) - KALDIRILDI
            // if (Math.abs(prevAngle - currentAngle) > 1) {
            //    console.log(`⚙️ Motor: ${currentAngle}° (hedef: ${targetAngle}°, mode: 0x${mode.toString(16)})`);
            // }
        }

        function updateMotorAngleDisplay(angle) {
            const shaft = document.getElementById('motorShaft');
            const info = document.getElementById('motorAngleInfo');

            if (shaft) {
                // Görsel dönüş için tam açıyı kullanabiliriz (animasyon varsa düzgün döner)
                shaft.style.transform = `rotate(${angle}deg)`;
            }

            if (info) {
                // Metin gösterimi için 0-359 arasına normalize et
                // ((angle % 360) + 360) % 360 formülü negatif sayıları da doğru işler
                const normalizedAngle = Math.round(((angle % 360) + 360) % 360);
                info.textContent = `${normalizedAngle}°`;
            }
        }

        function stopMotorAngleMonitoring() {
            if (activeMotorCharacteristic) {
                try {
                    activeMotorCharacteristic.removeEventListener('characteristicvaluechanged', handleMotorNotification);

                    // Sadece cihaz hala bağlıysa notification'ı durdurmayı dene
                    // Bağlantı zaten koptuysa (NetworkError) buna gerek yok
                    if (activeMotorDevice && activeMotorDevice.gatt && activeMotorDevice.gatt.connected) {
                        activeMotorCharacteristic.stopNotifications().catch(err => {
                            // Sessizce yut, zaten durduruyoruz
                        });
                    }
                } catch (e) {
                    console.log('Motor notification durdurma hatası:', e);
                }
            }

            motorMonitoringActive = false;
            activeMotorDevice = null;
            activeMotorCharacteristic = null;
            motorState.deviceId = null;

            console.log('⚙️ Motor angle monitoring durduruldu');
        }

        // ===== DOUBLE MOTOR MONITORING FUNCTIONS =====
        // PCAP Analizi sonucu (dmotor_init__1_.pcap):
        // Kısa mesaj (17 byte): Device Info - Byte 7 = Batarya yüzdesi (0x3e = 62%)
        // Uzun mesaj (59 byte): Sensör verisi
        //   - Byte 32-35: Motor 1 pozisyon (int32 little-endian)
        //   - Byte 44-47: Motor 2 pozisyon (int32 little-endian)

        async function startDoubleMotorMonitoring(device, notifyChar, deviceId, deviceColor) {
            console.log('⚙️⚙️ Double Motor monitoring başlatılıyor...');

            activeDoubleMotorDevice = device;
            activeDoubleMotorCharacteristic = notifyChar;
            doubleMotorState.deviceId = deviceId;
            doubleMotorMonitoringActive = true;

            try {
                // Notification'ları başlat
                await notifyChar.startNotifications();
                console.log('✅ Double Motor notifications başlatıldı');

                // Event listener ekle
                notifyChar.addEventListener('characteristicvaluechanged', handleDoubleMotorNotification);

                console.log('✅ Double Motor monitoring aktif!');

            } catch (err) {
                console.error('❌ Double Motor notification başlatma hatası:', err);
                doubleMotorMonitoringActive = false;
            }
        }

        function handleDoubleMotorNotification(event) {
            const value = event.target.value;
            const rawData = new Uint8Array(value.buffer);

            // Debug: İlk 10 mesajı logla
            if (!handleDoubleMotorNotification.logCount) handleDoubleMotorNotification.logCount = 0;
            if (handleDoubleMotorNotification.logCount < 10) {
                const hexDump = [...rawData].map(b => b.toString(16).padStart(2, '0')).join(' ');
                console.log(`📦 Double Motor RAW [${rawData.length} bytes]: ${hexDump.substring(0, 80)}...`);
                handleDoubleMotorNotification.logCount++;
            }

            // PCAP Analizi sonucu:
            // Kısa mesaj (17 byte): 01 01 00 31 00 01 00 [3e] 00 01 00 00 00 f7 00 01 02
            //   - Byte 7 = batarya yüzdesi (0x3e = 62%)
            // Uzun mesaj (59 byte): Sensör verisi
            //   - Byte 32-35: Motor 1 pozisyon (int32 LE) = 156°
            //   - Byte 44-47: Motor 2 pozisyon (int32 LE) = 51°

            if (rawData.length >= 17 && rawData.length < 50) {
                // Kısa mesaj - Device Info / Battery
                const batteryPercent = rawData[7];
                if (batteryPercent >= 0 && batteryPercent <= 100) {
                    doubleMotorState.battery = batteryPercent;
                    console.log(`🔋 Double Motor Battery: ${batteryPercent}%`);
                    updateDoubleMotorBatteryDisplay(batteryPercent);
                }
            }
            else if (rawData.length >= 48) {
                // Uzun mesaj - Sensör verisi (59 byte)
                // Motor pozisyonları: offset 32 ve 44'te int32 LE olarak
                const dv = new DataView(rawData.buffer, rawData.byteOffset);

                // Motor 1 pozisyonu (offset 32)
                const motor1Angle = dv.getInt32(32, true);

                // Motor 2 pozisyonu (offset 44)
                const motor2Angle = dv.getInt32(44, true);

                // Batarya raw değeri byte 6'da olabilir (170, 171 gibi değerler - normalize etmemiz gerekebilir)
                // Ancak asıl batarya yüzdesi kısa mesajda geliyor

                // State güncelle
                const prevAngle1 = doubleMotorState.motor1Angle;
                const prevAngle2 = doubleMotorState.motor2Angle;
                doubleMotorState.motor1Angle = motor1Angle;
                doubleMotorState.motor2Angle = motor2Angle;

                // Görsel güncelleme (throttled)
                const now = Date.now();
                if (now - doubleMotorLastVisualUpdate >= MOTOR_VISUAL_UPDATE_INTERVAL) {
                    doubleMotorLastVisualUpdate = now;
                    updateDoubleMotorAngleDisplay(motor1Angle, motor2Angle);
                }

                // Debug log (sadece değişiklik varsa)
                if (Math.abs(prevAngle1 - motor1Angle) > 1 || Math.abs(prevAngle2 - motor2Angle) > 1) {
                    console.log(`⚙️⚙️ Double Motor: M1=${motor1Angle}° M2=${motor2Angle}°`);
                }
            }
        }

        function updateDoubleMotorAngleDisplay(angle1, angle2) {
            const shaft1 = document.getElementById('doubleMotorShaft1');
            const info1 = document.getElementById('doubleMotorAngle1');
            const shaft2 = document.getElementById('doubleMotorShaft2');
            const info2 = document.getElementById('doubleMotorAngle2');

            // Motor 1
            if (shaft1) {
                shaft1.style.transform = `rotate(${angle1}deg)`;
            }
            if (info1) {
                const normalizedAngle1 = Math.round(((angle1 % 360) + 360) % 360);
                info1.textContent = `${normalizedAngle1}°`;
            }

            // Motor 2
            if (shaft2) {
                shaft2.style.transform = `rotate(${angle2}deg)`;
            }
            if (info2) {
                const normalizedAngle2 = Math.round(((angle2 % 360) + 360) % 360);
                info2.textContent = `${normalizedAngle2}°`;
            }
        }

        function updateDoubleMotorBatteryDisplay(batteryPercent) {
            const batteryEl = document.getElementById('doubleMotorBatteryPercent');
            const batteryFill = document.getElementById('doubleMotorBatteryFill');
            const batteryInfo = document.getElementById('doubleMotorBatteryInfo');

            if (batteryEl) {
                batteryEl.textContent = `${batteryPercent}%`;
            }

            if (batteryFill) {
                const fillWidth = Math.round((batteryPercent / 100) * 14);
                batteryFill.setAttribute('width', fillWidth);
            }

            if (batteryInfo) {
                // Pil düşükse rengi değiştir
                if (batteryPercent < 20) {
                    batteryInfo.style.color = '#e03131';
                } else if (batteryPercent < 50) {
                    batteryInfo.style.color = '#fab005';
                } else {
                    batteryInfo.style.color = '#37b24d';
                }
            }
        }

        function stopDoubleMotorMonitoring() {
            if (activeDoubleMotorCharacteristic) {
                try {
                    activeDoubleMotorCharacteristic.removeEventListener('characteristicvaluechanged', handleDoubleMotorNotification);
                    activeDoubleMotorCharacteristic.stopNotifications();
                } catch (e) {
                    console.log('Double Motor notification durdurma hatası:', e);
                }
            }

            doubleMotorMonitoringActive = false;
            activeDoubleMotorDevice = null;
            activeDoubleMotorCharacteristic = null;
            doubleMotorState.deviceId = null;

            console.log('⚙️⚙️ Double Motor monitoring durduruldu');
        }

        // Double Motor açılarını al (bloklar için)
        function getDoubleMotorAngle(deviceId, motorIndex = 1) {
            if (doubleMotorState.deviceId === deviceId) {
                return motorIndex === 1 ? doubleMotorState.motor1Angle : doubleMotorState.motor2Angle;
            }
            return 0;
        }

        // Global'e ekle
        window.getDoubleMotorAngle = getDoubleMotorAngle;
        window.doubleMotorState = doubleMotorState;
        // ===== END DOUBLE MOTOR MONITORING =====

        // Motor açısını al (bloklar için)
        function getMotorAngle(deviceId) {
            if (motorState.deviceId === deviceId) {
                return motorState.currentAngle;
            }
            return 0;
        }

        // Global'e ekle
        window.getMotorAngle = getMotorAngle;
        window.motorState = motorState;

        // RGB Display güncelleme fonksiyonları
        function updateRGBDisplay() {
            const redLed = document.getElementById('rgbRedLed');
            const greenLed = document.getElementById('rgbGreenLed');
            const blueLed = document.getElementById('rgbBlueLed');

            if (redLed) {
                redLed.classList.toggle('active', rgbLedState.red);
            }
            if (greenLed) {
                greenLed.classList.toggle('active', rgbLedState.green);
            }
            if (blueLed) {
                blueLed.classList.toggle('active', rgbLedState.blue);
            }
        }

        function updateRGBNumberDisplay() {
            const redNum = document.getElementById('rgbRedNum');
            const greenNum = document.getElementById('rgbGreenNum');
            const blueNum = document.getElementById('rgbBlueNum');

            if (redNum) redNum.textContent = rgbNumberState.red;
            if (greenNum) greenNum.textContent = rgbNumberState.green;
            if (blueNum) blueNum.textContent = rgbNumberState.blue;
        }

        // Tüm açık pop-up panelleri kapatır
        function closeAllPopups() {
            closeNumberPanel();
            closeAnglePanel();
            closeMessagePanel();
        }

        // Custom Angle Field (Açı seçici)
        class CustomAngleField extends Blockly.FieldNumber {
            showEditor_() {
                closeAllPopups(); // Önce diğerlerini kapat
                const fieldRect = this.getScaledBBox();
                const panel = document.getElementById('anglePanel');

                currentAngle = parseInt(this.getValue()) || 0;
                currentAngleField = this;

                updateAngleDisplay();

                panel.style.left = (fieldRect.right + 10) + 'px';
                panel.style.top = fieldRect.top + 'px';
                panel.classList.add('active');

                // Açı dairesi interaksiyonunu kur
                setTimeout(() => {
                    setupAngleCircleInteraction();
                }, 50);

                document.addEventListener('click', closeAnglePanelOnClickOutside);
            }
        }

        // Custom Message Field with Dropdown
        class CustomMessageField extends Blockly.FieldDropdown {
            constructor(value) {
                // Etiketin sonuna boşluk ekle ki ok işareti üstüne binmesin
                const options = messages.map(m => [m + '   ', m]);
                options.push(['➕ Yeni mesaj...', 'NEW']);
                super(options);
                this.setValue(value || messages[0]);
            }

            doValueUpdate_(newValue) {
                super.doValueUpdate_(newValue);

                // NEW seçilirse panel aç
                if (newValue === 'NEW') {
                    setTimeout(() => {
                        showMessagePanel(this);
                    }, 50);
                    return;
                }
            }

            updateOptions() {
                const currentValue = this.getValue();
                // Etiketin sonuna boşluk ekle ki ok işareti üstüne binmesin
                const options = messages.map(m => [m + '   ', m]);
                options.push(['➕ Yeni mesaj...', 'NEW']);
                this.menuGenerator_ = options;

                // Eğer mevcut değer listede yoksa, ilk mesajı seç
                if (currentValue === 'NEW' || !messages.includes(currentValue)) {
                    this.setValue(messages[0]);
                }
            }
        }

        function showMessagePanel(field) {
            closeAllPopups(); // Önce diğerlerini kapat
            currentMessageField = field;
            const panel = document.getElementById('messagePanel');
            const input = document.getElementById('messageInput');

            // Bloğun pozisyonunu al
            const block = field.getSourceBlock();
            const blockSvg = block.getSvgRoot();
            const rect = blockSvg.getBoundingClientRect();

            panel.style.left = (rect.right + 20) + 'px';
            panel.style.top = rect.top + 'px';
            panel.classList.add('active');

            input.value = '';
            input.focus();

            // Enter tuşu ile kaydet
            input.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    saveMessage();
                } else if (e.key === 'Escape') {
                    closeMessagePanel();
                }
            };

            document.addEventListener('click', closeMessagePanelOnClickOutside);
        }

        function closeMessagePanelOnClickOutside(e) {
            const panel = document.getElementById('messagePanel');
            if (!panel.contains(e.target) && !e.target.closest('.blocklyDropDownDiv')) {
                closeMessagePanel();
            }
        }

        function saveMessage() {
            const input = document.getElementById('messageInput');
            const newMessage = input.value.trim();

            if (newMessage && newMessage !== 'NEW') {
                if (!messages.includes(newMessage)) {
                    messages.push(newMessage);
                    console.log('Yeni mesaj eklendi:', newMessage);
                }

                if (currentMessageField) {
                    // Tüm mesaj field'larını güncelle
                    workspace.getAllBlocks().forEach(block => {
                        ['MESSAGE'].forEach(fieldName => {
                            const field = block.getField(fieldName);
                            if (field && field instanceof CustomMessageField) {
                                field.updateOptions();
                            }
                        });
                    });

                    currentMessageField.setValue(newMessage);
                    currentMessageField = null;
                }
            }

            closeMessagePanel();
        }

        function closeMessagePanel() {
            const panel = document.getElementById('messagePanel');
            panel.classList.remove('active');
            document.removeEventListener('click', closeMessagePanelOnClickOutside);

            // Eğer yeni mesaj seçilmediyse, ilk mesaja dön
            if (currentMessageField && currentMessageField.getValue() === 'NEW') {
                currentMessageField.setValue(messages[0]);
            }

            currentMessageField = null;
        }

        // ========== PIXEL MATRIX PANEL FOR COLOR LIGHT MATRIX ==========
        const PIXEL_COLORS = [
            { name: 'Pink', hex: '#FF69B4', index: 1 },
            { name: 'Purple', hex: '#E040FB', index: 2 },
            { name: 'Blue', hex: '#2196F3', index: 3 },
            { name: 'Cyan', hex: '#00BCD4', index: 4 },
            { name: 'Teal', hex: '#009688', index: 5 }, // Added Teal
            { name: 'Green', hex: '#4CAF50', index: 6 },
            { name: 'Yellow', hex: '#FFEB3B', index: 7 },
            { name: 'Orange', hex: '#FF9800', index: 8 },
            { name: 'Red', hex: '#F44336', index: 9 },
            { name: 'White', hex: '#FFFFFF', index: 10 },
            { name: 'Off', hex: '#333333', index: 0 }
        ];

        let currentPixelField = null;
        let selectedPixelColor = PIXEL_COLORS[5]; // Default yellow
        let pixelGridData = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // 9 pixels, all off

        function initPixelPanel() {
            const grid = document.getElementById('pixelGrid');
            const colorPicker = document.getElementById('pixelColorPicker');

            // Create 9 pixel cells
            grid.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.className = 'pixel-cell';
                cell.dataset.index = i;
                cell.style.background = '#333333';
                cell.onclick = () => paintPixel(i);
                grid.appendChild(cell);
            }

            // Create color picker content
            colorPicker.innerHTML = '';

            // Selected color indicator
            const selectedIndicator = document.createElement('div');
            selectedIndicator.id = 'pixelSelectedColor';
            selectedIndicator.style.cssText = 'width: 36px; height: 20px; border-radius: 4px; border: 2px solid white; margin-bottom: 8px; background: ' + selectedPixelColor.hex;
            colorPicker.appendChild(selectedIndicator);

            // Color buttons
            PIXEL_COLORS.forEach((color, idx) => {
                const btn = document.createElement('button');
                btn.className = 'pixel-color-btn' + (color === selectedPixelColor ? ' selected' : '');
                btn.style.background = color.hex;
                btn.title = color.name;
                btn.onclick = (e) => {
                    e.stopPropagation();
                    selectPixelColor(idx);
                };
                colorPicker.appendChild(btn);
            });
        }

        function selectPixelColor(idx) {
            selectedPixelColor = PIXEL_COLORS[idx];

            // Update indicator
            const indicator = document.getElementById('pixelSelectedColor');
            if (indicator) indicator.style.background = selectedPixelColor.hex;

            // Update buttons
            document.querySelectorAll('.pixel-color-btn').forEach((btn, i) => {
                btn.classList.toggle('selected', i === idx);
            });
        }

        function paintPixel(index) {
            pixelGridData[index] = selectedPixelColor.index;
            const cells = document.querySelectorAll('.pixel-cell');
            cells[index].style.background = selectedPixelColor.hex;
            updatePixelField();
        }

        function clearPixelGrid() {
            pixelGridData = [0, 0, 0, 0, 0, 0, 0, 0, 0];
            document.querySelectorAll('.pixel-cell').forEach(cell => {
                cell.style.background = '#333333';
            });
            updatePixelField();
        }

        function fillPixelGrid() {
            pixelGridData = pixelGridData.map(() => selectedPixelColor.index);
            document.querySelectorAll('.pixel-cell').forEach(cell => {
                cell.style.background = selectedPixelColor.hex;
            });
            updatePixelField();
        }

        function updatePixelField() {
            if (currentPixelField) {
                currentPixelField.setValue(pixelGridData.join(','));
            }
        }

        function showPixelPanel(field, currentData) {
            closeAllPopups();
            currentPixelField = field;

            // Parse existing data
            if (currentData && currentData !== '0,0,0,0,0,0,0,0,0') {
                pixelGridData = currentData.split(',').map(Number);
            } else {
                pixelGridData = [0, 0, 0, 0, 0, 0, 0, 0, 0];
            }

            // Update grid display
            const cells = document.querySelectorAll('.pixel-cell');
            cells.forEach((cell, i) => {
                const colorObj = PIXEL_COLORS.find(c => c.index === pixelGridData[i]) || PIXEL_COLORS[9];
                cell.style.background = colorObj.hex;
            });

            // Position and show panel
            const fieldRect = field.getScaledBBox();
            const panel = document.getElementById('pixelPanel');
            panel.style.left = `${fieldRect.left}px`;
            panel.style.top = `${fieldRect.bottom + 10}px`;
            panel.classList.add('active');

            setTimeout(() => {
                document.addEventListener('click', closePixelPanelOnClickOutside);
            }, 100);
        }

        function closePixelPanelOnClickOutside(e) {
            const panel = document.getElementById('pixelPanel');
            if (!panel.contains(e.target)) {
                closePixelPanel();
            }
        }

        function closePixelPanel() {
            const panel = document.getElementById('pixelPanel');
            panel.classList.remove('active');
            document.removeEventListener('click', closePixelPanelOnClickOutside);
            currentPixelField = null;
        }

        // Custom Pixel Matrix Field
        class PixelMatrixField extends Blockly.Field {
            constructor(value) {
                super(value || '0,0,0,0,0,0,0,0,0');
                this.SERIALIZABLE = true;
                this.pixels_ = []; // Store SVG elements
            }

            static fromJson(options) {
                return new PixelMatrixField(options['value']);
            }

            initView() {
                // Background border
                this.createBorderRect_();
                this.borderRect_.setAttribute('rx', 4);
                this.borderRect_.setAttribute('ry', 4);
                this.borderRect_.style.fill = '#5B21B6'; // Deep Purple
                this.borderRect_.style.stroke = 'rgba(255,255,255,0.4)';
                this.borderRect_.style.strokeWidth = '1';

                // Create 3x3 Grid Group
                this.previewGroup_ = Blockly.utils.dom.createSvgElement('g', {
                    'class': 'pixel-matrix-preview',
                    // Center grid vertically (6px top), padding left (12px)
                    'transform': 'translate(12, 6)'
                }, this.fieldGroup_);

                // Create 9 pixel rectangles
                this.pixels_ = [];
                for (let i = 0; i < 9; i++) {
                    const x = (i % 3) * 8;
                    const y = Math.floor(i / 3) * 8;
                    const rect = Blockly.utils.dom.createSvgElement('rect', {
                        'x': x,
                        'y': y,
                        'width': 6,
                        'height': 6,
                        'rx': 1,
                        'fill': 'rgba(255,255,255,0.2)' // Default Off Color
                    }, this.previewGroup_);
                    this.pixels_.push(rect);
                }

                // Add dropdown arrow, shifted right
                // New width 72. Arrow around 52-60.
                const arrow = Blockly.utils.dom.createSvgElement('path', {
                    'd': 'M52,14 L58,14 L55,18 Z',
                    'fill': 'white',
                    'opacity': '0.8'
                }, this.fieldGroup_);
            }

            showEditor_() {
                showPixelPanel(this, this.getValue());
            }

            doClassValidation_(newValue) {
                return newValue;
            }

            getDisplayText_() {
                return '';
            }

            // Override updateSize_ to enforce fixed dimensions properly
            updateSize_() {
                this.size_.width = 72;
                this.size_.height = 36;
            }

            // Update SVG preview based on values
            render_() {
                super.render_();

                if (this.pixels_) {
                    const vals = (this.getValue() || '').split(',').map(v => parseInt(v) || 0);
                    this.pixels_.forEach((pixel, i) => {
                        const colorIndex = vals[i] || 0;
                        // Find color from PIXEL_COLORS based on index
                        const colorObj = PIXEL_COLORS.find(c => c.index === colorIndex);
                        pixel.style.fill = colorObj ? colorObj.hex : 'rgba(255,255,255,0.2)';
                    });
                }
            }
        }

        Blockly.fieldRegistry.register('field_pixel_matrix', PixelMatrixField);

        // Initialize pixel panel on load
        document.addEventListener('DOMContentLoaded', initPixelPanel);
        // ========== END PIXEL MATRIX PANEL ==========

        // Custom Number Field with Popup
        class CustomNumberField extends Blockly.FieldNumber {
            showEditor_() {
                closeAllPopups(); // Önce diğerlerini kapat
                const fieldRect = this.getScaledBBox();
                const panel = document.getElementById('numberPanel');
                const display = document.getElementById('numberDisplay');

                currentValue = parseInt(this.getValue()) || 1;
                currentNumberField = this;
                minValue = this.min_ || 1;
                maxValue = this.max_ || 100;

                display.textContent = currentValue;

                panel.style.left = (fieldRect.right + 10) + 'px';
                panel.style.top = fieldRect.top + 'px';
                panel.classList.add('active');

                document.addEventListener('click', closeNumberPanelOnClickOutside);
            }
        }

        function closeNumberPanelOnClickOutside(e) {
            const panel = document.getElementById('numberPanel');
            if (!panel.contains(e.target) && !e.target.closest('.blocklyEditableText')) {
                closeNumberPanel();
            }
        }

        function closeNumberPanel() {
            const panel = document.getElementById('numberPanel');
            panel.classList.remove('active');
            document.removeEventListener('click', closeNumberPanelOnClickOutside);

            if (currentNumberField) {
                currentNumberField.setValue(currentValue);
                currentNumberField = null;
            }
        }

        function incrementNumber() {
            if (currentValue < maxValue) {
                currentValue++;
                updateDisplay();
            }
        }

        function decrementNumber() {
            if (currentValue > minValue) {
                currentValue--;
                updateDisplay();
            }
        }

        // Basılı tutma için değişkenler
        let holdTimer = null;
        let holdInterval = null;
        let isHolding = false;

        // Basılı tutma fonksiyonları
        function startHold(incrementFunc) {
            isHolding = false;

            // İlk tıklama - hemen çalıştır
            incrementFunc();

            // 500ms basılı tutulursa hızlı mod başlat
            holdTimer = setTimeout(() => {
                isHolding = true;
                holdInterval = setInterval(() => {
                    incrementFunc();
                }, 100); // Her 100ms'de bir değişir
            }, 500);
        }

        function stopHold() {
            if (holdTimer) {
                clearTimeout(holdTimer);
                holdTimer = null;
            }
            if (holdInterval) {
                clearInterval(holdInterval);
                holdInterval = null;
            }
            isHolding = false;
        }

        function updateDisplay() {
            document.getElementById('numberDisplay').textContent = currentValue;
        }

        // Event listener'ları sayfa yüklendiğinde ekle
        window.addEventListener('load', () => {
            const incrementBtn = document.getElementById('incrementBtn');
            const decrementBtn = document.getElementById('decrementBtn');

            if (incrementBtn && decrementBtn) {
                // Artı butonu
                incrementBtn.addEventListener('mousedown', () => startHold(incrementNumber));
                incrementBtn.addEventListener('mouseup', stopHold);
                incrementBtn.addEventListener('mouseleave', stopHold);
                incrementBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startHold(incrementNumber);
                });
                incrementBtn.addEventListener('touchend', stopHold);
                incrementBtn.addEventListener('touchcancel', stopHold);

                // Eksi butonu
                decrementBtn.addEventListener('mousedown', () => startHold(decrementNumber));
                decrementBtn.addEventListener('mouseup', stopHold);
                decrementBtn.addEventListener('mouseleave', stopHold);
                decrementBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startHold(decrementNumber);
                });
                decrementBtn.addEventListener('touchend', stopHold);
                decrementBtn.addEventListener('touchcancel', stopHold);
            }

            // Açı seçici butonları
            const angleIncrementBtn = document.getElementById('angleIncrementBtn');
            const angleDecrementBtn = document.getElementById('angleDecrementBtn');

            if (angleIncrementBtn && angleDecrementBtn) {
                // Artı butonu
                angleIncrementBtn.addEventListener('mousedown', () => startHold(incrementAngle));
                angleIncrementBtn.addEventListener('mouseup', stopHold);
                angleIncrementBtn.addEventListener('mouseleave', stopHold);
                angleIncrementBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startHold(incrementAngle);
                });
                angleIncrementBtn.addEventListener('touchend', stopHold);
                angleIncrementBtn.addEventListener('touchcancel', stopHold);

                // Eksi butonu
                angleDecrementBtn.addEventListener('mousedown', () => startHold(decrementAngle));
                angleDecrementBtn.addEventListener('mouseup', stopHold);
                angleDecrementBtn.addEventListener('mouseleave', stopHold);
                angleDecrementBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startHold(decrementAngle);
                });
                angleDecrementBtn.addEventListener('touchend', stopHold);
                angleDecrementBtn.addEventListener('touchcancel', stopHold);
            }

            // Açı işaretçilerini oluştur
            createAngleMarkers();

            // Açı dairesine tıklama/sürükleme özelliği ekle
            setupAngleCircleInteraction();
        });

        // Açı dairesi etkileşimi
        let isDraggingAngle = false;

        function setupAngleCircleInteraction() {
            const circle = document.getElementById('angleCircle');
            if (!circle) {
                // Circle henüz yok, daha sonra eklenecek
                return;
            }

            // Mouse olayları
            circle.addEventListener('mousedown', (e) => {
                isDraggingAngle = true;
                updateAngleFromMouse(e);
            });

            document.addEventListener('mousemove', (e) => {
                if (isDraggingAngle) {
                    updateAngleFromMouse(e);
                }
            });

            document.addEventListener('mouseup', () => {
                isDraggingAngle = false;
            });

            // Touch olayları
            circle.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isDraggingAngle = true;
                updateAngleFromTouch(e);
            });

            document.addEventListener('touchmove', (e) => {
                if (isDraggingAngle) {
                    e.preventDefault();
                    updateAngleFromTouch(e);
                }
            });

            document.addEventListener('touchend', () => {
                isDraggingAngle = false;
            });
        }

        function updateAngleFromMouse(e) {
            const circle = document.getElementById('angleCircle');
            if (!circle) return;

            const rect = circle.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const dx = e.clientX - centerX;
            const dy = e.clientY - centerY;

            calculateAngleFromCoordinates(dx, dy);
        }

        function updateAngleFromTouch(e) {
            const circle = document.getElementById('angleCircle');
            if (!circle || e.touches.length === 0) return;

            const rect = circle.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const touch = e.touches[0];
            const dx = touch.clientX - centerX;
            const dy = touch.clientY - centerY;

            calculateAngleFromCoordinates(dx, dy);
        }

        function calculateAngleFromCoordinates(dx, dy) {
            // Açıyı hesapla (radyan cinsinden)
            let angleRad = Math.atan2(dy, dx);

            // Radyandan dereceye çevir
            let angleDeg = angleRad * 180 / Math.PI;

            // 0-360 aralığına çevir (saat 3'ten başlayarak saat yönünde)
            // atan2 saat 3'ten başlar, biz saat 12'den başlatmak istiyoruz
            angleDeg = (angleDeg + 90) % 360;
            if (angleDeg < 0) angleDeg += 360;

            // 1'in katına yuvarla
            currentAngle = Math.round(angleDeg);
            if (currentAngle === 360) currentAngle = 0;

            updateAngleDisplay();
        }

        // Açı seçici fonksiyonları
        function incrementAngle() {
            currentAngle = (currentAngle + 1) % 360;
            updateAngleDisplay();
        }

        function decrementAngle() {
            currentAngle = (currentAngle - 1 + 360) % 360;
            updateAngleDisplay();
        }

        function updateAngleDisplay() {
            const indicator = document.getElementById('angleIndicator');
            const degrees = document.getElementById('angleDegrees');

            indicator.style.transform = `translate(-50%, -100%) rotate(${currentAngle}deg)`;
            degrees.textContent = `${currentAngle}°`;
        }

        function createAngleMarkers() {
            const markersContainer = document.getElementById('angleMarkers');
            if (!markersContainer) return;

            markersContainer.innerHTML = '';

            // Her 30 derece için işaret (0, 30, 60, 90, ...)
            for (let angle = 0; angle < 360; angle += 30) {
                const marker = document.createElement('div');
                marker.className = 'angle-marker major';
                marker.style.transform = `translate(-50%, -100%) rotate(${angle}deg)`;
                markersContainer.appendChild(marker);

                // Sadece ana açılarda (0, 90, 180, 270) etiket ekle
                if (angle % 90 === 0) {
                    const label = document.createElement('div');
                    label.className = 'angle-marker-label';
                    label.textContent = angle + '°';

                    // Etiketin pozisyonunu hesapla - daha da içe alındı
                    const radius = 60; // 72'den 60'a düşürdük
                    const rad = (angle - 90) * Math.PI / 180;
                    const x = 50 + radius * Math.cos(rad);
                    const y = 50 + radius * Math.sin(rad);

                    label.style.left = x + '%';
                    label.style.top = y + '%';
                    label.style.transform = 'translate(-50%, -50%)';

                    markersContainer.appendChild(label);
                }
            }

            // Her 15 derece için küçük işaret (15, 45, 75, ...)
            for (let angle = 15; angle < 360; angle += 30) {
                const marker = document.createElement('div');
                marker.className = 'angle-marker';
                marker.style.transform = `translate(-50%, -100%) rotate(${angle}deg)`;
                markersContainer.appendChild(marker);
            }
        }

        function closeAnglePanelOnClickOutside(e) {
            const panel = document.getElementById('anglePanel');
            if (!panel.contains(e.target) && !e.target.closest('.blocklyEditableText')) {
                closeAnglePanel();
            }
        }

        function closeAnglePanel() {
            const panel = document.getElementById('anglePanel');
            panel.classList.remove('active');
            document.removeEventListener('click', closeAnglePanelOnClickOutside);

            if (currentAngleField) {
                currentAngleField.setValue(currentAngle);
                currentAngleField = null;
            }
        }

        // Event blokları
        Blockly.Blocks['start'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_START, 20, 20, "*"))
                    .appendField(Blockly.Msg.BLOCK_START);
                this.setNextStatement(true, null);
                this.setColour("#E6AC00");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['when_condition'] = {
            init: function () {
                this.appendValueInput("CONDITION")
                    .setCheck("Boolean")
                    .appendField(new Blockly.FieldImage(ICON_BOLT, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_WHEN_PRE);
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_WHEN_POST);
                this.setInputsInline(true);
                this.setNextStatement(true, null);
                this.setColour("#FFBF00");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['when_message_received'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_MSG_IN, 20, 20, "*"))
                    .appendField(Blockly.Msg.BLOCK_MESSAGE_PRE)
                    .appendField(new CustomMessageField('message1'), "MESSAGE")
                    .appendField(Blockly.Msg.BLOCK_MESSAGE_POST);
                this.setNextStatement(true, null);
                this.setColour("#FFBF00");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['send_message'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_MSG_OUT, 20, 20, "*"))
                    .appendField(Blockly.Msg.BLOCK_SEND_MOBILE_PRE)
                    .appendField(new CustomMessageField('message1'), "MESSAGE")
                    .appendField(Blockly.Msg.BLOCK_SEND_MOBILE_POST);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['forward'] = {
            init: function () {
                this.appendValueInput('STEPS')
                    .setCheck('Number')
                    .appendField("⬆️");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FF8C1A");
                this.setInputsInline(true);
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['turn_right'] = {
            init: function () {
                this.appendValueInput('DEG')
                    .setCheck('Number')
                    .appendField("↻");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FF8C1A");
                this.setInputsInline(true);
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['turn_left'] = {
            init: function () {
                this.appendValueInput('DEG')
                    .setCheck('Number')
                    .appendField("↺");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FF8C1A");
                this.setInputsInline(true);
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['repeat'] = {
            init: function () {
                this.appendValueInput('TIMES')
                    .setCheck('Number')
                    .appendField(new Blockly.FieldImage(ICON_REFRESH, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_REPEAT_PRE);
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_REPEAT_POST);
                this.appendStatementInput('DO');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setInputsInline(true);
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['wait'] = {
            init: function () {
                this.appendValueInput('SECONDS')
                    .setCheck('Number')
                    .appendField(new Blockly.FieldImage(ICON_STOP_HAND, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_WAIT_PRE);
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_WAIT_POST);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setInputsInline(true);
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['forever'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_INFINITY, 20, 20, "*"))
                    .appendField(Blockly.Msg.BLOCK_FOREVER);
                this.appendStatementInput('DO');
                this.setPreviousStatement(true, null);
                this.setColour("#FFAB19");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['if_then'] = {
            init: function () {
                this.appendValueInput('CONDITION')
                    .setCheck('Boolean')
                    .appendField(new Blockly.FieldImage(ICON_RHOMBUS, 16, 16, "*"))
                    .appendField(Blockly.Msg.BLOCK_IF);
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_THEN);
                this.appendStatementInput('DO');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['if_then_else'] = {
            init: function () {
                this.appendValueInput('CONDITION')
                    .setCheck('Boolean')
                    .appendField(new Blockly.FieldImage(ICON_RHOMBUS, 16, 16, "*"))
                    .appendField(Blockly.Msg.BLOCK_IF);
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_THEN);
                this.appendStatementInput('DO');
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_ELSE);
                this.appendStatementInput('ELSE');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['wait_until'] = {
            init: function () {
                this.appendValueInput('CONDITION')
                    .setCheck('Boolean')
                    .appendField(new Blockly.FieldImage(ICON_HOURGLASS, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_WAIT_UNTIL_PRE);
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_WAIT_UNTIL_POST);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['repeat_until'] = {
            init: function () {
                this.appendValueInput('CONDITION')
                    .setCheck('Boolean')
                    .appendField(new Blockly.FieldImage(ICON_REFRESH, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_REPEAT_UNTIL_PRE);
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_REPEAT_UNTIL_POST);
                this.appendStatementInput('DO');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FFAB19");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['alarm'] = {
            init: function () {
                this.appendDummyInput().appendField("🔔");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#CF63CF");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['sound'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("🔊")
                    .appendField(new CustomNumberField(300, 100, 1000), 'FREQ');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#CF63CF");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['light'] = {
            init: function () {
                this.appendDummyInput().appendField("💡");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#0FBD8C");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['led_on'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("🟦")
                    .appendField(new CustomNumberField(90, 0, 255), 'VAL');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5CB1D6");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['led_off'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("⬛")
                    .appendField(new CustomNumberField(90, 0, 255), 'VAL');
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5CB1D6");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['smile'] = {
            init: function () {
                this.appendDummyInput().appendField("😊");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FF6680");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // RGB LED Blokları
        Blockly.Blocks['rgb_red_on'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_RED, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_RED_ON);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#ff6b6b");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_green_on'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_GREEN, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_GREEN_ON);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#51cf66");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_blue_on'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_BLUE, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_BLUE_ON);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4dabf7");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // RGB LED Söndür Blokları
        Blockly.Blocks['rgb_red_off'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_WHITE, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_RED_OFF);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#ffb3b3");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_green_off'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_WHITE, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_GREEN_OFF);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#b3e0b3");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_blue_off'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_WHITE, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_BLUE_OFF);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#b3d9ff");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_red_num'] = {
            init: function () {
                this.appendValueInput('NUM')
                    .setCheck('Number')
                    .appendField(new Blockly.FieldImage(ICON_SQ_RED, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_RED_NUM);
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#ff6b6b");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_green_num'] = {
            init: function () {
                this.appendValueInput('NUM')
                    .setCheck('Number')
                    .appendField(new Blockly.FieldImage(ICON_SQ_GREEN, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_GREEN_NUM);
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#51cf66");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_blue_num'] = {
            init: function () {
                this.appendValueInput('NUM')
                    .setCheck('Number')
                    .appendField(new Blockly.FieldImage(ICON_SQ_BLUE, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_BLUE_NUM);
                this.setInputsInline(true);
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4dabf7");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // RGB Sayı Getir Blokları (Yuvarlak şekilli - Number output)
        Blockly.Blocks['rgb_red_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_SQ_RED, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_RED_GET);
                this.setOutput(true, "Number");
                this.setColour("#ff6b6b");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_green_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_SQ_GREEN, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_GREEN_GET);
                this.setOutput(true, "Number");
                this.setColour("#51cf66");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_blue_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_SQ_BLUE, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_BLUE_GET);
                this.setOutput(true, "Number");
                this.setColour("#4dabf7");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // RGB Işık Getir Blokları (Altıgen şekilli - Boolean output)
        Blockly.Blocks['rgb_red_light_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_RED, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_LIGHT_GET_POST);
                this.setOutput(true, "Boolean");
                this.setColour("#ff6b6b");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_green_light_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_GREEN, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_LIGHT_GET_POST);
                this.setOutput(true, "Boolean");
                this.setColour("#51cf66");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_blue_light_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(ICON_CIRC_BLUE, 18, 18, "*"))
                    .appendField(Blockly.Msg.BLOCK_LIGHT_GET_POST);
                this.setOutput(true, "Boolean");
                this.setColour("#4dabf7");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // RGB Tuş Getir Blokları (Altıgen şekilli - Boolean output - Üçgen ikonlu)
        Blockly.Blocks['rgb_red_button_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTEyIDJMMiAyMmgyMEwxMiAyeiIgZmlsbD0iI2NmMTMyMiIvPjwvc3ZnPg==", 24, 24, "*"))
                    .appendField(Blockly.Msg.BLOCK_RED_BTN_GET);
                this.setOutput(true, "Boolean");
                this.setColour("#ff6b6b");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_green_button_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTEyIDJMMiAyMmgyMEwxMiAyeiIgZmlsbD0iIzFhOTAzZSIvPjwvc3ZnPg==", 24, 24, "*"))
                    .appendField(Blockly.Msg.BLOCK_GREEN_BTN_GET);
                this.setOutput(true, "Boolean");
                this.setColour("#51cf66");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['rgb_blue_button_get'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTEyIDJMMiAyMmgyMEwxMiAyeiIgZmlsbD0iIzE5NzFjMiIvPjwvc3ZnPg==", 24, 24, "*"))
                    .appendField(Blockly.Msg.BLOCK_BLUE_BTN_GET);
                this.setOutput(true, "Boolean");
                this.setColour("#4dabf7");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Motor Blokları
        // SVG Ikonlar (Base64 encoded)
        const DEVICE_ICONS = {
            'rotate': 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0id2hpdGUiPjxwYXRoIGQ9Ik0xMiA0VjFMNCA1bDQgNFY2YzMuMzEgMCA2IDIuNjkgNiA2IDAgMS4wMS0uMjUgMS45Ny0uNyAyLjhsMS40NiAxLjQ2QzE5LjU0IDE1LjAzIDIwIDEzLjU3IDIwIDEyYzAtNC40Mi0zLjU4LTgtOC04em0wIDE0Yy0zLjMxIDAtNi0yLjY5LTYtNiAwLTEuMDEuMjUtMS45Ny43LTIuOEw1LjI0IDcuNzRDNC40NiA4Ljk3IDQgMTAuNDMgNCAxMmMwIDQuNDIgMy41OCA4IDggOHYzbDQtNC00LTR2M3oiLz48L3N2Zz4=',
            'timer': 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0id2hpdGUiPjxwYXRoIGQ9Ik0xMS45OSAyQzYuNDcgMiAyIDYuNDggMiAxMnM0LjQ3IDEwIDkuOTkgMTBDMTcuNTIgMjIgMjIgMTcuNTIgMjIgMTJTMTcuNTIgMiAxMS45OSAyem0uMDEgMThjLTQuNDIgMC04LTMuNTgtOC04czMuNTgtOCA4LTggOCAzLjU4IDggOC0zLjU4LTgtOCA4em0uNS0xM0gxMXY2bDUuMjUgMy4xNS43NS0xLjIzLTQuNS0yLjY3eiIvPjwvc3ZnPg==',
            'speed': 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0id2hpdGUiPjxwYXRoIGQ9Ik03IDJ2MTFoM3Y5bDctMTJINWw0LTh6Ii8+PC9zdmc==',
            'stop': 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0id2hpdGUiPjxwYXRoIGQ9Ik02IDZoMTJ2MTJINnoiLz48L3N2Zz4=',
            'target': 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0id2hpdGUiPjxwYXRoIGQ9Ik0xMiAyQzYuNDggMiAyIDYuNDggMiAxMnM0LjQ4IDEwIDEwIDEwIDEwLTQuNDggMTAtMTBTMTcuNTIgMiAxMiAyem0wIDE4Yy00LjQxIDAtOC0zLjU5LTgtOHMzLjU5LTggOC04IDggMyuNTkgOCAzLjU5IDgtOC04em0tNS04YzAgMi43NiAyLjI0IDUgNSAzczUtMi4yNCA1LTUtMi4yNC01LTUtNS0yLjI0LTUtNS01eiIvPjwvc3ZnPg==',
            'play': 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0id2hpdGUiPjxwYXRoIGQ9Ik04IDV2MTRsMTEtN3oiLz48L3N2Zz4=',
            'pin': 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0id2hpdGUiPjxwYXRoIGQ9Ik0xMiAyQzguMSAyIDUgNS4xIDUgOWMwIDUuMiA3IDEzIDcgMTNzNy03LjggNy0xM2MwLTMuOS0zLjEtNy03LTd6bTAgOS41Yy0xLjQgMC0yLjUtMS4xLTIuNS0yLjVzMS4xLTIuNSAyLjUtMi41IDIuNSAxLjEgMi41IDIuNS0xLjEgMi41LTIuNSAyLjV6Ii8+PC9zdmc+'
        };
        Blockly.Blocks['motor_run_rotation'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage("img/single-motor.png", 30, 20, "*"))
                    .appendField("run")
                    .appendField(new Blockly.FieldDropdown([["↻", "CW"], ["↺", "CCW"]]), "DIRECTION")
                    .appendField("for")
                    .appendField(new CustomNumberField(1, 1, 100), 'ROTATIONS')
                    .appendField("rotations");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4ECDC4");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['motor_run_to_angle'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage("img/single-motor.png", 30, 20, "*"))
                    .appendField("run")
                    .appendField(new Blockly.FieldDropdown([["↻", "CW"], ["↺", "CCW"]]), "DIRECTION")
                    .appendField("to")
                    .appendField(new CustomAngleField(0, 0, 360), 'ANGLE')
                    .appendField("angle");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4ECDC4");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // YENİ BLOK: Mutlak pozisyon (0° referansına göre)
        Blockly.Blocks['motor_go_to_position'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage("img/single-motor.png", 30, 20, "*"))
                    .appendField("go to position ")
                    .appendField(new CustomAngleField(0, 0, 360), 'POSITION')
                    .appendField("°");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4ECDC4");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['motor_start'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage("img/single-motor.png", 30, 20, "*"))
                    .appendField("start motor ")
                    .appendField(new Blockly.FieldDropdown([["↻", "CW"], ["↺", "CCW"]]), "DIRECTION");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4ECDC4");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['motor_stop'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage("img/single-motor.png", 30, 20, "*"))
                    .appendField("stop motor");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4ECDC4");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };


        // Hub Motor Blocks with Port Selection
        const HUB_MOTOR_ICON = "img/spike_motor_icon.png"; // Updated icon

        const MOTOR_PORTS = function () {
            // Find ports with motors attached (0x4B Small Motor, 0x4C Large Motor)
            const motorPorts = [];
            const portLetters = ['A', 'B', 'C', 'D', 'E', 'F'];
            // Motor Types: 0x4B (Small), 0x4C (Large), 0x41 (Medium - Linear), 0x42 (Large - Angular)
            // Spike Essential usually uses 0x4B (Small). Spike Prime uses 0x4B, 0x4C.
            const MOTOR_IO_TYPES = [0x4B, 0x4C, 0x41, 0x42, 75, 76];

            for (const letter of portLetters) {
                const portState = spikeHubState[`port${letter}`];
                if (portState && MOTOR_IO_TYPES.includes(portState.type)) {
                    motorPorts.push([`${letter}\u00A0\u00A0\u00A0`, letter]);
                    continue;
                }
                if (typeof spikePrimeHubState !== 'undefined') {
                    const primePortState = spikePrimeHubState[`port${letter}`];
                    if (primePortState && MOTOR_IO_TYPES.includes(primePortState.type)) {
                        motorPorts.push([`${letter}\u00A0\u00A0\u00A0`, letter]);
                    }
                }
            }
            if (motorPorts.length === 0) {
                return [["A\u00A0\u00A0\u00A0", "A"], ["B\u00A0\u00A0\u00A0", "B"]]; // Default ports if no motor detected
            }
            return motorPorts;
        };

        const LIGHT_PORTS = function () {
            // Find ports with Lights (0x08)
            const lightPorts = [];
            const portLetters = ['A', 'B', 'C', 'D', 'E', 'F'];
            const LIGHT_IO_TYPES = [0x08];

            for (const letter of portLetters) {
                const portState = spikeHubState[`port${letter}`];
                if (portState && LIGHT_IO_TYPES.includes(portState.type)) {
                    lightPorts.push([`${letter}\u00A0\u00A0\u00A0`, letter]);
                    continue;
                }
                if (typeof spikePrimeHubState !== 'undefined') {
                    const primePortState = spikePrimeHubState[`port${letter}`];
                    if (primePortState && LIGHT_IO_TYPES.includes(primePortState.type)) {
                        lightPorts.push([`${letter}\u00A0\u00A0\u00A0`, letter]);
                    }
                }
            }
            if (lightPorts.length === 0) {
                return [["A\u00A0\u00A0\u00A0", "A"], ["B\u00A0\u00A0\u00A0", "B"]];
            }
            return lightPorts;
        };

        const MOTOR_PATH_OPTIONS = function () {
            const isTr = currentLanguage === 'tr';
            return [
                [isTr ? "en kısa yol\u00A0\u00A0\u00A0" : "shortest path\u00A0\u00A0\u00A0", "SHORTEST"],
                [isTr ? "saat yönünde\u00A0\u00A0\u00A0" : "clockwise\u00A0\u00A0\u00A0", "CW"],
                [isTr ? "saat yönü tersi\u00A0\u00A0\u00A0" : "counterclockwise\u00A0\u00A0\u00A0", "CCW"]
            ];
        };

        const ROTATION_UNITS = function () {
            const isTr = currentLanguage === 'tr';
            return [
                [isTr ? "tur\u00A0\u00A0\u00A0" : "rotations\u00A0\u00A0\u00A0", "ROTATIONS"],
                [isTr ? "derece\u00A0\u00A0\u00A0" : "degrees\u00A0\u00A0\u00A0", "DEGREES"],
                [isTr ? "saniye\u00A0\u00A0\u00A0" : "seconds\u00A0\u00A0\u00A0", "SECONDS"]
            ];
        };

        Blockly.Blocks['hub_motor_run'] = {
            init: function () {
                const isTr = currentLanguage === 'tr';
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(HUB_MOTOR_ICON, 30, 20, "*"))
                    .appendField(new Blockly.FieldDropdown(MOTOR_PORTS), "PORT")
                    .appendField(isTr ? "çalıştır" : "run")
                    .appendField(new Blockly.FieldDropdown([["↻", "CW"], ["↺", "CCW"]]), "DIRECTION")
                    .appendField(isTr ? " " : " for ")
                    .appendField(new CustomNumberField(1, 0, 1000), "VALUE")
                    .appendField(new Blockly.FieldDropdown(ROTATION_UNITS), "UNIT");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#0096FF");
                this.setTooltip(isTr ? "Motoru belirtilen miktar kadar çalıştır" : "Run motor for specified amount");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['hub_motor_go_position'] = {
            init: function () {
                const isTr = currentLanguage === 'tr';
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(HUB_MOTOR_ICON, 30, 20, "*"))
                    .appendField(new Blockly.FieldDropdown(MOTOR_PORTS), "PORT")
                    .appendField(isTr ? "git" : "go")
                    .appendField(new Blockly.FieldDropdown(MOTOR_PATH_OPTIONS), "PATH")
                    .appendField(isTr ? "pozisyona" : "to position")
                    .appendField(new CustomAngleField(0, -360, 360), "POSITION");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#0096FF");
                this.setTooltip(isTr ? "Motoru belirtilen pozisyona götür" : "Move motor to specified position");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['hub_motor_start'] = {
            init: function () {
                const isTr = currentLanguage === 'tr';
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(HUB_MOTOR_ICON, 30, 20, "*"))
                    .appendField(new Blockly.FieldDropdown(MOTOR_PORTS), "PORT")
                    .appendField(isTr ? "başlat" : "start motor")
                    .appendField(new Blockly.FieldDropdown([["↻", "CW"], ["↺", "CCW"]]), "DIRECTION");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#0096FF");
                this.setTooltip(isTr ? "Motoru sürekli çalıştır" : "Start motor continuously");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['hub_motor_stop'] = {
            init: function () {
                const isTr = currentLanguage === 'tr';
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(HUB_MOTOR_ICON, 30, 20, "*"))
                    .appendField(new Blockly.FieldDropdown(MOTOR_PORTS), "PORT")
                    .appendField(isTr ? "durdur" : "stop motor");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#0096FF");
                this.setTooltip(isTr ? "Motoru durdur" : "Stop motor");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['hub_light_control'] = {
            init: function () {
                const isTr = currentLanguage === 'tr';
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage("img/hub_light_icon.png", 32, 32, "*"))
                    .appendField(new Blockly.FieldDropdown(LIGHT_PORTS), "PORT")
                    .appendField(isTr ? "ışığını" : "light")
                    .appendField(new Blockly.FieldDropdown([
                        [isTr ? "aç" : "turn on", "ON"],
                        [isTr ? "kapat" : "turn off", "OFF"]
                    ]), "STATE")
                    .appendField(isTr ? "parlaklık %" : "brightness %")
                    .appendField(new CustomNumberField(100, 0, 100), "BRIGHTNESS");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#F5A623");
                this.setTooltip(isTr ? "Işığı belirtilen parlaklıkta açar veya kapatır" : "Turns light on with brightness or off");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // --- DOUBLE MOTOR BLOCKS ---

        Blockly.Blocks['double_motor_run_rotation'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage("img/double-motor.png", 30, 20, "*"))
                    .appendField("run")
                    .appendField(new Blockly.FieldDropdown([["left", "1"], ["right", "2"]]), "MOTOR_INDEX")
                    .appendField("motor")
                    .appendField(new Blockly.FieldDropdown([["↻", "CW"], ["↺", "CCW"]]), "DIRECTION")
                    .appendField("for")
                    .appendField(new CustomNumberField(1, 1, 100), 'ROTATIONS')
                    .appendField("rotations");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FF9F43");
            }
        };

        Blockly.JavaScript['double_motor_run_rotation'] = function (block) {
            var motor_index = block.getFieldValue('MOTOR_INDEX');
            var direction = block.getFieldValue('DIRECTION');
            var rotations = block.getFieldValue('ROTATIONS');
            var code = `await runDoubleMotorRotations(activeDoubleMotorDevice?.id, ${motor_index}, ${rotations}, '${direction}');\n`;
            return code;
        };

        Blockly.Blocks['double_motor_go_to_position'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage("img/double-motor.png", 30, 20, "*"))
                    .appendField("run")
                    .appendField(new Blockly.FieldDropdown([["left", "1"], ["right", "2"]]), "MOTOR_INDEX")
                    .appendField("motor to")
                    .appendField(new CustomAngleField(0, 0, 360), 'ANGLE')
                    .appendField("angle");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FF9F43");
            }
        };

        Blockly.JavaScript['double_motor_go_to_position'] = function (block) {
            var motor_index = block.getFieldValue('MOTOR_INDEX');
            var angle = block.getFieldValue('ANGLE');
            var code = `await runDoubleMotorToPosition(activeDoubleMotorDevice?.id, ${motor_index}, ${angle});\n`;
            return code;
        };

        Blockly.Blocks['double_motor_start'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage("img/double-motor.png", 30, 20, "*"))
                    .appendField("start")
                    .appendField(new Blockly.FieldDropdown([["left", "1"], ["right", "2"]]), "MOTOR_INDEX")
                    .appendField("motor")
                    .appendField(new Blockly.FieldDropdown([["↻", "CW"], ["↺", "CCW"]]), "DIRECTION");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FF9F43");
            }
        };

        Blockly.JavaScript['double_motor_start'] = function (block) {
            var motor_index = block.getFieldValue('MOTOR_INDEX');
            var direction = block.getFieldValue('DIRECTION');
            var code = `await startDoubleMotor(activeDoubleMotorDevice?.id, ${motor_index}, '${direction}');\n`;
            return code;
        };

        Blockly.Blocks['double_motor_stop'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage("img/double-motor.png", 30, 20, "*"))
                    .appendField("stop")
                    .appendField(new Blockly.FieldDropdown([["left", "1"], ["right", "2"]]), "MOTOR_INDEX")
                    .appendField("motor");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FF9F43");
            }
        };

        Blockly.JavaScript['double_motor_stop'] = function (block) {
            var motor_index = block.getFieldValue('MOTOR_INDEX');
            var code = `await stopDoubleMotor(activeDoubleMotorDevice?.id, ${motor_index});\n`;
            return code;
        };

        Blockly.Blocks['double_motor_set_speed'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage("img/double-motor.png", 30, 20, "*"))
                    .appendField("set")
                    .appendField(new Blockly.FieldDropdown([["left", "1"], ["right", "2"]]), "MOTOR_INDEX")
                    .appendField("motor speed to")
                    .appendField(new CustomNumberField(50, 0, 100), 'SPEED')
                    .appendField("%");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#FF9F43");
            }
        };

        Blockly.JavaScript['double_motor_set_speed'] = function (block) {
            var motor_index = block.getFieldValue('MOTOR_INDEX');
            var speed = block.getFieldValue('SPEED');
            var code = `await setDoubleMotorSpeed(activeDoubleMotorDevice?.id, ${motor_index}, ${speed});\n`;
            return code;
        };

        Blockly.Blocks['double_motor_get_angle'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage("img/double-motor.png", 30, 20, "*"))
                    .appendField(new Blockly.FieldDropdown([["left", "1"], ["right", "2"]]), "MOTOR_INDEX")
                    .appendField("motor")
                    .appendField(new Blockly.FieldDropdown([["angle", "ANGLE"], ["position", "POSITION"]]), "TYPE");
                this.setOutput(true, "Number");
                this.setColour("#FF9F43");
            }
        };

        Blockly.JavaScript['double_motor_get_angle'] = function (block) {
            var motor_index = block.getFieldValue('MOTOR_INDEX');
            var code = `getDoubleMotorAngle(activeDoubleMotorDevice?.id, ${motor_index})`;
            return [code, Blockly.JavaScript.ORDER_ATOMIC];
        };

        // Controller Blokları
        Blockly.Blocks['when_lever_position'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("🕹️") // Removed "when" text, icon implies it or handled by msg if needed, actually "when" was text.
                    .appendField(Blockly.Msg.BLOCK_LEVER_WHEN)
                    .appendField(new Blockly.FieldDropdown([
                        ["left", "LEFT"],
                        ["right", "RIGHT"],
                        ["both", "BOTH"],
                        ["any", "ANY"]
                    ]), "LEVER")
                    .appendField(Blockly.Msg.BLOCK_LEVER_IS)
                    .appendField(new Blockly.FieldDropdown([
                        ["released", "RELEASED"],
                        ["up", "UP"],
                        ["down", "DOWN"]
                    ]), "POSITION");
                this.setNextStatement(true, null);
                this.setColour("#45B7D1");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['lever_position'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("🕹️")
                    .appendField(new Blockly.FieldDropdown([
                        ["left", "LEFT"],
                        ["right", "RIGHT"],
                        ["both", "BOTH"],
                        ["any", "ANY"]
                    ]), "LEVER")
                    .appendField(Blockly.Msg.BLOCK_LEVER_IS)
                    .appendField(new Blockly.FieldDropdown([
                        ["released", "RELEASED"],
                        ["up", "UP"],
                        ["down", "DOWN"]
                    ]), "POSITION");
                this.setOutput(true, "Boolean");
                this.setColour("#45B7D1");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Yeni: Lever angle/percent bloğu (0-100 arası değer döner)
        Blockly.Blocks['lever_angle'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField("🕹️")
                    .appendField(new Blockly.FieldDropdown([
                        ["left", "LEFT"],
                        ["right", "RIGHT"]
                    ]), "LEVER")
                    .appendField(Blockly.Msg.BLOCK_LEVER_ANGLE);
                this.setOutput(true, "Number");
                this.setColour("#45B7D1");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // ========== COLOR SENSOR BLOCKS ==========

        // Color Sensor Icon for blocks
        const COLOR_SENSOR_ICON = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgdmlld0JveD0iMCAwIDIwIDIwIj48Y2lyY2xlIGN4PSIxMCIgY3k9IjEwIiByPSI4IiBmaWxsPSIjZmZmIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41Ii8+PGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMyIgZmlsbD0iIzMzMyIvPjwvc3ZnPg==';

        // Color dropdown options (matching LEGO/Spike Prime color codes)
        const COLOR_OPTIONS = [
            ["🔴 red  ", "RED"],           // 1
            ["🟡 yellow  ", "YELLOW"],     // 2
            ["🔵 blue  ", "BLUE"],         // 3
            ["🟢 green  ", "GREEN"],       // 4
            ["🟣 purple  ", "PURPLE"],     // 5
            ["🩵 cyan  ", "CYAN"],         // 6
            ["⚪ white  ", "WHITE"],       // 7
            ["🚫 none  ", "NONE"]          // 0
        ];

        // When color detected (hat block - event)
        Blockly.Blocks['when_color_detected'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(COLOR_SENSOR_ICON, 20, 20, "*"))
                    .appendField("when")
                    .appendField(new Blockly.FieldDropdown(COLOR_OPTIONS), "COLOR");
                this.appendDummyInput()
                    .appendField("detected");
                this.setInputsInline(true);
                this.setNextStatement(true, null);
                this.setColour("#9B59B6");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Detecting color? (boolean reporter)
        Blockly.Blocks['detecting_color'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(COLOR_SENSOR_ICON, 18, 18, "*"))
                    .appendField("detecting")
                    .appendField(new Blockly.FieldDropdown(COLOR_OPTIONS), "COLOR");
                this.appendDummyInput()
                    .appendField("?");
                this.setInputsInline(true);
                this.setOutput(true, "Boolean");
                this.setColour("#9B59B6");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Color value reporter (returns current detected color as string/number)
        Blockly.Blocks['color_value'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(COLOR_SENSOR_ICON, 18, 18, "*"))
                    .appendField("color");
                this.setOutput(true, "String");
                this.setColour("#9B59B6");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Reflection comparison (reflection < 50 %)
        Blockly.Blocks['reflection_compare'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(COLOR_SENSOR_ICON, 18, 18, "*"))
                    .appendField("reflection")
                    .appendField(new Blockly.FieldDropdown([
                        ["<", "LT"],
                        [">", "GT"],
                        ["=", "EQ"]
                    ]), "OP")
                    .appendField(new Blockly.FieldNumber(50, 0, 100), "VALUE")
                    .appendField("%?");
                this.setOutput(true, "Boolean");
                this.setColour("#9B59B6");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Reflection value reporter (returns 0-100)
        Blockly.Blocks['reflection_value'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(COLOR_SENSOR_ICON, 18, 18, "*"))
                    .appendField("reflection");
                this.setOutput(true, "Number");
                this.setColour("#9B59B6");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Color hue reporter (returns hue value)
        Blockly.Blocks['color_hue'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(COLOR_SENSOR_ICON, 18, 18, "*"))
                    .appendField("color")
                    .appendField(new Blockly.FieldDropdown([
                        ["hue", "HUE"],
                        ["saturation", "SAT"],
                        ["value", "VAL"]
                    ]), "MODE");
                this.setOutput(true, "Number");
                this.setColour("#9B59B6");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // ========== END COLOR SENSOR BLOCKS ==========

        // Operatör Blokları
        Blockly.Blocks['math_arithmetic'] = {
            init: function () {
                this.appendValueInput('A')
                    .setCheck('Number');
                this.appendDummyInput()
                    .appendField(new Blockly.FieldDropdown([
                        ["+", "ADD"],
                        ["-", "MINUS"],
                        ["×", "MULTIPLY"],
                        ["÷", "DIVIDE"],
                        ["^", "POWER"],
                        ["mod", "MOD"]
                    ]), "OP");
                this.appendValueInput('B')
                    .setCheck('Number');
                this.setOutput(true, 'Number');
                this.setInputsInline(true);
                this.setColour("#59C059");
            }
        };

        Blockly.Blocks['math_random'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_RANDOM_PRE);
                this.appendValueInput('FROM')
                    .setCheck('Number');
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_RANDOM_MID);
                this.appendValueInput('TO')
                    .setCheck('Number');
                this.setOutput(true, 'Number');
                this.setInputsInline(true);
                this.setColour("#59C059");
            }
        };

        Blockly.Blocks['logic_compare'] = {
            init: function () {
                this.appendValueInput('A')
                    .setCheck('Number');
                this.appendDummyInput()
                    .appendField(new Blockly.FieldDropdown([
                        [">", "GT"],
                        ["<", "LT"],
                        ["=", "EQ"],
                        ["≥", "GTE"],
                        ["≤", "LTE"]
                    ]), "OP");
                this.appendValueInput('B')
                    .setCheck('Number');
                this.setOutput(true, 'Boolean');
                this.setInputsInline(true);
                this.setColour("#5CB15C");
            }
        };

        Blockly.Blocks['logic_and'] = {
            init: function () {
                this.appendValueInput('A')
                    .setCheck('Boolean');
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_LOGIC_AND);
                this.appendValueInput('B')
                    .setCheck('Boolean');
                this.setOutput(true, 'Boolean');
                this.setInputsInline(true);
                this.setColour("#5CB15C");
            }
        };

        Blockly.Blocks['logic_or'] = {
            init: function () {
                this.appendValueInput('A')
                    .setCheck('Boolean');
                this.appendDummyInput()
                    .appendField(Blockly.Msg.BLOCK_LOGIC_OR);
                this.appendValueInput('B')
                    .setCheck('Boolean');
                this.setOutput(true, 'Boolean');
                this.setInputsInline(true);
                this.setColour("#5CB15C");
            }
        };

        Blockly.Blocks['logic_negate'] = {
            init: function () {
                this.appendValueInput('BOOL')
                    .setCheck('Boolean')
                    .appendField(Blockly.Msg.BLOCK_LOGIC_NOT);
                this.setOutput(true, 'Boolean');
                this.setColour("#5CB15C");
            }
        };

        // Sayı bloğu (shadow bloklar için)
        Blockly.Blocks['math_number'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new CustomNumberField(0, -999, 999), 'NUM');
                this.setOutput(true, 'Number');
                this.setColour("#59C059");
            }
        };

        // Hub LED Color Block for Spike Essential
        const HUB_LED_ICON = "img/spike_essential_icon.png";

        const HUB_LED_COLORS = [
            ["🔴", "RED"],
            ["🟠", "ORANGE"],
            ["🟡", "YELLOW"],
            ["🟢", "GREEN"],
            ["🔵", "BLUE"],
            ["🟣", "PURPLE"],
            ["🩷", "PINK"],
            ["🩵", "CYAN"],
            ["⬜", "WHITE"],
            ["⬛", "OFF"]
        ];

        // Helper to create visual color dropdown items (SVG Dots)
        const createColorDropdownItem = (color, name, id) => {
            const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="${color}" stroke="#ddd" stroke-width="1"/></svg>`;
            const src = `data:image/svg+xml;utf8,${encodeURIComponent(svg)}`;
            // Return [Image, Value] pair for Blockly Dropdown
            return [{ "src": src, "width": 20, "height": 20, "alt": name }, String(id)];
        };

        // Spike 3x3 Matrix Color Palette (LPF2 IDs)
        const MATRIX_COLOR_OPTIONS = [
            createColorDropdownItem('#FF0000', 'Red', 9),     // Red
            createColorDropdownItem('#FF8C00', 'Orange', 8),  // Orange
            createColorDropdownItem('#FFE900', 'Yellow', 7),  // Yellow
            createColorDropdownItem('#00C440', 'Green', 6),   // Green
            createColorDropdownItem('#00B397', 'Teal', 5),    // Teal
            createColorDropdownItem('#40E4FF', 'Cyan', 4),    // Cyan
            createColorDropdownItem('#2E53E5', 'Blue', 3),    // Blue
            createColorDropdownItem('#9388E6', 'Violet', 2),  // Violet
            createColorDropdownItem('#FF6680', 'Pink', 1),    // Pink
            createColorDropdownItem('#FFFFFF', 'White', 10),  // White
            createColorDropdownItem('#000000', 'Black', 0)    // Black
        ];

        Blockly.Blocks['hub_led_color'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(HUB_LED_ICON, 24, 20, "*"))
                    .appendField(Blockly.Msg.BLOCK_SET_HUB_LED)
                    .appendField("\u00A0\u00A0")
                    .appendField(new Blockly.FieldDropdown(HUB_LED_COLORS), "COLOR");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#F5A623");
                this.setTooltip("Set the Hub's LED color");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Hub Orientation Block (is face up?)
        const HUB_ORIENTATION_ICON = "img/spike_essential_icon.png";

        const HUB_ORIENTATIONS = [
            ["front\u00A0\u00A0\u00A0", "FRONT"],
            ["back\u00A0\u00A0\u00A0", "BACK"],
            ["top\u00A0\u00A0\u00A0", "TOP"],
            ["bottom\u00A0\u00A0\u00A0", "BOTTOM"],
            ["right side\u00A0\u00A0\u00A0", "RIGHT"],
            ["left side\u00A0\u00A0\u00A0", "LEFT"]
        ];

        Blockly.Blocks['hub_orientation'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(HUB_ORIENTATION_ICON, 24, 20, "*"))
                    .appendField(Blockly.Msg.BLOCK_HUB_IS)
                    .appendField(new Blockly.FieldDropdown(HUB_ORIENTATIONS), "ORIENTATION")
                    .appendField("\u00A0\u00A0")
                    .appendField(Blockly.Msg.BLOCK_HUB_UP);
                this.setOutput(true, "Boolean");
                this.setColour("#4FC3F7");
                this.setTooltip("Returns true if the specified face of the hub is facing up");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Remote Controller LED Color Block
        const REMOTE_LED_ICON = "img/remote_controller_icon.png";

        const REMOTE_LED_COLORS = [
            createColorDropdownItem('#FF69B4', 'Pink', 1),
            createColorDropdownItem('#9B59B6', 'Purple', 2),
            createColorDropdownItem('#3498DB', 'Blue', 3),
            createColorDropdownItem('#00A3DA', 'Light Blue', 4),
            createColorDropdownItem('#1ABC9C', 'Cyan', 5),
            createColorDropdownItem('#2ECC71', 'Green', 6),
            createColorDropdownItem('#F1C40F', 'Yellow', 7),
            createColorDropdownItem('#E67E22', 'Orange', 8),
            createColorDropdownItem('#E74C3C', 'Red', 9),
            createColorDropdownItem('#FFFFFF', 'White', 10),
            createColorDropdownItem('#000000', 'Off', 0)
        ];

        Blockly.Blocks['remote_led_color'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(REMOTE_LED_ICON, 30, 20, "*"))
                    .appendField(Blockly.Msg.BLOCK_SET_REMOTE_LED)
                    .appendField("\u00A0\u00A0")
                    .appendField(new Blockly.FieldDropdown(REMOTE_LED_COLORS), "COLOR");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#00A3DA");
                this.setTooltip("Set the Remote Controller's LED color");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Remote Controller Button State Block (boolean reporter)
        const REMOTE_BUTTON_ICON = "img/remote_controller_icon.png";

        const REMOTE_BUTTON_OPTIONS = function () {
            const t = TRANSLATIONS[currentLanguage] || TRANSLATIONS['en'];
            return [
                [t.remote_left_plus, "LEFT_PLUS"],
                [t.remote_left_minus, "LEFT_MINUS"],
                [t.remote_left_red, "LEFT_RED"],
                [t.remote_right_plus, "RIGHT_PLUS"],
                [t.remote_right_minus, "RIGHT_MINUS"],
                [t.remote_right_red, "RIGHT_RED"]
            ];
        };

        const REMOTE_STATE_OPTIONS = function () {
            const t = TRANSLATIONS[currentLanguage] || TRANSLATIONS['en'];
            return [
                [t.remote_pressed, "PRESSED"],
                [t.remote_released, "RELEASED"]
            ];
        };

        Blockly.Blocks['remote_button_state'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(REMOTE_BUTTON_ICON, 30, 20, "*"))
                    .appendField(new Blockly.FieldDropdown(REMOTE_BUTTON_OPTIONS), "BUTTON")
                    .appendField(Blockly.Msg.BLOCK_REMOTE_IS)
                    .appendField(new Blockly.FieldDropdown(REMOTE_STATE_OPTIONS), "STATE")
                    .appendField(Blockly.Msg.BLOCK_REMOTE_QM);
                this.setOutput(true, "Boolean");
                this.setColour("#00A3DA");
                this.setTooltip("Check if a Remote Controller button is pressed or released");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // Color Light Matrix - Turn off pixels
        const MATRIX_ICON = "img/matrix_icon.png";

        // Dynamic port list based on connected hub type
        function getAvailablePorts() {
            const hubType = spikeHubState?.hubType || 'spike_essential';

            if (hubType === 'spike_prime') {
                // 6 ports for Spike Prime
                return [["A   ", "A"], ["B   ", "B"], ["C   ", "C"], ["D   ", "D"], ["E   ", "E"], ["F   ", "F"]];
            } else if (hubType === 'technic_medium_hub' || hubType === 'city_hub' || hubType === 'boost_move_hub') {
                // 4 ports for Technic Hub, City Hub, Boost Move Hub
                return [["A   ", "A"], ["B   ", "B"], ["C   ", "C"], ["D   ", "D"]];
            } else {
                // 2 ports for Spike Essential and others
                return [["A   ", "A"], ["B   ", "B"]];
            }
        }

        const MATRIX_PORTS = function () {
            let deviceId = typeof selectedDeviceId !== 'undefined' ? selectedDeviceId : null;
            if (this && this.sourceBlock_ && this.sourceBlock_.data) {
                deviceId = this.sourceBlock_.data;
            }

            // Color Light Matrix IO Type
            const COLOR_LIGHT_MATRIX_IO = 0x0040;

            // Find ports with Color Light Matrix attached
            // Check spikeHubState (2-4 port hubs) and spikePrimeHubState (6 port hubs)
            const matrixPorts = [];
            const portLetters = ['A', 'B', 'C', 'D', 'E', 'F'];

            for (const letter of portLetters) {
                // Check spikeHubState first
                const portState = spikeHubState[`port${letter}`];
                if (portState && portState.type === COLOR_LIGHT_MATRIX_IO) {
                    matrixPorts.push([`${letter}\u00A0\u00A0\u00A0`, letter]);
                    continue;
                }
                // Check spikePrimeHubState for 6-port hubs
                if (typeof spikePrimeHubState !== 'undefined') {
                    const primePortState = spikePrimeHubState[`port${letter}`];
                    if (primePortState && primePortState.type === COLOR_LIGHT_MATRIX_IO) {
                        matrixPorts.push([`${letter}\u00A0\u00A0\u00A0`, letter]);
                    }
                }
            }

            // If no matrix ports found, show "?" as placeholder
            if (matrixPorts.length === 0) {
                return [["?\u00A0\u00A0\u00A0", "?"]];
            }

            return matrixPorts;
        };

        Blockly.Blocks['matrix_turn_off'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(MATRIX_ICON, 24, 24, "*"))
                    .appendField(new Blockly.FieldDropdown(MATRIX_PORTS), "PORT")
                    .appendField(Blockly.Msg.BLOCK_MATRIX_OFF)
                    .appendField("\u00A0\u00A0");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9B59B6");
                this.setTooltip("Turn off all pixels on the Color Light Matrix");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['matrix_turn_on'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(MATRIX_ICON, 24, 24, "*"))
                    .appendField(new Blockly.FieldDropdown(MATRIX_PORTS), "PORT")
                    .appendField(Blockly.Msg.BLOCK_MATRIX_ON)
                    .appendField(new PixelMatrixField('0,0,0,0,0,0,0,0,0'), "PATTERN");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9B59B6");
                this.setTooltip("Display a pattern on the Color Light Matrix");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['matrix_set_brightness'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(MATRIX_ICON, 24, 24, "*"))
                    .appendField(new Blockly.FieldDropdown(MATRIX_PORTS), "PORT")
                    .appendField(Blockly.Msg.BLOCK_MATRIX_BRIGHTNESS)
                    .appendField("\u00A0\u00A0");
                this.appendValueInput("BRIGHTNESS")
                    .setCheck("Number");
                this.appendDummyInput()
                    .appendField("%");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9B59B6");
                this.setTooltip("Set brightness of matrix (0-100%)");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['matrix_set_pixel_at'] = {
            init: function () {
                // Generate color options from PIXEL_COLORS
                // Make sure PIXEL_COLORS is accessible. If not, fallback to basic list.
                // Use visual color options
                const colorOptions = MATRIX_COLOR_OPTIONS;

                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(MATRIX_ICON, 24, 24, "*"))
                    .appendField(new Blockly.FieldDropdown(MATRIX_PORTS), "PORT")
                    .appendField(Blockly.Msg.BLOCK_MATRIX_PIXEL_AT)
                    .appendField(new Blockly.FieldDropdown([["1", "1"], ["2", "2"], ["3", "3"]]), "X")
                    .appendField(",")
                    .appendField(new Blockly.FieldDropdown([["1", "1"], ["2", "2"], ["3", "3"]]), "Y")
                    .appendField(Blockly.Msg.BLOCK_MATRIX_TO)
                    .appendField(new Blockly.FieldDropdown(colorOptions), "COLOR")
                    .appendField(Blockly.Msg.BLOCK_MATRIX_AT);
                this.appendValueInput("BRIGHTNESS").setCheck("Number");
                this.appendDummyInput().appendField("%");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9B59B6");
                this.setTooltip("Set specific pixel color and brightness");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) this.data = selectedDeviceId;
                });
            }
        };

        Blockly.Blocks['matrix_rotate_pattern'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(MATRIX_ICON, 24, 24, "*"))
                    .appendField(new Blockly.FieldDropdown(MATRIX_PORTS), "PORT")
                    .appendField(Blockly.Msg.BLOCK_MATRIX_ROTATE)
                    .appendField(new Blockly.FieldDropdown([["↷", "CW"], ["↶", "CCW"]]), "DIRECTION");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9B59B6");
                this.setTooltip("Rotate the pattern 90 degrees");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) this.data = selectedDeviceId;
                });
            }
        };
        Blockly.Python = new Blockly.Generator('Python');

        const FORCE_SENSOR_ICON = "img/force_sensor_icon.png";

        const FORCE_PORTS = function () {
            let deviceId = typeof selectedDeviceId !== 'undefined' ? selectedDeviceId : null;
            if (this && this.sourceBlock_ && this.sourceBlock_.data) {
                deviceId = this.sourceBlock_.data;
            }

            // Force Sensor IO Type
            const FORCE_SENSOR_IO = 0x003F;

            // Find ports with Force Sensor attached
            const forcePorts = [];
            const portLetters = ['A', 'B', 'C', 'D', 'E', 'F'];

            for (const letter of portLetters) {
                // Check spikeHubState first
                const portState = spikeHubState[`port${letter}`];
                if (portState && portState.type === FORCE_SENSOR_IO) {
                    forcePorts.push([`${letter}\u00A0\u00A0\u00A0`, letter]);
                    continue;
                }
                // Check spikePrimeHubState for 6-port hubs
                if (typeof spikePrimeHubState !== 'undefined') {
                    const primePortState = spikePrimeHubState[`port${letter}`];
                    if (primePortState && primePortState.type === FORCE_SENSOR_IO) {
                        forcePorts.push([`${letter}\u00A0\u00A0\u00A0`, letter]);
                    }
                }
            }

            // If no force sensor ports found, show "?" as placeholder
            if (forcePorts.length === 0) {
                return [["?\u00A0\u00A0\u00A0", "?"]];
            }

            return forcePorts;
        };

        const FORCE_STATES = [
            ["pressed\u00A0\u00A0\u00A0", "PRESSED"],
            ["hard-pressed\u00A0\u00A0\u00A0", "HARD_PRESSED"],
            ["released\u00A0\u00A0\u00A0", "RELEASED"]
        ];

        const FORCE_UNITS = [
            ["newton\u00A0\u00A0\u00A0", "NEWTON"],
            ["%\u00A0\u00A0\u00A0", "PERCENT"]
        ];

        Blockly.Blocks['force_sensor_is_pressed'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(FORCE_SENSOR_ICON, 24, 24, "*"))
                    .appendField(new Blockly.FieldDropdown(FORCE_PORTS), "PORT")
                    .appendField(Blockly.Msg.BLOCK_FORCE_IS)
                    .appendField(new Blockly.FieldDropdown(FORCE_STATES), "STATE")
                    .appendField("\u00A0\u00A0?");
                this.setOutput(true, "Boolean");
                this.setColour("#4FC3F7");
                this.setTooltip("Check if the Force Sensor is pressed, hard-pressed, or released");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['force_sensor_pressure'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(FORCE_SENSOR_ICON, 24, 24, "*"))
                    .appendField(new Blockly.FieldDropdown(FORCE_PORTS), "PORT")
                    .appendField(Blockly.Msg.BLOCK_FORCE_PRESSURE)
                    .appendField(new Blockly.FieldDropdown(FORCE_UNITS), "UNIT")
                    .appendField("\u00A0\u00A0");
                this.setOutput(true, "Number");
                this.setColour("#4FC3F7");
                this.setTooltip("Get the pressure value from the Force Sensor");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        // ===== DISTANCE SENSOR BLOCKS =====
        const DISTANCE_SENSOR_ICON = "img/distance_sensor_icon.png";

        const DISTANCE_PORTS = function () {
            let deviceId = typeof selectedDeviceId !== 'undefined' ? selectedDeviceId : null;
            if (this && this.sourceBlock_ && this.sourceBlock_.data) {
                deviceId = this.sourceBlock_.data;
            }

            // Distance Sensor IO Type
            const DISTANCE_SENSOR_IO = 0x003E;

            // Find ports with Distance Sensor attached
            const distancePorts = [];
            const portLetters = ['A', 'B', 'C', 'D', 'E', 'F'];

            for (const letter of portLetters) {
                // Check spikeHubState first
                const portState = spikeHubState[`port${letter}`];
                if (portState && portState.type === DISTANCE_SENSOR_IO) {
                    distancePorts.push([`${letter}\u00A0\u00A0\u00A0`, letter]);
                    continue;
                }
                // Check spikePrimeHubState for 6-port hubs
                if (typeof spikePrimeHubState !== 'undefined') {
                    const primePortState = spikePrimeHubState[`port${letter}`];
                    if (primePortState && primePortState.type === DISTANCE_SENSOR_IO) {
                        distancePorts.push([`${letter}\u00A0\u00A0\u00A0`, letter]);
                    }
                }
            }

            // If no distance sensor ports found, show "?" as placeholder
            if (distancePorts.length === 0) {
                return [[`?\u00A0\u00A0\u00A0`, "?"]];
            }

            return distancePorts;
        };

        const DISTANCE_COMPARISONS = function () {
            const isTr = currentLanguage === 'tr';
            return [
                [isTr ? "yakın\u00A0\u00A0\u00A0" : "closer than\u00A0\u00A0\u00A0", "CLOSER"],
                [isTr ? "uzak\u00A0\u00A0\u00A0" : "farther than\u00A0\u00A0\u00A0", "FARTHER"],
                [isTr ? "tam\u00A0\u00A0\u00A0" : "exactly at\u00A0\u00A0\u00A0", "EXACTLY"]
            ];
        };

        const DISTANCE_UNITS = function () {
            return [
                ["cm\u00A0\u00A0\u00A0", "CM"],
                ["inches\u00A0\u00A0\u00A0", "INCHES"]
            ];
        };

        Blockly.Blocks['distance_sensor_is'] = {
            init: function () {
                const isTr = currentLanguage === 'tr';
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(DISTANCE_SENSOR_ICON, 24, 24, "*"))
                    .appendField(new Blockly.FieldDropdown(DISTANCE_PORTS), "PORT")
                    .appendField(isTr ? Blockly.Msg.BLOCK_DISTANCE_IS || "is" : "is")
                    .appendField(new Blockly.FieldDropdown(DISTANCE_COMPARISONS), "COMPARISON")
                    .appendField(new CustomNumberField(15, 0, 200), "VALUE")
                    .appendField(new Blockly.FieldDropdown(DISTANCE_UNITS), "UNIT")
                    .appendField("\u00A0\u00A0?");
                this.setOutput(true, "Boolean");
                this.setColour("#4FC3F7");
                this.setTooltip("Check if the Distance Sensor detects distance closer than, farther than, or exactly at the specified value");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['distance_sensor_value'] = {
            init: function () {
                const isTr = currentLanguage === 'tr';
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(DISTANCE_SENSOR_ICON, 24, 24, "*"))
                    .appendField(new Blockly.FieldDropdown(DISTANCE_PORTS), "PORT")
                    .appendField(isTr ? Blockly.Msg.BLOCK_DISTANCE_VALUE || "distance in" : "distance in")
                    .appendField(new Blockly.FieldDropdown(DISTANCE_UNITS), "UNIT")
                    .appendField("\u00A0\u00A0");
                this.setOutput(true, "Number");
                this.setColour("#4FC3F7");
                this.setTooltip("Get the distance value from the Distance Sensor in cm or inches");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        const COLOR_SENSOR_ICON_BLOCK = "img/color_sensor_icon.png";

        // Helper to find ports with Color Sensor (Type 61 or 0x3D)
        const COLOR_PORTS = function () {
            const colorPorts = [];
            const isTr = currentLanguage === 'tr';
            const portLetters = ['A', 'B', 'C', 'D', 'E', 'F'];
            const COLOR_SENSOR_IO = 61; // Also 0x3D for Spike Prime

            for (const letter of portLetters) {
                // Check spikeHubState (Essential/Technic)
                const portState = spikeHubState[`port${letter}`];
                if (portState && (portState.type === COLOR_SENSOR_IO || portState.type === 0x3D)) {
                    colorPorts.push([`${letter}\u00A0\u00A0\u00A0`, letter]);
                    continue;
                }
                // Check spikePrimeHubState (Prime)
                if (typeof spikePrimeHubState !== 'undefined') {
                    const primePortState = spikePrimeHubState[`port${letter}`];
                    if (primePortState && (primePortState.type === COLOR_SENSOR_IO || primePortState.type === 0x3D)) {
                        colorPorts.push([`${letter}\u00A0\u00A0\u00A0`, letter]);
                    }
                }
            }

            if (colorPorts.length === 0) {
                return [[`?\u00A0\u00A0\u00A0`, "?"]];
            }
            return colorPorts;
        };

        const LEGO_COLORS_BLOCK = function () {
            const isTr = currentLanguage === 'tr';
            return [
                ["🔴 \u00A0 " + (isTr ? "Kırmızı" : "Red"), "9"],
                ["🟢 \u00A0 " + (isTr ? "Yeşil" : "Green"), "6"],
                ["🔵 \u00A0 " + (isTr ? "Mavi" : "Blue"), "3"],
                ["🟡 \u00A0 " + (isTr ? "Sarı" : "Yellow"), "7"],
                ["⚫ \u00A0 " + (isTr ? "Siyah" : "Black"), "0"],
                ["⚪ \u00A0 " + (isTr ? "Beyaz" : "White"), "10"],
                ["🟣 \u00A0 " + (isTr ? "Mor" : "Violet"), "1"],
                ["💠 \u00A0 " + (isTr ? "A.Mavi" : "Azure"), "4"],
                ["🧼 \u00A0 " + (isTr ? "Turkuaz" : "Teal"), "5"],
                ["🚫 \u00A0 " + (isTr ? "Yok" : "None"), "-1"]
            ];
        };

        Blockly.Blocks['color_sensor_is_color'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(COLOR_SENSOR_ICON_BLOCK, 24, 24, "*"))
                    .appendField(new Blockly.FieldDropdown(COLOR_PORTS), "PORT")
                    .appendField(Blockly.Msg.BLOCK_COLOR_IS)
                    .appendField(new Blockly.FieldDropdown(LEGO_COLORS_BLOCK), "COLOR")
                    .appendField("?");
                this.setOutput(true, "Boolean");
                this.setColour("#00c4d9");
                const isTr = currentLanguage === 'tr';
                this.setTooltip(isTr ? "Seçilen rengin algılanıp algılanmadığını kontrol eder" : "Checks if the sensor detects the selected color");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Blocks['color_sensor_color'] = {
            init: function () {
                this.appendDummyInput()
                    .appendField(new Blockly.FieldImage(COLOR_SENSOR_ICON_BLOCK, 24, 24, "*"))
                    .appendField(new Blockly.FieldDropdown(COLOR_PORTS), "PORT")
                    .appendField(Blockly.Msg.BLOCK_COLOR_VALUE);
                this.setOutput(true, "Number");
                this.setColour("#00c4d9");
                const isTr = currentLanguage === 'tr';
                this.setTooltip(isTr ? "Algılanan rengin sayısal değerini verir" : "Returns the detected color ID");
                this.setOnChange(function (e) {
                    if (e.type === Blockly.Events.BLOCK_CREATE && selectedDeviceId) {
                        this.data = selectedDeviceId;
                    }
                });
            }
        };

        Blockly.Python['start'] = () => '# When play clicked\n';
        Blockly.Python['when_condition'] = (b) => {
            const condition = Blockly.Python.valueToCode(b, 'CONDITION', Blockly.Python.ORDER_NONE) || 'True';
            return `# When ${condition}\n`;
        };
        Blockly.Python['when_message_received'] = (b) => {
            const message = b.getFieldValue('MESSAGE');
            return `# When ${message} received\n`;
        };
        Blockly.Python['send_message'] = (b) => {
            const message = b.getFieldValue('MESSAGE');
            return `send_message("${message}")\n`;
        };
        Blockly.Python['forward'] = (b) => `forward(${b.getFieldValue('STEPS')})\n`;
        Blockly.Python['turn_right'] = (b) => `turn_right(${b.getFieldValue('DEG')})\n`;
        Blockly.Python['turn_left'] = (b) => `turn_left(${b.getFieldValue('DEG')})\n`;
        Blockly.Python['repeat'] = (b) => {
            const times = b.getFieldValue('TIMES');
            const branch = Blockly.Python.statementToCode(b, 'DO');
            return `for i in range(${times}):\n${branch}\n`;
        };
        Blockly.Python['wait'] = (b) => `time.sleep(${b.getFieldValue('SECONDS')})\n`;
        Blockly.Python['forever'] = (b) => {
            const branch = Blockly.Python.statementToCode(b, 'DO');
            return `while True:\n${branch}\n`;
        };
        Blockly.Python['if_then'] = (b) => {
            const condition = Blockly.Python.valueToCode(b, 'CONDITION', Blockly.Python.ORDER_NONE) || 'False';
            const branch = Blockly.Python.statementToCode(b, 'DO');
            return `if ${condition}:\n${branch}\n`;
        };
        Blockly.Python['if_then_else'] = (b) => {
            const condition = Blockly.Python.valueToCode(b, 'CONDITION', Blockly.Python.ORDER_NONE) || 'False';
            const branchDo = Blockly.Python.statementToCode(b, 'DO');
            const branchElse = Blockly.Python.statementToCode(b, 'ELSE');
            return `if ${condition}:\n${branchDo}else:\n${branchElse}\n`;
        };
        Blockly.Python['wait_until'] = (b) => {
            const condition = Blockly.Python.valueToCode(b, 'CONDITION', Blockly.Python.ORDER_NONE) || 'False';
            return `while not (${condition}):\n    time.sleep(0.1)\n`;
        };
        Blockly.Python['repeat_until'] = (b) => {
            const condition = Blockly.Python.valueToCode(b, 'CONDITION', Blockly.Python.ORDER_NONE) || 'False';
            const branch = Blockly.Python.statementToCode(b, 'DO');
            return `while not (${condition}):\n${branch}\n`;
        };
        Blockly.Python['alarm'] = () => 'alarm()\n';
        Blockly.Python['sound'] = (b) => `play_tone(${b.getFieldValue('FREQ')})\n`;
        Blockly.Python['light'] = () => 'light_on()\n';
        Blockly.Python['led_on'] = (b) => `led_on(${b.getFieldValue('VAL')})\n`;
        Blockly.Python['led_off'] = (b) => `led_off(${b.getFieldValue('VAL')})\n`;
        Blockly.Python['smile'] = () => 'show_smile()\n';
        Blockly.Python['rgb_red_on'] = () => 'rgb_red_on()\n';
        Blockly.Python['rgb_green_on'] = () => 'rgb_green_on()\n';
        Blockly.Python['rgb_blue_on'] = () => 'rgb_blue_on()\n';
        Blockly.Python['rgb_red_off'] = () => 'rgb_red_off()\n';
        Blockly.Python['rgb_green_off'] = () => 'rgb_green_off()\n';
        Blockly.Python['rgb_blue_off'] = () => 'rgb_blue_off()\n';
        Blockly.Python['rgb_red_num'] = (b) => {
            const num = Blockly.Python.valueToCode(b, 'NUM', Blockly.Python.ORDER_ATOMIC) || '0';
            return `rgb_red_num(${num})\n`;
        };
        Blockly.Python['rgb_green_num'] = (b) => {
            const num = Blockly.Python.valueToCode(b, 'NUM', Blockly.Python.ORDER_ATOMIC) || '0';
            return `rgb_green_num(${num})\n`;
        };
        Blockly.Python['rgb_blue_num'] = (b) => {
            const num = Blockly.Python.valueToCode(b, 'NUM', Blockly.Python.ORDER_ATOMIC) || '0';
            return `rgb_blue_num(${num})\n`;
        };
        Blockly.Python['rgb_red_get'] = () => ['rgb_red_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_green_get'] = () => ['rgb_green_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_blue_get'] = () => ['rgb_blue_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_red_light_get'] = () => ['rgb_red_light_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_green_light_get'] = () => ['rgb_green_light_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_blue_light_get'] = () => ['rgb_blue_light_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_red_button_get'] = () => ['rgb_red_button_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_green_button_get'] = () => ['rgb_green_button_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['rgb_blue_button_get'] = () => ['rgb_blue_button_get()', Blockly.Python.ORDER_ATOMIC];
        Blockly.Python['motor_run_rotation'] = (b) => {
            const dir = b.getFieldValue('DIRECTION');
            const rot = b.getFieldValue('ROTATIONS');
            return `motor.run_for_rotations(${rot}, ${dir === 'CW' ? '1' : '-1'})\n`;
        };
        Blockly.Python['motor_run_to_angle'] = (b) => {
            const dir = b.getFieldValue('DIRECTION');
            const angle = b.getFieldValue('ANGLE');
            return `motor.run_to_angle(${angle}, ${dir === 'CW' ? '1' : '-1'})\n`;
        };
        Blockly.Python['motor_go_to_position'] = (b) => {
            const position = b.getFieldValue('POSITION');
            return `motor.go_to_position(${position})\n`;
        };
        Blockly.Python['motor_start'] = (b) => {
            const dir = b.getFieldValue('DIRECTION');
            return `motor.start(${dir === 'CW' ? '1' : '-1'})\n`;
        };
        Blockly.Python['motor_stop'] = () => 'motor.stop()\n';
        Blockly.Python['hub_led_color'] = (b) => {
            const color = b.getFieldValue('COLOR');
            return `hub.light.color(Color.${color})\n`;
        };
        Blockly.Python['hub_orientation'] = (b) => {
            const orientationMap = {
                'FRONT': 'Side.FRONT',
                'BACK': 'Side.BACK',
                'TOP': 'Side.TOP',
                'BOTTOM': 'Side.BOTTOM',
                'RIGHT': 'Side.RIGHT',
                'LEFT': 'Side.LEFT'
            };
            const orientation = orientationMap[b.getFieldValue('ORIENTATION')] || 'Side.TOP';
            return [`hub.imu.up() == ${orientation}`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['force_sensor_is_pressed'] = (b) => {
            const port = b.getFieldValue('PORT');
            const state = b.getFieldValue('STATE').toLowerCase(); // pressed, hard_pressed, released
            return [`force_sensor_${port}.is_${state}()`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['force_sensor_pressure'] = (b) => {
            const port = b.getFieldValue('PORT');
            const unit = b.getFieldValue('UNIT');
            if (unit === 'NEWTON') {
                return [`force_sensor_${port}.force()`, Blockly.Python.ORDER_ATOMIC];
            } else {
                return [`force_sensor_${port}.distance()`, Blockly.Python.ORDER_ATOMIC]; // Percentage maps to distance/depth
            }
        };
        Blockly.Python['distance_sensor_is'] = (b) => {
            const port = b.getFieldValue('PORT');
            const comparison = b.getFieldValue('COMPARISON');
            const value = b.getFieldValue('VALUE');
            const unit = b.getFieldValue('UNIT');
            const distance = unit === 'INCHES' ? `distance_sensor_${port}.distance() / 25.4` : `distance_sensor_${port}.distance()`;
            if (comparison === 'CLOSER') {
                return [`${distance} < ${value}`, Blockly.Python.ORDER_RELATIONAL];
            } else if (comparison === 'FARTHER') {
                return [`${distance} > ${value}`, Blockly.Python.ORDER_RELATIONAL];
            } else {
                return [`abs(${distance} - ${value}) <= 10`, Blockly.Python.ORDER_RELATIONAL];
            }
        };
        Blockly.Python['distance_sensor_value'] = (b) => {
            const port = b.getFieldValue('PORT');
            const unit = b.getFieldValue('UNIT');
            if (unit === 'INCHES') {
                return [`distance_sensor_${port}.distance() / 25.4`, Blockly.Python.ORDER_ATOMIC];
            }
            return [`distance_sensor_${port}.distance()`, Blockly.Python.ORDER_ATOMIC];
        };

        Blockly.Python['color_sensor_is_color'] = (b) => {
            const port = b.getFieldValue('PORT');
            const color = b.getFieldValue('COLOR');
            const colorMap = {
                '9': 'RED', '6': 'GREEN', '3': 'BLUE', '7': 'YELLOW', '0': 'BLACK', '10': 'WHITE',
                '1': 'VIOLET', '4': 'AZURE', '5': 'TEAL', '-1': 'NONE'
            };
            const colorName = colorMap[color] || 'NONE';
            return [`color_sensor_${port}.get_color() == '${colorName}'`, Blockly.Python.ORDER_RELATIONAL];
        };

        Blockly.Python['color_sensor_color'] = (b) => {
            const port = b.getFieldValue('PORT');
            return [`color_sensor_${port}.get_color()`, Blockly.Python.ORDER_ATOMIC];
        };

        Blockly.Python['when_lever_position'] = (b) => {
            const lever = b.getFieldValue('LEVER');
            const position = b.getFieldValue('POSITION');
            return `# When ${lever} lever is ${position}\n`;
        };
        Blockly.Python['lever_position'] = (b) => {
            const lever = b.getFieldValue('LEVER');
            const position = b.getFieldValue('POSITION');
            return [`controller.${lever.toLowerCase()}_lever_is_${position.toLowerCase()}()`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['lever_angle'] = (b) => {
            const lever = b.getFieldValue('LEVER');
            return [`controller.${lever.toLowerCase()}_lever_angle()`, Blockly.Python.ORDER_ATOMIC];
        };

        // ========== COLOR SENSOR PYTHON GENERATORS ==========
        Blockly.Python['when_color_detected'] = (b) => {
            const color = b.getFieldValue('COLOR').toLowerCase();
            return `# when ${color} detected\n`;
        };
        Blockly.Python['detecting_color'] = (b) => {
            const color = b.getFieldValue('COLOR').toLowerCase();
            return [`color_sensor.color() == '${color}'`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['color_value'] = (b) => {
            return [`color_sensor.color()`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['reflection_compare'] = (b) => {
            const ops = { 'GT': '>', 'LT': '<', 'EQ': '==' };
            const op = ops[b.getFieldValue('OP')];
            const value = b.getFieldValue('VALUE');
            return [`color_sensor.reflection() ${op} ${value}`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['reflection_value'] = (b) => {
            return [`color_sensor.reflection()`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['color_hue'] = (b) => {
            const mode = b.getFieldValue('MODE').toLowerCase();
            return [`color_sensor.${mode}()`, Blockly.Python.ORDER_ATOMIC];
        };
        // ========== END COLOR SENSOR PYTHON GENERATORS ==========

        Blockly.Python['math_arithmetic'] = (b) => {
            const ops = {
                'ADD': '+', 'MINUS': '-', 'MULTIPLY': '*',
                'DIVIDE': '/', 'POWER': '**', 'MOD': '%'
            };
            const op = ops[b.getFieldValue('OP')];
            const a = Blockly.Python.valueToCode(b, 'A', Blockly.Python.ORDER_ATOMIC) || '0';
            const bVal = Blockly.Python.valueToCode(b, 'B', Blockly.Python.ORDER_ATOMIC) || '0';
            return [`(${a} ${op} ${bVal})`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['math_random'] = (b) => {
            const from = Blockly.Python.valueToCode(b, 'FROM', Blockly.Python.ORDER_ATOMIC) || '1';
            const to = Blockly.Python.valueToCode(b, 'TO', Blockly.Python.ORDER_ATOMIC) || '10';
            return [`random.randint(${from}, ${to})`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['logic_compare'] = (b) => {
            const ops = { 'GT': '>', 'LT': '<', 'EQ': '==', 'GTE': '>=', 'LTE': '<=' };
            const op = ops[b.getFieldValue('OP')];
            const a = Blockly.Python.valueToCode(b, 'A', Blockly.Python.ORDER_ATOMIC) || '0';
            const bVal = Blockly.Python.valueToCode(b, 'B', Blockly.Python.ORDER_ATOMIC) || '0';
            return [`(${a} ${op} ${bVal})`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['logic_and'] = (b) => {
            const a = Blockly.Python.valueToCode(b, 'A', Blockly.Python.ORDER_ATOMIC) || 'False';
            const bVal = Blockly.Python.valueToCode(b, 'B', Blockly.Python.ORDER_ATOMIC) || 'False';
            return [`(${a} and ${bVal})`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['logic_or'] = (b) => {
            const a = Blockly.Python.valueToCode(b, 'A', Blockly.Python.ORDER_ATOMIC) || 'False';
            const bVal = Blockly.Python.valueToCode(b, 'B', Blockly.Python.ORDER_ATOMIC) || 'False';
            return [`(${a} or ${bVal})`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['logic_negate'] = (b) => {
            const bool = Blockly.Python.valueToCode(b, 'BOOL', Blockly.Python.ORDER_ATOMIC) || 'False';
            return [`not ${bool}`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Python['math_number'] = (b) => {
            const num = b.getFieldValue('NUM');
            return [num, Blockly.Python.ORDER_ATOMIC];
        };

        function initBlockly() {
            // Dil ayarlarını yükle (Blockly.Msg tanımları için)
            setLanguage(currentLanguage);

            workspace = Blockly.inject('blocklyDiv', {
                grid: {
                    spacing: 25,       // Daha geniş aralık
                    length: 1,         // Nokta boyutu (1 = küçük nokta)
                    colour: '#d0d0d0', // Hafif görünür gri
                    snap: true         // Blokları ızgaraya hizala
                },
                toolbox: `
                    <xml xmlns="https://developers.google.com/blockly/xml">
                        <block type="start"></block>
                        <block type="when_condition"></block>
                        <block type="when_message_received">
                            <field name="MESSAGE">message1</field>
                        </block>
                        <block type="send_message">
                            <field name="MESSAGE">message1</field>
                        </block>
                        <block type="forward">
                            <value name="STEPS">
                                <shadow type="math_number">
                                    <field name="NUM">4</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="turn_right">
                            <value name="DEG">
                                <shadow type="math_number">
                                    <field name="NUM">4</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="turn_left">
                            <value name="DEG">
                                <shadow type="math_number">
                                    <field name="NUM">4</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="repeat">
                            <value name="TIMES">
                                <shadow type="math_number">
                                    <field name="NUM">10</field>
                                </shadow>
                            </value>
                        </block>
                        <block type="alarm"></block>
                        <block type="sound"><field name="FREQ">300</field></block>
                        <block type="light"></block>
                        <block type="led_on"><field name="VAL">90</field></block>
                        <block type="led_off"><field name="VAL">90</field></block>
                        <block type="rgb_red_button_get"></block>
                        <block type="rgb_green_button_get"></block>
                        <block type="rgb_blue_button_get"></block>
                        <block type="smile"></block>
                    </xml>
                `,
                horizontalLayout: false,
                toolboxPosition: 'start',
                renderer: 'zelos',
                // Flyout ayarları - sabit genişlik için
                flyoutAutoClose: false,
                zoom: {
                    controls: false,
                    wheel: true,
                    startScale: 1.0,
                    maxScale: 2.0,
                    minScale: 0.5,
                    scaleSpeed: 1.15
                },
                grid: {
                    spacing: 25,       // Daha geniş aralık
                    length: 1,         // Nokta boyutu (1 = küçük nokta)
                    colour: '#d0d0d0', // Hafif görünür gri
                    snap: true         // Blokları ızgaraya hizala
                },
                move: {
                    scrollbars: {
                        horizontal: true,
                        vertical: true
                    },
                    drag: true,
                    wheel: true
                },
                trashcan: false
            });

            // Blok eklendiğinde cihaz ikonu ekle
            workspace.addChangeListener(function (event) {
                // Blok seçildiğinde silme butonunu göster
                if (event.type === Blockly.Events.SELECTED) {
                    handleBlockSelection(event);
                }

                if (event.type === Blockly.Events.BLOCK_CREATE && currentToolboxDevice) {
                    // Use currentToolboxDevice - this is set when device toolbox opens
                    // and doesn't change when user clicks elsewhere during drag
                    // console.log('🆕 BLOCK_CREATE: currentToolboxDevice =', currentToolboxDevice);
                    const capturedDeviceId = currentToolboxDevice;

                    setTimeout(() => {
                        const block = workspace.getBlockById(event.blockId);
                        if (block) {
                            // Always set data from the toolbox that was open
                            // USE CUSTOM PROPERTY 'deviceId' to avoid overwrites
                            block.deviceId = capturedDeviceId;
                            block.data = capturedDeviceId;
                            // console.log('✅ Block bound to device:', capturedDeviceId);
                            // console.log('🔒 Custom block.deviceId set:', block.deviceId);

                            // Add device icon
                            const blockSvg = block.getSvgRoot();
                            if (blockSvg && !blockSvg.querySelector('.device-badge')) {
                                const deviceIconData = getDeviceIcon(capturedDeviceId);
                                if (deviceIconData && deviceIconData.html) {
                                    const foreignObject = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
                                    foreignObject.setAttribute('x', '-12');
                                    foreignObject.setAttribute('y', Math.max(4, (block.height / 2) - 11));
                                    foreignObject.setAttribute('width', '22');
                                    foreignObject.setAttribute('height', '22');
                                    foreignObject.classList.add('device-badge');

                                    const div = document.createElement('div');
                                    div.style.width = '22px';
                                    div.style.height = '22px';
                                    div.style.borderRadius = '50%';
                                    div.style.background = 'white';
                                    div.style.border = `2px solid ${deviceIconData.color}`;
                                    div.style.display = 'flex';
                                    div.style.alignItems = 'center';
                                    div.style.justifyContent = 'center';
                                    div.style.boxShadow = '0 1px 3px rgba(0,0,0,0.3)';
                                    div.style.overflow = 'hidden';
                                    div.innerHTML = deviceIconData.html;

                                    foreignObject.appendChild(div);
                                    blockSvg.appendChild(foreignObject);
                                }
                            }
                        }
                    }, 50);
                }
            });

            // Workspace drop handler
            setupWorkspaceDrop();

            // Toolbox'ı başlangıçta gizle
            setTimeout(() => {
                hideAllToolboxes();

                // Varsayılan dili İngilizce yap
                setTimeout(() => {
                    setLanguage('en');
                }, 200);
            }, 100);

            // Window resize olayında workspace'i güncelle
            window.addEventListener('resize', () => {
                Blockly.svgResize(workspace);
            });
        }

        function showCode() {
            const code = Blockly.Python.workspaceToCode(workspace);
            if (!code.trim()) {
                alert('Önce blok ekle! 🎨');
                return;
            }
            document.getElementById('codeDisplay').textContent = '# MicroPython\n\n' + code;
            document.getElementById('codeModal').classList.add('show');
        }

        function closeModal() {
            document.getElementById('codeModal').classList.remove('show');
        }

        function copyCode() {
            const code = document.getElementById('codeDisplay').textContent;
            navigator.clipboard.writeText(code).then(() => alert('✅ Kopyalandı!'));
        }

        // Global execution control flags
        var isExecutionCancelled = false;
        var isExecutionRunning = false;
        var eventCheckInterval = null;

        async function runCode() {
            const playBtn = document.querySelector('.play-btn');

            // Eğer zaten çalışıyorsa, durdur
            if (isExecutionRunning) {
                stopExecution();
                return;
            }

            // Yeni çalıştırma başlat
            isExecutionCancelled = false;
            isExecutionRunning = true;

            // Play butonunu "çalışıyor" görünümüne getir
            playBtn.style.background = '#51cf66';
            playBtn.style.boxShadow = 'inset 0 2px 8px rgba(0,0,0,0.3)';
            playBtn.title = 'Durdur / Stop';
            playBtn.classList.add('status-running');

            // Workspace'teki tüm blokları al
            const allBlocks = workspace.getAllBlocks();

            // "start" bloklarını bul ve çalıştır
            const startBlocks = allBlocks.filter(block => block.type === 'start');
            // "when_condition" bloklarını bul (Event blokları)
            const eventBlocks = allBlocks.filter(block =>
                ['when_condition', 'when_message_received', 'when_color_detected'].includes(block.type)
            );

            if (startBlocks.length === 0 && eventBlocks.length === 0) {
                showRuntimeError(TRANSLATIONS[currentLanguage].alert_no_play);
                stopExecution();
                return;
            }

            console.log('▶️ Kod çalıştırılıyor...');

            // DEBUG: Show all blocks and their data
            console.log('🔍 DEBUG: Tüm bloklar ve data değerleri:');
            allBlocks.forEach(b => console.log(`   ${b.type} (${b.id}): data=${b.data}, deviceId=${b.deviceId}`));

            // Create a separate session for each start block
            const activeFlowSessions = new Map(); // flowId -> sessionIndex

            // If no start blocks but we have event blocks, create a session to capture logs
            if (startBlocks.length === 0 && eventBlocks.length > 0) {
                const sessionIndex = startExecutionSession(1, null);
                activeFlowSessions.set(1, sessionIndex);
            }

            // Start bloklarını PARALEL olarak çalıştır (hepsi aynı anda başlar)
            const executeStartBlock = async (startBlock, flowId) => {
                // Create a new session for this flow, passing the block ID for preview
                const sessionIndex = startExecutionSession(flowId, startBlock.id);
                activeFlowSessions.set(flowId, sessionIndex);

                const myFlowId = flowId;

                // Log flow start
                logExecutionToSession(sessionIndex, `<span style="background:#e3f2fd;padding:2px 8px;border-radius:4px;display:inline-block;">👆 ${currentLanguage === 'tr' ? '▶️ Kod çalıştırıldı' : '▶️ Code started'}</span>`);

                let nextBlock = startBlock.getNextBlock();
                while (nextBlock) {
                    if (isExecutionCancelled) {
                        console.log('🛑 Kod yürütme iptal edildi.');
                        break;
                    }
                    await executeBlockPlay(nextBlock, myFlowId);
                    nextBlock = nextBlock.getNextBlock();
                }

                // Log flow completion
                if (!isExecutionCancelled) {
                    logExecutionToSession(sessionIndex, currentLanguage === 'tr'
                        ? `<span style="color:#888;">✓ Bloklar tamamlandı</span>`
                        : `<span style="color:#888;">✓ Blocks completed</span>`);
                }
            };

            // Store active sessions globally so stop and event listening can access them
            window.activeFlowSessions = activeFlowSessions;
            window.activeFlowCount = startBlocks.length;

            // Tüm start bloklarını paralel olarak başlat, her birine benzersiz flow ID ver
            await Promise.all(startBlocks.map((startBlock, index) => executeStartBlock(startBlock, index + 1)));

            // Start blokları bitti, event dinlemeye başla
            if (!isExecutionCancelled) {
                startEventListening();
            }
        }

        function stopExecution() {
            // Log stop to all active sessions
            logToAllActiveSessions(`<span style="background:#e3f2fd;padding:2px 8px;border-radius:4px;display:inline-block;">👆 ${currentLanguage === 'tr' ? '⏹️ Durduruldu' : '⏹️ Stopped'}</span>`);

            // End all active sessions
            if (window.activeFlowSessions) {
                window.activeFlowSessions.forEach((sessionIndex) => {
                    endExecutionSessionByIndex(sessionIndex);
                });
            }

            isExecutionCancelled = true;
            isExecutionRunning = false;

            // Event dinlemeyi durdur
            if (eventCheckInterval) {
                clearInterval(eventCheckInterval);
                eventCheckInterval = null;
            }

            // Play butonunu normal haline getir
            const playBtn = document.querySelector('.play-btn');
            playBtn.style.background = '#FFBF00';
            playBtn.style.boxShadow = '0 3px 8px rgba(0, 0, 0, 0.2)';
            playBtn.title = 'Kodu Çalıştır / Run Code';
            playBtn.classList.remove('status-running');
        }

        function startEventListening() {
            console.log('👂 Event dinleme başladı...');

            // Log event listening to all active sessions
            logToAllActiveSessions(`<span style="background:#fff3e0;padding:2px 8px;border-radius:4px;display:inline-block;">${currentLanguage === 'tr' ? '👂 Event dinleniyor...' : '👂 Listening for events...'}</span>`);

            // Play butonunu "dinliyor" (daha koyu yeşil) görünümüne getir
            const playBtn = document.querySelector('.play-btn');
            if (playBtn) {
                // Çalışıyor state'inden (#51cf66) daha koyu bir yeşil yap
                playBtn.style.background = '#2b8a3e';
                playBtn.title = 'Dinleniyor... (Durdurmak için tıkla)';
            }

            // Track actively running event blocks to prevent overlapping execution
            const activeEventBlocks = new Set();

            // Her 100ms'de event bloklarını kontrol et
            eventCheckInterval = setInterval(async () => {
                if (isExecutionCancelled || !isExecutionRunning) {
                    clearInterval(eventCheckInterval);
                    eventCheckInterval = null;
                    return;
                }

                const allBlocks = workspace.getAllBlocks();

                // when_condition blokları (when [condition] true olduğunda)
                const conditionBlocks = allBlocks.filter(b => b.type === 'when_condition');
                for (const block of conditionBlocks) {
                    if (isExecutionCancelled) break;

                    // Skip if this block's sequence is already running
                    if (activeEventBlocks.has(block.id)) continue;

                    const conditionBlock = block.getInputTargetBlock('CONDITION');
                    if (conditionBlock) {
                        const result = await executeBlockPlay(conditionBlock);
                        if (result === true) {
                            if (activeEventBlocks.has(block.id)) continue;

                            // Mark as active
                            activeEventBlocks.add(block.id);

                            // Execute sequence asynchronously
                            (async () => {
                                let sessionIndex = -1;
                                try {
                                    // Start a NEW Session for this event execution
                                    const eventFlowId = `event_${block.id}_${Date.now()}`;
                                    const sessionTitle = currentLanguage === 'tr' ? 'Koşul Bloğu' : 'Condition Block';
                                    sessionIndex = startExecutionSession(eventFlowId, block.id, sessionTitle);

                                    // Log start
                                    logExecutionToSession(sessionIndex, `<span style="background:#e3f2fd;padding:2px 8px;border-radius:4px;display:inline-block;">👆 ${currentLanguage === 'tr' ? '▶️ Kod çalıştırıldı' : '▶️ Code started'}</span>`);

                                    // Koşul sağlandı, altındaki blokları çalıştır
                                    let nextBlock = block.getNextBlock();
                                    while (nextBlock && !isExecutionCancelled) {
                                        await executeBlockPlay(nextBlock, eventFlowId);
                                        nextBlock = nextBlock.getNextBlock();
                                    }

                                    // Log stop
                                    logExecutionToSession(sessionIndex, `<span style="background:#e3f2fd;padding:2px 8px;border-radius:4px;display:inline-block;">👆 ${currentLanguage === 'tr' ? '⏹️ Durduruldu' : '⏹️ Stopped'}</span>`);

                                    // End the session
                                    endExecutionSessionByIndex(sessionIndex);
                                } catch (e) {
                                    console.error("Error in event execution", e);
                                } finally {
                                    activeEventBlocks.delete(block.id);
                                }
                            })();
                        }
                    }
                }

                // when_message_received blokları
                // (Bu bloklar message gönderildiğinde tetiklenir, ayrıca yönetilir)

            }, 100);
        }

        // Global scope'a ekle
        window.runCode = runCode;
        window.stopExecution = stopExecution;

        async function executeBlockPlay(block, flowId = null, depth = 0) {
            if (!block || isExecutionCancelled) return;

            // Use passed flowId or fall back to global currentFlowId
            const myFlowId = flowId !== null ? flowId : currentFlowId;

            const blockType = block.type;

            // Note: We only log meaningful actions, not every block type

            // Wait bloğu - gerçek bekleme
            if (blockType === 'wait') {
                // ValueInput'tan bağlı bloğun değerini al
                const secondsBlock = block.getInputTargetBlock('SECONDS');
                let seconds = 1; // varsayılan
                if (secondsBlock) {
                    // Recursively execute to get value (handles variables, math blocks, etc.)
                    const val = await executeBlockPlay(secondsBlock, myFlowId, depth + 1);
                    seconds = parseFloat(val);
                    if (isNaN(seconds)) seconds = 1;
                }

                logExecution(currentLanguage === 'tr' ? `⏱️ <b>${seconds}sn</b> bekle` : `⏱️ Wait <b>${seconds}s</b>`, myFlowId, depth);
                // Wait sırasında da iptal kontrolü için döngülü bekleme
                const steps = seconds * 10;
                for (let i = 0; i < steps; i++) {
                    if (isExecutionCancelled) return;
                    await sleep(100);
                }

                return;
            }

            // Repeat bloğu - döngü
            if (blockType === 'repeat') {
                const timesBlock = block.getInputTargetBlock('TIMES');
                let times = 10; // varsayılan
                if (timesBlock) {
                    times = await executeBlockPlay(timesBlock, myFlowId);
                }
                const doBlock = block.getInputTargetBlock('DO');

                console.log(`🔄 ${times} kez tekrarlanıyor...`);
                logExecution(currentLanguage === 'tr' ? `🔄 <b>${times}</b> kez tekrarla` : `🔄 Repeat <b>${times}</b> times`, myFlowId, depth);
                for (let i = 0; i < times; i++) {
                    if (isExecutionCancelled) break;

                    // Show remaining loops nicely
                    const remaining = times - i;
                    if (i > 0) { // Don't log on first iteration, avoiding clutter
                        logExecution(currentLanguage === 'tr'
                            ? `<span style="color:#666;">🔄 <b>${remaining}</b> döngü kaldı</span>`
                            : `<span style="color:#666;">🔄 <b>${remaining}</b> ${remaining === 1 ? 'loop' : 'loops'} remaining</span>`, myFlowId, depth);
                    }

                    let innerBlock = doBlock;
                    while (innerBlock) {
                        if (isExecutionCancelled) break;
                        await executeBlockPlay(innerBlock, myFlowId, depth + 1);
                        innerBlock = innerBlock.getNextBlock();
                    }
                }

                logExecution(currentLanguage === 'tr'
                    ? `<span style="color:#888;">🔄 Döngü bitti</span>`
                    : `<span style="color:#888;">🔄 Loop finished</span>`, myFlowId, depth);
                return;
            }

            // If-then bloğu
            if (blockType === 'if_then') {
                const conditionBlock = block.getInputTargetBlock('CONDITION');
                const doBlock = block.getInputTargetBlock('DO');

                // Koşulu değerlendir
                let conditionTrue = false;
                let conditionName = '';
                if (conditionBlock) {
                    const result = await executeBlockPlay(conditionBlock, myFlowId, depth + 1);
                    conditionTrue = Boolean(result);
                    // Get human-readable condition name
                    const condType = conditionBlock.type;
                    if (condType === 'rgb_red_light_get') conditionName = currentLanguage === 'tr' ? 'Kırmızı ışık' : 'Red light';
                    else if (condType === 'rgb_green_light_get') conditionName = currentLanguage === 'tr' ? 'Yeşil ışık' : 'Green light';
                    else if (condType === 'rgb_blue_light_get') conditionName = currentLanguage === 'tr' ? 'Mavi ışık' : 'Blue light';
                    else if (condType === 'rgb_red_button_get') conditionName = currentLanguage === 'tr' ? 'Kırmızı buton' : 'Red button';
                    else if (condType === 'rgb_green_button_get') conditionName = currentLanguage === 'tr' ? 'Yeşil buton' : 'Green button';
                    else if (condType === 'rgb_blue_button_get') conditionName = currentLanguage === 'tr' ? 'Mavi buton' : 'Blue button';
                    else if (condType === 'logic_compare') conditionName = currentLanguage === 'tr' ? 'Karşılaştırma' : 'Comparison';
                    else if (condType === 'logic_and') conditionName = currentLanguage === 'tr' ? 'VE koşulu' : 'AND condition';
                    else if (condType === 'logic_or') conditionName = currentLanguage === 'tr' ? 'VEYA koşulu' : 'OR condition';
                    else if (condType === 'logic_negate') conditionName = currentLanguage === 'tr' ? 'DEĞİL koşulu' : 'NOT condition';
                    else if (condType === 'remote_button_state') {
                        const btn = conditionBlock.getFieldValue('BUTTON');
                        const state = conditionBlock.getFieldValue('STATE');
                        const t = TRANSLATIONS[currentLanguage] || TRANSLATIONS['en'];
                        const btnName = t['remote_' + btn.toLowerCase()] || btn;
                        const stateName = t['remote_' + state.toLowerCase()] || state;
                        conditionName = `${btnName} ${stateName}`;
                    }
                    else conditionName = currentLanguage === 'tr' ? 'Koşul' : 'Condition';
                }

                logExecution(`${currentLanguage === 'tr' ? `❓ Eğer <b>${conditionName}</b> ise (${conditionTrue ? 'Doğru' : 'Yanlış'})` : `❓ If <b>${conditionName}</b> is (${conditionTrue ? 'True' : 'False'})`}`, myFlowId, depth);

                if (conditionTrue && doBlock) {
                    let innerBlock = doBlock;
                    while (innerBlock) {
                        if (isExecutionCancelled) break;
                        await executeBlockPlay(innerBlock, myFlowId, depth + 1);
                        innerBlock = innerBlock.getNextBlock();
                    }
                }
                return;
            }

            // Force Sensor - is pressed?
            else if (blockType === 'force_sensor_is_pressed') {
                const port = block.getFieldValue('PORT');
                const state = block.getFieldValue('STATE');

                const portData = port === 'A' ? spikeHubState.portA : spikeHubState.portB;
                let force = 0; // 0-100 (decinewtons)

                // Only read if it appears to be a Force Sensor
                if (portData && portData.type === 0x003F) {
                    force = portData.value || 0;
                }

                if (state === 'PRESSED') {
                    // Pressed: > 0 (using a small threshold of 2dN = 0.2N to avoid noise)
                    return force > 2;
                } else if (state === 'HARD_PRESSED') {
                    // Hard pressed: > 50dN (5N)
                    return force > 50;
                } else if (state === 'RELEASED') {
                    // Released: <= 2dN
                    return force <= 2;
                }
                return false;
            }

            // Force Sensor - pressure
            else if (blockType === 'force_sensor_pressure') {
                const port = block.getFieldValue('PORT');
                const unit = block.getFieldValue('UNIT');

                const portData = port === 'A' ? spikeHubState.portA : spikeHubState.portB;
                let force = 0; // 0-100 (decinewtons)

                if (portData && portData.type === 0x003F) {
                    force = portData.value || 0;
                }

                if (unit === 'NEWTON') {
                    return parseFloat((force / 10).toFixed(1));
                } else {
                    // Percentage (since max is 10N = 100dN, force is already 0-100%)
                    return force;
                }
            }

            // Distance Sensor - comparison (is closer/farther/exactly at)
            else if (blockType === 'distance_sensor_is') {
                const port = block.getFieldValue('PORT');
                const comparison = block.getFieldValue('COMPARISON');
                const value = parseFloat(block.getFieldValue('VALUE'));
                const unit = block.getFieldValue('UNIT');

                // Get port data - check all hub types
                let portData = spikeHubState[`port${port}`];
                if (!portData || portData.type !== 0x003E) {
                    // Check spikePrimeHubState
                    if (typeof spikePrimeHubState !== 'undefined') {
                        portData = spikePrimeHubState[`port${port}`];
                    }
                }

                let distance = 200; // Default max distance
                if (portData && portData.type === 0x003E) {
                    distance = portData.value || 200;
                }

                // Convert to inches if needed (1 inch = 2.54 cm)
                let measuredValue = distance;
                let compareValue = value;
                if (unit === 'INCHES') {
                    measuredValue = distance / 2.54;
                }

                if (comparison === 'CLOSER') {
                    return measuredValue < compareValue;
                } else if (comparison === 'FARTHER') {
                    return measuredValue > compareValue;
                } else if (comparison === 'EXACTLY') {
                    // Allow small tolerance (±1cm or ±0.4 inches)
                    const tolerance = unit === 'INCHES' ? 0.4 : 1;
                    return Math.abs(measuredValue - compareValue) <= tolerance;
                }
                return false;
            }

            // Distance Sensor - get value
            else if (blockType === 'distance_sensor_value') {
                const port = block.getFieldValue('PORT');
                const unit = block.getFieldValue('UNIT');

                // Get port data - check all hub types
                let portData = spikeHubState[`port${port}`];
                if (!portData || portData.type !== 0x003E) {
                    // Check spikePrimeHubState
                    if (typeof spikePrimeHubState !== 'undefined') {
                        portData = spikePrimeHubState[`port${port}`];
                    }
                }

                let distance = 200; // Default max distance
                if (portData && portData.type === 0x003E) {
                    distance = portData.value || 200;
                }

                if (unit === 'INCHES') {
                    return parseFloat((distance / 2.54).toFixed(1));
                }
                return distance;
            }

            // Color Sensor Blocks
            else if (blockType === 'color_sensor_is_color') {
                const port = block.getFieldValue('PORT');
                const targetColor = parseInt(block.getFieldValue('COLOR'), 10);

                // Get port data - check all hub types
                let portData = spikeHubState[`port${port}`];
                if (!portData || (portData.type !== 61 && portData.type !== 0x3D)) {
                    if (typeof spikePrimeHubState !== 'undefined') {
                        portData = spikePrimeHubState[`port${port}`];
                    }
                }

                let detectedColor = -1; // Default: No Color
                if (portData && (portData.type === 61 || portData.type === 0x3D)) {
                    detectedColor = portData.value !== undefined ? portData.value : -1;
                }

                return detectedColor === targetColor;
            }
            else if (blockType === 'color_sensor_color') {
                const port = block.getFieldValue('PORT');

                // Get port data
                let portData = spikeHubState[`port${port}`];
                if (!portData || (portData.type !== 61 && portData.type !== 0x3D)) {
                    if (typeof spikePrimeHubState !== 'undefined') {
                        portData = spikePrimeHubState[`port${port}`];
                    }
                }

                if (portData && (portData.type === 61 || portData.type === 0x3D)) {
                    return portData.value !== undefined ? portData.value : -1;
                }
                return -1; // No color
            }

            // Matrix Turn ON
            else if (blockType === 'matrix_turn_on') {
                const port = block.getFieldValue('PORT');
                const patternStr = block.getFieldValue('PATTERN') || '0,0,0,0,0,0,0,0,0';
                const pixels = patternStr.split(',').map(Number);
                await setSpikeMatrix(port, pixels, block.deviceId || block.data);
                logExecution(`<span style="display:inline-flex;gap:1px;vertical-align:middle;">${generateMatrixPreview(pixels)}</span> ${currentLanguage === 'tr' ? `Port ${port} matris deseni yandı` : `Port ${port} matrix pattern on`}`, myFlowId, depth);
            } else if (blockType === 'matrix_turn_off') {
                const port = block.getFieldValue('PORT');
                await setSpikeMatrix(port, [0, 0, 0, 0, 0, 0, 0, 0, 0], block.deviceId || block.data);
                logExecution(`<span style="display:inline-block;width:12px;height:12px;background:#333;border-radius:2px;vertical-align:middle;border:1px solid #666;"></span> ${currentLanguage === 'tr' ? `Port ${port} matris söndürüldü` : `Port ${port} matrix off`}`, myFlowId, depth);
            } else if (blockType === 'matrix_set_brightness') {
                const port = block.getFieldValue('PORT');
                const brightnessBlock = block.getInputTargetBlock('BRIGHTNESS');
                let brightness = 100;
                if (brightnessBlock) {
                    const val = await executeBlockPlay(brightnessBlock, flowId);
                    brightness = val !== null ? val : 100;
                }
                const bVal = Math.min(100, Math.max(0, Number(brightness)));
                await setSpikeMatrixBrightness(port, bVal, block.deviceId || block.data);
                logExecution(`<span style="display:inline-block;width:12px;height:12px;background:linear-gradient(135deg,#ffcc00,#ff9500);border-radius:2px;vertical-align:middle;opacity:${bVal / 100};"></span> ${currentLanguage === 'tr' ? `Port ${port} parlaklık <b>${bVal}%</b>` : `Port ${port} brightness <b>${bVal}%</b>`}`, myFlowId, depth);
            } else if (blockType === 'matrix_set_pixel_at') {
                const port = block.getFieldValue('PORT');
                const x = parseInt(block.getFieldValue('X'));
                const y = parseInt(block.getFieldValue('Y'));
                const color = parseInt(block.getFieldValue('COLOR'));

                const brBlock = block.getInputTargetBlock('BRIGHTNESS');
                let br = 100;
                if (brBlock) {
                    const val = await executeBlockPlay(brBlock, flowId);
                    br = val !== null ? val : 100;
                }
                const brightness = Math.round((Math.max(0, Math.min(100, Number(br))) / 100) * 10); // 0-10

                // Update specific pixel
                if (spikeHubState.matrix && spikeHubState.matrix[port]) {
                    const pixels = [...spikeHubState.matrix[port].pixels];
                    const idx = (y - 1) * 3 + (x - 1);
                    // Use Object format
                    pixels[idx] = { color: color, brightness: brightness };
                    await setSpikeMatrix(port, pixels, block.deviceId || block.data);
                }
                const pixelColorHex = ['#1c1c1e', '#ff2d55', '#ff9500', '#ffcc00', '#34c759', '#5ac8fa', '#007aff', '#af52de', '#ff3b30', '#ff6b6b', '#ffffff'][color] || '#ffcc00';
                logExecution(`<span style="display:inline-block;width:12px;height:12px;background:${pixelColorHex};border-radius:2px;vertical-align:middle;border:1px solid rgba(0,0,0,0.2);"></span> ${currentLanguage === 'tr' ? `Port ${port} piksel (${x},${y})` : `Port ${port} pixel (${x},${y})`}`, myFlowId, depth);

            } else if (blockType === 'matrix_rotate_pattern') {
                const port = block.getFieldValue('PORT');
                const dir = block.getFieldValue('DIRECTION');

                if (spikeHubState.matrix && spikeHubState.matrix[port]) {
                    const old = spikeHubState.matrix[port].pixels;
                    const newP = new Array(9);
                    // Rotations
                    if (dir === 'CW') {
                        newP[0] = old[6]; newP[1] = old[3]; newP[2] = old[0];
                        newP[3] = old[7]; newP[4] = old[4]; newP[5] = old[1];
                        newP[6] = old[8]; newP[7] = old[5]; newP[8] = old[2];
                    } else { // CCW
                        newP[0] = old[2]; newP[1] = old[5]; newP[2] = old[8];
                        newP[3] = old[1]; newP[4] = old[4]; newP[5] = old[7];
                        newP[6] = old[0]; newP[7] = old[3]; newP[8] = old[6];
                    }
                    await setSpikeMatrix(port, newP, block.deviceId || block.data);
                }
                const rotateIcon = dir === 'CW' ? '↻' : '↺';
                logExecution(`<span style="font-size:14px;vertical-align:middle;">${rotateIcon}</span> ${currentLanguage === 'tr' ? `Port ${port} desen döndürüldü (${dir === 'CW' ? 'Saat yönü' : 'Saat yönü tersi'})` : `Port ${port} pattern rotated (${dir})`}`, myFlowId, depth);
            }

            // Double Motor Blokları
            else if (blockType === 'double_motor_run_rotation') {
                const motorIndex = block.getFieldValue('MOTOR_INDEX');
                const direction = block.getFieldValue('DIRECTION');
                const rotations = block.getFieldValue('ROTATIONS');
                const deviceId = block.deviceId || block.data;

                logExecution(currentLanguage === 'tr'
                    ? `⚙️ Çift Motor ${motorIndex}: <b>${rotations}</b> tur ${direction}`
                    : `⚙️ Double Motor ${motorIndex}: <b>${rotations}</b> rot ${direction}`, myFlowId, depth);

                if (deviceId) {
                    await runDoubleMotorRotations(deviceId, motorIndex, rotations, direction);
                }
            }
            else if (blockType === 'double_motor_go_to_position') {
                const motorIndex = block.getFieldValue('MOTOR_INDEX');
                const angle = block.getFieldValue('ANGLE');
                const deviceId = block.deviceId || block.data;

                logExecution(currentLanguage === 'tr'
                    ? `⚙️ Çift Motor ${motorIndex}: <b>${angle}°</b> açısına git`
                    : `⚙️ Double Motor ${motorIndex}: Go to <b>${angle}°</b>`, myFlowId, depth);

                if (deviceId) {
                    await runDoubleMotorToPosition(deviceId, motorIndex, angle);
                }
            }
            else if (blockType === 'double_motor_start') {
                const motorIndex = block.getFieldValue('MOTOR_INDEX');
                const direction = block.getFieldValue('DIRECTION');
                const deviceId = block.deviceId || block.data;

                logExecution(currentLanguage === 'tr'
                    ? `⚙️ Çift Motor ${motorIndex}: <b>Başla</b> ${direction}`
                    : `⚙️ Double Motor ${motorIndex}: <b>Start</b> ${direction}`, myFlowId, depth);

                if (deviceId) {
                    await startDoubleMotor(deviceId, motorIndex, direction);
                }
            }
            else if (blockType === 'double_motor_stop') {
                const motorIndex = block.getFieldValue('MOTOR_INDEX');
                const deviceId = block.deviceId || block.data;

                logExecution(currentLanguage === 'tr'
                    ? `⚙️ Çift Motor ${motorIndex}: <b>Dur</b>`
                    : `⚙️ Double Motor ${motorIndex}: <b>Stop</b>`, myFlowId, depth);

                if (deviceId) {
                    await stopDoubleMotor(deviceId, motorIndex);
                }
            }
            else if (blockType === 'double_motor_set_speed') {
                const motorIndex = block.getFieldValue('MOTOR_INDEX');
                const speed = block.getFieldValue('SPEED');
                const deviceId = block.deviceId || block.data;

                logExecution(currentLanguage === 'tr'
                    ? `⚙️ Çift Motor ${motorIndex}: Hız <b>${speed}%</b>`
                    : `⚙️ Double Motor ${motorIndex}: Speed <b>${speed}%</b>`, myFlowId, depth);

                if (deviceId) {
                    await setDoubleMotorSpeed(deviceId, motorIndex, speed);
                }
            }

            else if (blockType === 'controls_if') {
                const conditionBlock = block.getInputTargetBlock('IF0');
                const conditionTrue = conditionBlock ? await executeBlockPlay(conditionBlock, myFlowId, depth + 1) : false;
                const doBlock = block.getInputTargetBlock('DO0');

                // Get variable based name if condition is a variable
                let conditionName = 'Condition';
                if (conditionBlock && conditionBlock.type === 'variables_get') {
                    conditionName = conditionBlock.getFieldValue('VAR');
                } else if (conditionBlock && conditionBlock.type === 'compare_values') {
                    conditionName = 'Comparison';
                }

                console.log('🔶 If koşulu kontrol ediliyor...', conditionTrue);
                if (conditionTrue) {
                    console.log('✅ Koşul doğru, then bloğu çalıştırılıyor');
                    logExecution(currentLanguage === 'tr'
                        ? `<span style="color:#4CAF50;">✅</span> ${conditionName} <b>doğru</b>, çalıştırılıyor`
                        : `<span style="color:#4CAF50;">✅</span> ${conditionName} is <b>true</b>, executing`, myFlowId, depth);
                    let innerBlock = doBlock;
                    while (innerBlock) {
                        if (isExecutionCancelled) break;
                        await executeBlockPlay(innerBlock, myFlowId, depth + 1);
                        innerBlock = innerBlock.getNextBlock();
                    }
                } else {
                    console.log('❌ Koşul yanlış, atlanıyor');
                    logExecution(currentLanguage === 'tr'
                        ? `<span style="color:#f44336;">❌</span> ${conditionName} <b>yanlış</b>, atlanıyor`
                        : `<span style="color:#f44336;">❌</span> ${conditionName} is <b>false</b>, skipping`, myFlowId, depth);
                }
                return;
            }

            // If-then-else bloğu
            if (blockType === 'if_then_else') {
                const conditionBlock = block.getInputTargetBlock('CONDITION');
                const doBlock = block.getInputTargetBlock('DO');
                const elseBlock = block.getInputTargetBlock('ELSE');

                // Koşulu değerlendir
                let conditionTrue = false;
                let conditionName = '';
                if (conditionBlock) {
                    const result = await executeBlockPlay(conditionBlock, myFlowId);
                    conditionTrue = Boolean(result);
                    // Get human-readable condition name
                    const condType = conditionBlock.type;
                    if (condType === 'rgb_red_light_get') conditionName = currentLanguage === 'tr' ? 'Kırmızı ışık' : 'Red light';
                    else if (condType === 'rgb_green_light_get') conditionName = currentLanguage === 'tr' ? 'Yeşil ışık' : 'Green light';
                    else if (condType === 'rgb_blue_light_get') conditionName = currentLanguage === 'tr' ? 'Mavi ışık' : 'Blue light';
                    else if (condType === 'rgb_red_button_get') conditionName = currentLanguage === 'tr' ? 'Kırmızı buton' : 'Red button';
                    else if (condType === 'rgb_green_button_get') conditionName = currentLanguage === 'tr' ? 'Yeşil buton' : 'Green button';
                    else if (condType === 'rgb_blue_button_get') conditionName = currentLanguage === 'tr' ? 'Mavi buton' : 'Blue button';
                    else if (condType === 'logic_compare') conditionName = currentLanguage === 'tr' ? 'Karşılaştırma' : 'Comparison';
                    else if (condType === 'logic_and') conditionName = currentLanguage === 'tr' ? 'VE koşulu' : 'AND condition';
                    else if (condType === 'logic_or') conditionName = currentLanguage === 'tr' ? 'VEYA koşulu' : 'OR condition';
                    else if (condType === 'logic_negate') conditionName = currentLanguage === 'tr' ? 'DEĞİL koşulu' : 'NOT condition';
                    else conditionName = currentLanguage === 'tr' ? 'Koşul' : 'Condition';
                }

                console.log('🔶 If-else koşulu kontrol ediliyor...', conditionTrue);
                if (conditionTrue) {
                    console.log('✅ Koşul doğru, then bloğu çalıştırılıyor');
                    logExecution(currentLanguage === 'tr'
                        ? `<span style="color:#4CAF50;">✅</span> ${conditionName} <b>doğru</b>, then çalıştırılıyor`
                        : `<span style="color:#4CAF50;">✅</span> ${conditionName} is <b>true</b>, executing then`, myFlowId, depth);
                    let innerBlock = doBlock;
                    while (innerBlock) {
                        if (isExecutionCancelled) break;
                        await executeBlockPlay(innerBlock, myFlowId, depth + 1);
                        innerBlock = innerBlock.getNextBlock();
                    }
                } else {
                    console.log('❌ Koşul yanlış, else bloğu çalıştırılıyor');
                    logExecution(currentLanguage === 'tr'
                        ? `<span style="color:#f44336;">❌</span> ${conditionName} <b>yanlış</b>, else çalıştırılıyor`
                        : `<span style="color:#f44336;">❌</span> ${conditionName} is <b>false</b>, executing else`, myFlowId, depth);
                    let innerBlock = elseBlock;
                    while (innerBlock) {
                        if (isExecutionCancelled) break;
                        await executeBlockPlay(innerBlock, myFlowId, depth + 1);
                        innerBlock = innerBlock.getNextBlock();
                    }
                }
                return;
            }

            // Wait until bloğu
            if (blockType === 'wait_until') {
                console.log('⏳ Wait until - koşul bekleniyor...');
                // Basitleştirilmiş: 1 saniye bekle
                await sleep(1000);
                console.log('✅ Wait until tamamlandı');
                return;
            }

            // Repeat until bloğu - koşul sağlanana kadar tekrarla
            if (blockType === 'repeat_until') {
                const conditionBlock = block.getInputTargetBlock('CONDITION');
                const doBlock = block.getInputTargetBlock('DO');

                console.log('🔁 Repeat until başladı...');

                // Determine condition name for logging
                let conditionName = currentLanguage === 'tr' ? 'koşul' : 'condition';
                if (conditionBlock) {
                    const condType = conditionBlock.type;
                    if (condType === 'rgb_red_light_get') conditionName = currentLanguage === 'tr' ? 'kırmızı ışık yanana' : 'until red light is on';
                    else if (condType === 'rgb_green_light_get') conditionName = currentLanguage === 'tr' ? 'yeşil ışık yanana' : 'until green light is on';
                    else if (condType === 'rgb_blue_light_get') conditionName = currentLanguage === 'tr' ? 'mavi ışık yanana' : 'until blue light is on';
                    else if (condType === 'rgb_red_button_get') conditionName = currentLanguage === 'tr' ? 'kırmızı butona basılana' : 'until red button is pressed';
                    else if (condType === 'rgb_green_button_get') conditionName = currentLanguage === 'tr' ? 'yeşil butona basılana' : 'until green button is pressed';
                    else if (condType === 'rgb_blue_button_get') conditionName = currentLanguage === 'tr' ? 'mavi butona basılana' : 'until blue button is pressed';
                    else conditionName = currentLanguage === 'tr' ? 'koşul sağlanana' : 'until condition is true';
                }

                // Maksimum 1000 iterasyon (sonsuz döngü koruması)
                for (let i = 0; i < 1000; i++) {
                    // Koşulu kontrol et
                    let conditionMet = false;
                    if (conditionBlock) {
                        const result = await executeBlockPlay(conditionBlock, myFlowId, depth + 1);
                        conditionMet = Boolean(result);
                    }

                    if (conditionMet) {
                        console.log('🔁 Repeat until koşul sağlandı, çıkılıyor');
                        logExecution(currentLanguage === 'tr'
                            ? `🔁 ${conditionName} kadar tekrarla tamamlandı`
                            : `🔁 Repeat ${conditionName} finished`, myFlowId, depth);
                        break;
                    }

                    if (i === 0) {
                        logExecution(currentLanguage === 'tr'
                            ? `🔁 ${conditionName} kadar tekrarla`
                            : `🔁 Repeat ${conditionName}`, myFlowId, depth);
                    }

                    // İç blokları çalıştır
                    let innerBlock = doBlock;
                    while (innerBlock) {
                        if (isExecutionCancelled) break;
                        await executeBlockPlay(innerBlock, myFlowId, depth + 1);
                        innerBlock = innerBlock.getNextBlock();
                    }

                    // Her iterasyonda küçük bir bekleme
                    await sleep(50);
                    if (isExecutionCancelled) break;
                }
                console.log('🔁 Repeat until tamamlandı');
                return;
            }

            // Forever bloğu - sonsuz döngü (şimdilik 100 kez)
            if (blockType === 'forever') {
                const doBlock = block.getInputTargetBlock('DO');
                console.log('♾️ Sürekli döngü başladı (100 iterasyon)...');
                logExecution(currentLanguage === 'tr'
                    ? `♾️ Sürekli tekrarla`
                    : `♾️ Forever loop`, myFlowId, depth);

                for (let i = 0; i < 100; i++) {
                    if (isExecutionCancelled) break;
                    let innerBlock = doBlock;
                    while (innerBlock) {
                        if (isExecutionCancelled) break;
                        await executeBlockPlay(innerBlock, myFlowId, depth + 1);
                        innerBlock = innerBlock.getNextBlock();
                    }
                    // Prevent tight loop freezing
                    await sleep(20);
                }
                return;
            }

            // RGB LED kontrolleri
            if (blockType === 'rgb_red_on') {
                rgbLedState.red = true;
                document.getElementById('rgbRedLed').classList.add('active');
                logLedValue('red', 255);
                console.log('🔴 Kırmızı LED yandı');
                logExecution(currentLanguage === 'tr' ? `<span style="display:inline-block;width:12px;height:12px;background:#ff0000;border-radius:50%;vertical-align:middle;"></span> Kırmızı LED Yandı` : `<span style="display:inline-block;width:12px;height:12px;background:#ff0000;border-radius:50%;vertical-align:middle;"></span> Red LED On`, myFlowId, depth);
            } else if (blockType === 'rgb_green_on') {
                rgbLedState.green = true;
                document.getElementById('rgbGreenLed').classList.add('active');
                logLedValue('green', 255);
                console.log('🟢 Yeşil LED yandı');
                logExecution(currentLanguage === 'tr' ? `<span style="display:inline-block;width:12px;height:12px;background:#00ff00;border-radius:50%;vertical-align:middle;"></span> Yeşil LED Yandı` : `<span style="display:inline-block;width:12px;height:12px;background:#00ff00;border-radius:50%;vertical-align:middle;"></span> Green LED On`, myFlowId, depth);
            } else if (blockType === 'rgb_blue_on') {
                rgbLedState.blue = true;
                document.getElementById('rgbBlueLed').classList.add('active');
                logLedValue('blue', 255);
                console.log('🔵 Mavi LED yandı');
                logExecution(currentLanguage === 'tr' ? `<span style="display:inline-block;width:12px;height:12px;background:#0066ff;border-radius:50%;vertical-align:middle;"></span> Mavi LED Yandı` : `<span style="display:inline-block;width:12px;height:12px;background:#0066ff;border-radius:50%;vertical-align:middle;"></span> Blue LED On`, myFlowId, depth);
            } else if (blockType === 'rgb_red_off') {
                rgbLedState.red = false;
                document.getElementById('rgbRedLed').classList.remove('active');
                logLedValue('red', 0);
                console.log('⭕ Kırmızı LED söndü');
                logExecution(currentLanguage === 'tr' ? `<span style="display:inline-block;width:12px;height:12px;border:2px solid #ff0000;border-radius:50%;vertical-align:middle;"></span> Kırmızı LED Söndü` : `<span style="display:inline-block;width:12px;height:12px;border:2px solid #ff0000;border-radius:50%;vertical-align:middle;"></span> Red LED Off`, myFlowId, depth);
            } else if (blockType === 'rgb_green_off') {
                rgbLedState.green = false;
                document.getElementById('rgbGreenLed').classList.remove('active');
                logLedValue('green', 0);
                console.log('⭕ Yeşil LED söndü');
                logExecution(currentLanguage === 'tr' ? `<span style="display:inline-block;width:12px;height:12px;border:2px solid #00ff00;border-radius:50%;vertical-align:middle;"></span> Yeşil LED Söndü` : `<span style="display:inline-block;width:12px;height:12px;border:2px solid #00ff00;border-radius:50%;vertical-align:middle;"></span> Green LED Off`, myFlowId, depth);
            } else if (blockType === 'rgb_blue_off') {
                rgbLedState.blue = false;
                document.getElementById('rgbBlueLed').classList.remove('active');
                logLedValue('blue', 0);
                console.log('⭕ Mavi LED söndü');
                logExecution(currentLanguage === 'tr' ? `<span style="display:inline-block;width:12px;height:12px;border:2px solid #0066ff;border-radius:50%;vertical-align:middle;"></span> Mavi LED Söndü` : `<span style="display:inline-block;width:12px;height:12px;border:2px solid #0066ff;border-radius:50%;vertical-align:middle;"></span> Blue LED Off`, myFlowId, depth);
            }

            // RGB sayı kontrolleri
            else if (blockType === 'rgb_red_num') {
                const numBlock = block.getInputTargetBlock('NUM');
                const numValue = numBlock ? await executeBlockPlay(numBlock, myFlowId) : 0;
                rgbNumberState.red = numValue;
                document.getElementById('rgbRedNum').textContent = numValue;
                logNumberValue('red', numValue);
                console.log('🟥 Kırmızı sayı:', numValue);
                logExecution(`<span style="display:inline-block;width:12px;height:12px;background:#ff0000;vertical-align:middle;border-radius:2px;"></span> ${currentLanguage === 'tr' ? `Kırmızı sayı <b>${numValue}</b> yapıldı` : `Red number set to <b>${numValue}</b>`}`, myFlowId, depth);
            } else if (blockType === 'rgb_green_num') {
                const numBlock = block.getInputTargetBlock('NUM');
                const numValue = numBlock ? await executeBlockPlay(numBlock, myFlowId) : 0;
                rgbNumberState.green = numValue;
                document.getElementById('rgbGreenNum').textContent = numValue;
                logNumberValue('green', numValue);
                console.log('🟩 Yeşil sayı:', numValue);
                logExecution(`<span style="display:inline-block;width:12px;height:12px;background:#00ff00;vertical-align:middle;border-radius:2px;"></span> ${currentLanguage === 'tr' ? `Yeşil sayı <b>${numValue}</b> yapıldı` : `Green number set to <b>${numValue}</b>`}`, myFlowId, depth);
            } else if (blockType === 'rgb_blue_num') {
                const numBlock = block.getInputTargetBlock('NUM');
                const numValue = numBlock ? await executeBlockPlay(numBlock, myFlowId) : 0;
                rgbNumberState.blue = numValue;
                document.getElementById('rgbBlueNum').textContent = numValue;
                logNumberValue('blue', numValue);
                console.log('🟦 Mavi sayı:', numValue);
                logExecution(`<span style="display:inline-block;width:12px;height:12px;background:#0066ff;vertical-align:middle;border-radius:2px;"></span> ${currentLanguage === 'tr' ? `Mavi sayı <b>${numValue}</b> yapıldı` : `Blue number set to <b>${numValue}</b>`}`, myFlowId, depth);
            }

            // RGB sayı getir kontrolleri
            else if (blockType === 'rgb_red_get') {
                console.log('🟥 Kırmızı sayı getir:', rgbNumberState.red);
                return rgbNumberState.red;
            } else if (blockType === 'rgb_green_get') {
                console.log('🟩 Yeşil sayı getir:', rgbNumberState.green);
                return rgbNumberState.green;
            } else if (blockType === 'rgb_blue_get') {
                console.log('🟦 Mavi sayı getir:', rgbNumberState.blue);
                return rgbNumberState.blue;
            }

            // RGB ışık getir kontrolleri
            else if (blockType === 'rgb_red_light_get') {
                console.log('🔴 Kırmızı ışık getir:', rgbLedState.red);
                return rgbLedState.red;
            } else if (blockType === 'rgb_green_light_get') {
                console.log('🟢 Yeşil ışık getir:', rgbLedState.green);
                return rgbLedState.green;
            } else if (blockType === 'rgb_blue_light_get') {
                console.log('🔵 Mavi ışık getir:', rgbLedState.blue);
                return rgbLedState.blue;
            }

            // RGB tuş getir kontrolleri
            else if (blockType === 'rgb_red_button_get') {
                console.log('🔺 Kırmızı tuş getir:', btnStates.red);
                return btnStates.red;
            } else if (blockType === 'rgb_green_button_get') {
                console.log('🔺 Yeşil tuş getir:', btnStates.green);
                return btnStates.green;
            } else if (blockType === 'rgb_blue_button_get') {
                console.log('🔺 Mavi tuş getir:', btnStates.blue);
                return btnStates.blue;
            }

            // Motor kontrolleri
            else if (blockType === 'motor_run_rotation') {
                const dir = block.getFieldValue('DIRECTION');
                const rot = block.getFieldValue('ROTATIONS');
                console.log(`🔄 Motor ${dir === 'CW' ? '↻' : '↺'} ${rot} rotasyon`);

                // Bluetooth motor kontrolü
                const deviceId = block.deviceId || block.data;
                console.log('DEBUG: deviceId =', deviceId);
                console.log('DEBUG: block =', block);
                console.log('DEBUG: block.data =', block.data);

                if (deviceId) {
                    console.log('✅ deviceId var, runMotorRotations çağrılıyor...');
                    await runMotorRotations(deviceId, parseInt(rot), dir);
                } else {
                    console.log('❌ deviceId yok! Motor Bluetooth komutu gönderilemedi.');
                    console.log('   Motor cihazını önce bağlayın ve bloğu motor ikonundan sürükleyin.');
                }
                return; // Motor run_rotation işlemi tamamlandı
            } else if (blockType === 'motor_run_to_angle') {
                const dir = block.getFieldValue('DIRECTION');
                const angle = block.getFieldValue('ANGLE');
                console.log(`🎯 Motor ${dir === 'CW' ? '↻' : '↺'} ${angle}° açıya git (göreceli)`);

                // Bluetooth motor kontrolü
                const deviceId = block.deviceId || block.data;
                console.log('DEBUG: deviceId =', deviceId);

                if (deviceId) {
                    console.log('✅ deviceId var, runMotorToAngle çağrılıyor...');
                    await runMotorToAngle(deviceId, parseInt(angle), dir);
                } else {
                    console.log('❌ deviceId yok! Motor Bluetooth komutu gönderilemedi.');
                }
                return; // Motor run_to_angle işlemi tamamlandı
            } else if (blockType === 'motor_go_to_position') {
                const position = block.getFieldValue('POSITION');
                console.log(`📍 Motor ${position}° pozisyonuna git (mutlak)`);

                // Bluetooth motor kontrolü
                const deviceId = block.deviceId || block.data;
                if (deviceId) {
                    await goToPosition(deviceId, parseInt(position));
                } else {
                    console.log('❌ deviceId yok!');
                }
                return; // Motor go_to_position işlemi tamamlandı
            } else if (blockType === 'motor_start') {
                const dir = block.getFieldValue('DIRECTION');
                console.log(`▶️ Motor ${dir === 'CW' ? '↻' : '↺'} başlatıldı`);

                // Bluetooth motor kontrolü
                const deviceId = block.deviceId || block.data;
                if (deviceId) {
                    await startMotor(deviceId, dir);
                } else {
                    console.log('❌ deviceId yok!');
                }
                return; // Motor start işlemi tamamlandı
            } else if (blockType === 'motor_stop') {
                console.log('⏹️ Motor durduruldu');

                // Bluetooth motor kontrolü
                const deviceId = block.deviceId || block.data;
                if (deviceId) {
                    await stopMotor(deviceId);
                } else {
                    console.log('❌ deviceId yok!');
                }
                return; // Motor stop işlemi tamamlandı
            }

            // --- HUB MOTOR COMMANDS ---
            else if (blockType === 'hub_light_control') {
                const port = block.getFieldValue('PORT');
                const state = block.getFieldValue('STATE');
                let brightness = parseInt(block.getFieldValue('BRIGHTNESS'));

                if (state === 'OFF') brightness = 0;

                const deviceId = block.deviceId || block.data;
                // console.log(`💡 Light Control: ${port} ${state} ${brightness}%`);

                if (deviceId) {
                    // Use dedicated Light function with WriteDirectModeData
                    await setHubLightBrightness(deviceId, port, brightness);
                }
                return;
            }
            else if (blockType === 'hub_motor_run') {
                const port = block.getFieldValue('PORT');
                const dir = block.getFieldValue('DIRECTION');
                const val = block.getFieldValue('VALUE');
                const unit = block.getFieldValue('UNIT');
                // Unit handling: ROTATIONS, DEGREES, SECONDS.
                // Our runHubMotorRotations handles rotations. For degrees, divide by 360.
                let rotations = parseFloat(val);
                if (unit === 'DEGREES') rotations = rotations / 360;
                // Seconds not yet handled in runHubMotorRotations (needs StartSpeedForTime 0x09)
                // Assuming Rotations for now.

                const deviceId = block.deviceId || block.data;
                console.log(`🚀 Hub Motor Run: Port ${port}, ${val} ${unit}`);

                if (deviceId) {
                    await runHubMotorRotations(deviceId, port, rotations, dir);
                }
                return;
            }
            else if (blockType === 'hub_motor_go_position') {
                const port = block.getFieldValue('PORT');
                const position = block.getFieldValue('POSITION');
                const path = block.getFieldValue('PATH');
                const deviceId = block.deviceId || block.data;

                if (deviceId) {
                    await goToHubMotorPosition(deviceId, port, parseInt(position), path);
                }
                return;
            }
            else if (blockType === 'hub_motor_start') {
                const port = block.getFieldValue('PORT');
                const dir = block.getFieldValue('DIRECTION');
                const deviceId = block.deviceId || block.data;
                if (deviceId) {
                    await startHubMotor(deviceId, port, dir);
                }
                return;
            }
            else if (blockType === 'hub_motor_stop') {
                const port = block.getFieldValue('PORT');
                const deviceId = block.deviceId || block.data;
                if (deviceId) {
                    await stopHubMotor(deviceId, port);
                }
                return;
            }

            // Hub LED Color block
            else if (blockType === 'hub_led_color') {
                const colorName = block.getFieldValue('COLOR');
                // console.log(`💡 Hub LED Color: ${colorName}`);
                // console.log('🔍 DEBUG block.data:', block.data);
                // console.log('🔍 DEBUG block.id:', block.id);

                // Map color name to LEGO color index and hex colors
                const colorMap = {
                    'RED': { index: 9, hex: '#ff3b30' },
                    'GREEN': { index: 6, hex: '#34c759' },
                    'BLUE': { index: 3, hex: '#007aff' },
                    'YELLOW': { index: 7, hex: '#ffcc00' },
                    'PURPLE': { index: 2, hex: '#af52de' },
                    'CYAN': { index: 4, hex: '#5ac8fa' },
                    'WHITE': { index: 10, hex: '#ffffff' },
                    'ORANGE': { index: 8, hex: '#ff9500' },
                    'AZURE': { index: 3, hex: '#32ade6' },
                    'PINK': { index: 1, hex: '#ff2d55' },
                    'BLACK': { index: 0, hex: '#1c1c1e' }
                };
                const colorData = colorMap[colorName] || { index: 0, hex: '#888888' };
                const colorIndex = colorData.index;
                const colorHex = colorData.hex;
                const deviceId = block.deviceId || block.data;
                await setHubLedColor(colorIndex, deviceId);

                // Log to execution panel
                const colorDisplayName = currentLanguage === 'tr' ? {
                    'RED': 'Kırmızı', 'GREEN': 'Yeşil', 'BLUE': 'Mavi', 'YELLOW': 'Sarı',
                    'PURPLE': 'Mor', 'CYAN': 'Cam Göbeği', 'WHITE': 'Beyaz', 'ORANGE': 'Turuncu',
                    'AZURE': 'Açık Mavi', 'PINK': 'Pembe', 'BLACK': 'Siyah'
                }[colorName] || colorName : colorName;
                logExecution(`<span style="display:inline-block;width:12px;height:12px;background:${colorHex};border-radius:50%;vertical-align:middle;border:1px solid rgba(0,0,0,0.2);"></span> ${currentLanguage === 'tr' ? `Hub LED <b>${colorDisplayName}</b> yapıldı` : `Hub LED set to <b>${colorName}</b>`}`, myFlowId, depth);
            }

            // Remote Controller LED Color block
            else if (blockType === 'remote_led_color') {
                const colorValue = block.getFieldValue('COLOR');

                // Map numeric string ID to hex colors and display name
                // IDs: 0=Off, 1=Pink, 2=Purple, 3=Blue, 4=Light Blue, 5=Cyan, 6=Green, 7=Yellow, 8=Orange, 9=Red, 10=White
                const colorMap = {
                    '0': { index: 0, hex: '#333333', name: 'Off', nameTr: 'Kapalı' },
                    '1': { index: 1, hex: '#ff69b4', name: 'Pink', nameTr: 'Pembe' },
                    '2': { index: 2, hex: '#9b59b6', name: 'Purple', nameTr: 'Mor' },
                    '3': { index: 3, hex: '#3498db', name: 'Blue', nameTr: 'Mavi' },
                    '4': { index: 4, hex: '#00a3da', name: 'Light Blue', nameTr: 'Açık Mavi' },
                    '5': { index: 5, hex: '#1abc9c', name: 'Cyan', nameTr: 'Cam Göbeği' },
                    '6': { index: 6, hex: '#2ecc71', name: 'Green', nameTr: 'Yeşil' },
                    '7': { index: 7, hex: '#f1c40f', name: 'Yellow', nameTr: 'Sarı' },
                    '8': { index: 8, hex: '#e67e22', name: 'Orange', nameTr: 'Turuncu' },
                    '9': { index: 9, hex: '#e74c3c', name: 'Red', nameTr: 'Kırmızı' },
                    '10': { index: 10, hex: '#ffffff', name: 'White', nameTr: 'Beyaz' }
                };
                const colorData = colorMap[colorValue] || { index: 0, hex: '#888888', name: 'Unknown', nameTr: 'Bilinmeyen' };
                const colorIndex = colorData.index;
                const colorHex = colorData.hex;

                await setRemoteControllerLEDColor(colorIndex);

                // Update display panel LED indicator
                updateRemoteControllerLedDisplay(colorHex, colorIndex === 0);

                // Log to execution panel
                const colorDisplayName = currentLanguage === 'tr' ? colorData.nameTr : colorData.name;
                logExecution(`<span style="display:inline-block;width:12px;height:12px;background:${colorHex};border-radius:50%;vertical-align:middle;border:1px solid rgba(0,0,0,0.2);"></span> ${currentLanguage === 'tr' ? `Remote LED <b>${colorDisplayName}</b> yapıldı` : `Remote LED set to <b>${colorDisplayName}</b>`}`, myFlowId, depth);
            }

            // Remote Controller Button State block (boolean reporter)
            else if (blockType === 'remote_button_state') {
                const buttonSelection = block.getFieldValue('BUTTON');
                const stateSelection = block.getFieldValue('STATE');

                // Parse button selection
                const [side, buttonType] = buttonSelection.split('_'); // LEFT_PLUS -> ['LEFT', 'PLUS']

                // Get current button state from remoteControllerState
                const currentState = side === 'LEFT' ? remoteControllerState.leftButton : remoteControllerState.rightButton;

                // Map button type to state value
                // leftButton/rightButton values: 'PLUS', 'MINUS', 'RED', 'RELEASED'
                let isButtonPressed = false;

                if (buttonType === 'PLUS') {
                    isButtonPressed = currentState === 'PLUS';
                } else if (buttonType === 'MINUS') {
                    isButtonPressed = currentState === 'MINUS';
                } else if (buttonType === 'RED') {
                    isButtonPressed = currentState === 'RED';
                }

                // Return based on state selection
                let result;
                if (stateSelection === 'PRESSED') {
                    result = isButtonPressed;
                } else {
                    result = !isButtonPressed;
                }

                // Log to execution panel (optional, can be verbose)
                const buttonName = buttonSelection.replace('_', ' ').toLowerCase();
                const stateName = stateSelection.toLowerCase();
                // logExecution(`🎮 ${buttonName} is ${stateName}: ${result}`, myFlowId, depth);

                return result;
            }

            // Hub Orientation block (is face up?)
            else if (blockType === 'hub_orientation') {
                const orientation = block.getFieldValue('ORIENTATION');
                const tilt = spikeHubState.tilt || { yaw: 0, pitch: 0, roll: 0 };
                const pitch = tilt.pitch || 0;
                const roll = tilt.roll || 0;

                // Threshold for orientation detection (degrees)
                const THRESHOLD = 45;
                let isUp = false;

                switch (orientation) {
                    case 'TOP':
                        // Flat, facing up: pitch and roll close to 0
                        isUp = Math.abs(pitch) < THRESHOLD && Math.abs(roll) < THRESHOLD;
                        break;
                    case 'BOTTOM':
                        // Upside down: pitch close to ±180
                        isUp = Math.abs(pitch) > 135 || Math.abs(roll) > 135;
                        break;
                    case 'FRONT':
                        // Front side up: positive pitch
                        isUp = pitch > THRESHOLD && Math.abs(roll) < THRESHOLD;
                        break;
                    case 'BACK':
                        // Back side up: negative pitch
                        isUp = pitch < -THRESHOLD && Math.abs(roll) < THRESHOLD;
                        break;
                    case 'RIGHT':
                        // Right side up: positive roll
                        isUp = roll > THRESHOLD && Math.abs(pitch) < THRESHOLD;
                        break;
                    case 'LEFT':
                        // Left side up: negative roll
                        isUp = roll < -THRESHOLD && Math.abs(pitch) < THRESHOLD;
                        break;
                }

                console.log(`📐 Hub orientation: ${orientation} up? ${isUp} (pitch: ${pitch}, roll: ${roll})`);
                return isUp;
            }

            // Matematik blokları
            else if (blockType === 'math_number') {
                const num = parseFloat(block.getFieldValue('NUM'));
                return num;
            } else if (blockType === 'math_random') {
                const fromBlock = block.getInputTargetBlock('FROM');
                const toBlock = block.getInputTargetBlock('TO');
                const from = fromBlock ? await executeBlockPlay(fromBlock, myFlowId) : 1;
                const to = toBlock ? await executeBlockPlay(toBlock, myFlowId) : 10;
                return Math.floor(Math.random() * (to - from + 1)) + from;
            } else if (blockType === 'math_arithmetic') {
                const op = block.getFieldValue('OP');
                const aBlock = block.getInputTargetBlock('A');
                const bBlock = block.getInputTargetBlock('B');
                const a = aBlock ? await executeBlockPlay(aBlock, myFlowId) : 0;
                const b = bBlock ? await executeBlockPlay(bBlock, myFlowId) : 0;

                let result = 0;
                switch (op) {
                    case 'ADD': result = a + b; break;
                    case 'MINUS': result = a - b; break;
                    case 'MULTIPLY': result = a * b; break;
                    case 'DIVIDE': result = a / b; break;
                    case 'POWER': result = Math.pow(a, b); break;
                    case 'MOD': result = a % b; break;
                }
                return result;
            }

            // Controller kontrolleri
            else if (blockType === 'lever_angle') {
                const lever = block.getFieldValue('LEVER');
                let angle = 50; // Varsayılan değer (orta pozisyon)

                if (lever === 'LEFT') {
                    angle = Math.round(controllerState.leftPercent || 50);
                } else if (lever === 'RIGHT') {
                    angle = Math.round(controllerState.rightPercent || 50);
                }

                console.log(`🕹️ Lever angle ${lever}: ${angle}%`);
                return angle;
            }
            else if (blockType === 'when_lever_position') {
                const lever = block.getFieldValue('LEVER');
                const position = block.getFieldValue('POSITION');
                console.log(`🕹️ When ${lever} lever is ${position}`);
            } else if (blockType === 'lever_position') {
                const lever = block.getFieldValue('LEVER');
                const position = block.getFieldValue('POSITION');

                // Mevcut controller durumunu kontrol et
                let currentPosition;
                if (lever === 'LEFT') {
                    currentPosition = controllerState.left;
                } else if (lever === 'RIGHT') {
                    currentPosition = controllerState.right;
                } else if (lever === 'ANY') {
                    currentPosition = controllerState.left !== 'RELEASED' ? controllerState.left : controllerState.right;
                } else if (lever === 'BOTH') {
                    if (controllerState.left === controllerState.right) {
                        currentPosition = controllerState.left;
                    } else {
                        currentPosition = 'RELEASED';
                    }
                }

                const result = currentPosition === position;
                console.log(`🕹️ Checking ${lever} lever is ${position}? Current: ${currentPosition}, Result: ${result}`);
                return result;
            }

            // detecting_color bloğu (Color Sensor)
            if (blockType === 'detecting_color') {
                const targetColor = block.getFieldValue('COLOR');
                const currentColor = colorSensorState.detectedColor;
                const result = currentColor === targetColor;
                console.log(`🎨 Renk kontrolü: ${targetColor} algılanıyor mu? Mevcut: ${currentColor}, Sonuç: ${result}`);
                return result;
            }

            // reflection_compare bloğu (Color Sensor)
            if (blockType === 'reflection_compare') {
                const op = block.getFieldValue('OP');
                const value = parseFloat(block.getFieldValue('VALUE')) || 50;
                const reflection = colorSensorState.reflection;
                let result = false;

                if (op === 'LT') result = reflection < value;
                else if (op === 'GT') result = reflection > value;
                else if (op === 'EQ') result = reflection === value;

                console.log(`📊 Yansıma kontrolü: ${reflection} ${op} ${value}? Sonuç: ${result}`);
                return result;
            }

            // Non-boolean block passed to evaluator - silently return false
            return false;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Koşul bloğunu değerlendir
        function evaluateCondition(conditionBlock) {
            if (!conditionBlock) return false;

            const blockType = conditionBlock.type;

            // lever_position bloğu
            if (blockType === 'lever_position') {
                const lever = conditionBlock.getFieldValue('LEVER');
                const position = conditionBlock.getFieldValue('POSITION');

                // Mevcut controller durumunu kontrol et
                let currentPosition;
                if (lever === 'LEFT') {
                    currentPosition = controllerState.left;
                } else if (lever === 'RIGHT') {
                    currentPosition = controllerState.right;
                } else if (lever === 'ANY') {
                    currentPosition = controllerState.left !== 'RELEASED' ? controllerState.left : controllerState.right;
                } else if (lever === 'BOTH') {
                    // Her iki lever da aynı pozisyonda mı?
                    if (controllerState.left === controllerState.right) {
                        currentPosition = controllerState.left;
                    } else {
                        currentPosition = 'RELEASED';
                    }
                }

                const result = currentPosition === position;
                console.log(`🕹️ Koşul kontrolü: ${lever} lever is ${position}? Mevcut: ${currentPosition}, Sonuç: ${result}`);
                return result;
            }

            // detecting_color bloğu (Color Sensor)
            if (blockType === 'detecting_color') {
                const targetColor = conditionBlock.getFieldValue('COLOR');
                const currentColor = colorSensorState.detectedColor;
                const result = currentColor === targetColor;
                console.log(`🎨 Renk kontrolü: ${targetColor} algılanıyor mu? Mevcut: ${currentColor}, Sonuç: ${result}`);
                return result;
            }

            // reflection_compare bloğu (Color Sensor)
            if (blockType === 'reflection_compare') {
                const op = conditionBlock.getFieldValue('OP');
                const value = parseFloat(conditionBlock.getFieldValue('VALUE')) || 50;
                const reflection = colorSensorState.reflection;
                let result = false;

                if (op === 'LT') result = reflection < value;
                else if (op === 'GT') result = reflection > value;
                else if (op === 'EQ') result = reflection === value;

                console.log(`📊 Yansıma kontrolü: ${reflection} ${op} ${value}? Sonuç: ${result}`);
                return result;
            }

            // Non-boolean block passed to evaluator - silently return false
            return false;
        }

        // Color Sensor value reporter blokları için executeBlockPlay'e eklenecek
        function getColorSensorValue(block) {
            const blockType = block.type;

            if (blockType === 'color_value') {
                return colorSensorState.detectedColor;
            }

            if (blockType === 'reflection_value') {
                return colorSensorState.reflection;
            }

            if (blockType === 'color_hue') {
                const mode = block.getFieldValue('MODE');
                if (mode === 'HUE') return colorSensorState.hue;
                if (mode === 'SAT') return colorSensorState.saturation;
                if (mode === 'VAL') return colorSensorState.value;
            }

            return 0;
        }

        function stopCode() {
            alert(TRANSLATIONS[currentLanguage].alert_stopped);
        }

        // --- EXPORT & IMPORT FUNCTIONS --- //
        function exportWorkspace() {
            try {
                const xml = Blockly.Xml.workspaceToDom(workspace);
                const xmlText = Blockly.Xml.domToText(xml);

                const blob = new Blob([xmlText], { type: 'text/xml' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = 'blockcode_project.xml'; // Varsayılan dosya adı
                document.body.appendChild(a);
                a.click();

                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                console.log('✅ Workspace exported successfully');
            } catch (e) {
                console.error('❌ Export error:', e);
                alert(TRANSLATIONS[currentLanguage].alert_export_error);
            }
        }

        // Bekleyen import verisi
        let pendingImportXml = null;
        let pendingImportInput = null;

        function importWorkspace(input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const xmlText = e.target.result;

                    // XML geçerliliğini kontrol et
                    if (!xmlText.trim().startsWith('<xml')) {
                        throw new Error('Dosya geçerli bir Blockly XML dosyası değil.');
                    }

                    // Blockly 10+ uyumlu XML parsing
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, 'text/xml');

                    // Parse hatası kontrolü
                    const parseError = xmlDoc.querySelector('parsererror');
                    if (parseError) {
                        throw new Error('XML parse hatası: ' + parseError.textContent);
                    }

                    const xml = xmlDoc.documentElement;

                    // Workspace'te blok var mı kontrol et
                    const existingBlocks = workspace.getAllBlocks();
                    if (existingBlocks.length > 0) {
                        // Kullanıcıya modal ile sor
                        pendingImportXml = xml;
                        pendingImportInput = input;
                        showImportConfirmModal();
                    } else {
                        // Direkt yükle
                        Blockly.Xml.domToWorkspace(xml, workspace);
                        console.log('✅ Workspace imported successfully');
                        input.value = '';
                    }
                } catch (e) {
                    console.error('❌ Import error:', e);
                    showImportErrorModal(
                        TRANSLATIONS[currentLanguage].alert_import_error,
                        e.message || 'Bilinmeyen hata'
                    );
                    input.value = '';
                }
            };
            reader.onerror = function () {
                showImportErrorModal(
                    TRANSLATIONS[currentLanguage].alert_import_error,
                    'Dosya okunamadı.'
                );
                input.value = '';
            };
            reader.readAsText(file);
        }

        function showImportConfirmModal() {
            const modal = document.getElementById('importConfirmModal');
            const titleEl = document.getElementById('importConfirmTitle');
            const messageEl = document.getElementById('importConfirmMessage');
            const hintEl = document.getElementById('importConfirmHint');
            const cancelBtn = document.getElementById('importConfirmCancelBtn');
            const okBtn = document.getElementById('importConfirmOkBtn');

            if (currentLanguage === 'tr') {
                titleEl.textContent = 'Dosya Yükleme';
                messageEl.textContent = 'Mevcut blokları temizleyip yüklensin mi?';
                hintEl.textContent = '(İptal\'e tıklayarak mevcut bloklara ekleyebilirsiniz)';
                cancelBtn.textContent = 'Ekle';
                okBtn.textContent = 'Temizle ve Yükle';
            } else {
                titleEl.textContent = 'Import File';
                messageEl.textContent = 'Clear current workspace before loading?';
                hintEl.textContent = '(Click Append to add to existing blocks)';
                cancelBtn.textContent = 'Append';
                okBtn.textContent = 'Clear & Load';
            }

            modal.classList.add('active');
        }

        function confirmImport(clearWorkspace) {
            const modal = document.getElementById('importConfirmModal');
            modal.classList.remove('active');

            pendingClearWorkspace = clearWorkspace;

            if (pendingImportXml) {
                // XML'den cihaz ID'lerini çıkar
                const deviceIds = extractDeviceIdsFromXml(pendingImportXml);
                const unmappedDevices = findUnmappedDevices(deviceIds);

                if (unmappedDevices.length > 0) {
                    // Eşleştirilmemiş cihazlar var, modal göster
                    showDeviceMappingModal(unmappedDevices);
                } else {
                    // Tüm cihazlar mevcut veya cihaz yok, direkt yükle
                    finalizeImport();
                }
            }
        }

        let pendingClearWorkspace = false;
        let pendingDeviceMapping = {};

        function extractDeviceIdsFromXml(xml) {
            const deviceIds = new Set();
            const dataElements = xml.querySelectorAll('data');
            dataElements.forEach(el => {
                const deviceId = el.textContent.trim();
                if (deviceId) {
                    deviceIds.add(deviceId);
                }
            });
            return Array.from(deviceIds);
        }

        function findUnmappedDevices(deviceIds) {
            const unmapped = [];
            const connectedIds = connectedDevices.map(d => d.id);

            deviceIds.forEach(id => {
                if (!connectedIds.includes(id)) {
                    unmapped.push(id);
                }
            });

            return unmapped;
        }

        function showDeviceMappingModal(unmappedDevices) {
            const modal = document.getElementById('deviceMappingModal');
            const titleEl = document.getElementById('deviceMappingTitle');
            const messageEl = document.getElementById('deviceMappingMessage');
            const listEl = document.getElementById('deviceMappingList');
            const skipBtn = document.getElementById('deviceMappingSkipBtn');
            const applyBtn = document.getElementById('deviceMappingApplyBtn');

            // Dili ayarla
            if (currentLanguage === 'tr') {
                titleEl.textContent = 'Cihaz Eşleştirme';
                messageEl.textContent = 'İçe aktarılan dosyada bağlı olmayan cihazlara ait bloklar bulundu. Lütfen bu blokları mevcut cihazlarla eşleştirin:';
                skipBtn.textContent = 'Eşleştirmeden Devam Et';
                applyBtn.textContent = 'Eşleştir ve Yükle';
            } else {
                titleEl.textContent = 'Device Mapping';
                messageEl.textContent = 'The imported file contains blocks from devices that are not connected. Please map them to current devices:';
                skipBtn.textContent = 'Skip Mapping';
                applyBtn.textContent = 'Apply & Load';
            }

            // Mapping listesini oluştur
            listEl.innerHTML = '';
            pendingDeviceMapping = {};

            unmappedDevices.forEach((oldId, index) => {
                const row = document.createElement('div');
                row.style.cssText = 'display: flex; align-items: center; gap: 10px; padding: 10px; background: #f8f9fa; border-radius: 8px; margin-bottom: 8px;';

                // Eski cihaz ID'si (kısaltılmış)
                const shortId = oldId.substring(0, 8) + '...';
                const oldLabel = document.createElement('div');
                oldLabel.style.cssText = 'flex: 1; font-family: monospace; font-size: 12px; color: #888;';
                oldLabel.textContent = currentLanguage === 'tr' ? `Eski Cihaz #${index + 1}` : `Old Device #${index + 1}`;
                oldLabel.title = oldId;

                // Ok ikonu
                const arrow = document.createElement('span');
                arrow.textContent = '→';
                arrow.style.cssText = 'color: #4C97FF; font-weight: bold;';

                // Yeni cihaz seçimi
                const select = document.createElement('select');
                select.style.cssText = 'flex: 1; padding: 8px; border: 2px solid #ddd; border-radius: 8px; font-size: 14px;';
                select.dataset.oldId = oldId;

                // Boş seçenek
                const emptyOption = document.createElement('option');
                emptyOption.value = '';
                emptyOption.textContent = currentLanguage === 'tr' ? '-- Seçiniz --' : '-- Select --';
                select.appendChild(emptyOption);

                // Mevcut cihazları listele
                connectedDevices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.id;
                    option.textContent = device.name;
                    option.style.color = device.color;
                    select.appendChild(option);
                });

                row.appendChild(oldLabel);
                row.appendChild(arrow);
                row.appendChild(select);
                listEl.appendChild(row);
            });

            modal.classList.add('active');
        }

        function skipDeviceMapping() {
            const modal = document.getElementById('deviceMappingModal');
            modal.classList.remove('active');
            finalizeImport();
        }

        function applyDeviceMapping() {
            const modal = document.getElementById('deviceMappingModal');
            const selects = modal.querySelectorAll('select');

            // Mapping'leri topla
            selects.forEach(select => {
                const oldId = select.dataset.oldId;
                const newId = select.value;
                if (newId) {
                    pendingDeviceMapping[oldId] = newId;
                }
            });

            // XML'deki data etiketlerini güncelle
            if (Object.keys(pendingDeviceMapping).length > 0) {
                const dataElements = pendingImportXml.querySelectorAll('data');
                dataElements.forEach(el => {
                    const oldId = el.textContent.trim();
                    if (pendingDeviceMapping[oldId]) {
                        el.textContent = pendingDeviceMapping[oldId];
                    }
                });
            }

            modal.classList.remove('active');
            finalizeImport();
        }

        function finalizeImport() {
            if (pendingClearWorkspace) {
                workspace.clear();
            }

            if (pendingImportXml) {
                Blockly.Xml.domToWorkspace(pendingImportXml, workspace);
                console.log('✅ Workspace imported successfully');
            }

            if (pendingImportInput) {
                pendingImportInput.value = '';
            }

            pendingImportXml = null;
            pendingImportInput = null;
            pendingClearWorkspace = false;
            pendingDeviceMapping = {};
        }

        function showImportErrorModal(title, details) {
            const modal = document.getElementById('importErrorModal');
            const titleEl = document.getElementById('importErrorTitle');
            const messageEl = document.getElementById('importErrorMessage');
            const detailsEl = document.getElementById('importErrorDetails');

            if (modal && titleEl && detailsEl) {
                titleEl.textContent = currentLanguage === 'tr' ? 'Dosya Yükleme Hatası' : 'Import Error';
                messageEl.textContent = title;
                detailsEl.textContent = details;

                // Buton metnini çevir
                const okBtn = document.getElementById('importErrorOkBtn');
                if (okBtn) okBtn.textContent = currentLanguage === 'tr' ? 'Tamam' : 'OK';

                modal.classList.add('active');
            }
        }

        function closeImportErrorModal() {
            const modal = document.getElementById('importErrorModal');
            if (modal) modal.classList.remove('active');
        }
        // -------------------------------- //

        function resetEverything() {
            openResetModal();
        }

        function openResetModal() {
            document.getElementById('resetModal').classList.add('active');
        }

        function closeResetModal() {
            document.getElementById('resetModal').classList.remove('active');
        }

        function showRuntimeError(message) {
            const title = currentLanguage === 'tr' ? 'Hata' : 'Error';
            const okText = currentLanguage === 'tr' ? 'Tamam' : 'OK';

            document.getElementById('runtimeErrorTitle').textContent = title;
            document.getElementById('runtimeErrorMessage').textContent = message;
            document.getElementById('runtimeErrorOkBtn').textContent = okText;

            document.getElementById('runtimeErrorModal').classList.add('active');
        }

        function closeRuntimeErrorModal() {
            document.getElementById('runtimeErrorModal').classList.remove('active');
        }

        function performReset() {
            closeResetModal();

            // Çalışan kod varsa durdur
            isExecutionCancelled = true;

            // RGB LED'leri söndür
            rgbLedState = { red: false, green: false, blue: false };
            document.getElementById('rgbRedLed').classList.remove('active');
            document.getElementById('rgbGreenLed').classList.remove('active');
            document.getElementById('rgbBlueLed').classList.remove('active');

            // RGB sayıları sıfırla
            rgbNumberState = { red: 0, green: 0, blue: 0 };
            document.getElementById('rgbRedNum').textContent = '0';
            document.getElementById('rgbGreenNum').textContent = '0';
            document.getElementById('rgbBlueNum').textContent = '0';

            // Motor işlem kilidini sıfırla
            motorOperationInProgress = false;

            // Üçgen butonların basılı tutma durumunu sıfırla
            stopHold();

            // Play butonunu aktif et ve görünümünü düzelt
            const playBtn = document.querySelector('.play-btn');
            if (playBtn) {
                playBtn.disabled = false;
                playBtn.style.opacity = '1';
                playBtn.style.cursor = 'pointer';
                playBtn.style.pointerEvents = 'auto'; // Kilitlenmeyi önler
                playBtn.style.background = '#FFBF00'; // Orijinal sarı renk
            }



            // Görsel feedback
            const resetBtn = document.querySelector('.reset-btn');
            resetBtn.style.background = '#51cf66';
            setTimeout(() => {
                resetBtn.style.background = '#FF6680';
            }, 300);
        }


        // Global scope'a ekle
        window.resetEverything = resetEverything;

        function addDevice() {



            const modal = document.getElementById('deviceModal');


            if (modal) {
                // Hem class hem inline style ekle
                modal.classList.add('show');
                modal.style.display = 'flex';
                modal.style.zIndex = '10000';


            } else {
                console.error('deviceModal bulunamadı!');
                alert('Modal element bulunamadı!');
            }
        }

        // Global scope'a ekle
        window.addDevice = addDevice;

        // RGB LED kontrol fonksiyonları
        let bluetoothDevice = null;
        let bluetoothServer = null;
        let connectedCharacteristics = {};
        let connectedDevices = [];
        let selectedDeviceId = null;
        let deviceMenuOpen = null; // Açık cihaz menüsü

        // Button States
        let btnStates = { red: false, green: false, blue: false };
        let btnLock = { red: false, green: false, blue: false };
        let pressTimer = { red: null, green: null, blue: null };

        function handleBtnDown(color) {
            const btn = document.getElementById(`rgb${color.charAt(0).toUpperCase() + color.slice(1)}Btn`);
            if (!btn) return;

            // Eğer kilitliyse (basılı tutularak açılma kontrolü için timer başlat)
            if (btnLock[color]) {
                // Tıklama anında kilitli olduğunu göster (opsiyonel)
                // 3 saniye basılı tutulursa kilidi kaldır
                if (pressTimer[color]) clearTimeout(pressTimer[color]);
                pressTimer[color] = setTimeout(() => {
                    // UNLOCK
                    btnLock[color] = false;
                    btnStates[color] = false; // Bırakınca sönecek, ama timer bitince direkt sönsün mü? 
                    // Kullanıcı parmağını kaldırınca handleBtnUp çalışacak ve btnLock false olduğu için sönecek.
                    // Burada görsel feedback verelim:
                    btn.classList.remove('active');
                    btn.classList.add('flash');
                    setTimeout(() => btn.classList.remove('flash'), 500);
                    console.log(`${color} button UNLOCKED (3s hold)`);
                }, 3000);
                return;
            }

            // Kilitli değilse: Normal basma işlemi
            btnStates[color] = true;
            btn.classList.add('active');

            // 3 saniye basılı tutulursa KİLİTLE
            if (pressTimer[color]) clearTimeout(pressTimer[color]);
            pressTimer[color] = setTimeout(() => {
                // LOCK
                btnLock[color] = true;
                btn.classList.add('flash'); // Parlama efekti
                setTimeout(() => btn.classList.remove('flash'), 500);
                console.log(`${color} button LOCKED (3s hold)`);
            }, 3000);
        }

        function handleBtnUp(color) {
            const btn = document.getElementById(`rgb${color.charAt(0).toUpperCase() + color.slice(1)}Btn`);

            if (pressTimer[color]) {
                clearTimeout(pressTimer[color]);
                pressTimer[color] = null;
            }

            // Eğer kilitliyse, bırakınca SÖNMEZ (active kalır)
            // Sadece tıklayıp bırakınca (kısa basış) kilitli state değişmez, ama timer iptal olduğu için (yukarıda) bir şey olmaz.

            // Eğer kilitli DEĞİLSE, bırakınca söner
            if (!btnLock[color]) {
                if (btnStates[color]) {
                    btnStates[color] = false;
                    if (btn) btn.classList.remove('active');
                }
            }
        }




        // Global'e ekle
        window.handleBtnDown = handleBtnDown;
        window.handleBtnUp = handleBtnUp;

        const DEVICE_SHAPES = ['triangle', 'square', 'rectangle', 'pentagon', 'hexagon', 'octagon', 'circle'];
        const DEVICE_COLORS = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B739'];

        // ===== BLUETOOTH MOTOR KONTROL FONKSİYONLARI =====

        // Hex string'i byte array'e çevir
        function hexToBytes(hexString) {
            const hex = hexString.replace(/:/g, '');
            const bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i < hex.length; i += 2) {
                bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
            }
            return bytes;
        }

        // Motor komut sabitleri
        const MOTOR_COMMANDS = {
            INIT: hexToBytes("30:31:30:32:30:33:30:34:30:35:30:36:30:37:30:38"),
            CONFIG: hexToBytes("02:00"),
            CMD_START: hexToBytes("00"),
            CMD_PREPARE: hexToBytes("1a"),
            CMD_MODE: hexToBytes("28:32:00"),
            CMD_CONTROL: hexToBytes("20:00"),
            // CMD_EXECUTE rotasyon sayısına göre değişir, aşağıda fonksiyon var
            MOTOR_INIT_1: hexToBytes("01:01:00:31:00:01:00:3e:00:01:00:00:00:f7:00:00:02"),
            MOTOR_INIT_2: hexToBytes("1b:9d:4d:ce:36:00:4b:12:00"),
            MOTOR_INIT_3: hexToBytes("29:00"),
            MOTOR_BASE: hexToBytes("3c:12:00:00:46:00:0a:01:07:56:01:00:00:00:ef:ff:ff:ff:11:01:ff"), // capturing_rotasyon_sagvesol.pcap
            MOTOR_STOP_INIT: hexToBytes("7d:01:00"),
            // Alternatif durma komutları
            MOTOR_BRAKE: hexToBytes("00:00"),  // Fren
            MOTOR_FLOAT: hexToBytes("7d:00:00"), // Serbest bırak
        };

        // Yöne göre motor base komutu oluştur
        function createMotorBaseCommand(direction = 'CW') {
            // capturing_rotasyon_sagvesol.pcap ANALİZİ (ROTASYON):
            // SAĞA (CW): 3c 12 00 00 46 00 0a 01 07 56 01 00 00 00 ef ff ff ff 11 01 ff
            // SOLA (CCW): Motor base byte 8-9 değişmiyor, execute komutu yönü belirliyor
            //             SOLA için motor base SAĞA ile aynı

            // Rotasyon için her iki yön de aynı motor base kullanıyor
            return hexToBytes("3c:12:00:00:46:00:0a:01:07:56:01:00:00:00:ef:ff:ff:ff:11:01:ff");
        }

        // Rotasyon/açıya göre CMD_EXECUTE oluştur
        function createExecuteCommand(value, isRotation = true, direction = 'CW') {
            // Eğer rotasyon ise dereceye çevir
            let degrees = isRotation ? (value * 360) : value;

            // PCAP ANALİZİ (capturing_rotasyon_sagvesol.pcap):
            // SAĞA: 7c 01 68 01 00 00 00 (son byte = 0x00)
            // SOLA: 7c 01 68 01 00 00 01 (son byte = 0x01)
            // Yön son byte'ta kodlanıyor, derece değeri pozitif kalıyor!

            // Derece değeri her zaman pozitif (negatif YOK)
            const posDegrees = Math.abs(degrees);

            // Signed 16-bit integer olarak encode et (little endian)
            const signed16 = posDegrees & 0xFFFF;
            const lowByte = signed16 & 0xFF;
            const highByte = (signed16 >> 8) & 0xFF;

            // Son byte yönü belirliyor: 0x00 = SAĞA, 0x01 = SOLA
            const directionByte = direction === 'CW' ? 0x00 : 0x01;

            // 7c:01:[LOW]:[HIGH]:00:00:[DIR]
            const cmd = new Uint8Array([0x7c, 0x01, lowByte, highByte, 0x00, 0x00, directionByte]);

            const unit = isRotation ? 'rotasyon' : 'derece';
            const dirSymbol = direction === 'CW' ? '↻' : '↺';
            console.log(`CMD_EXECUTE için ${value} ${unit} ${dirSymbol} = ${posDegrees}° = 0x${signed16.toString(16)} = [${lowByte.toString(16)}, ${highByte.toString(16)}, dir=${directionByte.toString(16)}]`);

            return cmd;
        }

        const MOTOR_SPEED_CHANGES = [
            hexToBytes("3c:12:00:00:64:00:0a:01:07:2e:01:00:00:00:c6:ff:ff:ff:11:01:ff"),
            hexToBytes("3c:12:00:00:64:00:0a:01:01:31:01:75:09:00:c9:ff:ff:ff:11:01:ff"),
            hexToBytes("3c:12:00:00:64:00:0a:01:01:42:01:cb:13:04:da:ff:ff:ff:11:01:ff"),
            hexToBytes("3c:12:00:00:64:00:0a:01:01:60:01:a3:1e:09:f8:ff:ff:ff:11:01:ff"),
        ];

        const MOTOR_SLOWDOWN = [
            hexToBytes("3c:12:00:00:64:00:0a:01:07:2e:01:00:00:33:fe:03:00:00:11:01:ff"),
            hexToBytes("3c:12:00:00:64:00:0a:01:07:2e:01:00:00:2d:fe:03:00:00:11:01:ff"),
            hexToBytes("3c:12:00:00:64:00:0a:01:07:2e:01:00:00:28:fe:03:00:00:11:01:ff"),
            hexToBytes("3c:12:00:00:64:00:0a:01:07:2e:01:00:00:23:fe:03:00:00:11:01:ff"),
        ];

        // Cihazın karakteristiklerini al
        async function getMotorCharacteristics(deviceId) {
            console.log('getMotorCharacteristics çağrıldı, deviceId:', deviceId);
            console.log('connectedDevices:', connectedDevices);

            const deviceData = connectedDevices.find(d => d.id === deviceId);
            console.log('Bulunan deviceData:', deviceData);

            if (!deviceData) {
                console.error('❌ Motor cihazı connectedDevices içinde bulunamadı!');
                return null;
            }

            if (!deviceData.server) {
                console.error('❌ deviceData.server yok!');
                return null;
            }

            if (!deviceData.server.connected) {
                console.error('❌ GATT server bağlı değil!');
                return null;
            }

            // Motor UUID'leri (PCAP analizinden)
            const MOTOR_SERVICE_UUIDS = [
                '0000fd02-0000-1000-8000-00805f9b34fb', // Ana motor servisi
                '00002a05-0000-1000-8000-00805f9b34fb', // INIT
                '00002b2a-0000-1000-8000-00805f9b34fb', // CONFIG
            ];

            const MOTOR_CHAR_UUIDS = {
                INIT: '00002a05-0000-1000-8000-00805f9b34fb',
                CONFIG: '00002b2a-0000-1000-8000-00805f9b34fb',
                COMMAND: '0000fd02-0001-1000-8000-00805f9b34fb',
                MOTOR: '0000fd02-0002-1000-8000-00805f9b34fb'
            };

            try {
                console.log('✓ Server bağlı, belirli servisleri arıyoruz...');
                const chars = {};

                // Her UUID'yi deneyelim
                for (const serviceUUID of MOTOR_SERVICE_UUIDS) {
                    try {
                        console.log(`  → Servis ${serviceUUID} deneniyor...`);
                        const service = await deviceData.server.getPrimaryService(serviceUUID);
                        console.log(`    ✓ Servis bulundu!`);

                        const characteristics = await service.getCharacteristics();
                        console.log(`    ${characteristics.length} karakteristik bulundu`);

                        for (const char of characteristics) {
                            console.log(`      - UUID: ${char.uuid}, Write: ${char.properties.write}, WriteNoResp: ${char.properties.writeWithoutResponse}`);

                            // Tüm write karakteristiklerini kaydet
                            if (char.properties.write || char.properties.writeWithoutResponse) {
                                chars[char.uuid] = char;
                                console.log(`        ✓ Yazılabilir karakteristik kaydedildi`);
                            }
                        }
                    } catch (e) {
                        console.log(`    ⚠️ Servis ${serviceUUID} bulunamadı: ${e.message}`);
                    }
                }

                // Eğer hiç karakteristik bulamadıysak, belirli karakteristikleri deneyelim
                if (Object.keys(chars).length === 0) {
                    console.log('  → Hiç servis bulunamadı, karakteristikleri direkt deniyoruz...');

                    for (const [name, uuid] of Object.entries(MOTOR_CHAR_UUIDS)) {
                        try {
                            // Ana servisten karakteristiği almayı dene
                            const service = await deviceData.server.getPrimaryService('0000fd02-0000-1000-8000-00805f9b34fb');
                            const char = await service.getCharacteristic(uuid);
                            chars[uuid] = char;
                            console.log(`    ✓ ${name} karakteristiği bulundu: ${uuid}`);
                        } catch (e) {
                            console.log(`    ⚠️ ${name} karakteristiği bulunamadı`);
                        }
                    }
                }

                console.log(`✅ Toplam ${Object.keys(chars).length} yazılabilir karakteristik bulundu`);

                if (Object.keys(chars).length === 0) {
                    console.error('❌ Hiç karakteristik bulunamadı! Motor cihazı Web Bluetooth ile uyumlu olmayabilir.');
                    return null;
                }

                return chars;
            } catch (error) {
                console.error('❌ Karakteristikler alınamadı:', error);
                console.error('   Error name:', error.name);
                console.error('   Error message:', error.message);
                return null;
            }
        }

        // Karakteristiğe veri yaz
        async function writeMotorCommand(characteristic, data, delay = 50) {
            if (!characteristic) return;
            try {
                await characteristic.writeValue(data);
                await new Promise(resolve => setTimeout(resolve, delay));
            } catch (error) {
                console.error('Motor komut yazma hatası:', error);
            }
        }

        // Motor initialize
        async function initializeMotor(deviceId) {
            const chars = await getMotorCharacteristics(deviceId);
            if (!chars) return false;

            console.log('Motor başlatılıyor...');

            // İlk erişilebilir karakteristik üzerinden komutları gönder
            // Gerçek uygulamada doğru UUID'leri bulup kullanmalısınız
            const writeChar = Object.values(chars)[0];

            if (writeChar) {
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.INIT);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CONFIG);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_START);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_INIT_1);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_PREPARE);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_INIT_2);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_MODE);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_INIT_3);
            }

            console.log('✓ Motor başlatıldı');
            return true;
        }

        // Helper function for unified motor control
        async function sendMotorPositionCommand(deviceId, angle) {

            // Device'ı bul
            const deviceData = connectedDevices.find(d => d.id === deviceId);
            if (!deviceData || !deviceData.server) {
                console.error('❌ Device bulunamadı veya bağlı değil');
                return false;
            }

            const charUUID = '0000fd02-0001-1000-8000-00805f9b34fb';
            const serviceUUID = '0000fd02-0000-1000-8000-00805f9b34fb';

            try {
                const service = await deviceData.server.getPrimaryService(serviceUUID);
                cmdChar = await service.getCharacteristic(charUUID);
            } catch (e) {
                console.error('   ❌ Characteristic alınamadı:', e);
                return false;
            }

            // Pozisyon değerini little-endian formatında hazırla
            // Açı negatif olabilir veya 360'tan büyük olabilir
            const posBytes = angle & 0xFFFF;
            const lowByte = posBytes & 0xFF;
            const highByte = (posBytes >> 8) & 0xFF;

            // 0. Notify Characteristic'i bul ve Subscribe ol
            try {
                const notifyUUID = '0000fd02-0002-1000-8000-00805f9b34fb';
                let notifyChar = null;

                if (deviceData.characteristics) {
                    notifyChar = deviceData.characteristics[notifyUUID];
                }

                // Cache'te yoksa servisten al (writeChar'ın servisini kullanabiliriz if available in obj or refetch)
                if (!notifyChar && cmdChar.service) {
                    try {
                        notifyChar = await cmdChar.service.getCharacteristic(notifyUUID);
                    } catch (e) { console.log('   ⚠️ Notify char servisten alınamadı'); }
                }

                if (notifyChar) {
                    // Start notifications safely
                    // 1. Başlatma komutu: 20 00
                    const startCmd = new Uint8Array([0x20, 0x00]);

                    try {
                        await cmdChar.writeValueWithoutResponse(startCmd);
                        console.log('   ✅ CMD1 yazıldı başarılı');
                    } catch (writeErr) {
                        console.error('   ❌ CMD1 yazma hatası:', writeErr);
                        return false;
                    }

                    await new Promise(resolve => setTimeout(resolve, 50));

                    // 2. Pozisyon komutu: 80 [PORT] [LOW] [HIGH] 02
                    // Port ID belirsiz olabilir (0, 1, 2 vb.), hepsini deneyelim (Shotgun approach)
                    const ports = [0x00, 0x01, 0x02];
                    let anySuccess = false;

                    try {
                        await cmdChar.writeValueWithoutResponse(positionCmd);
                        anySuccess = true;
                        // Komutlar arasında kısa bekleme
                        await new Promise(resolve => setTimeout(resolve, 30));
                    } catch (writeErr) {
                        console.error(`   ❌ CMD2 (Port ${port}) yazma hatası:`, writeErr);
                    }
                }

                if (!anySuccess) return false;

                // Update State
                motorState.currentAngle = angle;
                motorState.targetAngle = angle;
                updateMotorAngleDisplay(angle);

                return true;
            } catch (err) {
                console.error('❌ Motor komut hatası:', err);
                return false;
            }
        }

        // Motor rotasyon çalıştır
        /*
         * NOT: sendMotorPositionCommand fonksiyonu, belirli bir marka/model (örn. Robot Invader) 
         * BLE motorlar için bir "Shotgun" yaklaşımla port taraması yapar.
         * Standart port (0x01) bazen çalışmayabilir, bu yüzden 0x00, 0x01, 0x02 denenir.
         * Bu sayede "Go to Position" gibi komutların kararlı çalışması sağlanmıştır.
         */

        // Motor rotasyon çalıştır (Karmaşık 43-Komut Protokolü - Restore Edildi)
        // Kullanıcı geri bildirimi: "Eskiden 0/43, 10/43 logları vardı ve tam tur atıyordu."
        async function runMotorRotations(deviceId, rotations, direction = 'CW') {
            if (motorOperationInProgress) {
                console.log('⏳ Başka bir motor işlemi devam ediyor...');
                return;
            }
            motorOperationInProgress = true;

            try {
                // 1. Önce eski protokolün ihtiyaç duyduğu başlatma sekansını gönder
                await initializeMotor(deviceId);

                const chars = await getMotorCharacteristics(deviceId);
                if (!chars) {
                    console.error('❌ Karakteristikler alınamadı!');
                    return;
                }

                // Genellikle ilk karakteristik (fd02-0001) yazma için uygundur
                const writeChar = Object.values(chars)[0];
                if (!writeChar) {
                    console.error('❌ Yazılabilir karakteristik bulunamadı');
                    return;
                }

                // Number'a çevir ve default 1 yap
                const r = Number(rotations);
                const validRotations = isNaN(r) ? 1 : r;



                // 2. 43 adet MOTOR_BASE komutu gönder (Hızlanma/Hazırlık?)
                // "GATT operation already in progress" hatasını önlemek için delay ekliyoruz
                const totalCommands = 43;
                for (let i = 0; i < totalCommands; i++) {
                    // writeMotorCommand içinde 50ms delay var, burada ekstra güvenli yapalım (100ms total)
                    await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_BASE, 50);
                }

                // 3. Kontrol ve tekrar Base
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_CONTROL);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_BASE);

                // 4. Execute Komutu (Rotasyon sayısı ve yön burada)
                const executeCmd = createExecuteCommand(validRotations, true, direction);
                await writeMotorCommand(writeChar, executeCmd);

                // 5. Hız değişimleri
                for (const cmd of MOTOR_SPEED_CHANGES) {
                    await writeMotorCommand(writeChar, cmd);
                }

                // 6. Devam komutları (Magic bytes from PCAP)
                const rotationCommands = [
                    hexToBytes("3c:12:00:00:64:00:0a:01:01:21:00:97:22:11:22:00:00:00:11:01:ff"),
                    hexToBytes("3c:12:00:00:64:00:0a:01:01:50:00:60:22:18:51:00:00:00:11:01:ff"),
                    hexToBytes("3c:12:00:00:64:00:0a:01:01:7e:00:ee:21:1f:7f:00:00:00:11:01:ff"),
                ];

                for (const cmd of rotationCommands) {
                    await writeMotorCommand(writeChar, cmd);
                }

                // 7. Durma sekansı
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_STOP_INIT);

                for (const cmd of MOTOR_SLOWDOWN) {
                    await writeMotorCommand(writeChar, cmd);
                }

                // Final temizlik
                for (let i = 0; i < 5; i++) {
                    await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_BASE, 30);
                }



                // State güncelle (Tahmini)
                let current = motorState.currentAngle || 0;
                let delta = validRotations * 360 * (direction === 'CCW' ? -1 : 1);
                motorState.currentAngle = current + delta;
                updateMotorAngleDisplay(motorState.currentAngle);

            } catch (err) {
                console.error('❌ Rotasyon hatası:', err);
            } finally {
                motorOperationInProgress = false;
            }
        }

        function getPortIdFromLetter(letter) {
            const map = { 'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5 };
            return map[letter] !== undefined ? map[letter] : 0;
        }

        async function runHubMotorRotations(deviceId, portLetter, rotations, direction = 'CW', speed = 50) {
            console.log(`🚀 Hub Motor Run: Port=${portLetter}, Rot=${rotations}, Dir=${direction}`);
            const deviceData = connectedDevices.find(d => d.id === deviceId);
            const targetDevice = deviceData ? deviceData.device : null;
            if (!targetDevice) return;

            try {
                let characteristic = null;
                const services = await targetDevice.gatt.getPrimaryServices();
                for (const service of services) {
                    const chars = await service.getCharacteristics();
                    for (const c of chars) {
                        if (c.properties.write || c.properties.writeWithoutResponse) {
                            characteristic = c;
                            break;
                        }
                    }
                    if (characteristic) break;
                }

                if (!characteristic) {
                    console.error('❌ Karakteristik bulunamadı (Hub Motor)');
                    return;
                }

                const portId = getPortIdFromLetter(portLetter);
                const degrees = Math.round(rotations * 360);
                const speedVal = direction === 'CW' ? speed : -speed;

                // LWP3 Command: StartSpeedForDegrees (0x0B)
                const buffer = new ArrayBuffer(14);
                const view = new DataView(buffer);
                let idx = 0;
                view.setUint8(idx++, 14); view.setUint8(idx++, 0x00);
                view.setUint8(idx++, 0x81); view.setUint8(idx++, portId);
                view.setUint8(idx++, 0x11); view.setUint8(idx++, 0x0B);
                view.setInt32(idx, degrees, true); idx += 4;
                view.setInt8(idx++, speedVal);
                view.setUint8(idx++, 100);
                view.setUint8(idx++, 1);
                view.setUint8(idx++, 0);

                await characteristic.writeValueWithoutResponse(new Uint8Array(buffer));

                // Wait for the duration
                const duration = Math.abs(degrees / 360) * (100 / Math.abs(speed)) * 1000 * 1.5;
                await new Promise(r => setTimeout(r, Math.min(duration, 2000)));

            } catch (e) {
                console.error('Motor Hatası:', e);
            }
        }

        async function goToHubMotorPosition(deviceId, portLetter, position, path = 'SHORTEST', speed = 50) {
            const deviceData = connectedDevices.find(d => d.id === deviceId);
            const targetDevice = deviceData ? deviceData.device : null;
            if (!targetDevice) return;
            try {
                let characteristic = null;
                const services = await targetDevice.gatt.getPrimaryServices();
                for (const service of services) {
                    const chars = await service.getCharacteristics();
                    for (const c of chars) { if (c.properties.write || c.properties.writeWithoutResponse) { characteristic = c; break; } }
                    if (characteristic) break;
                }
                if (!characteristic) return;

                const portId = getPortIdFromLetter(portLetter);
                let targetPos = position;

                // Command: GotoAbsolutePosition (0x0D)
                const buffer = new ArrayBuffer(14);
                const view = new DataView(buffer);
                let idx = 0;
                view.setUint8(idx++, 14); view.setUint8(idx++, 0x00);
                view.setUint8(idx++, 0x81); view.setUint8(idx++, portId);
                view.setUint8(idx++, 0x11); view.setUint8(idx++, 0x0D);
                view.setInt32(idx, targetPos, true); idx += 4;
                view.setInt8(idx++, speed);
                view.setUint8(idx++, 100);
                view.setUint8(idx++, 1);
                view.setUint8(idx++, 0);

                await characteristic.writeValueWithoutResponse(new Uint8Array(buffer));
            } catch (e) { console.error(e); }
        }

        async function startHubMotor(deviceId, portLetter, direction = 'CW', speed = 50) {
            const deviceData = connectedDevices.find(d => d.id === deviceId);
            const targetDevice = deviceData ? deviceData.device : null;
            if (!targetDevice) return;
            try {
                let characteristic = null;
                const services = await targetDevice.gatt.getPrimaryServices();
                for (const service of services) {
                    const chars = await service.getCharacteristics();
                    for (const c of chars) { if (c.properties.write || c.properties.writeWithoutResponse) { characteristic = c; break; } }
                    if (characteristic) break;
                }
                if (!characteristic) return;

                const portId = getPortIdFromLetter(portLetter);
                const speedVal = direction === 'CW' ? speed : -speed;

                // Command: StartSpeed (0x07)
                const buffer = new ArrayBuffer(9);
                const view = new DataView(buffer);
                let idx = 0;
                view.setUint8(idx++, 9); view.setUint8(idx++, 0x00);
                view.setUint8(idx++, 0x81); view.setUint8(idx++, portId);
                view.setUint8(idx++, 0x11); view.setUint8(idx++, 0x07);
                view.setInt8(idx++, speedVal);
                view.setUint8(idx++, 100);
                view.setUint8(idx++, 0);

                await characteristic.writeValueWithoutResponse(new Uint8Array(buffer));
            } catch (e) { console.error(e); }
        }

        async function stopHubMotor(deviceId, portLetter) {
            const deviceData = connectedDevices.find(d => d.id === deviceId);
            const targetDevice = deviceData ? deviceData.device : null;
            if (!targetDevice) return;
            try {
                let characteristic = null;
                const services = await targetDevice.gatt.getPrimaryServices();
                for (const service of services) {
                    const chars = await service.getCharacteristics();
                    for (const c of chars) { if (c.properties.write || c.properties.writeWithoutResponse) { characteristic = c; break; } }
                    if (characteristic) break;
                }
                if (!characteristic) return;

                const portId = getPortIdFromLetter(portLetter);

                // Command: StartSpeed (0x07) with Speed 0
                const buffer = new ArrayBuffer(9);
                const view = new DataView(buffer);
                let idx = 0;
                view.setUint8(idx++, 9); view.setUint8(idx++, 0x00);
                view.setUint8(idx++, 0x81); view.setUint8(idx++, portId);
                view.setUint8(idx++, 0x11); view.setUint8(idx++, 0x07);
                view.setInt8(idx++, 0);
                view.setUint8(idx++, 100);
                view.setUint8(idx++, 0);

                await characteristic.writeValueWithoutResponse(new Uint8Array(buffer));
            } catch (e) { console.error(e); }
        }

        async function setHubLightBrightness(deviceId, portLetter, brightness) {
            const deviceData = connectedDevices.find(d => d.id === deviceId);
            const targetDevice = deviceData ? deviceData.device : null;

            if (!targetDevice) return;

            try {
                // LPF2 Hub Characteristic UUID
                const LPF2_CHARACTERISTIC = '00001624-1212-efde-1623-785feabcd123';

                let characteristic = null;
                const services = await targetDevice.gatt.getPrimaryServices();

                for (const service of services) {
                    const chars = await service.getCharacteristics();
                    for (const c of chars) {
                        if (c.uuid === LPF2_CHARACTERISTIC) {
                            characteristic = c;
                            break;
                        }
                    }
                    if (characteristic) break;
                }

                // Fallback (Generic Write Characteristic)
                if (!characteristic) {
                    for (const service of services) {
                        const chars = await service.getCharacteristics();
                        for (const c of chars) {
                            if (c.properties.write || c.properties.writeWithoutResponse) {
                                characteristic = c;
                                break;
                            }
                        }
                        if (characteristic) break;
                    }
                }

                if (!characteristic) return;

                const portId = getPortIdFromLetter(portLetter);

                // WriteDirectModeData (0x51) - Mode 0 (Brightness)
                // Startup/Completion: 0x01 (Buffer + Feedback) -> node-poweredup default
                const buffer = new ArrayBuffer(8);
                const view = new DataView(buffer);
                let idx = 0;
                view.setUint8(idx++, 8); // Len
                view.setUint8(idx++, 0x00); // Hub ID
                view.setUint8(idx++, 0x81); // Port Output Command
                view.setUint8(idx++, portId); // Port
                view.setUint8(idx++, 0x01); // Startup/Completion: 0x01
                view.setUint8(idx++, 0x51); // Sub Command: WriteDirectModeData
                view.setUint8(idx++, 0x00); // Mode 0 (Brightness)
                view.setUint8(idx++, brightness); // Data (0-100)

                await characteristic.writeValueWithoutResponse(new Uint8Array(buffer));

            } catch (e) {
                console.error('Light Error:', e);
            }
        }


        // Motor açıya git (Göreceli hareket: Mevcut + Açı)
        // Kullanıcı "Run to Angle" bloğunu "Turn By Angle" (Göreceli Dönüş) olarak bekliyor.
        async function runMotorToAngle(deviceId, angle, direction = 'CW') {
            if (motorOperationInProgress) {
                console.log('⏳ Başka bir motor işlemi devam ediyor...');
                return;
            }
            motorOperationInProgress = true;

            try {

                let current = motorState.currentAngle || 0;
                let targetDelta = angle;

                if (direction === 'CCW') {
                    targetDelta = -targetDelta;
                }

                const targetAngle = current + targetDelta;
                console.log(`   📍 Açı Hedef: ${current}° + ${targetDelta}° = ${targetAngle}°`);

                const success = await sendMotorPositionCommand(deviceId, targetAngle);
                if (success) {
                    const waitTime = Math.max(500, Math.abs(targetDelta) * 10);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                }
            } finally {
                motorOperationInProgress = false;
            }
        }

        // Motor mutlak pozisyona git (Eski fonksiyonu koru ama yeni helper'ı kullansın)
        // PCAP ANALİZİ (capturing_bluetooth_67angle.pcap):
        // Frame 23: 20 00            → Handle 0x000c (CMD char) - Başlatma komutu
        // Frame 25: 80 01 43 00 02   → Handle 0x000c (CMD char) - 67° pozisyon komutu (0x43 = 67)
        // Frame 86: 20 01            → Handle 0x000c (CMD char) - Tamamlama komutu (opsiyonel)
        async function goToPosition(deviceId, position) {
            if (motorOperationInProgress) {
                console.log('⏳ Başka bir motor işlemi devam ediyor...');
                return;
            }
            motorOperationInProgress = true;
            try {
                const success = await sendMotorPositionCommand(deviceId, position);
                if (success) {
                    const waitTime = Math.max(500, Math.abs(position - (motorState.currentAngle || 0)) * 10);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                    console.log(`✅ ${position}° pozisyonuna gidildi!`);
                }
            } finally {
                motorOperationInProgress = false;
            }
        }

        // Motor başlat (sürekli dönme)
        async function startMotor(deviceId, direction = 'CW') {
            // Motor işlemi devam ediyorsa bekle
            if (motorOperationInProgress) {
                console.log('⏳ Başka bir motor işlemi devam ediyor, bekleniyor...');
                return;
            }

            motorOperationInProgress = true;

            try {
                const chars = await getMotorCharacteristics(deviceId);

                if (!chars) {
                    console.error('❌ Karakteristikler alınamadı!');
                    return;
                }

                console.log(`▶️ Motor ${direction === 'CW' ? 'sağa ↻' : 'sola ↺'} başlatılıyor...`);

                const writeChar = Object.values(chars)[0];

                if (!writeChar) {
                    console.error('❌ Yazılabilir karakteristik bulunamadı');
                    return;
                }

                // Başlatma komutları
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_START);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_INIT_1);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_PREPARE);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_INIT_2);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_MODE);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_INIT_3);

                // Yöne göre motor base komutu
                const motorBaseCmd = createMotorBaseCommand(direction);

                // Sabit hız komutları (43 komut)
                for (let i = 0; i < 43; i++) {
                    await writeMotorCommand(writeChar, motorBaseCmd, 30);
                }

                // Kontrol ve execute
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_CONTROL);
                await writeMotorCommand(writeChar, motorBaseCmd);

                // Sürekli dönme için yüksek rotasyon execute komutu
                const continuousRotations = 100;
                const executeCmd = createExecuteCommand(continuousRotations, true, direction);
                await writeMotorCommand(writeChar, executeCmd);

                console.log(`✅ Motor ${direction === 'CW' ? 'sağa ↻' : 'sola ↺'} başlatıldı!`);
            } finally {
                motorOperationInProgress = false;
            }
        }

        // Motor durdur
        async function stopMotor(deviceId) {
            // Stop komutu her zaman çalışabilmeli - kilidi temizle ve çalıştır
            motorOperationInProgress = false;

            try {
                const chars = await getMotorCharacteristics(deviceId);

                if (!chars) {
                    console.error('❌ Karakteristikler alınamadı!');
                    return;
                }

                console.log('⏹️ Motor durduruluyor...');

                const writeChar = Object.values(chars)[0];

                if (!writeChar) {
                    console.error('❌ Yazılabilir karakteristik bulunamadı');
                    return;
                }

                // Çoklu durma yaklaşımı
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_STOP_INIT);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_STOP_INIT);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_STOP_INIT);

                await writeMotorCommand(writeChar, MOTOR_COMMANDS.CMD_CONTROL);
                const stopExecute = new Uint8Array([0x7c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00]);
                await writeMotorCommand(writeChar, stopExecute);

                for (const cmd of MOTOR_SLOWDOWN) {
                    await writeMotorCommand(writeChar, cmd, 50);
                }

                for (let i = 0; i < 30; i++) {
                    await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_BASE, 10);
                }

                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_STOP_INIT);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_BRAKE);
                await writeMotorCommand(writeChar, MOTOR_COMMANDS.MOTOR_FLOAT);

                console.log('✅ Motor durduruldu!');
            } catch (error) {
                console.error('❌ stopMotor hatası:', error);
            }
        }

        // Cihaz tiplerini isimden algıla
        function detectDeviceType(deviceName) {
            const name = deviceName.toLowerCase();
            if (name.includes('boost') && name.includes('hub')) return 'boost_move_hub';
            if (name.includes('city') && name.includes('hub')) return 'city_hub';
            if (name.includes('technic') && name.includes('hub')) return 'technic_medium_hub';
            if (name.includes('prime')) return 'spike_prime';
            if (name.includes('spike') || name.includes('essential')) return 'spike_essential';
            if (name.includes('hub')) return 'technic_hub';
            if (name.includes('motor')) return 'motor';
            if (name.includes('controller') || name.includes('joystick') || name.includes('gamepad') || name.includes('handset')) return 'controller';
            if (name.includes('color') && name.includes('sensor')) return 'color_sensor';
            if (name.includes('sensor')) return 'sensor';
            return 'generic';
        }



        // Cihaz tipine göre özel bloklar
        const DEVICE_BLOCKS = {
            'double_motor': [
                {
                    type: 'motor_run_seconds',
                    icon: 'timer',
                    label: 'run for [1] seconds',
                    color: '#4ECDC4'
                },
                {
                    type: 'motor_stop',
                    icon: 'stop',
                    label: 'stop',
                    color: '#4ECDC4'
                }
            ],
            'motor': [
                {
                    type: 'motor_run_rotation',
                    icon: 'rotate',
                    label: 'run for [1] rotations',
                    color: '#4ECDC4'
                },
                {
                    type: 'motor_run_seconds',
                    icon: 'timer',
                    label: 'run for [1] seconds',
                    color: '#4ECDC4'
                },
                {
                    type: 'motor_set_speed',
                    icon: 'speed',
                    label: 'set speed to [100]%',
                    color: '#4ECDC4'
                },
                {
                    type: 'motor_stop',
                    icon: 'stop',
                    label: 'stop',
                    color: '#4ECDC4'
                }
            ],
            'double_motor': [
                {
                    type: 'double_motor_run_rotation',
                    icon: 'img/double-motor.png',
                    label: 'run [left] motor for [1] rotations',
                    color: '#FF9F43'
                },
                {
                    type: 'double_motor_go_to_position',
                    icon: 'img/double-motor.png',
                    label: 'run [left] motor to [0] angle',
                    color: '#FF9F43'
                },
                {
                    type: 'double_motor_start',
                    icon: 'img/double-motor.png',
                    label: 'start [left] motor',
                    color: '#FF9F43'
                },
                {
                    type: 'double_motor_stop',
                    icon: 'img/double-motor.png',
                    label: 'stop [left] motor',
                    color: '#FF9F43'
                },
                {
                    type: 'double_motor_set_speed',
                    icon: 'img/double-motor.png',
                    label: 'set [left] motor speed to [50]%',
                    color: '#FF9F43'
                },
                {
                    type: 'double_motor_get_angle',
                    icon: 'img/double-motor.png',
                    label: '[left] motor angle',
                    color: '#FF9F43',
                    isReporter: true
                }
            ],
            'controller': [
                {
                    type: 'when_lever_up',
                    icon: '🕹️',
                    label: 'when left lever is up',
                    color: '#45B7D1',
                    isEvent: true
                },
                {
                    type: 'when_lever_down',
                    icon: '🕹️',
                    label: 'when left lever is down',
                    color: '#45B7D1',
                    isEvent: true
                },
                {
                    type: 'when_button_pressed',
                    icon: '🔘',
                    label: 'when button A pressed',
                    color: '#45B7D1',
                    isEvent: true
                }
            ],
            'color_sensor': [
                {
                    type: 'when_color_detected',
                    icon: '🔴',
                    label: 'when red detected',
                    color: '#9B59B6',
                    isEvent: true
                },
                {
                    type: 'detecting_color',
                    icon: '🟡',
                    label: 'detecting yellow?',
                    color: '#9B59B6',
                    isBoolean: true
                },
                {
                    type: 'color_value',
                    icon: '🎨',
                    label: 'color',
                    color: '#9B59B6',
                    isReporter: true
                }
            ],
            'spike_essential': [
                {
                    type: 'hub_led_color',
                    icon: '💡',
                    label: 'set hub LED',
                    color: '#F5A623'
                },
                {
                    type: 'hub_orientation',
                    icon: '📐',
                    label: 'is front up?',
                    color: '#4FC3F7',
                    isBoolean: true
                }
            ],
            'spike_prime': [
                {
                    type: 'hub_led_color',
                    icon: '💡',
                    label: 'set hub LED',
                    color: '#F5A623'
                },
                {
                    type: 'hub_orientation',
                    icon: '📐',
                    label: 'is front up?',
                    color: '#4FC3F7',
                    isBoolean: true
                }
            ],
            'technic_medium_hub': [
                {
                    type: 'hub_led_color',
                    icon: '💡',
                    label: 'set hub LED',
                    color: '#27AE60'
                },
                {
                    type: 'hub_orientation',
                    icon: '📐',
                    label: 'is front up?',
                    color: '#4FC3F7',
                    isBoolean: true
                }
            ],
            'city_hub': [
                {
                    type: 'hub_led_color',
                    icon: '💡',
                    label: 'set hub LED',
                    color: '#3498DB'
                },
                {
                    type: 'hub_orientation',
                    icon: '📐',
                    label: 'is front up?',
                    color: '#4FC3F7',
                    isBoolean: true
                }
            ],
            'boost_move_hub': [
                {
                    type: 'hub_led_color',
                    icon: '💡',
                    label: 'set hub LED',
                    color: '#E74C3C'
                },
                {
                    type: 'hub_orientation',
                    icon: '📐',
                    label: 'is front up?',
                    color: '#4FC3F7',
                    isBoolean: true
                }
            ],
            'remote_controller': [
                {
                    type: 'remote_led_color',
                    icon: '💡',
                    label: 'set LED color',
                    color: '#00A3DA'
                },
                {
                    type: 'remote_left_button',
                    icon: '⬅️',
                    label: 'left button',
                    color: '#00A3DA',
                    isReporter: true
                },
                {
                    type: 'remote_right_button',
                    icon: '➡️',
                    label: 'right button',
                    color: '#00A3DA',
                    isReporter: true
                },
                {
                    type: 'remote_button_pressed',
                    icon: '🎮',
                    label: 'button pressed?',
                    color: '#00A3DA',
                    isBoolean: true
                }
            ],
            'generic': [
                {
                    type: 'device_command',
                    icon: '📡',
                    label: 'send command',
                    color: '#98D8C8'
                },
                {
                    type: 'force_sensor_is_pressed',
                    icon: '👇',
                    label: 'is pressed?',
                    color: '#4FC3F7',
                    isBoolean: true
                },
                {
                    type: 'force_sensor_pressure',
                    icon: '💪',
                    label: 'pressure',
                    color: '#4FC3F7',
                    isReporter: true
                }
            ],
            'generic': [
                {
                    type: 'device_command',
                    icon: '📡',
                    label: 'send command',
                    color: '#98D8C8'
                }
            ]
        };

        function getRandomShape() {
            return DEVICE_SHAPES[Math.floor(Math.random() * DEVICE_SHAPES.length)];
        }

        function getRandomColor() {
            return DEVICE_COLORS[Math.floor(Math.random() * DEVICE_COLORS.length)];
        }

        function addDeviceToSidebar(device, overrideColor = null, overrideType = null) {
            const deviceType = overrideType || detectDeviceType(device.name || '');

            // İsim düzeltme - cihaz adı yoksa tip bazlı isim kullan
            let displayName = device.name;
            if (!displayName || displayName.trim() === '') {
                if (overrideType === 'motor') displayName = 'Single Motor';
                else if (overrideType === 'double_motor') displayName = 'Double Motor';
                else if (overrideType === 'color_sensor') displayName = 'Color Sensor';
                else if (overrideType === 'controller') displayName = 'Controller';
                else displayName = 'Device';
            }
            // Tip bazlı özel isim geçersiz kılma
            if (overrideType === 'color_sensor' && !device.name?.toLowerCase().includes('color')) {
                displayName = 'Color Sensor';
            }
            if (overrideType === 'controller' && !device.name?.toLowerCase().includes('controller')) {
                displayName = 'Controller';
            }
            if (overrideType === 'double_motor') {
                displayName = 'Double Motor';
            }
            if (overrideType === 'spike_essential') {
                displayName = 'Spike Essential Hub';
            }
            if (overrideType === 'spike_prime') {
                displayName = 'Spike Prime Hub';
            }
            if (overrideType === 'technic_medium_hub') {
                displayName = 'Technic Medium Hub';
            }
            if (overrideType === 'city_hub') {
                displayName = 'City Hub';
            }
            if (overrideType === 'boost_move_hub') {
                displayName = 'Boost Move Hub';
            }
            if (overrideType === 'remote_controller') {
                displayName = 'Remote Controller';
            }

            if (typeof logDeviceAction === 'function') {
                logDeviceAction('add', displayName, deviceType);
            }

            const deviceData = {
                id: device.id,
                name: displayName,
                type: deviceType,
                shape: getRandomShape(),
                color: overrideColor || getRandomColor(),
                device: device,
                server: bluetoothServer,
                characteristics: { ...connectedCharacteristics },
                connected: true
            };

            connectedDevices.push(deviceData);

            // Ana device list'e ekle
            const deviceList = document.getElementById('deviceList');
            const deviceIcon = document.createElement('div');
            deviceIcon.className = `device-icon ${deviceData.shape}`;
            deviceIcon.dataset.deviceId = deviceData.id;
            deviceIcon.title = deviceData.name;

            // Controller için özel stil
            if (deviceType === 'controller') {
                deviceIcon.classList.add('controller');
                deviceIcon.style.setProperty('--device-color', deviceData.color);

                // Normal durumda beyaz arka plan, siyah yazı
                deviceIcon.style.background = '#FFFFFF';
                deviceIcon.style.borderColor = deviceData.color;
                deviceIcon.style.color = 'black';

                deviceIcon.innerHTML = '<img src="img/controller.png" style="width: 28px; height: 28px; object-fit: contain;">';
                // deviceIcon.style.fontSize = '16px'; // No longer needed
            } else if (deviceType === 'color_sensor') {
                // Color Sensor için özel stil
                deviceIcon.classList.add('color-sensor');
                deviceIcon.style.setProperty('--device-color', deviceData.color);

                // Normal durumda beyaz arka plan
                deviceIcon.style.background = '#FFFFFF';
                deviceIcon.style.borderColor = deviceData.color;
                deviceIcon.style.color = deviceData.color;

                deviceIcon.innerHTML = '<img src="img/color-sensor.png" style="width: 28px; height: 28px; object-fit: contain;">';
            } else if (deviceType === 'spike_essential') {
                // Spike Essential Hub için özel stil
                deviceIcon.classList.add('spike-essential');
                deviceIcon.style.setProperty('--device-color', deviceData.color);
                deviceIcon.style.background = '#FFFFFF';
                deviceIcon.style.borderColor = deviceData.color;
                deviceIcon.style.color = deviceData.color;
                deviceIcon.innerHTML = '<img src="img/spike_essential_icon.png" style="width: 28px; height: 28px; object-fit: contain;">';
            } else if (deviceType === 'spike_prime') {
                // Spike Prime Hub için özel stil
                deviceIcon.classList.add('spike-prime');
                deviceIcon.style.setProperty('--device-color', deviceData.color);
                deviceIcon.style.background = '#FFFFFF';
                deviceIcon.style.borderColor = deviceData.color;
                deviceIcon.style.color = deviceData.color;
                deviceIcon.innerHTML = '<img src="img/spike_prime_icon.png" style="width: 28px; height: 28px; object-fit: contain;">';
            } else if (deviceType === 'technic_medium_hub') {
                // Technic Medium Hub için özel stil
                deviceIcon.classList.add('technic-medium-hub');
                deviceIcon.style.setProperty('--device-color', deviceData.color);
                deviceIcon.style.background = '#FFFFFF';
                deviceIcon.style.borderColor = deviceData.color;
                deviceIcon.style.color = deviceData.color;
                deviceIcon.innerHTML = '<img src="img/technic-hub.png" style="width: 28px; height: 28px; object-fit: contain;">';
            } else if (deviceType === 'city_hub') {
                // City Hub için özel stil
                deviceIcon.classList.add('city-hub');
                deviceIcon.style.setProperty('--device-color', deviceData.color);
                deviceIcon.style.background = '#FFFFFF';
                deviceIcon.style.borderColor = deviceData.color;
                deviceIcon.style.color = deviceData.color;
                deviceIcon.innerHTML = '<img src="img/city-hub.png" style="width: 28px; height: 28px; object-fit: contain;">';
            } else if (deviceType === 'boost_move_hub') {
                // Boost Move Hub için özel stil
                deviceIcon.classList.add('boost-move-hub');
                deviceIcon.style.setProperty('--device-color', deviceData.color);
                deviceIcon.style.background = '#FFFFFF';
                deviceIcon.style.borderColor = deviceData.color;
                deviceIcon.style.color = deviceData.color;
                deviceIcon.innerHTML = '<img src="img/boost-hub.png" style="width: 28px; height: 28px; object-fit: contain;">';
            } else if (deviceType === 'remote_controller') {
                // Remote Controller için özel stil
                deviceIcon.classList.add('remote-controller');
                deviceIcon.style.setProperty('--device-color', deviceData.color);
                deviceIcon.style.background = '#FFFFFF';
                deviceIcon.style.borderColor = deviceData.color;
                deviceIcon.style.color = deviceData.color;
                deviceIcon.innerHTML = '<img src="img/remote_controller_icon.png" style="width: 28px; height: 28px; object-fit: contain;">';
            } else {
                deviceIcon.style.borderColor = deviceData.color;
                deviceIcon.style.color = deviceData.color;

                // Single/Double Motor için özel kontrol
                const name = (deviceData.name || '').toLowerCase();
                if (name.includes('single motor')) {
                    deviceIcon.innerHTML = '<img src="img/single-motor.png" style="width: 28px; height: 28px; object-fit: contain;">';
                } else if (name.includes('double motor')) {
                    deviceIcon.innerHTML = '<img src="img/double-motor.png" style="width: 28px; height: 28px; object-fit: contain;">';
                } else {
                    // Diğer cihazlar için ID'nin son 4 karakteri
                    const shortId = deviceData.id.split('-').pop().substring(0, 4).toUpperCase();
                    deviceIcon.innerHTML = `${shortId}`;
                }
            }

            deviceIcon.onclick = (e) => {
                e.stopPropagation();

                // Tüm ikonlardan seçili durumunu kaldır
                document.querySelectorAll('.device-icon').forEach(icon => icon.classList.remove('selected'));

                // Eğer aynı cihaza tekrar tıklandıysa toolbox'ı kapat
                if (currentToolboxDevice === deviceData.id && currentToolboxMode === 'device') {
                    hideAllToolboxes();
                    currentToolboxDevice = null;
                } else {
                    // Farklı cihaz - cihaz bloklarını toolbox'ta göster
                    currentToolboxDevice = deviceData.id;
                    selectedDeviceId = deviceData.id; // Set selected device ID explicitly
                    showDeviceToolbox(deviceData);
                    deviceIcon.classList.add('selected');
                }
            };

            deviceList.appendChild(deviceIcon);

            // Tabloyu güncelle
            updateDevicesTable();

            // console.log('Cihaz eklendi:', deviceData);
        }

        function toggleDeviceMenu(deviceData) {
            const sidebar = document.getElementById('sidebar');
            const panelTitle = document.getElementById('panelTitle');
            const panelContent = document.getElementById('panelContent');
            const icon = document.querySelector(`[data-device-id="${deviceData.id}"]`);

            // Aynı cihaza tekrar tıklanırsa kapat
            if (deviceMenuOpen === deviceData.id) {
                sidebar.classList.remove('expanded');
                icon.classList.remove('active');
                deviceMenuOpen = null;
                return;
            }

            // Önceki aktif ikonu temizle
            document.querySelectorAll('.device-icon').forEach(i => i.classList.remove('active'));
            icon.classList.add('active');

            // Panel içeriğini oluştur
            const blocks = DEVICE_BLOCKS[deviceData.type] || DEVICE_BLOCKS['generic'];
            panelTitle.textContent = `${deviceData.name} Blokları`;
            panelContent.innerHTML = '';

            blocks.forEach(blockDef => {
                const blockDiv = document.createElement('div');
                blockDiv.className = 'device-menu-block';

                // Geçici bir Blockly bloğu oluştur
                const tempBlockType = `temp_${deviceData.id}_${blockDef.type}`;

                // Blok tipini tanımla
                if (!Blockly.Blocks[tempBlockType]) {
                    createDeviceBlock(tempBlockType, blockDef, deviceData);
                }

                try {
                    // Workspace'de geçici blok oluştur
                    const tempBlock = workspace.newBlock(tempBlockType);
                    tempBlock.initSvg();
                    tempBlock.render();

                    // Bloğun SVG'sini al
                    const blockSvg = tempBlock.getSvgRoot();
                    const bbox = blockSvg.getBBox();

                    // SVG wrapper oluştur
                    const svgWrapper = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svgWrapper.setAttribute('width', bbox.width + 10);
                    svgWrapper.setAttribute('height', bbox.height + 10);
                    svgWrapper.setAttribute('viewBox', `${bbox.x - 5} ${bbox.y - 5} ${bbox.width + 10} ${bbox.height + 10}`);

                    // İçeriği clone'la
                    const clonedContent = blockSvg.cloneNode(true);
                    svgWrapper.appendChild(clonedContent);

                    blockDiv.appendChild(svgWrapper);

                    // Geçici bloğu sil
                    tempBlock.dispose(false);

                } catch (error) {
                    console.error('Blok önizleme hatası:', error);
                    // Hata durumunda basit gösterim
                    blockDiv.innerHTML = `
                        <div style="background: ${blockDef.color}; color: white; padding: 10px 15px; border-radius: 8px; font-size: 13px; font-weight: 600;">
                            ${blockDef.icon} ${blockDef.label}
                        </div>
                    `;
                }

                // Drag and drop
                blockDiv.draggable = true;

                blockDiv.ondragstart = (e) => {
                    e.dataTransfer.effectAllowed = 'copy';
                    e.dataTransfer.setData('blockType', blockDef.type);
                    e.dataTransfer.setData('deviceId', deviceData.id);
                    blockDiv.style.opacity = '0.5';
                };

                blockDiv.ondragend = (e) => {
                    blockDiv.style.opacity = '1';
                };

                panelContent.appendChild(blockDiv);
            });

            // Sidebar'ı genişlet
            sidebar.classList.add('expanded');
            deviceMenuOpen = deviceData.id;
        }

        function adjustColor(color, amount) {
            const num = parseInt(color.replace("#", ""), 16);
            const r = Math.max(0, Math.min(255, (num >> 16) + amount));
            const g = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amount));
            const b = Math.max(0, Math.min(255, (num & 0x0000FF) + amount));
            return "#" + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
        }

        // Workspace'e drop handler ekle
        function setupWorkspaceDrop() {
            const workspaceDiv = document.getElementById('blocklyDiv');

            workspaceDiv.ondragover = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            };

            workspaceDiv.ondrop = (e) => {
                e.preventDefault();
                const blockType = e.dataTransfer.getData('blockType');
                const deviceId = e.dataTransfer.getData('deviceId');

                if (blockType && deviceId) {
                    const deviceData = connectedDevices.find(d => d.id === deviceId);
                    const blockDef = Object.values(DEVICE_BLOCKS).flat()
                        .find(b => b.type === blockType);

                    if (deviceData && blockDef) {
                        // Mouse pozisyonunu Blockly koordinatlarına çevir
                        const metrics = workspace.getMetrics();
                        const scale = workspace.scale;

                        // Blockly canvas'ının pozisyonunu al
                        const blocklyRect = workspaceDiv.getBoundingClientRect();

                        // Mouse pozisyonunu workspace koordinatlarına çevir
                        const x = (e.clientX - blocklyRect.left) / scale - metrics.viewLeft;
                        const y = (e.clientY - blocklyRect.top) / scale - metrics.viewTop;

                        addDeviceBlockToWorkspace(blockDef, deviceData, x, y);
                    }
                }
            };
        }

        function addDeviceBlockToWorkspace(blockDef, deviceData, x, y) {
            // Dinamik blok oluştur
            const blockType = `${deviceData.id}_${blockDef.type}`;

            // Blok zaten tanımlı değilse oluştur
            if (!Blockly.Blocks[blockType]) {
                createDeviceBlock(blockType, blockDef, deviceData);
            }

            // Workspace'e ekle
            const newBlock = workspace.newBlock(blockType);
            newBlock.initSvg();
            newBlock.render();

            // Pozisyon belirtilmişse kullan, yoksa varsayılan
            if (x !== undefined && y !== undefined) {
                newBlock.moveBy(x, y);
            } else {
                newBlock.moveBy(200, 100);
            }

            console.log('Cihaz bloğu eklendi:', blockType, 'at', x, y);
        }

        function createDeviceBlock(blockType, blockDef, deviceData) {
            Blockly.Blocks[blockType] = {
                init: function () {
                    const input = this.appendDummyInput();

                    if (DEVICE_ICONS[blockDef.icon]) {
                        input.appendField(new Blockly.FieldImage(DEVICE_ICONS[blockDef.icon], 16, 16, "*"));
                    } else {
                        input.appendField(blockDef.icon);
                    }

                    // Label'ı parçala ve number field'ları ekle
                    const parts = blockDef.label.split(/\[|\]/);
                    parts.forEach((part, index) => {
                        if (index % 2 === 0) {
                            // Normal text
                            if (part.trim()) input.appendField(part.trim());
                        } else {
                            // Number field
                            const value = parseInt(part) || 1;
                            input.appendField(new CustomNumberField(value, 1, 100), `VAL${index}`);
                        }
                    });

                    if (blockDef.isEvent) {
                        this.setNextStatement(true, null);
                    } else {
                        this.setPreviousStatement(true, null);
                        this.setNextStatement(true, null);
                    }

                    this.setColour(blockDef.color);
                    this.data = deviceData.id;
                }
            };

            // Kod üretici
            Blockly.Python[blockType] = function (block) {
                return `# ${deviceData.name}: ${blockDef.label}\n`;
            };
        }

        function updateDevicesTable() {
            const tbody = document.getElementById('devicesTableBody');
            const t = TRANSLATIONS[currentLanguage];

            if (connectedDevices.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="4" style="padding: 30px; text-align: center; color: #999;">
                            ${t.no_device}
                        </td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = '';

            connectedDevices.forEach((device, index) => {
                const row = document.createElement('tr');
                row.style.borderBottom = '1px solid #e0e0e0';
                row.style.background = index % 2 === 0 ? 'white' : '#f9f9f9';

                const statusIcon = device.connected ? '🟢' : '🔴';
                const statusText = device.connected ? t.status_connected : t.status_disconnected;
                const statusColor = device.connected ? '#0FBD8C' : '#FF6680';

                row.innerHTML = `
                    <td style="padding: 12px; font-size: 14px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div style="width: 20px; height: 20px; border-radius: 50%; background: ${device.color}; border: 2px solid ${device.color};"></div>
                            <strong>${device.name}</strong>
                        </div>
                    </td>
                    <td style="padding: 12px; font-size: 12px; color: #666; font-family: monospace;">
                        ${device.id}
                    </td>
                    <td style="padding: 12px; text-align: center;">
                        <span style="background: ${statusColor}20; color: ${statusColor}; padding: 4px 12px; border-radius: 12px; font-size: 12px; font-weight: bold;">
                            ${statusIcon} ${statusText}
                        </span>
                    </td>
                    <td style="padding: 12px; text-align: center;">
                        <div style="display: flex; gap: 8px; justify-content: center;">
                            ${(device.type === 'spike_essential' || device.type === 'spike_prime' || device.type === 'technic_medium_hub' || device.type === 'city_hub' || device.type === 'boost_move_hub') ? `
                                <button onclick="openDeviceSettings('${device.id}')" style="background: #4C97FF; color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: bold; display: flex; align-items: center; gap: 6px;">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="white"><path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.64-.06.94s.02.63.06.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
                                    Settings
                                </button>
                            ` : ''}
                            <button onclick="removeDeviceFromTable('${device.id}')" style="background: #FF6680; color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: bold; display: flex; align-items: center; gap: 6px;">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="white"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
                                ${t.btn_remove}
                            </button>
                        </div>
                    </td>
                `;

                tbody.appendChild(row);
            });
        }

        let pendingRemoveDeviceId = null;

        function removeDeviceFromTable(deviceId) {
            pendingRemoveDeviceId = deviceId;
            const modal = document.getElementById('removeDeviceModal');
            if (modal) {
                modal.classList.add('active');
            }
        }

        function closeRemoveDeviceModal() {
            const modal = document.getElementById('removeDeviceModal');
            if (modal) {
                modal.classList.remove('active');
            }
            pendingRemoveDeviceId = null;
        }

        function confirmRemoveDevice() {
            if (pendingRemoveDeviceId) {
                removeDevice(pendingRemoveDeviceId);
            }
            closeRemoveDeviceModal();
        }

        // Device Settings Modal
        let currentSettingsDeviceId = null;

        function openDeviceSettings(deviceId) {
            currentSettingsDeviceId = deviceId;
            const device = connectedDevices.find(d => d.id === deviceId);
            if (!device) return;

            // Update title
            const title = document.getElementById('deviceSettingsTitle');
            if (title) title.textContent = `Settings: ${device.name}`;

            // Set current nickname
            const nicknameInput = document.getElementById('deviceNicknameInput');
            if (nicknameInput) nicknameInput.value = device.name || '';

            // Generate LED color picker
            const colorPicker = document.getElementById('ledColorPicker');
            if (colorPicker) {
                colorPicker.innerHTML = '';
                Object.entries(LEGO_COLORS).forEach(([index, colorData]) => {
                    const btn = document.createElement('button');
                    btn.style.cssText = `
                        width: 36px; height: 36px; border-radius: 50%; border: 3px solid #e0e0e0;
                        background: ${colorData.hex}; cursor: pointer; transition: all 0.2s;
                        ${colorData.name === 'Off' ? 'background: linear-gradient(45deg, #333 25%, #666 25%, #666 50%, #333 50%, #333 75%, #666 75%);' : ''}
                    `;
                    btn.title = colorData.name;
                    btn.onclick = () => setHubLedColor(parseInt(index));

                    // Highlight current color
                    if (spikeHubState.hubColor === parseInt(index)) {
                        btn.style.borderColor = '#4C97FF';
                        btn.style.transform = 'scale(1.1)';
                    }

                    colorPicker.appendChild(btn);
                });
            }

            // Show modal
            const modal = document.getElementById('deviceSettingsModal');
            if (modal) modal.classList.add('active');
        }

        function closeDeviceSettings() {
            const modal = document.getElementById('deviceSettingsModal');
            if (modal) modal.classList.remove('active');
            currentSettingsDeviceId = null;
        }

        async function saveDeviceNickname() {
            if (!currentSettingsDeviceId) return;
            const device = connectedDevices.find(d => d.id === currentSettingsDeviceId);
            if (!device || !spikeHubState.writeChar) {
                console.error('❌ Cannot save nickname: device or writeChar not available');
                return;
            }

            const nicknameInput = document.getElementById('deviceNicknameInput');
            const newName = nicknameInput.value.trim().substring(0, 14);
            if (!newName) return;

            try {
                // LWP3 Hub Properties - Set Advertising Name
                // Format: [Length] [0x00] [0x01] [0x01] [0x01] [name bytes...]
                // 0x01 = Hub Properties, 0x01 = Advertising Name, 0x01 = Set operation
                const nameBytes = new TextEncoder().encode(newName);
                const data = new Uint8Array(5 + nameBytes.length);
                data[0] = 5 + nameBytes.length; // Length
                data[1] = 0x00; // Hub ID
                data[2] = 0x01; // Hub Properties
                data[3] = 0x01; // Property: Advertising Name
                data[4] = 0x01; // Operation: Set
                data.set(nameBytes, 5);

                await spikeHubState.writeChar.writeValueWithoutResponse(data);
                console.log('✅ Hub nickname saved:', newName);

                // Update local device name
                device.name = newName;
                updateDevicesTable();

                // Update panel header
                const header = document.getElementById('spikeEssentialHeader');
                if (header) {
                    // Keep the color dot, update text
                    const colorDot = document.getElementById('spikeHubColorDot');
                    header.textContent = newName;
                    if (colorDot) header.appendChild(colorDot);
                }

                // Visual feedback
                nicknameInput.style.borderColor = '#37b24d';
                setTimeout(() => { nicknameInput.style.borderColor = '#e0e0e0'; }, 1500);

            } catch (e) {
                console.error('❌ Failed to save nickname:', e);
                nicknameInput.style.borderColor = '#e03131';
                setTimeout(() => { nicknameInput.style.borderColor = '#e0e0e0'; }, 1500);
            }
        }

        async function setHubLedColor(colorIndex, deviceId = null) {
            // DEBUG: Show what we received
            console.log('🔍 DEBUG setHubLedColor:');
            console.log('   deviceId parameter:', deviceId);
            console.log('   connectedDevices:', connectedDevices.map(d => ({ id: d.id, name: d.name })));

            let targetDevice = null;

            if (deviceId) {
                targetDevice = connectedDevices.find(d => d.id === deviceId);
                console.log('   Found device by ID:', targetDevice ? targetDevice.name : 'NOT FOUND');
                if (!targetDevice) {
                    console.error(`❌ Hedef cihaz (ID: ${deviceId}...) bulunamadı.`);
                    return;
                }
            }

            // NO FALLBACK - If no ID provided, do nothing or user error
            if (!targetDevice) {
                console.error('❌ Hedef cihaz belirtilmedi (Hub LED).');
                return;
            }

            try {
                let characteristic = null;

                // 1. Try to find ANY writable characteristic in stored list (Recommended)
                if (targetDevice.characteristics) {
                    const chars = Object.values(targetDevice.characteristics);
                    characteristic = chars.find(c => c.properties.writeWithoutResponse || c.properties.write);
                }

                // 2. Fetch if missing (Try LWP3 first, then LPF2)
                if (!characteristic) {
                    const server = targetDevice.server || (targetDevice.device ? targetDevice.device.gatt : null);
                    if (server && server.connected) {
                        try {
                            // LWP3 (Newer Hubs)
                            const s = await server.getPrimaryService('00001623-1212-efde-1623-785feabcd123');
                            characteristic = await s.getCharacteristic('00001624-1212-efde-1623-785feabcd123');
                        } catch (err) {
                            try {
                                // LPF2 (Older Hubs)
                                const s = await server.getPrimaryService('0000fd02-0000-1000-8000-00805f9b34fb');
                                characteristic = await s.getCharacteristic('0000fd02-0001-1000-8000-00805f9b34fb');
                            } catch (e2) { console.warn('Service fetch failed', e2); }
                        }
                    }
                }

                if (!characteristic) {
                    console.error('❌ Karakteristik bulunamadı (Hub LED)');
                    return;
                }

                // Port Selection Logic
                const hubType = detectDeviceType(targetDevice.name);
                let ledPort = 0x31;
                if (hubType === 'spike_prime') ledPort = 0x61;
                else if (hubType === 'technic_medium_hub' || hubType === 'city_hub' || hubType === 'boost_move_hub') ledPort = 0x32;
                else if (hubType === 'spike_essential') ledPort = 0x31;
                else if (hubType === 'technic_hub') ledPort = 0x32;

                // Command: 0x81 (Direct Write), [Port], 0x11 (Execute), 0x51 (Write), 0x00 (Mode Color), ColorIndex
                const data = new Uint8Array([0x08, 0x00, 0x81, ledPort, 0x11, 0x51, 0x00, colorIndex]);
                await characteristic.writeValueWithoutResponse(data);

                console.log(`✅ Hub LED (${targetDevice.name}) color set to:`, colorIndex);

                // Update UI state if active
                if (spikeHubState.deviceId === targetDevice.id) {
                    spikeHubState.hubColor = colorIndex;
                    updateSpikeHubColor(colorIndex);

                    // Update picker highlight
                    const colorPicker = document.getElementById('ledColorPicker');
                    if (colorPicker) {
                        colorPicker.querySelectorAll('button').forEach((btn, i) => {
                            btn.style.borderColor = (i === colorIndex) ? '#4C97FF' : '#e0e0e0';
                            btn.style.transform = (i === colorIndex) ? 'scale(1.1)' : 'scale(1)';
                        });
                    }
                }
            } catch (e) {
                console.error('❌ Failed to set LED color:', e);
            }
        }

        async function setSpikeMatrix(portLetter, pixels, deviceId = null) {
            let targetDevice = null;

            if (deviceId) {
                targetDevice = connectedDevices.find(d => d.id === deviceId);
                if (!targetDevice) {
                    console.error(`❌ Hedef cihaz (ID: ${deviceId}...) bulunamadı.`);
                    return;
                }
            }
            // NO FALLBACK

            if (!targetDevice) return;

            // Generic Port Map
            const portMap = { 'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5 };
            const portId = portMap[portLetter] !== undefined ? portMap[portLetter] : 0;

            console.log(`💡 Matrix Update (${portLetter}) on ${targetDevice.name}`);

            try {
                let characteristic = null;

                // 1. Try stored
                if (targetDevice.characteristics) {
                    const chars = Object.values(targetDevice.characteristics);
                    characteristic = chars.find(c => c.properties.writeWithoutResponse || c.properties.write);
                }

                // 2. Fetch if missing
                if (!characteristic) {
                    const server = targetDevice.server || (targetDevice.device ? targetDevice.device.gatt : null);
                    if (server && server.connected) {
                        try {
                            const s = await server.getPrimaryService('00001623-1212-efde-1623-785feabcd123');
                            characteristic = await s.getCharacteristic('00001624-1212-efde-1623-785feabcd123');
                        } catch (err) {
                            try {
                                const s = await server.getPrimaryService('0000fd02-0000-1000-8000-00805f9b34fb');
                                characteristic = await s.getCharacteristic('0000fd02-0001-1000-8000-00805f9b34fb');
                            } catch (e2) { }
                        }
                    }
                }

                if (!characteristic) {
                    console.error('❌ Karakteristik bulunamadı (Matrix)');
                    return;
                }

                // Get Global Brightness (Safe value 9)
                let globalBr = 9;

                // 1. FORCE MODE 2 (9 values) - Critical Step from working code
                const setupData = new Uint8Array([
                    0x0A, 0x00, 0x41, portId, 0x02, 0x01, 0x00, 0x00, 0x00, 0x01
                ]);
                await characteristic.writeValueWithoutResponse(setupData);

                // Wait for mode switch
                await new Promise(r => setTimeout(r, 50));

                // Prepare Data
                const packedPixels = pixels.map(p => {
                    let c = 0;
                    let b = globalBr;
                    if (typeof p === 'object' && p !== null) {
                        c = p.color || 0;
                        if (p.brightness !== undefined) b = p.brightness;
                    } else {
                        c = Number(p);
                    }
                    c = Math.min(10, Math.max(0, c));
                    b = Math.min(10, Math.max(0, b));
                    if (c === 0) return 0x00;
                    // Standard LPF2 Matrix: Brightness high, Color low
                    return ((b & 0xF) << 4) | (c & 0xF);
                });

                // Spike 3x3 Matrix Command (Mode 2)
                const totalLen = 7 + packedPixels.length;
                const payload = new Uint8Array([
                    totalLen, 0x00, 0x81, portId, 0x11, 0x51, 0x02,
                    ...packedPixels
                ]);

                console.log('📦 Matrix Payload HEX:', Array.from(payload).map(b => b.toString(16).padStart(2, '0')).join(' '));

                await characteristic.writeValueWithoutResponse(payload);

            } catch (e) {
                console.error('❌ Matrix update error', e);
            }
        }

        async function setSpikeMatrixBrightness(portLetter, percent, deviceId = null) {
            // Not fully implemented for multi-device logic yet, but prevents errors
            console.log(`Setting brightness ${percent}% for port ${portLetter} on device ${deviceId}`);
        }


        let selectedBlock = null;

        function handleBlockSelection(event) {
            const deleteOverlay = document.getElementById('deleteBlockOverlay');

            if (event.newElementId) {
                // Bir blok seçildi
                selectedBlock = workspace.getBlockById(event.newElementId);
                if (selectedBlock) {
                    deleteOverlay.classList.add('show');
                }
            } else {
                // Seçim kaldırıldı
                selectedBlock = null;
                deleteOverlay.classList.remove('show');
            }
        }

        function deleteSelectedBlock() {
            if (selectedBlock) {
                selectedBlock.dispose(true);
                selectedBlock = null;
                document.getElementById('deleteBlockOverlay').classList.remove('show');
            }
        }

        function duplicateSelectedBlock() {
            if (selectedBlock && workspace) {
                // Blok XML'ini al
                const xml = Blockly.Xml.blockToDom(selectedBlock);
                // Yeni blok oluştur
                const newBlock = Blockly.Xml.domToBlock(xml, workspace);
                // Yeni bloğu biraz kaydır
                const oldPos = selectedBlock.getRelativeToSurfaceXY();
                newBlock.moveBy(oldPos.x + 30, oldPos.y + 30);
                // console.log('📋 Blok kopyalandı');
            }
        }

        // --- Block Documentation & Help ---
        const BLOCK_DOCS = {
            'start': {
                en: `
# Start Block
When clicking the "Play" button, the code connected to this block runs.

### How to use
Connect this block to the beginning of your program.
`,
                tr: `
# Başlangıç Bloğu
"Oynat" butonuna tıklandığında, bu bloğa bağlı olan kodlar çalışır.

### Nasıl Kullanılır
Bu bloğu programınızın en başına yerleştirin.
`
            },
            'when_condition': {
                en: `
# When Condition
Continuously checks a condition. When it becomes **True**, the connected blocks run.

### Example
When detecting a red color, stop the motor.
`,
                tr: `
# Bir Durum Olduğunda
Sürekli olarak bir koşulu kontrol eder. Koşul **Doğru** olduğunda, altındaki blokları çalıştırır.

### Örnek
Kırmızı renk algılandığında motoru durdur.
`
            },
            'wait': {
                en: `
# Wait
Pauses the program for a specific amount of time.

### Parameters
- **Seconds**: How long to wait (e.g., 1, 0.5).
`,
                tr: `
# Bekle
Programı belirli bir süre duraklatır.

### Parametreler
- **Saniye**: Ne kadar bekleneceği (örn. 1, 0.5).
`
            },
            'wait_until': {
                en: `
# Wait Until
Pauses the program execution until a specific condition becomes true.
`,
                tr: `
# Olana Kadar Bekle
Belirli bir koşul gerçekleşene kadar programı bekletir.
`
            },
            'repeat_forever': {
                en: `
# Repeat Forever
Runs the blocks inside it continuously in a loop, forever.
`,
                tr: `
# Sürekli Tekrarla
İçindeki blokları sonsuza kadar sürekli tekrar eder.
`
            },
            'repeat': {
                en: '# Repeat\nRuns the blocks inside a specific number of times.',
                tr: '# Tekrarla\nİçindeki blokları belirli bir sayıda tekrar eder.'
            },
            'forever': {
                en: '# Forever\nRuns the blocks inside continuously forever.',
                tr: '# Sürekli Çalıştır\nİçindeki blokları sonsuza kadar sürekli çalıştırır.'
            },
            'if_then': {
                en: '# If Then\nIf the condition check is **TRUE**, the blocks inside will run.',
                tr: '# Eğer İse\nEğer koşul **DOĞRU** ise, içindeki bloklar çalışır.'
            },
            'if_then_else': {
                en: '# If / Else\nIf the condition is **TRUE**, runs the first blocks. If **FALSE**, runs the "Else" blocks.',
                tr: '# Eğer / Değilse\nKoşul **DOĞRU** ise ilk blokları çalıştırır. **YANLIŞ** ise "Değilse" kısmındaki blokları çalıştırır.'
            },
            'repeat_until': {
                en: '# Repeat Until\nRepeats the blocks inside until the condition becomes true.',
                tr: '# Olana Kadar Tekrarla\nKoşul doğru olana kadar içindeki blokları tekrar eder.'
            },

            // --- Operators & Math ---
            'math_arithmetic': {
                en: '# Arithmetic\nPerforms mathematical operations (+, -, x, ÷) on two numbers.',
                tr: '# Aritmetik\nİki sayı üzerinde matematiksel işlemler (+, -, x, ÷) yapar.'
            },
            'logic_compare': {
                en: '# Comparison\nCompares two values (Equal, Greater Than, Less Than). Returns True or False.',
                tr: '# Karşılaştırma\nİki değeri karşılaştırır (Eşittir, Büyüktür, Küçüktür). Doğru veya Yanlış döndürür.'
            },
            'logic_and': {
                en: '# And\nReturns True only if **BOTH** conditions are True.',
                tr: '# Ve (And)\nSadece **İKİ** koşul da Doğru ise Doğru döndürür.'
            },
            'logic_or': {
                en: '# Or\nReturns True if **AT LEAST ONE** condition is True.',
                tr: '# Veya (Or)\nKoşullardan **EN AZ BİRİ** Doğru ise Doğru döndürür.'
            },
            'logic_negate': {
                en: '# Not\nInverts a condition. True becomes False, False becomes True.',
                tr: '# Değil\nBir koşulu tersine çevirir. Doğru Yanlış olur, Yanlış Doğru olur.'
            },
            'math_random': {
                en: '# Pick Random\nPicks a random integer between two numbers.',
                tr: '# Rastgele Sayı\nİki sayı arasında rastgele bir tam sayı seçer.'
            },
            'math_number': {
                en: '# Number\nA generic number block used to set values.',
                tr: '# Sayı\nDeğer ayarlamak için kullanılan genel sayı bloğu.'
            },
            'math_round': {
                en: '# Round\nRounds a number to the nearest integer, up, or down.',
                tr: '# Yuvarla\nBir sayıyı en yakın tam sayıya, yukarıya veya aşağıya yuvarlar.'
            },
            'math_modulo': {
                en: '# Remainder\nReturns the remainder after division.',
                tr: '# Kalan\nBölme işleminden kalanı verir.'
            },

            // --- Events ---
            'when_message_received': {
                en: `
# When Message Received
Triggers when a specific message is broadcasted.
`,
                tr: `
# Mesaj Alındığında
Belirli bir mesaj yayınlandığında çalışır.
`
            },
            'send_message': {
                en: `
# Send Message
Broadcasts a message to trigger other scripts.
`,
                tr: `
# Mesaj Gönder
Diğer komut dizilerini tetiklemek için bir mesaj yayınlar.
`
            },

            // --- Motor Blocks ---
            'motor_run_rotation': {
                en: `
# Motor Run (Rotations)
Runs the motor for a specific number of rotations.

### Parameters
- **Rotations**: Number of full turns (e.g., 1, 0.5).
- **Direction**: Clockwise or Counter-Clockwise.
`,
                tr: `
# Motoru Çevir (Tur)
Motoru belirli bir tur sayısı kadar döndürür.

### Parametreler
- **Tur**: Tam tur sayısı (örn. 1, 0.5).
- **Yön**: Saat yönü veya tersi.
`
            },
            'motor_run_seconds': {
                en: `
# Motor Run (Seconds)
Runs the motor for a specific amount of time.

### Parameters
- **Seconds**: Time in seconds.
`,
                tr: `
# Motoru Çalıştır (Saniye)
Motoru belirli bir süre çalıştırır.

### Parametreler
- **Saniye**: Süre (saniye cinsinden).
`
            },
            'motor_start': {
                en: `
# Start Motor
Starts the motor running continuously until stopped.
`,
                tr: `
# Motoru Başlat
Motoru durdurulana kadar sürekli çalıştırır.
`
            },
            'motor_stop': {
                en: `
# Stop Motor
Stops the specific motor immediately.
`,
                tr: `
# Motoru Durdur
Seçilen motoru anında durdurur.
`
            },
            'motor_speed': {
                en: `
# Set Motor Speed
Sets the speed (0-100%) for subsequent motor commands.
`,
                tr: `
# Motor Hızını Ayarla
Sonraki motor komutları için hızı (0-100%) ayarlar.
`
            },

            // --- Color Sensor ---
            'when_color_detected': {
                en: `
# When Color Detected
Triggers an event when the Color Sensor detects a specific color.

### Parameters
- **Color**: Select the color (Red, Green, Blue, etc.).
`,
                tr: `
# Renk Algılandığında
Renk Sensörü belirli bir rengi algıladığında çalışır.

### Parametreler
- **Renk**: Algılanacak rengi seçin (Kırmızı, Yeşil, Mavi vb.).
`
            },
            'detecting_color': {
                en: `
# Detecting Color?
Checks if the Color Sensor is currently seeing a specific color. (True/False)
`,
                tr: `
# Renk Algılanıyor mu?
Renk Sensörünün şu anda belirli bir rengi görüp görmediğini kontrol eder. (Doğru/Yanlış)
`
            },
            'color_value': {
                en: `
# Color Name
Returns the name of the color currently seen by the sensor.
`,
                tr: `
# Renk Değişkeni
Sensörün şu anda gördüğü rengin ismini verir.
`
            },
            'reflection_value': {
                en: `
# Reflection %
Returns the light reflection percentage (0-100). useful for line following.
`,
                tr: `
# Yansıma %
Işık yansıma yüzdesini (0-100) verir. Çizgi izlemek için kullanışlıdır.
`
            },

            // --- Controller ---
            'when_controller_button': {
                en: `
# When Button Pressed
Runs code when a specific button on the controller is pressed or released.
`,
                tr: `
# Düğmeye Basıldığında
Kumandadaki belirli bir düğmeye basıldığında veya bırakıldığında çalışır.
`
            },
            'controller_axis': {
                en: `
# Controller Axis
Returns the numeric value (-100 to 100) of a joystick axis.
`,
                tr: `
# Kumanda Ekseni
Joystick ekseninin sayısal değerini (-100 ile 100 arası) verir.
`
            },

            // --- LED ---
            'rgb_red_on': { en: '# Red LED On\nTurns on the Red LED.', tr: '# Kırmızı LED Aç\nKırmızı LED\'i yakar.' },
            'rgb_green_on': { en: '# Green LED On\nTurns on the Green LED.', tr: '# Yeşil LED Aç\nYeşil LED\'i yakar.' },
            'rgb_blue_on': { en: '# Blue LED On\nTurns on the Blue LED.', tr: '# Mavi LED Aç\nMavi LED\'i yakar.' },
            'rgb_red_off': { en: '# Red LED Off\nTurns off the Red LED.', tr: '# Kırmızı LED Kapat\nKırmızı LED\'i söndürür.' },

            // --- LED Getters ---
            'rgb_red_light_get': { en: '# Get Red Status\nReturns TRUE if Red LED is On.', tr: '# Kırmızı Durumu\nKırmızı LED Açık ise DOĞRU döndürür.' },
            'rgb_green_light_get': { en: '# Get Green Status\nReturns TRUE if Green LED is On.', tr: '# Yeşil Durumu\nYeşil LED Açık ise DOĞRU döndürür.' },
            'rgb_blue_light_get': { en: '# Get Blue Status\nReturns TRUE if Blue LED is On.', tr: '# Mavi Durumu\nMavi LED Açık ise DOĞRU döndürür.' },

            'rgb_red_get': { en: '# Get Red Value\nReturns current brightness (0-255).', tr: '# Kırmızı Değeri\nMevcut parlaklığı verir (0-255).' },
            'rgb_green_get': { en: '# Get Green Value\nReturns current brightness (0-255).', tr: '# Yeşil Değeri\nMevcut parlaklığı verir (0-255).' },
            'rgb_blue_get': { en: '# Get Blue Value\nReturns current brightness (0-255).', tr: '# Mavi Değeri\nMevcut parlaklığı verir (0-255).' },

            // --- Action Buttons ---
            'rgb_red_button_get': { en: '# Red Button Pressed?\nReturns true if the Red button is pressed.', tr: '# Kırmızı Düğmeye Basıldı mı?\nKırmızı düğmeye basılıyorsa Doğru değerini verir.' },
            'rgb_green_button_get': { en: '# Green Button Pressed?\nReturns true if the Green button is pressed.', tr: '# Yeşil Düğmeye Basıldı mı?\nYeşil düğmeye basılıyorsa Doğru değerini verir.' },
            'rgb_blue_button_get': { en: '# Blue Button Pressed?\nReturns true if the Blue button is pressed.', tr: '# Mavi Düğmeye Basıldı mı?\nMavi düğmeye basılıyorsa Doğru değerini verir.' },

            // --- Action Numbers (Set) ---
            'rgb_red_num': { en: '# Set Red LED\nSets the Red LED brightness (0-255).', tr: '# Kırmızı LED Ayarla\nKırmızı LED parlaklığını ayarlar (0-255).' },
            'rgb_green_num': { en: '# Set Green LED\nSets the Green LED brightness (0-255).', tr: '# Yeşil LED Ayarla\nYeşil LED parlaklığını ayarlar (0-255).' },
            'rgb_blue_num': { en: '# Set Blue LED\nSets the Blue LED brightness (0-255).', tr: '# Mavi LED Ayarla\nMavi LED parlaklığını ayarlar (0-255).' },

            // --- Math/Logic ---
            'math_number': { en: '# Number\nA numeric value.', tr: '# Sayı\nSayısal bir değer.' },
            'logic_compare': { en: '# Compare\nCompares two values (e.g. A > B).', tr: '# Karşılaştır\nİki değeri karşılaştırır (örn. A > B).' },
            'math_arithmetic': { en: '# Arithmetic\nPerforms math operations (+, -, *, /).', tr: '# Matematik\nMatematiksel işlem yapar (+, -, *, /).' },
            'math_random_int': { en: '# Pick Random\nPicks a random integer between two numbers.', tr: '# Rastgele Sayı\nİki sayı arasında rastgele bir tam sayı seçer.' },
            'logic_operation': { en: '# Logic Operation\nConnects two conditions (AND / OR).', tr: '# Mantıksal İşlem\nİki koşulu bağlar (VE / VEYA).' },
            'logic_negate': { en: '# Not\nInverts a condition (True becomes False).', tr: '# Değil\nBir koşulun tersini alır (Doğru ise Yanlış olur).' },

            // --- Spike Essential Hub ---
            'hub_led_color': {
                en: `
# Hub LED Color
Changes the color of the LED light on the Spike Essential Hub.

### Parameters
- **Color**: Choose from predefined colors (Black, Pink, Violet, Blue, Cyan, Green, Yellow, Orange, Red, White).

### Example
Set the hub light to Green when connected.
`,
                tr: `
# Hub LED Rengi
Spike Essential Hub üzerindeki LED ışığının rengini değiştirir.

### Parametreler
- **Renk**: Önceden tanımlı renklerden birini seçin (Siyah, Pembe, Mor, Mavi, Camgöbeği, Yeşil, Sarı, Turuncu, Kırmızı, Beyaz).

### Örnek
Bağlandığında hub ışığını Yeşil yapın.
`
            },
            'hub_orientation': {
                en: `
# Hub Orientation
Detects the orientation/position of the Spike Essential Hub.

### Return Values
- **Front, Back, Left, Right, Top, Bottom**: Current orientation.

### Example
When the hub is tilted left, play a sound.
`,
                tr: `
# Hub Yönelimi
Spike Essential Hub'ın yönünü/pozisyonunu algılar.

### Dönüş Değerleri
- **Ön, Arka, Sol, Sağ, Üst, Alt**: Mevcut yönelim.

### Örnek
Hub sola eğildiğinde ses çal.
`
            },

            // --- Hub Motor Blocks ---
            'hub_motor_run': {
                en: `
# Hub Motor Run
Runs a motor connected to a specific hub port.

### Parameters
- **Port**: A, B, C, D, E, or F
- **Direction**: Clockwise (CW) or Counter-Clockwise (CCW)
- **Value**: Number of rotations, degrees, or seconds.
- **Unit**: Rotations, Degrees, or Seconds.
`,
                tr: `
# Hub Motor Çalıştır
Belirli bir hub portuna bağlı motoru çalıştırır.

### Parametreler
- **Port**: A, B, C, D, E veya F
- **Yön**: Saat Yönü (CW) veya Saat Yönü Tersi (CCW)
- **Değer**: Tur sayısı, derece veya saniye.
- **Birim**: Tur, Derece veya Saniye.
`
            },
            'hub_motor_go_position': {
                en: `
# Hub Motor Go to Position
Rotates the motor to a specific absolute angle.

### Parameters
- **Port**: A-F
- **Path**: Shortest Path, CW, or CCW
- **Position**: Target angle (0-360 degrees)
`,
                tr: `
# Hub Motor Pozisyona Git
Motoru belirli bir mutlak açıya döndürür.

### Parametreler
- **Port**: A-F
- **Yol**: En Kısa Yol, SY veya SYT
- **Pozisyon**: Hedef açı (0-360 derece)
`
            },
            'hub_motor_start': {
                en: `
# Hub Motor Start
Starts the motor running continuously.

### Parameters
- **Port**: A-F
- **Direction**: CW or CCW
`,
                tr: `
# Hub Motor Başlat
Motoru sürekli çalışacak şekilde başlatır.

### Parametreler
- **Port**: A-F
- **Yön**: SY veya SYT
`
            },
            'hub_motor_stop': {
                en: `
# Hub Motor Stop
Stops the motor on the specified port.

### Parameters
- **Port**: A-F
`,
                tr: `
# Hub Motor Durdur
Belirtilen porttaki motoru durdurur.

### Parametreler
- **Port**: A-F
`
            },
            'hub_light_control': {
                en: `
# Hub Light Control
Turns a light connected to the hub on or off.

### Parameters
- **Port**: A-F
- **State**: Turn On or Turn Off
- **Brightness**: 0-100% (Only used when Turning On)
`,
                tr: `
# Hub Işık Kontrolü
Huba bağlı bir ışığı açar veya kapatır.

### Parametreler
- **Port**: A-F
- **Durum**: Aç veya Kapat
- **Parlaklık**: %0-100 (Sadece Açarken kullanılır)
`
            },
            'remote_led_color': {
                en: `
# Remote LED Color
Sets the color of the LED on the Handset Remote.

### Parameters
- **Color**: Select a color.
`,
                tr: `
# Kumanda LED Rengi
El Kumandasındaki LED'in rengini ayarlar.

### Parametreler
- **Renk**: Bir renk seçin.
`
            },

            // --- Color Light Matrix (3x3) ---
            'matrix_turn_on': {
                en: `
# Matrix Turn On
Displays a custom pattern on the 3x3 Color Light Matrix.

### Parameters
- **Port**: A or B
- **Pattern**: Click pixels to set colors.

### Colors Available
Black (off), Pink, Violet, Blue, Cyan, Teal, Green, Yellow, Orange, Red, White.
`,
                tr: `
# Matris Aç
3x3 Renkli Işık Matrisinde özel bir desen görüntüler.

### Parametreler
- **Port**: A veya B
- **Desen**: Renk ayarlamak için piksellere tıklayın.

### Mevcut Renkler
Siyah (kapalı), Pembe, Mor, Mavi, Camgöbeği, Turkuaz, Yeşil, Sarı, Turuncu, Kırmızı, Beyaz.
`
            },
            'matrix_turn_off': {
                en: `
# Matrix Turn Off
Turns off all pixels on the 3x3 Color Light Matrix.

### Parameters
- **Port**: A or B
`,
                tr: `
# Matris Kapat
3x3 Renkli Işık Matrisindeki tüm pikselleri kapatır.

### Parametreler
- **Port**: A veya B
`
            },
            'matrix_set_brightness': {
                en: `
# Set Pixel Brightness
Sets the brightness level for all pixels on the matrix.

### Parameters
- **Port**: A or B
- **Brightness**: 0-100%

### Note
This affects all pixels. Use the pattern block to set which pixels are lit.
`,
                tr: `
# Piksel Parlaklığını Ayarla
Matristeki tüm piksellerin parlaklık seviyesini ayarlar.

### Parametreler
- **Port**: A veya B
- **Parlaklık**: 0-100%

### Not
Bu tüm pikselleri etkiler. Hangi piksellerin yanacağını desen bloğuyla ayarlayın.
`
            },
            'matrix_set_pixel_at': {
                en: `
# Set Pixel At Position
Sets a specific pixel's color and brightness on the 3x3 matrix.

### Parameters
- **Port**: A or B
- **X**: Column (1-3)
- **Y**: Row (1-3)
- **Color**: Pink, Red, Blue, etc.
- **Brightness**: 0-100%

### Coordinate System
\`\`\`
(1,1) (2,1) (3,1)
(1,2) (2,2) (3,2)
(1,3) (2,3) (3,3)
\`\`\`
`,
                tr: `
# Belirli Pikseli Ayarla
3x3 matristeki belirli bir pikselin rengini ve parlaklığını ayarlar.

### Parametreler
- **Port**: A veya B
- **X**: Sütun (1-3)
- **Y**: Satır (1-3)
- **Renk**: Pembe, Kırmızı, Mavi vb.
- **Parlaklık**: 0-100%

### Koordinat Sistemi
\`\`\`
(1,1) (2,1) (3,1)
(1,2) (2,2) (3,2)
(1,3) (2,3) (3,3)
\`\`\`
`
            },
            'matrix_rotate_pattern': {
                en: `
# Rotate Pattern
Rotates the current pattern on the matrix 90 degrees.

### Parameters
- **Port**: A or B
- **Direction**: ↷ Clockwise or ↶ Counter-Clockwise

### Example
Create an animation by rotating a pattern in a loop.
`,
                tr: `
# Deseni Döndür
Matristeki mevcut deseni 90 derece döndürür.

### Parametreler
- **Port**: A veya B
- **Yön**: ↷ Saat yönünde veya ↶ Saat yönünün tersi

### Örnek
Bir döngüde deseni döndürerek animasyon oluşturun.
`
            },

            // --- Force Sensor ---
            'force_sensor_is_pressed': {
                en: `
# Force Sensor Pressed?
Checks if the Force Sensor is pressed, hard-pressed, or released.

### Parameters
- **Port**: A or B
- **State**: 
  - **Pressed**: Lightly touched
  - **Hard-Pressed**: Firmly pressed
  - **Released**: Not touched

### Returns
True or False
`,
                tr: `
# Kuvvet Sensörü Basılı mı?
Kuvvet Sensörünün basılı, sert basılı veya bırakılmış olup olmadığını kontrol eder.

### Parametreler
- **Port**: A veya B
- **Durum**: 
  - **Basılı**: Hafifçe dokunulmuş
  - **Sert Basılı**: Sıkıca basılmış
  - **Bırakılmış**: Dokunulmamış

### Döndürür
Doğru veya Yanlış
`
            },
            'force_sensor_pressure': {
                en: `
# Force Sensor Pressure
Returns the current pressure value from the Force Sensor.

### Parameters
- **Port**: A or B
- **Unit**: 
  - **Newton**: Force in Newtons (0-10N)
  - **%**: Percentage (0-100%)

### Example
Move motor faster when more pressure is applied.
`,
                tr: `
# Kuvvet Sensörü Basıncı
Kuvvet Sensöründen mevcut basınç değerini döndürür.

### Parametreler
- **Port**: A veya B
- **Birim**: 
  - **Newton**: Newton cinsinden kuvvet (0-10N)
  - **%**: Yüzde (0-100%)

### Örnek
Daha fazla basınç uygulandığında motoru daha hızlı hareket ettirin.
`
            },

            // --- Additional Motor Blocks ---
            'motor_run_to_angle': {
                en: `
# Motor Run to Angle
Rotates the motor to a specific angle position.

### Parameters
- **Angle**: Target angle in degrees (0-360).
- **Direction**: Shortest path, Clockwise, or Counter-Clockwise.
`,
                tr: `
# Motoru Açıya Döndür
Motoru belirli bir açı konumuna döndürür.

### Parametreler
- **Açı**: Hedef açı (derece cinsinden, 0-360).
- **Yön**: En kısa yol, Saat yönü veya Saat yönünün tersi.
`
            },
            'motor_go_to_position': {
                en: `
# Motor Go to Position
Moves the motor to an absolute position.

### Parameters
- **Position**: Target position in degrees.
`,
                tr: `
# Motoru Pozisyona Götür
Motoru mutlak bir pozisyona hareket ettirir.

### Parametreler
- **Pozisyon**: Hedef pozisyon (derece cinsinden).
`
            },

            // --- Lever/Encoder Blocks ---
            'when_lever_position': {
                en: `
# When Lever Position
Triggers when the motor/lever reaches a specific position.

### Parameters
- **Position**: Up, Middle, or Down.
`,
                tr: `
# Kol Pozisyonunda
Motor/kol belirli bir pozisyona ulaştığında tetiklenir.

### Parametreler
- **Pozisyon**: Yukarı, Orta veya Aşağı.
`
            },
            'lever_position': {
                en: `
# Lever Position
Returns the current lever position.

### Returns
- **Up**: Lever is pushed up
- **Middle**: Lever is centered
- **Down**: Lever is pushed down
`,
                tr: `
# Kol Pozisyonu
Mevcut kol pozisyonunu döndürür.

### Döndürür
- **Yukarı**: Kol yukarı itilmiş
- **Orta**: Kol merkezde
- **Aşağı**: Kol aşağı itilmiş
`
            },
            'lever_angle': {
                en: `
# Lever Angle
Returns the current rotation angle of the lever/motor.

### Returns
Angle in degrees (-180 to 180).
`,
                tr: `
# Kol Açısı
Kol/motorun mevcut dönüş açısını döndürür.

### Döndürür
Derece cinsinden açı (-180 ile 180 arası).
`
            },

            // --- Color Sensor Extended ---
            'reflection_compare': {
                en: `
# Reflection Compare
Compares the reflection value with a threshold.

### Parameters
- **Comparison**: Greater than, Less than, Equal to.
- **Value**: Threshold percentage (0-100).

### Example
If reflection < 30%, we are on a dark line.
`,
                tr: `
# Yansıma Karşılaştır
Yansıma değerini bir eşik değeriyle karşılaştırır.

### Parametreler
- **Karşılaştırma**: Büyüktür, Küçüktür, Eşittir.
- **Değer**: Eşik yüzdesi (0-100).

### Örnek
Yansıma < %30 ise, koyu bir çizgi üzerindeyiz.
`
            },

            // --- Controller Extended ---
            'controller_button': {
                en: `
# Controller Button
Checks if a specific button on the game controller is pressed.

### Parameters
- **Button**: A, B, X, Y, L1, R1, etc.

### Returns
True if pressed, False otherwise.
`,
                tr: `
# Kumanda Düğmesi
Oyun kumandasındaki belirli bir düğmenin basılı olup olmadığını kontrol eder.

### Parametreler
- **Düğme**: A, B, X, Y, L1, R1, vb.

### Döndürür
Basılıysa Doğru, değilse Yanlış.
`
            }
        };

        function showBlockHelp() {
            if (!selectedBlock) return;

            const sidebar = document.getElementById('helpSidebar');
            const content = document.getElementById('helpContent');
            const title = document.getElementById('helpTitle');

            sidebar.classList.add('open');

            const blockType = selectedBlock.type;
            const docData = BLOCK_DOCS[blockType];

            // Set Title
            title.textContent = (currentLanguage === 'tr' ? 'Blok Yardımı: ' : 'Block Help: ') + blockType;

            // --- Block Visual Creation ---
            let blockVisualHtml = '';
            try {
                const svgRoot = selectedBlock.getSvgRoot();
                if (svgRoot) {
                    const clone = svgRoot.cloneNode(true);

                    // Remove connected blocks (nested .blocklyDraggable elements)
                    clone.querySelectorAll('g.blocklyDraggable').forEach(el => el.remove());

                    // Reset positioning for the preview
                    clone.setAttribute('transform', 'translate(10, 10)');
                    clone.classList.remove('blocklySelected');
                    clone.removeAttribute('data-id');

                    // Cleanup any nested selected classes
                    const selectedChildren = clone.querySelectorAll('.blocklySelected');
                    selectedChildren.forEach(child => child.classList.remove('blocklySelected'));

                    // Calculate dimensions from the block's path (first path is usually the block shape)
                    const blockPath = clone.querySelector('.blocklyPath');
                    let width = 200, height = 60; // Default fallback
                    if (blockPath) {
                        // Try to get approximate dimensions from the block itself
                        const hw = selectedBlock.getHeightWidth();
                        // Use block's own height only (not including connected blocks)
                        // Blockly doesn't have a direct method, but typically the block itself is smaller
                        width = hw.width;
                        // Height estimation: use a reasonable fraction or fixed height for single block
                        height = Math.min(hw.height, 80); // Most single blocks are under 80px tall
                    }

                    // Create container
                    blockVisualHtml = `
                        <div style="display: flex; justify-content: center; margin-bottom: 20px; padding: 20px; background: #fff; border: 1px solid #eee; border-radius: 8px; box-shadow: inset 0 0 10px rgba(0,0,0,0.02);">
                            <svg xmlns="http://www.w3.org/2000/svg" width="${width + 20}" height="${height + 20}" style="display: block; overflow: visible;">
                                ${clone.outerHTML}
                            </svg>
                        </div>
                    `;
                }
            } catch (e) {
                console.warn('Block visual creation failed:', e);
            }

            if (docData) {
                const lang = currentLanguage === 'tr' ? 'tr' : 'en';
                const doc = docData[lang] || docData['en'] || docData;
                const text = typeof doc === 'string' ? doc : JSON.stringify(doc);
                content.innerHTML = blockVisualHtml + parseMarkdown(text.trim());
            } else {
                const msg = currentLanguage === 'tr'
                    ? '<div style="color: #666; font-style: italic; padding: 20px; text-align: center;">Bu blok için henüz yardım dokümanı eklenmemiştir.<br><br>🚧</div>'
                    : '<div style="color: #666; font-style: italic; padding: 20px; text-align: center;">Help documentation has not been added for this block yet.<br><br>🚧</div>';
                content.innerHTML = blockVisualHtml + msg;
            }
        }

        function closeBlockHelp() {
            document.getElementById('helpSidebar').classList.remove('open');
        }

        function parseMarkdown(md) {
            // Simple Markdown Parser
            let html = md
                .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                .replace(/\*\*(.*)\*\*/gim, '<b>$1</b>')
                .replace(/`(.*)`/gim, '<code>$1</code>')
                .replace(/^\- (.*$)/gim, '<li>$1</li>');

            // Wrap lists
            html = html.replace(/(<li>.*<\/li>)/gim, '<ul>$1</ul>').replace(/<\/ul>\s*<ul>/g, '');

            // Newlines to br (except around tags)
            html = html.replace(/\n/g, '<br>');

            return html;
        }

        // Close help sidebar when clicking outside
        function handleGlobalClick(e) {
            const sidebar = document.getElementById('helpSidebar');
            const helpBtn = document.getElementById('helpBlockBtn');

            // Should exist and be open
            if (sidebar && sidebar.classList.contains('open')) {
                // Check if click is outside sidebar and outside the help button
                // SVG elementlerinde .contains bazen sorun olabilir, bu yüzden closest kontrolü de ekleyelim
                const target = e.target;
                const clickedInsideSidebar = sidebar.contains(target) || !!target.closest('#helpSidebar');
                const clickedOnButton = (helpBtn && (helpBtn.contains(target) || !!target.closest('#helpBlockBtn')));

                if (!clickedInsideSidebar && !clickedOnButton) {
                    closeBlockHelp();
                }
            }
        }

        // Use capture phase on window for maximum priority
        window.addEventListener('mousedown', handleGlobalClick, true);
        window.addEventListener('pointerdown', handleGlobalClick, true);
        window.addEventListener('touchstart', handleGlobalClick, true);

        function selectDevice(deviceId) {
            const icon = document.querySelector(`[data-device-id="${deviceId}"]`);

            // Toggle seçimi
            if (selectedDeviceId === deviceId) {
                // Aynı cihaza basıldı - seçimi kaldır
                if (icon) icon.classList.remove('selected');
                selectedDeviceId = null;
                document.getElementById('disconnectOverlay').classList.remove('show');
                console.log('Seçim iptal edildi');
            } else {
                // Farklı cihaz seçildi
                document.querySelectorAll('.device-icon').forEach(i => {
                    i.classList.remove('selected');
                });

                if (icon) {
                    icon.classList.add('selected');
                    selectedDeviceId = deviceId;
                    document.getElementById('disconnectOverlay').classList.add('show');
                    console.log('Seçili cihaz:', deviceId);
                }
            }
        }

        function disconnectSelectedDevice() {
            if (selectedDeviceId) {
                removeDevice(selectedDeviceId);
            }
        }

        function removeDevice(deviceId, event) {
            if (event) event.stopPropagation();

            const device = connectedDevices.find(d => d.id === deviceId);
            if (device) {
                // Hide the corresponding display panel based on device type
                if (device.type === 'motor' || device.type === 'double_motor') {
                    hideMotorDisplay();
                } else if (device.type === 'color_sensor') {
                    hideColorSensorDisplay();
                } else if (device.type === 'spike_prime') {
                    hideSpikePrimeDisplay();
                } else if (device.type === 'spike_essential' || device.type === 'technic_medium_hub' || device.type === 'city_hub' || device.type === 'boost_move_hub') {
                    hideSpikeEssentialDisplay(deviceId);
                }

                // Disconnect GATT if connected
                if (device.device && device.device.gatt.connected) {
                    device.device.gatt.disconnect();
                }
            }

            connectedDevices = connectedDevices.filter(d => d.id !== deviceId);

            const icon = document.querySelector(`[data-device-id="${deviceId}"]`);
            if (icon) {
                icon.remove();
            }

            if (selectedDeviceId === deviceId) {
                selectedDeviceId = null;
                document.getElementById('disconnectOverlay').classList.remove('show');

                if (connectedDevices.length > 0) {
                    selectDevice(connectedDevices[0].id);
                }
            }

            // Tabloyu güncelle
            updateDevicesTable();

            // console.log('Cihaz kaldırıldı:', deviceId);
        }

        function getSelectedDevice() {
            return connectedDevices.find(d => d.id === selectedDeviceId);
        }

        function getDeviceIcon(deviceId) {
            const device = connectedDevices.find(d => d.id === deviceId);
            if (!device) return { html: '', color: '#888' };

            const color = device.color;
            const deviceType = device.type;
            let imgSrc = '';

            // Cihaz tipine göre doğru ikonu belirle (sidebar'daki ile aynı)
            switch (deviceType) {
                case 'controller':
                    imgSrc = 'img/controller.png';
                    break;
                case 'color_sensor':
                    imgSrc = 'img/color-sensor.png';
                    break;
                case 'spike_essential':
                    imgSrc = 'img/spike_essential_icon.png';
                    break;
                case 'spike_prime':
                    imgSrc = 'img/spike_prime_icon.png';
                    break;
                case 'technic_medium_hub':
                    imgSrc = 'img/technic-hub.png';
                    break;
                case 'city_hub':
                    imgSrc = 'img/city-hub.png';
                    break;
                case 'boost_move_hub':
                    imgSrc = 'img/boost-hub.png';
                    break;
                case 'motor':
                    imgSrc = 'img/single-motor.png';
                    break;
                case 'double_motor':
                    imgSrc = 'img/double-motor.png';
                    break;
                default:
                    // Bilinmeyen cihazlar için basit bir daire ikonu
                    imgSrc = '';
                    break;
            }

            if (imgSrc) {
                return {
                    html: `<img src="${imgSrc}" style="width: 16px; height: 16px; object-fit: contain;">`,
                    color: color
                };
            } else {
                // Fallback: Renkli daire
                return {
                    html: `<svg width="16" height="16"><circle cx="8" cy="8" r="7" fill="${color}" stroke="white" stroke-width="1"/></svg>`,
                    color: color
                };
            }
        }

        const OPTIONAL_SERVICES = [
            'generic_access', 'generic_attribute', 'device_information', 'battery_service',
            '00002a05-0000-1000-8000-00805f9b34fb', '00002b2a-0000-1000-8000-00805f9b34fb',
            '0000fd02-0000-1000-8000-00805f9b34fb', '0000fd02-0001-1000-8000-00805f9b34fb', '0000fd02-0002-1000-8000-00805f9b34fb',
            0x1800, 0x1801, 0x180a, 0x180f, 0x2a05, 0x2b2a, 0xfd02,
            0xffe0, 0xffe1, 0xffe2, 0xffe3, 0xffe4, 0xffe5, 0xffe6, 0xffe7, 0xffe8, 0xffe9,
            0x1623, 0x1624, 0x1625, 0x1626,
            '00001623-1212-efde-1623-785feabcd123', '00001624-1212-efde-1623-785feabcd123', '00001625-1212-efde-1623-785feabcd123',
            '0000ffe0-0000-1000-8000-00805f9b34fb', '0000ffe1-0000-1000-8000-00805f9b34fb'
        ];

        function openSpecificDeviceModal() {
            document.getElementById('specificDeviceModal').classList.add('show');
        }

        function closeSpecificDeviceModal() {
            document.getElementById('specificDeviceModal').classList.remove('show');
        }

        function showNotSupportedAlert(deviceName) {
            const message = currentLanguage === 'tr'
                ? `${deviceName} henüz desteklenmiyor. Yakında eklenecek!`
                : `${deviceName} is not yet supported. Coming soon!`;

            showImportErrorModal(
                currentLanguage === 'tr' ? 'Henüz Desteklenmiyor' : 'Not Yet Supported',
                message
            );
        }

        async function scanSpecificDevice(type) {
            closeSpecificDeviceModal();
            let options = { filters: [] };

            // LEGO ortak BLE tanımlayıcıları
            // Company ID: 0x0397 (919)
            // Service UUID: 0xFD02 (64770)
            // Device Type Byte: Motor=0x00, Color Sensor=0x02, Controller=0x03

            if (type === 'controller') {
                // Controller: Device Type Byte = 0x03
                options.filters.push({ services: [0xFD02] });
                options.filters.push({
                    manufacturerData: [{
                        companyIdentifier: 0x0397,
                        dataPrefix: new Uint8Array([0x03])
                    }]
                });
                options.inputType = 'controller';
            } else if (type === 'single_motor') {
                // Single Motor: Device Type Byte = 0x00
                options.filters.push({ services: [0xFD02] });
                options.filters.push({
                    manufacturerData: [{
                        companyIdentifier: 0x0397,
                        dataPrefix: new Uint8Array([0x00])
                    }]
                });
                options.inputType = 'motor';
            } else if (type === 'double_motor') {
                // Double Motor: Device Type Byte = 0x01
                options.filters.push({ services: [0xFD02] });
                options.filters.push({
                    manufacturerData: [{
                        companyIdentifier: 0x0397,
                        dataPrefix: new Uint8Array([0x01])
                    }]
                });
                options.inputType = 'double_motor';
            } else if (type === 'color_sensor') {
                // Color Sensor: Device Type Byte = 0x02
                options.filters.push({ services: [0xFD02] });
                options.filters.push({
                    manufacturerData: [{
                        companyIdentifier: 0x0397,
                        dataPrefix: new Uint8Array([0x02])
                    }]
                });
                options.inputType = 'color_sensor';
            } else if (type === 'spike_essential') {
                // Spike Essential Hub: Device Type Byte = 0x83
                // Service UUID: 00001623-1212-efde-1623-785feabcd123
                options.filters.push({ services: ['00001623-1212-efde-1623-785feabcd123'] });
                options.filters.push({
                    manufacturerData: [{
                        companyIdentifier: 0x0397,
                        dataPrefix: new Uint8Array([0x83])
                    }]
                });
                options.inputType = 'spike_essential';
            } else if (type === 'spike_prime') {
                // Spike Prime Hub: Device Type Byte = 0x01
                // Hem LWP3 (1623) hem de yeni FD02 servislerini kabul et
                options.filters.push({ services: ['00001623-1212-efde-1623-785feabcd123'] });
                options.filters.push({ services: [0xFD02] });
                options.filters.push({
                    manufacturerData: [{
                        companyIdentifier: 0x0397,
                        dataPrefix: new Uint8Array([0x01])
                    }]
                });
                // İsme göre de filtrele (bilgehan01 gibi)
                options.filters.push({ namePrefix: 'bilgehan' });
                options.inputType = 'spike_prime';
            } else if (type === 'technic_medium_hub') {
                // Technic Medium Hub: Device Type Byte = 0x80
                // Service UUID: 00001623-1212-efde-1623-785feabcd123 (LWP3)
                options.filters.push({ services: ['00001623-1212-efde-1623-785feabcd123'] });
                options.filters.push({
                    manufacturerData: [{
                        companyIdentifier: 0x0397,
                        dataPrefix: new Uint8Array([0x80])
                    }]
                });
                options.inputType = 'technic_medium_hub';
            } else if (type === 'city_hub') {
                // City Hub: Device Type Byte = 0x41
                // Service UUID: 00001623-1212-efde-1623-785feabcd123 (LWP3)
                options.filters.push({ services: ['00001623-1212-efde-1623-785feabcd123'] });
                options.filters.push({
                    manufacturerData: [{
                        companyIdentifier: 0x0397,
                        dataPrefix: new Uint8Array([0x41])
                    }]
                });
                options.inputType = 'city_hub';
            } else if (type === 'boost_move_hub') {
                // Boost Move Hub: Device Type Byte = 0x40
                // Service UUID: 00001623-1212-efde-1623-785feabcd123 (LWP3)
                options.filters.push({ services: ['00001623-1212-efde-1623-785feabcd123'] });
                options.filters.push({
                    manufacturerData: [{
                        companyIdentifier: 0x0397,
                        dataPrefix: new Uint8Array([0x40])
                    }]
                });
                options.inputType = 'boost_move_hub';
            } else if (type === 'remote_controller') {
                // Remote Controller (88010): Device Type Byte = 0x42
                // Service UUID: 00001623-1212-efde-1623-785feabcd123 (LWP3)
                options.filters.push({ services: ['00001623-1212-efde-1623-785feabcd123'] });
                options.filters.push({
                    manufacturerData: [{
                        companyIdentifier: 0x0397,
                        dataPrefix: new Uint8Array([0x42])
                    }]
                });
                options.inputType = 'remote_controller';
            }
            await scanDeviceInternal(options);
        }

        async function scanAndConnect() {
            await scanDeviceInternal({ acceptAllDevices: true });
        }

        async function scanDeviceInternal(customOptions) {
            // Bluetooth kontrolü
            if (!navigator.bluetooth) {
                alert('❌ Tarayıcınız Web Bluetooth desteklemiyor!\n\nChrome, Edge veya Opera kullanın.');
                return;
            }

            try {
                const scanStatus = document.getElementById('scanStatus');
                const t = TRANSLATIONS[currentLanguage];
                scanStatus.style.display = 'block';
                scanStatus.textContent = t.device_list_opening;

                // Motor/cihaz tarama
                const forcedType = customOptions.inputType;
                const deviceRequestOptions = { ...customOptions };
                delete deviceRequestOptions.inputType;

                const requestOptions = {
                    optionalServices: OPTIONAL_SERVICES,
                    ...deviceRequestOptions
                };
                bluetoothDevice = await navigator.bluetooth.requestDevice(requestOptions);

                // Determine friendly name based on forcedType if device has no name
                let friendlyName = bluetoothDevice.name;
                if (!friendlyName && forcedType) {
                    if (forcedType === 'motor') friendlyName = 'Single Motor';
                    else if (forcedType === 'double_motor') friendlyName = 'Double Motor';
                    else if (forcedType === 'color_sensor') friendlyName = 'Color Sensor';
                    else if (forcedType === 'controller') friendlyName = 'Controller';
                    else if (forcedType === 'spike_essential') friendlyName = 'Spike Essential Hub';
                    else if (forcedType === 'spike_prime') friendlyName = 'Spike Prime Hub';
                    else if (forcedType === 'technic_medium_hub') friendlyName = 'Technic Medium Hub';
                    else if (forcedType === 'city_hub') friendlyName = 'City Hub';
                    else if (forcedType === 'boost_move_hub') friendlyName = 'Boost Move Hub';
                    else if (forcedType === 'remote_controller') friendlyName = 'Remote Controller';
                    else friendlyName = t.unknown_device;
                } else if (!friendlyName) {
                    friendlyName = t.unknown_device;
                }

                scanStatus.textContent = `${t.connecting_to} ${friendlyName}...`;
                // console.log('Seçilen cihaz:', bluetoothDevice.name || friendlyName, bluetoothDevice.id);

                // GATT sunucusuna bağlan
                bluetoothServer = await bluetoothDevice.gatt.connect();

                // Rengi önceden belirle, böylece hem sidebar hem panel aynı rengi kullanır
                const assignedColor = getRandomColor();

                scanStatus.textContent = `${t.connected_to} ${friendlyName}`;

                // console.log('GATT server connected');
                // console.log('Server:', bluetoothServer);
                // console.log('Server.connected:', bluetoothServer.connected);

                // Servisleri al ve logla
                try {
                    // console.log('→ getPrimaryServices() çağrılıyor...');

                    // Önce LWP3 servisine direkt bağlanmayı dene
                    let allServices = [];
                    try {
                        const lwp3 = await bluetoothServer.getPrimaryService('00001623-1212-efde-1623-785feabcd123');
                        // console.log('✅ LWP3 servisi (1623) direkt olarak bulundu!');
                        allServices = [lwp3];
                    } catch (e) {
                        // console.log('ℹ️ LWP3 servisi direkt bulunamadı, tüm servisler alınıyor...');
                        allServices = await bluetoothServer.getPrimaryServices();
                    }
                    // console.log(`✓ ${allServices.length} servis bulundu!`);

                    // SPIKE Prime/Essential için doğru servisi seç
                    // LWP3 UUID: 00001623-1212-efde-1623-785feabcd123
                    // Motor/Sensor UUID: 0000fd02-0000-1000-8000-00805f9b34fb
                    const deviceType = forcedType || detectDeviceType(bluetoothDevice.name || '');
                    const isLWP3Hub = ['spike_essential', 'spike_prime', 'technic_medium_hub', 'city_hub', 'boost_move_hub', 'remote_controller'].includes(deviceType);

                    let services = allServices;

                    // Tüm servisleri logla
                    // console.log('📋 Bulunan tüm servisler:');
                    // allServices.forEach(s => console.log(`   - ${s.uuid}`));

                    if (isLWP3Hub) {
                        // Önce LWP3 (1623) servisini ara
                        const lwp3Service = allServices.find(s => s.uuid.includes('1623'));
                        if (lwp3Service) {
                            // console.log('🎯 LWP3 servisi bulundu: 00001623-...');
                            services = [lwp3Service];
                        } else {
                            // LWP3 yoksa FD02'yi kullan ama uyar
                            const fd02Service = allServices.find(s => s.uuid.includes('fd02'));
                            if (fd02Service) {
                                // console.warn('⚠️ LWP3 (1623) servisi YOK! FD02 servisi kullanılacak.');
                                // console.warn('⚠️ Bu yeni firmware olabilir - farklı protokol gerekebilir.');
                                services = [fd02Service];
                            }
                        }
                    }

                    for (const service of services) {
                        // console.log(`  Servis UUID: ${service.uuid}`);
                        try {
                            const chars = await service.getCharacteristics();
                            // console.log(`    ${chars.length} karakteristik bulundu`);

                            let writeChar = null;
                            let notifyChar = null;

                            for (const char of chars) {
                                // console.log(`      - ${char.uuid} (write: ${char.properties.write}, writeNoResp: ${char.properties.writeWithoutResponse}, notify: ${char.properties.notify})`);

                                // Write karakteristiği sakla
                                if (char.properties.writeWithoutResponse) {
                                    writeChar = char;
                                }

                                // Notify karakteristiği tespit et
                                // Her cihaz kendi notify char'ını kullanabilsin
                                if (char.properties.notify) {
                                    notifyChar = char;
                                }
                            }

                            // Eğer controller ise, önce write ile başlat, sonra notify dinle
                            // Eğer controller ise, sadece notify dinle (write YOK)
                            // Sadece "Controller" tipindeyse display'i aç (Single Motor vs açmasın)
                            const deviceType = forcedType || detectDeviceType(bluetoothDevice.name || '');
                            if (notifyChar && deviceType === 'controller') {
                                // console.log('      🎮 Controller tespit edildi!');
                                // console.log('      DEBUG: writeChar var mı?', !!writeChar);
                                // console.log('      DEBUG: writeChar UUID:', writeChar ? writeChar.uuid : 'YOK');

                                // Characteristic'leri kaydet
                                connectedCharacteristics[notifyChar.uuid] = notifyChar;
                                if (writeChar) {
                                    connectedCharacteristics[writeChar.uuid] = writeChar;

                                    // DENEME: Controller'a "wake up" ping gönder
                                    try {
                                        console.log('      📤 Controller wake-up ping gönderiliyor...');
                                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x00]));
                                        console.log('      ✓ Ping gönderildi!');
                                        await new Promise(resolve => setTimeout(resolve, 100));
                                    } catch (e) {
                                        console.log('      ⚠️ Ping hatası:', e.message);
                                    }
                                }

                                // Monitoring başlat (periyodik ping ile)
                                console.log('      🎮 Monitoring başlatılıyor...');
                                await startControllerMonitoring(bluetoothDevice, notifyChar, writeChar, assignedColor);
                            }

                            // Motor için notification monitoring başlat
                            // Motor açısını Bluetooth'tan gerçek zamanlı almak için
                            if (notifyChar && deviceType === 'motor' && !motorMonitoringActive) {
                                console.log('      ⚙️ Motor tespit edildi!');
                                console.log('      DEBUG: notifyChar UUID:', notifyChar.uuid);

                                // Characteristic'leri kaydet
                                connectedCharacteristics[notifyChar.uuid] = notifyChar;
                                if (writeChar) {
                                    connectedCharacteristics[writeChar.uuid] = writeChar;
                                }

                                // Motor açı monitoring başlat
                                console.log('      ⚙️ Motor açı monitoring başlatılıyor...');

                                // Motor'a sensor stream başlatma komutu gönder (PCAP'tan: 0x28 0x32 0x00)


                                if (writeChar) {
                                    try {
                                        console.log('      📤 Motor sensor stream başlatılıyor...');

                                        // Adım 1: Reset/Init
                                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x00]));
                                        await new Promise(resolve => setTimeout(resolve, 100));

                                        // Adım 2: Handshake
                                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x1a]));
                                        await new Promise(resolve => setTimeout(resolve, 100));

                                        // Adım 3: Sensor data stream başlat
                                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x28, 0x32, 0x00]));
                                        console.log('      ✓ Sensor stream başlatıldı!');

                                    } catch (e) {
                                        console.log('      ⚠️ Motor başlatma hatası:', e.message);
                                    }
                                }

                                // Monitoring başlat
                                await startMotorAngleMonitoring(bluetoothDevice, notifyChar, bluetoothDevice.id, assignedColor);
                            }

                            // Double Motor için notification monitoring başlat
                            // PCAP analizi: dmotor_init__1_.pcap
                            if (notifyChar && deviceType === 'double_motor' && !doubleMotorMonitoringActive) {
                                console.log('      ⚙️⚙️ Double Motor tespit edildi!');
                                console.log('      DEBUG: notifyChar UUID:', notifyChar.uuid);

                                // Characteristic'leri kaydet
                                connectedCharacteristics[notifyChar.uuid] = notifyChar;
                                if (writeChar) {
                                    connectedCharacteristics[writeChar.uuid] = writeChar;
                                }

                                // Double Motor'a sensor stream başlatma komutu gönder
                                // PCAP'tan: TX op=0x12 h=0x000f (2B): 0100 (notification enable)
                                // ve TX op=0x52 h=0x000c (1B): 00 (sensor stream start)
                                if (writeChar) {
                                    try {
                                        console.log('      📤 Double Motor sensor stream başlatılıyor...');

                                        // Adım 1: Reset/Init
                                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x00]));
                                        await new Promise(resolve => setTimeout(resolve, 100));

                                        // Adım 2: Handshake (PCAP'tan: 0x1a)
                                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x1a]));
                                        await new Promise(resolve => setTimeout(resolve, 100));

                                        // Adım 3: Sensor data stream başlat (PCAP'tan: 0x28 0x32 0x00)
                                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x28, 0x32, 0x00]));
                                        console.log('      ✓ Double Motor sensor stream başlatıldı!');

                                    } catch (e) {
                                        console.log('      ⚠️ Double Motor başlatma hatası:', e.message);
                                    }
                                }

                                // Monitoring başlat
                                await startDoubleMotorMonitoring(bluetoothDevice, notifyChar, bluetoothDevice.id, assignedColor);
                            }

                            // Color Sensor için notification monitoring başlat
                            if (notifyChar && deviceType === 'color_sensor') {
                                console.log('      🎨 Color Sensor tespit edildi!');
                                console.log('      DEBUG: notifyChar UUID:', notifyChar.uuid);

                                // Characteristic'leri kaydet
                                connectedCharacteristics[notifyChar.uuid] = notifyChar;
                                if (writeChar) {
                                    connectedCharacteristics[writeChar.uuid] = writeChar;
                                }

                                // Color Sensor'a sensor stream başlatma komutu gönder
                                if (writeChar) {
                                    try {
                                        console.log('      📤 Color Sensor stream başlatılıyor...');

                                        // Adım 1: Reset/Init
                                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x00]));
                                        await new Promise(resolve => setTimeout(resolve, 100));

                                        // Adım 2: Handshake
                                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x1a]));
                                        await new Promise(resolve => setTimeout(resolve, 100));

                                        // Adım 3: Sensor data stream başlat (PCAP'tan analiz edilebilir)
                                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x28, 0x32, 0x00]));
                                        console.log('      ✓ Color Sensor stream başlatıldı!');

                                    } catch (e) {
                                        console.log('      ⚠️ Color Sensor başlatma hatası:', e.message);
                                    }
                                }

                                // Monitoring başlat
                                await startColorSensorMonitoring(bluetoothDevice, notifyChar, bluetoothDevice.id, assignedColor);
                            }

                            // LWP3 Hub (Spike Essential, Spike Prime, Technic Medium, City, Boost Move) için monitoring başlat
                            if (notifyChar && (deviceType === 'spike_essential' || deviceType === 'spike_prime' || deviceType === 'technic_medium_hub' || deviceType === 'city_hub' || deviceType === 'boost_move_hub')) {
                                const hubName = deviceType === 'spike_prime' ? 'Spike Prime' :
                                    deviceType === 'technic_medium_hub' ? 'Technic Medium' :
                                        deviceType === 'city_hub' ? 'City' :
                                            deviceType === 'boost_move_hub' ? 'Boost Move' : 'Spike Essential';
                                // console.log(`      🔌 ${hubName} Hub tespit edildi!`);
                                // console.log('      DEBUG: notifyChar UUID:', notifyChar.uuid);
                                // console.log('      DEBUG: writeChar UUID:', writeChar ? writeChar.uuid : 'YOK');

                                // Characteristic'leri kaydet
                                connectedCharacteristics[notifyChar.uuid] = notifyChar;
                                if (writeChar) {
                                    connectedCharacteristics[writeChar.uuid] = writeChar;
                                }

                                // Monitoring başlat
                                await startSpikeHubMonitoring(bluetoothDevice, notifyChar, writeChar, assignedColor, friendlyName, deviceType);
                            }

                        } catch (e) {
                            console.log(`    Karakteristik hatası: ${e.message}`);
                        }
                    }

                    // connectedCharacteristics = {}; // KALDIRDIM - characteristic'leri silme!
                } catch (err) {
                    console.error('❌ Servis hatası:', err);
                    console.error('   Bu motor cihazının servisleri Web Bluetooth izin listesinde olmayabilir.');
                    console.error('   Motor çalışmayabilir ama cihaz listeye eklendi.');
                }

                // Bağlantı kesilince
                bluetoothDevice.addEventListener('gattserverdisconnected', onDisconnected);

                // Cihazı sidebar'a ekle (aynı rengi kullanarak)
                addDeviceToSidebar(bluetoothDevice, assignedColor, forcedType);

                // Eğer Motor ise Display'i göster
                const connectedType = forcedType || detectDeviceType(bluetoothDevice.name || '');
                if (connectedType === 'motor') {
                    showMotorDisplay(bluetoothDevice, assignedColor, friendlyName);
                } else if (connectedType === 'double_motor') {
                    showDoubleMotorDisplay(bluetoothDevice, assignedColor, friendlyName);
                }
                // Eğer Color Sensor ise Display'i göster
                else if (connectedType === 'color_sensor') {
                    showColorSensorDisplay(bluetoothDevice, assignedColor);
                }
                // Eğer Remote Controller ise Display'i göster ve notification handler kur
                else if (connectedType === 'remote_controller') {
                    showRemoteControllerDisplay(friendlyName, assignedColor);
                    remoteControllerState.deviceId = bluetoothDevice.id;

                    // LWP3 notification handler for Remote Controller
                    setupRemoteControllerNotifications(bluetoothDevice, assignedColor);
                }

                scanStatus.textContent = t.device_added;

                // Scan status'u gizle
                setTimeout(() => {
                    scanStatus.style.display = 'none';
                }, 2000);

            } catch (error) {
                console.error('Bluetooth hatası:', error);
                const scanStatus = document.getElementById('scanStatus');
                scanStatus.style.display = 'block';
                scanStatus.style.background = '#FFE5E5';
                scanStatus.textContent = `❌ Hata: ${error.message}`;

                let errorMsg = `Bluetooth bağlantı hatası:\n${error.message}\n\n`;

                if (error.message.includes('User cancelled')) {
                    scanStatus.style.display = 'none';
                    return; // İptal - hata gösterme
                } else if (error.message.includes('Bluetooth adapter not available')) {
                    errorMsg = '❌ Bluetooth açık değil!\n\nLütfen Bluetooth\'u açın ve tekrar deneyin.';
                } else {
                    errorMsg += 'Kontrol edin:\n✓ Bluetooth açık mı?\n✓ Cihaz açık mı?\n✓ Cihaz menzilde mi?';
                }

                alert(errorMsg);

                setTimeout(() => {
                    scanStatus.style.display = 'none';
                    scanStatus.style.background = '#f0f0f0';
                }, 5000);
            }
        }

        function onDisconnected(event) {
            // Find the device in connectedDevices first for accurate name/type
            const device = connectedDevices.find(d => d.device === bluetoothDevice);
            const deviceName = device ? device.name : (event && event.target ? (event.target.name || 'Unknown') : 'Device');
            const deviceType = device ? device.type : 'unknown';
            // console.log('Bluetooth cihaz bağlantısı kesildi', deviceName);

            if (typeof logDeviceAction === 'function') {
                logDeviceAction('remove', deviceName, deviceType);
            }

            // Controller monitoring'i durdur
            if (controllerMonitoring) {
                clearInterval(controllerMonitoring);
                controllerMonitoring = null;
            }

            // Controller ping'i durdur
            if (controllerPingInterval) {
                clearInterval(controllerPingInterval);
                controllerPingInterval = null;
            }

            activeControllerDevice = null;
            activeControllerCharacteristic = null;

            // Motor monitoring'i durdur
            if (motorMonitoringActive) {
                stopMotorAngleMonitoring();
            }

            // Double Motor monitoring'i durdur
            if (doubleMotorMonitoringActive) {
                stopDoubleMotorMonitoring();
            }

            // Controller display'i gizle
            hideControllerDisplay();
            hideMotorDisplay();
            hideColorSensorDisplay();
            hideSpikeEssentialDisplay();
            hideSpikePrimeDisplay();

            // Bağlantısı kesilen cihazı bul ve durumunu güncelle (device already found above)
            if (device) {
                device.connected = false;
                updateDevicesTable();
            }

            bluetoothDevice = null;
            bluetoothServer = null;
            connectedCharacteristics = {};
        }

        // Controller'dan veri oku ve state güncelle
        async function startControllerMonitoring(device, notifyChar, writeChar, deviceColor = null) {
            console.log('🎮 Controller monitoring başlatılıyor...');
            activeControllerDevice = device;
            activeControllerCharacteristic = notifyChar; // Global'e kaydet

            console.log('   DEBUG: Notify characteristic:', notifyChar.uuid);
            console.log('   DEBUG: Write characteristic:', writeChar ? writeChar.uuid : 'YOK');

            // Controller display'i göster - cihaz bilgilerini bul
            // Eğer renk parametre olarak geldiyse kullan, yoksa listeden bulmaya çalış
            let colorToUse = deviceColor;
            let nameToUse = device.name || 'Controller';

            if (!colorToUse) {
                const deviceData = connectedDevices.find(d => d.device === device || d.id === device.id);
                if (deviceData) {
                    nameToUse = deviceData.name;
                    colorToUse = deviceData.color;
                } else {
                    colorToUse = '#4C97FF';
                }
            }

            showControllerDisplay(nameToUse, colorToUse);

            // Notification'ları dinle
            try {
                await notifyChar.startNotifications();
                console.log('✅ Notifications başlatıldı - kolları hareket ettirin');
                console.log('   Characteristic UUID:', notifyChar.uuid);
                console.log('   Is notifying:', notifyChar.properties.notify);

                // Event listener ekle - notification'dan SONRA
                notifyChar.addEventListener('characteristicvaluechanged', (event) => {
                    const value = event.target.value;

                    // RAW HEX DUMP (Debug için devre dışı)
                    // if (!event.target._logCount) event.target._logCount = 0;
                    // if (event.target._logCount < 10) {
                    //     const bytes = new Uint8Array(value.buffer);
                    //     const hexDump = [...bytes].map(b => b.toString(16).padStart(2, '0')).join(' ');
                    //     console.log(`🎮 Controller RAW [${value.byteLength} bytes]: ${hexDump}`);
                    //     event.target._logCount++;
                    // }

                    // Format: 60, 10, 0, 0, 50, 0, 15, 1, 0, 50, 0, 248, 255
                    // Index:   0   1  2  3   4  5   6  7  8   9 10   11  12
                    // Index 7 = Sol lever byte
                    // Index 8 = Sağ lever byte
                    // Değerler: 0-1 = normal, 2-104 = up, 152-255 = down

                    if (value.byteLength >= 9) {
                        const leftByte = value.getUint8(7);   // Index 7 = Sol lever
                        const rightByte = value.getUint8(8);  // Index 8 = Sağ lever

                        // Sadece değer değiştiyse güncelle
                        if (leftByte !== controllerState.leftValue || rightByte !== controllerState.rightValue) {
                            updateControllerState(leftByte, rightByte);
                        }

                        // Pil yüzdesini al (index 4 olabilir - motor ile aynı gibi deneyelim)
                        if (value.byteLength >= 5) {
                            let batteryPercent = value.getUint8(4);
                            // 0-100 arasına normalize et
                            if (batteryPercent > 100) {
                                batteryPercent = Math.round((batteryPercent / 255) * 100);
                            }

                            // Pil göstergesini güncelle
                            const batteryEl = document.getElementById('controllerBatteryPercent');
                            const batteryFill = document.getElementById('controllerBatteryFill');
                            if (batteryEl) {
                                batteryEl.textContent = `${batteryPercent}%`;

                                // Pil doluluk göstergesini güncelle
                                if (batteryFill) {
                                    const fillWidth = Math.round((batteryPercent / 100) * 14);
                                    batteryFill.setAttribute('width', fillWidth);
                                }

                                // Renk ayarla
                                if (batteryPercent < 20) {
                                    batteryEl.parentElement.style.color = '#e03131';
                                } else if (batteryPercent < 50) {
                                    batteryEl.parentElement.style.color = '#fab005';
                                } else {
                                    batteryEl.parentElement.style.color = '#37b24d';
                                }
                            }
                        }
                    }
                });

                console.log('✓ Event listener eklendi');

                // Controller'ı başlat ve sensor stream'i aç
                if (writeChar) {
                    console.log('🔄 Controller sensor stream başlatılıyor...');

                    try {
                        // PCAP analizinden: Başlatma sırası
                        // Paket 403: 0x00 (reset/init)
                        // 0. Notify Characteristic'i bul ve Subscribe ol (Gerekli olabilir)
                        try {
                            const notifyUUID = '0000fd02-0002-1000-8000-00805f9b34fb';
                            let notifyChar = null;

                            // deviceData'yı bul
                            const deviceData = connectedDevices.find(d => d.device === device || d.id === device.id);

                            if (deviceData && deviceData.characteristics) {
                                notifyChar = deviceData.characteristics[notifyUUID];
                            }

                            // Cache'te yoksa servisten al (writeChar'ın servisini kullanabiliriz)
                            if (!notifyChar && writeChar && writeChar.service) {
                                try {
                                    notifyChar = await writeChar.service.getCharacteristic(notifyUUID);
                                } catch (e) { console.log('   ⚠️ Notify char servisten alınamadı:', e.message); }
                            }

                            if (notifyChar) {
                                // Start notifications if we haven't tracked it yet or just to be safe
                                // Web Bluetooth automatically handles duplicate startNotifications calls usually, or checks properties
                                console.log('   🔔 Notifications başlatılıyor (Handshake için gerekli olabilir)...');
                                await notifyChar.startNotifications();
                                // Listener eklemeye gerek yok, sadece aktif olması yetebilir
                            } else {
                                console.log('   ⚠️ Notify char bulunamadı, bu adım atlanıyor.');
                            }
                        } catch (err) {
                            console.log('   ⚠️ Notification başlatma uyarısı:', err);
                            // Notification hatası motoru durdurmamalı, devam et
                        }

                        // 1. Wake UP / Init / Handshake)
                        // Paket 409: 0x28 0x32 0x00 (sensor data stream başlat)

                        // Adım 1: Reset/Init
                        console.log('   📤 Adım 1: Reset komutu (0x00)...');
                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x00]));
                        await new Promise(resolve => setTimeout(resolve, 100));

                        // Adım 2: Handshake
                        console.log('   📤 Adım 2: Handshake komutu (0x1a)...');
                        await writeChar.writeValueWithoutResponse(new Uint8Array([0x1a]));
                        await new Promise(resolve => setTimeout(resolve, 100));

                        // Adım 3: Sensor data stream başlat (PCAP Paket 409)
                        // Bu komut gönderildikten sonra cihaz SÜREKLİ notification gönderir
                        const sensorStreamCmd = new Uint8Array([0x28, 0x32, 0x00]);
                        console.log('   📤 Adım 3: Sensor stream başlat (0x28 0x32 0x00)...');
                        await writeChar.writeValueWithoutResponse(sensorStreamCmd);

                        console.log('   ✅ Sensor stream başlatıldı! Cihaz artık sürekli veri gönderecek.');

                    } catch (e) {
                        console.error('   ❌ Başlatma hatası:', e.message);
                    }

                    // NOT: Periyodik ping GEREKMEYOR - cihaz tek komutla sürekli stream yapıyor
                    // Eski periyodik ping kaldırıldı
                }

                // TEST: Event listener gerçekten çalışıyor mu?
                console.log('🧪 TEST: Event listener count:',
                    notifyChar.getAttributeNames ? 'Modern API' : 'Eski API');

                // Manuel bir test eventi tetikle
                setTimeout(() => {
                    console.log('🧪 5 saniye geçti, manuel test...');
                    console.log('   Characteristic hala var mı?', !!activeControllerCharacteristic);
                    console.log('   Event listener sayısı kontrol edilemiyor (Web Bluetooth API sınırlaması)');
                }, 5000);

                // İlk değeri okumayı dene
                if (notifyChar.properties.read) {
                    try {
                        console.log('   📖 İlk değer okunuyor...');
                        const initialValue = await notifyChar.readValue();
                        console.log('   📖 İlk değer:', initialValue.byteLength, 'bytes');

                        // İlk değeri manuel olarak işle
                        if (initialValue.byteLength >= 9) {
                            const leftByte = initialValue.getUint8(7);   // Index 7 = Sol
                            const rightByte = initialValue.getUint8(8);  // Index 8 = Sağ
                            console.log(`   📖 İlk değerler: Left=${leftByte}, Right=${rightByte}`);
                        }
                    } catch (e) {
                        console.log('   ⚠️ Read desteklenmiyor:', e.message);
                    }
                }

                // Test: 5 saniye sonra hala veri gelmediyse uyar
                setTimeout(() => {
                    console.log('⏰ 5 saniye geçti - Eğer hala veri gelmediyse:');
                    console.log('   1. Kolları hareket ettirmeyi deneyin');
                    console.log('   2. Controller\'ı yeniden bağlayın');
                    console.log('   3. Controller\'ın pilini kontrol edin');
                }, 5000);

            } catch (err) {
                console.error('❌ Notification başlatma hatası:', err.message);
            }
        }

        function updateControllerState(leftByte, rightByte) {
            // Önceki state'i kaydet
            const prevLeft = controllerState.left;
            const prevRight = controllerState.right;

            // Yüzdeleri hesapla - her iki lever için aynı mantık
            const leftPercent = calculateLeverPercent(leftByte);
            const rightPercent = calculateLeverPercent(rightByte);

            // State'i yüzdeye göre belirle
            // >55%: UP, <45%: DOWN, 45-55%: RELEASED
            const newLeft = leftPercent > 55 ? 'UP' : (leftPercent < 45 ? 'DOWN' : 'RELEASED');
            const newRight = rightPercent > 55 ? 'UP' : (rightPercent < 45 ? 'DOWN' : 'RELEASED');

            controllerState.left = newLeft;
            controllerState.right = newRight;
            controllerState.leftValue = leftByte;
            controllerState.rightValue = rightByte;

            // Görseli throttle ile güncelle (100ms'de bir)
            const now = Date.now();
            if (now - lastVisualUpdate >= VISUAL_UPDATE_INTERVAL) {
                lastVisualUpdate = now;
                updateControllerVisualThrottled(leftPercent, rightPercent);
            }

            // State değişikliklerinde when bloklarını tetikle
            if (newLeft !== prevLeft) {
                triggerLeverEvents('LEFT', newLeft);
            }
            if (newRight !== prevRight) {
                triggerLeverEvents('RIGHT', newRight);
            }

            // Both ve Any kontrolü
            if (newLeft !== prevLeft || newRight !== prevRight) {
                triggerLeverEvents('BOTH', newLeft === newRight ? newLeft : null);
                triggerLeverEvents('ANY', newLeft !== 'RELEASED' || newRight !== 'RELEASED' ?
                    (newLeft !== 'RELEASED' ? newLeft : newRight) : null);
            }
        }

        // Throttled görsel güncelleme - dikey bar için height kullan
        function updateControllerVisualThrottled(leftPercent, rightPercent) {
            // Sol kol
            const leftFill = document.getElementById('leftLeverFill');
            const leftValue = document.getElementById('leftLeverValue');

            if (leftFill && leftValue) {
                const leftHeight = Math.round(leftPercent);
                leftFill.style.height = leftHeight + '%';
                leftValue.textContent = leftHeight + '%';
            }

            // Sağ kol
            const rightFill = document.getElementById('rightLeverFill');
            const rightValueEl = document.getElementById('rightLeverValue');

            if (rightFill && rightValueEl) {
                const rightHeight = Math.round(rightPercent);
                rightFill.style.height = rightHeight + '%';
                rightValueEl.textContent = rightHeight + '%';
            }
        }

        // Lever yüzde hesaplama
        // 0-1 = normal (ortada) = %50
        // 2-104 = up (yukarı) = %50-%100 (2→%50, 104→%100)
        // 152-255 = down (aşağı) = %0-%50 (255→%50, 152→%0)
        function calculateLeverPercent(byteValue) {
            let percent;

            if (byteValue <= 1) {
                // NORMAL - ortada
                percent = 50;
            } else if (byteValue >= 2 && byteValue <= 104) {
                // UP - yukarı
                // 2 → %50, 104 → %100
                percent = 50 + ((byteValue - 2) / (104 - 2)) * 50;
            } else if (byteValue >= 152 && byteValue <= 255) {
                // DOWN - aşağı
                // 255 → %50'ye yakın, 152 → %0
                // 255'ten 152'ye gittikçe aşağı iniyor
                percent = ((byteValue - 152) / (255 - 152)) * 50;
            } else {
                // Ara değerler (105-151) - geçiş bölgesi, ortada say
                percent = 50;
            }

            return Math.max(0, Math.min(100, percent));
        }

        // Lever angle değerini döndür (bloklar için)
        function getLeverAngle(lever) {
            if (lever === 'LEFT') {
                return Math.round(calculateLeverPercent(controllerState.leftValue));
            } else if (lever === 'RIGHT') {
                return Math.round(calculateLeverPercent(controllerState.rightValue));
            }
            return 50;
        }

        function triggerLeverEvents(lever, position) {
            if (!position) return;

            // Motor işlemi devam ediyorsa yeni işlem başlatma
            if (motorOperationInProgress) {
                return;
            }

            // Workspace'teki tüm when_lever_position bloklarını bul
            const allBlocks = workspace.getAllBlocks();
            allBlocks.forEach(block => {
                if (block.type === 'when_lever_position') {
                    const blockLever = block.getFieldValue('LEVER');
                    const blockPosition = block.getFieldValue('POSITION');

                    // Eğer blok parametreleri mevcut durumla eşleşiyorsa
                    if (blockLever === lever && blockPosition === position) {
                        // Bloğu vurgula
                        highlightBlock(block);

                        // Bloktan sonraki komutları çalıştır
                        executeBlockChain(block);
                    }
                }
            });
        }

        // Color Sensor event trigger - when_color_detected blokları için
        function triggerColorEvents(detectedColor) {
            if (!detectedColor || detectedColor === 'NONE') return;

            // Motor işlemi devam ediyorsa yeni işlem başlatma
            if (motorOperationInProgress) {
                return;
            }

            // Workspace'teki tüm when_color_detected bloklarını bul
            const allBlocks = workspace.getAllBlocks();
            allBlocks.forEach(block => {
                if (block.type === 'when_color_detected') {
                    const blockColor = block.getFieldValue('COLOR');

                    // Eğer blok parametresi mevcut renkle eşleşiyorsa
                    if (blockColor === detectedColor) {
                        console.log(`🎨 Color event triggered: ${detectedColor}`);

                        // Bloğu vurgula
                        highlightBlock(block);

                        // Bloktan sonraki komutları çalıştır
                        executeBlockChain(block);
                    }
                }
            });
        }

        function highlightBlock(block) {
            // Bloğu kısa süreliğine vurgula
            const blockSvg = block.getSvgRoot();
            if (blockSvg) {
                blockSvg.style.filter = 'brightness(1.3)';
                setTimeout(() => {
                    blockSvg.style.filter = '';
                }, 300);
            }
        }

        async function executeBlockChain(startBlock) {
            // Bloğun altındaki komut zincirini çalıştır
            let nextBlock = startBlock.getNextBlock();

            while (nextBlock) {
                await executeBlock(nextBlock);
                nextBlock = nextBlock.getNextBlock();
            }
        }

        async function executeBlock(block) {
            const blockType = block.type;
            console.log('  → Executing block:', blockType);

            if (typeof logExecution === 'function') {
                logExecution(blockType);
            }

            // RGB LED blokları
            if (blockType === 'rgb_red_on') {
                rgbLedState.red = true;
                updateRGBDisplay();
            } else if (blockType === 'rgb_red_off') {
                rgbLedState.red = false;
                updateRGBDisplay();
            } else if (blockType === 'rgb_green_on') {
                rgbLedState.green = true;
                updateRGBDisplay();
            } else if (blockType === 'rgb_green_off') {
                rgbLedState.green = false;
                updateRGBDisplay();
            } else if (blockType === 'rgb_blue_on') {
                rgbLedState.blue = true;
                updateRGBDisplay();
            } else if (blockType === 'rgb_blue_off') {
                rgbLedState.blue = false;
                updateRGBDisplay();
            }
            // RGB sayı gönder blokları
            else if (blockType === 'rgb_red_num') {
                const value = block.getFieldValue('NUM') || 1;
                rgbNumberState.red = parseInt(value);
                updateRGBNumberDisplay();
            } else if (blockType === 'rgb_green_num') {
                const value = block.getFieldValue('NUM') || 1;
                rgbNumberState.green = parseInt(value);
                updateRGBNumberDisplay();
            } else if (blockType === 'rgb_blue_num') {
                const value = block.getFieldValue('NUM') || 1;
                rgbNumberState.blue = parseInt(value);
                updateRGBNumberDisplay();
            }
            // Motor blokları - Gerçek Bluetooth kontrolü
            else if (blockType === 'motor_run_rotation') {
                const direction = block.getFieldValue('DIRECTION');
                const rotations = block.getFieldValue('ROTATIONS');
                console.log(`  ⚙️ Motor: ${rotations} rotation ${direction}`);

                const deviceId = block.data;
                if (deviceId) {
                    await runMotorRotations(deviceId, parseInt(rotations), direction);
                } else {
                    console.log('  ❌ deviceId yok - motor çalıştırılamadı');
                }
            } else if (blockType === 'motor_run_to_angle') {
                const direction = block.getFieldValue('DIRECTION');
                const angle = block.getFieldValue('ANGLE');
                console.log(`  ⚙️ Motor: Go to ${angle}° ${direction}`);

                const deviceId = block.data;
                if (deviceId) {
                    await runMotorToAngle(deviceId, parseInt(angle), direction);
                } else {
                    console.log('  ❌ deviceId yok');
                }
            } else if (blockType === 'motor_go_to_position') {
                const position = block.getFieldValue('POSITION');
                console.log(`  ⚙️ Motor: Go to position ${position}`);

                const deviceId = block.data;
                if (deviceId) {
                    await goToPosition(deviceId, parseInt(position));
                } else {
                    console.log('  ❌ deviceId yok');
                }
            } else if (blockType === 'motor_start') {
                const direction = block.getFieldValue('DIRECTION');
                console.log(`  ⚙️ Motor: Start ${direction}`);

                const deviceId = block.data;
                if (deviceId) {
                    await startMotor(deviceId, direction);
                } else {
                    console.log('  ❌ deviceId yok');
                }
            } else if (blockType === 'motor_stop') {
                console.log(`  ⚙️ Motor: Stop`);

                const deviceId = block.data;
                if (deviceId) {
                    await stopMotor(deviceId);
                } else {
                    console.log('  ❌ deviceId yok');
                }
            }
            // Double Motor blokları
            else if (blockType === 'double_motor_run_rotation') {
                const motorIndex = block.getFieldValue('MOTOR_INDEX');
                const direction = block.getFieldValue('DIRECTION');
                const rotations = block.getFieldValue('ROTATIONS');
                const deviceId = block.data;
                if (deviceId) {
                    await runDoubleMotorRotations(deviceId, motorIndex, rotations, direction);
                } else {
                    console.log('  ❌ DoubleMotor: deviceId yok');
                }
            } else if (blockType === 'double_motor_go_to_position') {
                const motorIndex = block.getFieldValue('MOTOR_INDEX');
                const angle = block.getFieldValue('ANGLE');
                const deviceId = block.data;
                if (deviceId) {
                    await runDoubleMotorToPosition(deviceId, motorIndex, angle);
                } else {
                    console.log('  ❌ DoubleMotor: deviceId yok');
                }
            } else if (blockType === 'double_motor_start') {
                const motorIndex = block.getFieldValue('MOTOR_INDEX');
                const direction = block.getFieldValue('DIRECTION');
                const deviceId = block.data;
                if (deviceId) {
                    await startDoubleMotor(deviceId, motorIndex, direction);
                }
            } else if (blockType === 'double_motor_stop') {
                const motorIndex = block.getFieldValue('MOTOR_INDEX');
                const deviceId = block.data;
                if (deviceId) {
                    await stopDoubleMotor(deviceId, motorIndex);
                }
            } else if (blockType === 'double_motor_set_speed') {
                const motorIndex = block.getFieldValue('MOTOR_INDEX');
                const speed = block.getFieldValue('SPEED');
                const deviceId = block.data;
                if (deviceId) {
                    await setDoubleMotorSpeed(deviceId, motorIndex, speed);
                }
            }
            // Wait bloğu
            else if (blockType === 'wait') {
                const seconds = block.getFieldValue('SECONDS') || 1;
                console.log(`  → Waiting ${seconds} seconds...`);
                await new Promise(resolve => setTimeout(resolve, seconds * 1000));
            }
        }

        function showDeviceModal() {
            document.getElementById('deviceModal').classList.add('show');
        }

        function closeDeviceModal() {
            const modal = document.getElementById('deviceModal');
            if (modal) {
                modal.classList.remove('show');
                modal.style.display = 'none';
            }
        }

        function zoomIn() {
            workspace.zoomCenter(1.2);
        }

        function zoomOut() {
            workspace.zoomCenter(-1.2);
        }

        function resetView() {
            workspace.setScale(1);
            workspace.scrollCenter();
        }

        function clearWorkspace() {
            if (workspace.getAllBlocks().length > 0 && confirm('Tüm blokları sil?')) {
                workspace.clear();
            }
        }

        function toggleStartBlocks() {


            if (!workspace) {
                console.error('Workspace henüz yüklenmedi!');
                return;
            }

            if (currentToolboxMode === 'start') {
                hideAllToolboxes();
            } else {
                showStartToolbox();
            }
        }

        function toggleControlBlocks() {


            if (!workspace) {
                console.error('Workspace henüz yüklenmedi!');
                return;
            }

            if (currentToolboxMode === 'control') {
                hideAllToolboxes();
            } else {
                showControlToolbox();
            }
        }

        function toggleActionLedBlocks() {


            if (!workspace) {
                console.error('Workspace henüz yüklenmedi!');
                return;
            }

            if (currentToolboxMode === 'action_led') {
                hideAllToolboxes();
            } else {
                showActionLedToolbox();
            }
        }

        function toggleActionNumBlocks() {


            if (!workspace) {
                console.error('Workspace henüz yüklenmedi!');
                return;
            }

            if (currentToolboxMode === 'action_num') {
                hideAllToolboxes();
            } else {
                showActionNumToolbox();
            }
        }

        function toggleOperatorBlocks() {


            if (!workspace) {
                console.error('Workspace henüz yüklenmedi!');
                return;
            }

            // Eğer zaten operator mode aktifse kapat, değilse operator mode aç
            if (currentToolboxMode === 'operator') {
                hideAllToolboxes();
            } else {
                showOperatorToolbox();
            }
        }

        function toggleMotorControl() {
            console.log('toggleMotorControl çağrıldı, currentMode:', currentToolboxMode);

            if (!workspace) {
                console.error('Workspace henüz yüklenmedi!');
                return;
            }

            // Eğer zaten motor mode aktifse kapat, değilse motor mode aç
            if (currentToolboxMode === 'motor') {
                hideAllToolboxes();
            } else {
                // Full veya kapalı olabilir - her durumda motor aç
                showMotorToolbox();
            }
        }

        let currentToolboxMode = null;

        // Toolbox değiştiğinde güncelleme
        function updateToolboxPreservingScroll(toolboxXml) {
            // Flyout'u görünür yap (hideAllToolboxes tarafından gizlenmiş olabilir)
            const flyoutSvg = document.querySelector('.blocklyFlyout');
            if (flyoutSvg) {
                flyoutSvg.style.display = '';
            }

            // Toolbox'ı güncelle
            workspace.updateToolbox(toolboxXml);
        }

        function showStartToolbox() {
            const startToolbox = `
                <xml xmlns="https://developers.google.com/blockly/xml">
                    <block type="start"></block>
                    <block type="when_condition"></block>
                    <block type="when_message_received">
                        <field name="MESSAGE">message1</field>
                    </block>
                    <sep gap="32"></sep>
                    <block type="send_message">
                        <field name="MESSAGE">message1</field>
                    </block>
                    <sep gap="32"></sep>
                    <block type="wait">
                        <value name="SECONDS">
                            <shadow type="math_number">
                                <field name="NUM">1</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="wait_until"></block>
                </xml>
            `;

            updateToolboxPreservingScroll(startToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'start';
            currentToolboxDevice = null;
            selectedDeviceId = null;

            updateToolboxButtons('startToggle');
            resetDeviceIcons();

        }

        function showControlToolbox() {
            const controlToolbox = `
                <xml xmlns="https://developers.google.com/blockly/xml">
                    <block type="repeat">
                        <value name="TIMES">
                            <shadow type="math_number">
                                <field name="NUM">10</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="forever"></block>
                    <block type="if_then"></block>
                    <block type="if_then_else"></block>
                    <block type="repeat_until"></block>
                </xml>
            `;

            updateToolboxPreservingScroll(controlToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'control';
            currentToolboxDevice = null;
            selectedDeviceId = null;

            updateToolboxButtons('controlToggle');
            resetDeviceIcons();

        }

        function showActionLedToolbox() {
            const actionLedToolbox = `
                <xml xmlns="https://developers.google.com/blockly/xml">
                    <block type="rgb_red_on"></block>
                    <block type="rgb_green_on"></block>
                    <block type="rgb_blue_on"></block>
                    <sep gap="32"></sep>
                    <block type="rgb_red_off"></block>
                    <block type="rgb_green_off"></block>
                    <block type="rgb_blue_off"></block>
                    <sep gap="32"></sep>
                    <block type="rgb_red_light_get"></block>
                    <block type="rgb_green_light_get"></block>
                    <block type="rgb_blue_light_get"></block>
                </xml>
            `;

            updateToolboxPreservingScroll(actionLedToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'action_led';
            selectedDeviceId = null;
            currentToolboxDevice = null;

            updateToolboxButtons('actionLedToggle');
            resetDeviceIcons();

        }

        function showActionNumToolbox() {
            const actionNumToolbox = `
                <xml xmlns="https://developers.google.com/blockly/xml">
                    <block type="rgb_red_num">
                        <value name="NUM">
                            <shadow type="math_number">
                                <field name="NUM">1</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="rgb_green_num">
                        <value name="NUM">
                            <shadow type="math_number">
                                <field name="NUM">1</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="rgb_blue_num">
                        <value name="NUM">
                            <shadow type="math_number">
                                <field name="NUM">1</field>
                            </shadow>
                        </value>
                    </block>
                    <sep gap="32"></sep>
                    <block type="rgb_red_get"></block>
                    <block type="rgb_green_get"></block>
                    <block type="rgb_blue_get"></block>
                </xml>
            `;

            updateToolboxPreservingScroll(actionNumToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'action_num';
            selectedDeviceId = null;
            currentToolboxDevice = null;

            updateToolboxButtons('actionNumToggle');
            resetDeviceIcons();

        }

        function showDeviceToolbox(deviceData) {
            // selectedDeviceId'yi set et - ÖNEMLI!
            selectedDeviceId = deviceData.id;
            // console.log('📱 showDeviceToolbox:', deviceData.name, 'ID:', deviceData.id);

            // Cihaz tipine göre blokları al
            const blocks = DEVICE_BLOCKS[deviceData.type] || DEVICE_BLOCKS['generic'];

            // Toolbox XML'i oluştur
            let deviceToolboxXml = '<xml xmlns="https://developers.google.com/blockly/xml">';

            // Motor blokları ekle
            if (deviceData.type === 'motor') {
                deviceToolboxXml += `
                    <block type="motor_run_rotation">
                        <field name="DIRECTION">CW</field>
                        <field name="ROTATIONS">1</field>
                    </block>
                    <block type="motor_run_to_angle">
                        <field name="DIRECTION">CW</field>
                        <field name="ANGLE">90</field>
                    </block>
                    <block type="motor_go_to_position">
                        <field name="POSITION">270</field>
                    </block>
                    <block type="motor_start">
                        <field name="DIRECTION">CW</field>
                    </block>
                    <block type="motor_stop"></block>
                `;
            }
            // Double Motor blokları ekle
            else if (deviceData.type === 'double_motor') {
                deviceToolboxXml += `
                    <block type="double_motor_run_rotation">
                        <field name="MOTOR_INDEX">1</field>
                        <field name="DIRECTION">CW</field>
                        <field name="ROTATIONS">1</field>
                    </block>
                    <block type="double_motor_go_to_position">
                        <field name="MOTOR_INDEX">1</field>
                        <field name="ANGLE">0</field>
                    </block>
                    <block type="double_motor_start">
                        <field name="MOTOR_INDEX">1</field>
                        <field name="DIRECTION">CW</field>
                    </block>
                    <block type="double_motor_stop">
                        <field name="MOTOR_INDEX">1</field>
                    </block>
                    <block type="double_motor_set_speed">
                        <field name="MOTOR_INDEX">1</field>
                        <field name="SPEED">50</field>
                    </block>
                    <block type="double_motor_get_angle">
                        <field name="MOTOR_INDEX">1</field>
                        <field name="TYPE">ANGLE</field>
                    </block>
                `;
            }
            // Controller blokları ekle
            else if (deviceData.type === 'controller') {
                deviceToolboxXml += `
                    <block type="when_lever_position">
                        <field name="LEVER">LEFT</field>
                        <field name="POSITION">UP</field>
                    </block>
                    <block type="lever_position">
                        <field name="LEVER">LEFT</field>
                        <field name="POSITION">UP</field>
                    </block>
                    <block type="lever_angle">
                        <field name="LEVER">LEFT</field>
                    </block>
                `;
            }
            // Color Sensor blokları ekle
            else if (deviceData.type === 'color_sensor') {
                deviceToolboxXml += `
                    <block type="when_color_detected">
                        <field name="COLOR">RED</field>
                    </block>
                    <block type="detecting_color">
                        <field name="COLOR">YELLOW</field>
                    </block>
                    <block type="color_value"></block>
                    <block type="reflection_compare">
                        <field name="OP">LT</field>
                        <field name="VALUE">50</field>
                    </block>
                    <block type="reflection_value"></block>
                    <block type="color_hue">
                        <field name="MODE">HUE</field>
                    </block>
                `;
            }
            // Spike Essential blokları ekle
            else if (deviceData.type === 'spike_essential') {
                deviceToolboxXml += `
                    <block type="hub_led_color">
                        <field name="COLOR">RED</field>
                    </block>
                    <block type="hub_orientation">
                        <field name="ORIENTATION">FRONT</field>
                    </block>
                    <block type="matrix_turn_on">
                        <field name="PORT">A</field>
                    </block>
                    <block type="matrix_turn_off">
                        <field name="PORT">A</field>
                    </block>
                    <block type="matrix_set_brightness">
                        <field name="PORT">A</field>
                        <value name="BRIGHTNESS">
                            <shadow type="math_number">
                                <field name="NUM">100</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="matrix_set_pixel_at">
                        <field name="PORT">A</field>
                        <field name="X">1</field>
                        <field name="Y">1</field>
                        <field name="COLOR">9</field>
                        <value name="BRIGHTNESS">
                            <shadow type="math_number">
                                <field name="NUM">100</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="matrix_rotate_pattern">
                        <field name="PORT">A</field>
                        <field name="DIRECTION">CW</field>
                    </block>
                    <block type="force_sensor_is_pressed">
                        <field name="PORT">B</field>
                        <field name="STATE">PRESSED</field>
                    </block>
                    <block type="force_sensor_pressure">
                        <field name="PORT">B</field>
                        <field name="UNIT">NEWTON</field>
                    </block>
                    <block type="distance_sensor_is">
                        <field name="PORT">A</field>
                        <field name="COMPARISON">CLOSER</field>
                        <field name="VALUE">15</field>
                        <field name="UNIT">CM</field>
                    </block>
                    <block type="distance_sensor_value">
                        <field name="PORT">A</field>
                        <field name="UNIT">CM</field>
                    </block>
                    <block type="color_sensor_is_color">
                        <field name="PORT">A</field>
                        <field name="COLOR">9</field>
                    </block>
                    <block type="color_sensor_color">
                        <field name="PORT">A</field>
                    </block>
                    <block type="hub_motor_run">
                        <field name="PORT">A</field>
                        <field name="DIRECTION">CW</field>
                        <field name="VALUE">1</field>
                        <field name="UNIT">ROTATIONS</field>
                    </block>
                    <block type="hub_motor_go_position">
                        <field name="PORT">A</field>
                        <field name="POSITION">0</field>
                    </block>
                    <block type="hub_motor_start">
                        <field name="PORT">A</field>
                        <field name="DIRECTION">CW</field>
                    </block>
                    <block type="hub_motor_stop">
                        <field name="PORT">A</field>
                    </block>
                    <block type="hub_light_control">
                        <field name="PORT">A</field>
                        <field name="STATE">ON</field>
                        <field name="BRIGHTNESS">100</field>
                    </block>
                `;
            }
            // Spike Prime blokları ekle (Spike Essential ile aynı blokları kullanır)
            else if (deviceData.type === 'spike_prime') {
                deviceToolboxXml += `
                    <block type="hub_led_color">
                        <field name="COLOR">RED</field>
                    </block>
                    <block type="hub_light_control">
                        <field name="PORT">A</field>
                        <field name="STATE">ON</field>
                        <field name="BRIGHTNESS">100</field>
                    </block>
                    <block type="hub_orientation">
                        <field name="ORIENTATION">FRONT</field>
                    </block>
                    <block type="matrix_turn_on">
                        <field name="PORT">A</field>
                    </block>
                    <block type="matrix_turn_off">
                        <field name="PORT">A</field>
                    </block>
                    <block type="matrix_set_brightness">
                        <field name="PORT">A</field>
                        <value name="BRIGHTNESS">
                            <shadow type="math_number">
                                <field name="NUM">100</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="matrix_set_pixel_at">
                        <field name="PORT">A</field>
                        <field name="X">1</field>
                        <field name="Y">1</field>
                        <field name="COLOR">9</field>
                        <value name="BRIGHTNESS">
                            <shadow type="math_number">
                                <field name="NUM">100</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="matrix_rotate_pattern">
                        <field name="PORT">A</field>
                        <field name="DIRECTION">CW</field>
                    </block>
                    <block type="force_sensor_is_pressed">
                        <field name="PORT">B</field>
                        <field name="STATE">PRESSED</field>
                    </block>
                    <block type="force_sensor_pressure">
                        <field name="PORT">B</field>
                        <field name="UNIT">NEWTON</field>
                    </block>
                    <block type="distance_sensor_is">
                        <field name="PORT">A</field>
                        <field name="COMPARISON">CLOSER</field>
                        <field name="VALUE">15</field>
                        <field name="UNIT">CM</field>
                    </block>
                    <block type="distance_sensor_value">
                        <field name="PORT">A</field>
                        <field name="UNIT">CM</field>
                    </block>
                    <block type="color_sensor_is_color">
                        <field name="PORT">A</field>
                        <field name="COLOR">9</field>
                    </block>
                    <block type="color_sensor_color">
                        <field name="PORT">A</field>
                    </block>
                `;
            }
            // Technic Medium Hub blokları ekle (LWP3 - diğer hub'larla aynı)
            else if (deviceData.type === 'technic_medium_hub') {
                deviceToolboxXml += `
                    <block type="hub_led_color">
                        <field name="COLOR">RED</field>
                    </block>
                    <block type="hub_light_control">
                        <field name="PORT">A</field>
                        <field name="STATE">ON</field>
                        <field name="BRIGHTNESS">100</field>
                    </block>
                    <block type="hub_orientation">
                        <field name="ORIENTATION">FRONT</field>
                    </block>
                    <block type="matrix_turn_on">
                        <field name="PORT">A</field>
                    </block>
                    <block type="matrix_turn_off">
                        <field name="PORT">A</field>
                    </block>
                    <block type="matrix_set_brightness">
                        <field name="PORT">A</field>
                        <value name="BRIGHTNESS">
                            <shadow type="math_number">
                                <field name="NUM">100</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="matrix_set_pixel_at">
                        <field name="PORT">A</field>
                        <field name="X">1</field>
                        <field name="Y">1</field>
                        <field name="COLOR">9</field>
                        <value name="BRIGHTNESS">
                            <shadow type="math_number">
                                <field name="NUM">100</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="matrix_rotate_pattern">
                        <field name="PORT">A</field>
                        <field name="DIRECTION">CW</field>
                    </block>
                    <block type="force_sensor_is_pressed">
                        <field name="PORT">B</field>
                        <field name="STATE">PRESSED</field>
                    </block>
                    <block type="force_sensor_pressure">
                        <field name="PORT">B</field>
                        <field name="UNIT">NEWTON</field>
                    </block>
                    <block type="distance_sensor_is">
                        <field name="PORT">A</field>
                        <field name="COMPARISON">CLOSER</field>
                        <field name="VALUE">15</field>
                        <field name="UNIT">CM</field>
                    </block>
                    <block type="distance_sensor_value">
                        <field name="PORT">A</field>
                        <field name="UNIT">CM</field>
                    </block>
                    <block type="color_sensor_is_color">
                        <field name="PORT">A</field>
                        <field name="COLOR">9</field>
                    </block>
                    <block type="color_sensor_color">
                        <field name="PORT">A</field>
                    </block>
                `;
            }
            // City Hub blokları ekle (LWP3 - diğer hub'larla aynı)
            else if (deviceData.type === 'city_hub') {
                deviceToolboxXml += `
                    <block type="hub_led_color">
                        <field name="COLOR">RED</field>
                    </block>
                    <block type="hub_light_control">
                        <field name="PORT">A</field>
                        <field name="STATE">ON</field>
                        <field name="BRIGHTNESS">100</field>
                    </block>
                    <block type="hub_orientation">
                        <field name="ORIENTATION">FRONT</field>
                    </block>
                    <block type="matrix_turn_on">
                        <field name="PORT">A</field>
                    </block>
                    <block type="matrix_turn_off">
                        <field name="PORT">A</field>
                    </block>
                    <block type="matrix_set_brightness">
                        <field name="PORT">A</field>
                        <value name="BRIGHTNESS">
                            <shadow type="math_number">
                                <field name="NUM">100</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="matrix_set_pixel_at">
                        <field name="PORT">A</field>
                        <field name="X">1</field>
                        <field name="Y">1</field>
                        <field name="COLOR">9</field>
                        <value name="BRIGHTNESS">
                            <shadow type="math_number">
                                <field name="NUM">100</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="matrix_rotate_pattern">
                        <field name="PORT">A</field>
                        <field name="DIRECTION">CW</field>
                    </block>
                    <block type="force_sensor_is_pressed">
                        <field name="PORT">B</field>
                        <field name="STATE">PRESSED</field>
                    </block>
                    <block type="force_sensor_pressure">
                        <field name="PORT">B</field>
                        <field name="UNIT">NEWTON</field>
                    </block>
                    <block type="distance_sensor_is">
                        <field name="PORT">A</field>
                        <field name="COMPARISON">CLOSER</field>
                        <field name="VALUE">15</field>
                        <field name="UNIT">CM</field>
                    </block>
                    <block type="distance_sensor_value">
                        <field name="PORT">A</field>
                        <field name="UNIT">CM</field>
                    </block>
                    <block type="color_sensor_is_color">
                        <field name="PORT">A</field>
                        <field name="COLOR">9</field>
                    </block>
                    <block type="color_sensor_color">
                        <field name="PORT">A</field>
                    </block>
                `;
            }
            // Boost Move Hub blokları ekle (LWP3 - diğer hub'larla aynı)
            else if (deviceData.type === 'boost_move_hub') {
                deviceToolboxXml += `
                    <block type="hub_led_color">
                        <field name="COLOR">RED</field>
                    </block>
                    <block type="hub_orientation">
                        <field name="ORIENTATION">FRONT</field>
                    </block>
                    <block type="matrix_turn_on">
                        <field name="PORT">A</field>
                    </block>
                    <block type="matrix_turn_off">
                        <field name="PORT">A</field>
                    </block>
                    <block type="matrix_set_brightness">
                        <field name="PORT">A</field>
                        <value name="BRIGHTNESS">
                            <shadow type="math_number">
                                <field name="NUM">100</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="matrix_set_pixel_at">
                        <field name="PORT">A</field>
                        <field name="X">1</field>
                        <field name="Y">1</field>
                        <field name="COLOR">9</field>
                        <value name="BRIGHTNESS">
                            <shadow type="math_number">
                                <field name="NUM">100</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="matrix_rotate_pattern">
                        <field name="PORT">A</field>
                        <field name="DIRECTION">CW</field>
                    </block>
                    <block type="force_sensor_is_pressed">
                        <field name="PORT">B</field>
                        <field name="STATE">PRESSED</field>
                    </block>
                    <block type="force_sensor_pressure">
                        <field name="PORT">B</field>
                        <field name="UNIT">NEWTON</field>
                    </block>
                    <block type="distance_sensor_is">
                        <field name="PORT">A</field>
                        <field name="COMPARISON">CLOSER</field>
                        <field name="VALUE">15</field>
                        <field name="UNIT">CM</field>
                    </block>
                    <block type="distance_sensor_value">
                        <field name="PORT">A</field>
                        <field name="UNIT">CM</field>
                    </block>
                    <block type="color_sensor_is_color">
                        <field name="PORT">A</field>
                        <field name="COLOR">9</field>
                    </block>
                    <block type="color_sensor_color">
                        <field name="PORT">A</field>
                    </block>
                `;
            }
            // Remote Controller (88010) blokları ekle
            else if (deviceData.type === 'remote_controller') {
                deviceToolboxXml += `
                    <block type="remote_led_color">
                        <field name="COLOR">6</field>
                    </block>
                    <block type="remote_button_state">
                        <field name="BUTTON">LEFT_PLUS</field>
                        <field name="STATE">PRESSED</field>
                    </block>
                `;
            }
            // Generic bloklar
            else {
                deviceToolboxXml += '<block type="led_on"><field name="VAL">90</field></block>';
            }

            deviceToolboxXml += '</xml>';

            // CRITICAL: Inject device ID into ALL block definitions so blocks are created with mode proper data
            deviceToolboxXml = deviceToolboxXml.replace(/<block type="([^"]+)">/g,
                `<block type="$1"><data>${deviceData.id}</data>`);

            // Suppress Blockly warnings about unavailable dropdown options during toolbox update
            const originalWarn = console.warn;
            console.warn = function (msg) {
                if (typeof msg === 'string' && msg.includes("Cannot set the dropdown's value")) return;
                originalWarn.apply(console, arguments);
            };

            updateToolboxPreservingScroll(deviceToolboxXml);

            // Restore console.warn
            console.warn = originalWarn;
            isToolboxVisible = true;
            currentToolboxMode = 'device';
            currentToolboxDevice = deviceData.id; // Bu da ekleyelim

            // Tüm butonları pasif yap, cihaz ikonu aktif
            updateToolboxButtons(null);

            // Cihaz ikonunu aktif göster
            document.querySelectorAll('.device-icon').forEach(icon => {
                icon.style.background = 'white';
            });
            const activeIcon = document.querySelector(`[data-device-id="${deviceData.id}"]`);
            if (activeIcon) {
                activeIcon.style.background = '#0FBD8C';
            }

            // console.log('Device toolbox gösterildi:', deviceData.name);
            // console.log('currentToolboxDevice:', currentToolboxDevice);
        }

        function showOperatorToolbox() {
            const operatorToolbox = `
                    <xml xmlns="https://developers.google.com/blockly/xml">
                    <block type="math_number">
                        <field name="NUM">0</field>
                    </block>
                    <block type="math_arithmetic">
                        <field name="OP">ADD</field>
                        <value name="A">
                            <shadow type="math_number">
                                <field name="NUM">2</field>
                            </shadow>
                        </value>
                        <value name="B">
                            <shadow type="math_number">
                                <field name="NUM">1</field>
                            </shadow>
                        </value>
                    </block>
                    <block type="math_random">
                        <value name="FROM">
                            <shadow type="math_number">
                                <field name="NUM">1</field>
                            </shadow>
                        </value>
                        <value name="TO">
                            <shadow type="math_number">
                                <field name="NUM">10</field>
                            </shadow>
                        </value>
                    </block>
                    <sep gap="32"></sep>
                    <block type="logic_compare">
                        <field name="OP">GT</field>
                        <value name="A">
                            <shadow type="math_number">
                                <field name="NUM">3</field>
                            </shadow>
                        </value>
                        <value name="B">
                            <shadow type="math_number">
                                <field name="NUM">2</field>
                            </shadow>
                        </value>
                    </block>
                    <sep gap="32"></sep>
                    <block type="logic_and"></block>
                    <block type="logic_or"></block>
                    <block type="logic_negate"></block>
                </xml>
                    `;

            updateToolboxPreservingScroll(operatorToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'operator';
            selectedDeviceId = null;
            currentToolboxDevice = null;

            updateToolboxButtons('operatorToggle');
            resetDeviceIcons();

        }

        function showMotorToolbox() {
            const motorToolbox = `
                    <xml xmlns="https://developers.google.com/blockly/xml">
                        <block type="led_on"><field name="VAL">90</field></block>
                </xml>
                    `;

            updateToolboxPreservingScroll(motorToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'motor';
            selectedDeviceId = null;
            currentToolboxDevice = null;

            updateToolboxButtons('motorToggle');
            resetDeviceIcons();
            console.log('Motor toolbox gösterildi');
        }

        function resetDeviceIcons() {
            document.querySelectorAll('.device-icon').forEach(icon => {
                icon.style.background = '';
            });
        }

        function toggleActionButtonBlocks() {


            if (!workspace) {
                console.error('Workspace henüz yüklenmedi!');
                return;
            }

            if (currentToolboxMode === 'action_button') {
                hideAllToolboxes();
            } else {
                showActionButtonToolbox();
            }
        }

        function showActionButtonToolbox() {
            const actionButtonToolbox = `
                    <xml xmlns="https://developers.google.com/blockly/xml">
                    <block type="rgb_red_button_get"></block>
                    <block type="rgb_green_button_get"></block>
                    <block type="rgb_blue_button_get"></block>
                </xml>
                    `;

            updateToolboxPreservingScroll(actionButtonToolbox);
            isToolboxVisible = true;
            currentToolboxMode = 'action_button';
            selectedDeviceId = null;
            currentToolboxDevice = null;

            updateToolboxButtons('actionButtonToggle');
            resetDeviceIcons();

        }

        function updateToolboxButtons(activeButtonId) {
            const buttons = ['startToggle', 'controlToggle', 'actionLedToggle', 'actionNumToggle', 'actionButtonToggle', 'operatorToggle'];

            buttons.forEach(buttonId => {
                const btn = document.getElementById(buttonId);
                if (btn) {
                    if (buttonId === activeButtonId) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                }
            });
        }

        function hideAllToolboxes() {
            const emptyToolbox = '<xml xmlns="https://developers.google.com/blockly/xml"></xml>';
            updateToolboxPreservingScroll(emptyToolbox);
            isToolboxVisible = false;
            currentToolboxMode = null;
            currentToolboxDevice = null;

            updateToolboxButtons(null);
            resetDeviceIcons();

            // Flyout genişliğini sıfırla - gri alan sorununu çözmek için
            setTimeout(() => {
                const flyoutSvg = document.querySelector('.blocklyFlyout');
                if (flyoutSvg) {
                    flyoutSvg.setAttribute('width', '0');
                    flyoutSvg.style.display = 'none';
                }
                const flyoutBg = document.querySelector('.blocklyFlyoutBackground');
                if (flyoutBg) {
                    flyoutBg.setAttribute('width', '0');
                }
            }, 50);
        }

        function showToolbox() {
            showStartToolbox();
        }

        function hideToolbox() {
            hideAllToolboxes();
        }

        document.getElementById('codeModal').addEventListener('click', (e) => {
            if (e.target.id === 'codeModal') closeModal();
        });

        document.getElementById('deviceModal').addEventListener('click', (e) => {
            if (e.target.id === 'deviceModal') closeDeviceModal();
        });

        // Cihaz ekle butonu event listener
        window.addEventListener('load', () => {
            const addDeviceBtn = document.getElementById('addDeviceBtn');
            if (addDeviceBtn) {
                addDeviceBtn.addEventListener('click', addDevice);

            } else {
                console.error('❌ addDeviceBtn bulunamadı!');
            }
        });

        // --- Info Modal Logic ---

        let executionSessions = []; // Array of { startTime, logs[], ended, endTime }
        let deviceLogs = [];
        const MAX_LOGS = 100;

        function openInfoModal() {
            document.getElementById('infoModal').classList.add('show');
            updateInfoModalTexts();
            updateStartersTab();
            switchInfoTab('starters'); // Reset to first tab
        }

        function closeInfoModal() {
            document.getElementById('infoModal').classList.remove('show');
        }

        // Close on background click
        document.getElementById('infoModal').addEventListener('click', (e) => {
            if (e.target.id === 'infoModal') closeInfoModal();
        });

        function updateInfoModalTexts() {
            const isTr = currentLanguage === 'tr';
            const title = document.getElementById('infoModalTitle');
            if (title) title.textContent = isTr ? 'ℹ️ Sistem Bilgisi' : 'ℹ️ System Info';

            const tab1 = document.getElementById('tab-btn-starters');
            if (tab1) tab1.textContent = isTr ? 'Başlangıç' : 'Starters';

            const tab2 = document.getElementById('tab-btn-executions');
            if (tab2) tab2.textContent = isTr ? 'Çalıştırmalar' : 'Executions';

            const tab3 = document.getElementById('tab-btn-devices');
            if (tab3) tab3.textContent = isTr ? 'Cihazlar' : 'Devices';

            const tab4 = document.getElementById('tab-btn-graphs');
            if (tab4) tab4.textContent = isTr ? 'Grafikler' : 'Graphs';

            const refreshBtn = document.getElementById('refreshGraphBtn');
            if (refreshBtn) refreshBtn.innerHTML = isTr ? '🔄 Yenile' : '🔄 Refresh';

            const cancelBtn = document.getElementById('cancelZoomBtn');
            if (cancelBtn) cancelBtn.innerHTML = isTr ? '↩️ Zoom İptal' : '↩️ Cancel Zoom';
        }

        function switchInfoTab(tabId) {
            // Update Headers
            ['starters', 'executions', 'devices', 'graphs'].forEach(id => {
                const btn = document.getElementById(`tab-btn-${id}`);
                const content = document.getElementById(`tab-${id}`);

                if (id === tabId) {
                    btn.style.borderBottom = '3px solid #4C97FF';
                    btn.style.color = '#4C97FF';
                    if (tabId === 'graphs') {
                        btn.style.background = '#4C97FF';
                        btn.style.color = 'white';
                    }
                    content.style.display = 'block';
                } else {
                    btn.style.borderBottom = 'none';
                    btn.style.color = '#888';
                    btn.style.background = '';
                    content.style.display = 'none';
                }
            });

            if (tabId === 'executions') renderExecutionLogs();
            if (tabId === 'devices') renderDeviceLogs();
            if (tabId === 'graphs') {
                renderLedGraph();
                renderNumbersGraph();
                renderButtonsGraph();
            }
        }

        function updateStartersTab() {
            if (!workspace) return;
            const topBlocks = workspace.getTopBlocks(false);
            const list = document.getElementById('startersList');
            list.innerHTML = '';

            const starterTypes = ['start', 'when_condition', 'when_message_received', 'when_color_detected', 'when_controller_button'];
            let count = 0;
            const isTr = currentLanguage === 'tr';

            topBlocks.forEach(block => {
                // Filter strict: Only explicitly defined starter types
                if (starterTypes.includes(block.type)) {
                    count++;
                    const childCount = block.getDescendants().length - 1; // Exclude self

                    const li = document.createElement('li');
                    li.style.padding = '15px';
                    li.style.borderBottom = '1px solid #eee';
                    li.style.display = 'flex';
                    li.style.alignItems = 'center';
                    li.style.gap = '15px';

                    const subText = isTr ? `Altında ${childCount} blok var` : `${childCount} blocks below`;

                    li.innerHTML = `
                    <div style="background: #FFBF00; border-radius: 12px; padding: 8px; width: 44px; height: 44px; display: flex; align-items: center; justify-content: center;">
                        ${getIconForBlock(block.type)}
                    </div>
                    <div>
                        <div style="font-weight: bold; color: #333; font-size: 16px;">${getBlockName(block.type)}</div>
                        <div style="color: #666; font-size: 14px; margin-top: 4px;">${subText}</div>
                    </div>
                `;
                    list.appendChild(li);
                }
            });

            if (count === 0) {
                list.innerHTML = `<div style="padding: 30px; text-align: center; color: #999;">${isTr ? 'Henüz başlangıç bloğu eklenmemiş.' : 'No starter blocks added yet.'}</div>`;
            }
        }

        function getIconForBlock(type) {
            // Return SVG icons matching the actual block icons
            if (type.includes('start')) return `<img src="${ICON_START}" width="24" height="24" style="display:block;">`;
            if (type.includes('color')) return `<img src="${ICON_RHOMBUS}" width="24" height="24" style="display:block; filter: hue-rotate(180deg);">`;
            if (type.includes('controller')) return `<img src="${ICON_RHOMBUS}" width="24" height="24" style="display:block;">`;
            if (type.includes('message')) return `<img src="${ICON_MSG_IN}" width="24" height="24" style="display:block;">`;
            if (type.includes('condition')) return `<img src="${ICON_BOLT}" width="24" height="24" style="display:block;">`;
            return '🧩';
        }

        function getBlockName(type) {
            const names = {
                'start': { tr: 'Başla Bloğu', en: 'Start Block' },
                'when_condition': { tr: 'Koşul Bloğu', en: 'Condition Block' },
                'when_message_received': { tr: 'Mesaj Alındı', en: 'Msg Received' },
                'when_color_detected': { tr: 'Renk Algılandı', en: 'Color Detected' },
            };

            if (names[type]) {
                return currentLanguage === 'tr' ? names[type].tr : names[type].en;
            }
            return type;
        }

        // Current active flow ID for logging (set by each parallel start block)
        let currentFlowId = null;
        let flowCounter = 0;

        // Helper function to generate a small matrix preview HTML
        function generateMatrixPreview(pixels) {
            const colors = ['#1c1c1e', '#ff2d55', '#ff9500', '#ffcc00', '#34c759', '#5ac8fa', '#007aff', '#af52de', '#ff3b30', '#ff6b6b', '#ffffff'];
            let html = '<span style="display:inline-grid;grid-template-columns:repeat(3,4px);gap:1px;vertical-align:middle;">';
            for (let i = 0; i < 9; i++) {
                const val = typeof pixels[i] === 'object' ? pixels[i].color : pixels[i];
                const colorHex = colors[val] || '#ffcc00';
                const opacity = val > 0 ? 1 : 0.2;
                html += `<span style="width:4px;height:4px;background:${colorHex};opacity:${opacity};border-radius:1px;"></span>`;
            }
            html += '</span>';
            return html;
        }

        // Updated logExecution signature to support depth
        function logExecution(message, flowId = null, depth = 0) {
            // Find the correct session for this flowId
            const targetFlowId = flowId !== null ? flowId : currentFlowId;
            let sessionIndex = -1;

            if (targetFlowId !== null && flowIdToSessionIndex.has(targetFlowId)) {
                sessionIndex = flowIdToSessionIndex.get(targetFlowId);
            } else if (executionSessions.length > 0) {
                // Fall back to most recent session
                sessionIndex = executionSessions.length - 1;
            }

            if (sessionIndex >= 0 && sessionIndex < executionSessions.length) {
                const session = executionSessions[sessionIndex];
                if (!session.ended) {
                    const time = new Date().toLocaleTimeString();
                    session.logs.push({ time, message, depth });
                    if (session.logs.length > MAX_LOGS) session.logs.shift();
                }
            }

            const modal = document.getElementById('infoModal');
            if (modal.classList.contains('show') && document.getElementById('tab-executions').style.display !== 'none') {
                renderExecutionLogs();
            }
        }

        // Log to a specific session by index
        function logExecutionToSession(sessionIndex, message, depth = 0) {
            if (sessionIndex >= 0 && sessionIndex < executionSessions.length) {
                const session = executionSessions[sessionIndex];
                if (!session.ended) {
                    const time = new Date().toLocaleTimeString();
                    session.logs.push({ time, message, depth });
                    if (session.logs.length > MAX_LOGS) session.logs.shift();
                }
            }

            const modal = document.getElementById('infoModal');
            if (modal.classList.contains('show') && document.getElementById('tab-executions').style.display !== 'none') {
                renderExecutionLogs();
            }
        }

        // Log to all active sessions (for shared events like stop, event listening)
        function logToAllActiveSessions(message, depth = 0) {
            if (window.activeFlowSessions) {
                window.activeFlowSessions.forEach((sessionIndex) => {
                    logExecutionToSession(sessionIndex, message, depth);
                });
            }
        }

        // flowIdToSessionIndex maps flowId to session index
        const flowIdToSessionIndex = new Map();

        function startExecutionSession(flowId = null, blockId = null, title = null) {
            // Snapshot the block appearance at the start of execution
            const blockPreviewData = blockId ? getBlockSvg(blockId) : null;

            const session = {
                startTime: new Date(),
                logs: [],
                flowId: flowId, // Track which flow this session belongs to
                blockId: blockId, // Store block ID reference
                blockPreviewData: blockPreviewData, // Store the static snapshot
                title: title, // Custom session title
                ended: false,
                expanded: true // Most recent is expanded by default
            };
            // Collapse previous sessions
            executionSessions.forEach(s => s.expanded = false);
            executionSessions.push(session);

            const sessionIndex = executionSessions.length - 1;

            // Map flowId to session index
            if (flowId !== null) {
                flowIdToSessionIndex.set(flowId, sessionIndex);
            }

            // Limit total sessions
            if (executionSessions.length > 20) {
                executionSessions.shift();
                // Adjust indices in map
                flowIdToSessionIndex.forEach((idx, fid) => {
                    flowIdToSessionIndex.set(fid, idx - 1);
                });
            }

            renderExecutionLogs();
            return sessionIndex;
        }

        function endExecutionSession(reason) {
            if (executionSessions.length > 0) {
                const currentSession = executionSessions[executionSessions.length - 1];
                if (!currentSession.ended) {
                    currentSession.ended = true;
                    currentSession.endTime = new Date();
                    currentSession.endReason = reason || 'Completed';
                }
            }
            renderExecutionLogs();
        }

        function endExecutionSessionByIndex(sessionIndex, reason) {
            if (sessionIndex >= 0 && sessionIndex < executionSessions.length) {
                const session = executionSessions[sessionIndex];
                if (!session.ended) {
                    session.ended = true;
                    session.endTime = new Date();
                    session.endReason = reason || 'Completed';
                }
            }
            renderExecutionLogs();
        }

        function toggleSessionExpand(index) {
            if (executionSessions[index]) {
                executionSessions[index].expanded = !executionSessions[index].expanded;
                renderExecutionLogs();
            }
        }

        // Export a block and its children as SVG data URI
        function getBlockSvg(blockId) {
            try {
                const block = workspace.getBlockById(blockId);
                if (!block) return null;

                // Get the block's SVG element
                const blockSvg = block.getSvgRoot();
                if (!blockSvg) return null;

                // Get block bounds including all children
                const bbox = blockSvg.getBBox();
                if (bbox.width === 0 || bbox.height === 0) return null;

                // Add padding
                const padding = 10;
                const width = bbox.width + padding * 2;
                const height = bbox.height + padding * 2;

                // Create a new SVG
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                svg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
                svg.setAttribute('width', width);
                svg.setAttribute('height', height);
                svg.setAttribute('viewBox', `${bbox.x - padding} ${bbox.y - padding} ${width} ${height} `);

                // Copy defs from the workspace SVG (contains gradients, patterns, etc.)
                const workspaceSvg = workspace.getParentSvg();
                const originalDefs = workspaceSvg.querySelector('defs');
                if (originalDefs) {
                    const defsClone = originalDefs.cloneNode(true);
                    svg.appendChild(defsClone);
                }

                // Add necessary styles
                const style = document.createElementNS('http://www.w3.org/2000/svg', 'style');
                style.textContent = `
                    .blocklyText { font-family: "Helvetica Neue", Helvetica, sans-serif; font-size: 11pt; fill: #fff; }
                    /* Input fields (Editable) - Force white background */
                    .blocklyEditableText > rect { fill: #ffffff !important; stroke: none; }
                    .blocklyEditableText > text { fill: #000000 !important; }
                    /* Non-editable text */
                    .blocklyNonEditableText > text { fill: #ffffff !important; }
                    .blocklyDropdownText { fill: #ffffff !important; }
                    /* Angle field specifics */
                    .blocklyAngularPie { fill: #ffffff; stroke: #000000; }
                `;
                svg.appendChild(style);

                // Clone the block SVG with deep clone
                const clone = blockSvg.cloneNode(true);

                // Remove transforms and selection
                clone.removeAttribute('transform');
                clone.classList.remove('blocklySelected');

                // Fix Image Paths (convert relative to absolute) - CRITICAL FIX
                const images = clone.querySelectorAll('image');
                images.forEach(img => {
                    const href = img.getAttribute('href') || img.getAttribute('xlink:href');
                    if (href && !href.startsWith('http') && !href.startsWith('data:')) {
                        // Create absolute URL
                        try {
                            const absUrl = new URL(href, window.location.href).href;
                            img.setAttribute('href', absUrl);
                            img.setAttribute('xlink:href', absUrl); // For compatibility
                        } catch (e) { console.warn('Image URL fix failed:', href); }
                    }
                });

                // Wrap in a group
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.appendChild(clone);
                svg.appendChild(g);

                // Serialize to string
                const serializer = new XMLSerializer();
                const svgString = serializer.serializeToString(svg);

                // Convert to data URI
                return 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgString)));
            } catch (e) {
                console.error('Error exporting block SVG:', e);
                return null;
            }
        }

        function renderExecutionLogs() {
            const container = document.getElementById('executionLogs');
            const isTr = currentLanguage === 'tr';

            if (executionSessions.length === 0) {
                container.innerHTML = `<div style="padding: 30px; text-align: center; color: #999;">${isTr ? 'Henüz çalıştırma kaydı yok.' : 'No execution logs yet.'}</div>`;
                return;
            }

            // Flow colors for visual distinction
            const flowColors = ['#e3f2fd', '#e8f5e9', '#fff3e0', '#fce4ec', '#e1f5fe', '#f3e5f5'];

            let html = '';
            // Show sessions in reverse order (newest first)
            [...executionSessions].reverse().forEach((session, revIndex) => {
                const index = executionSessions.length - 1 - revIndex;
                const startTimeStr = session.startTime.toLocaleTimeString();
                const dateStr = session.startTime.toLocaleDateString();
                const logCount = session.logs.length;
                const statusIcon = session.ended ? '⏹️' : '▶️';
                const expandIcon = session.expanded ? '▼' : '▶';

                // Get flow label if this session has an associated flowId
                const flowLabel = session.flowId ? ` (${isTr ? 'Akış' : 'Flow'} ${session.flowId})` : '';
                const bgColor = session.flowId ? flowColors[(session.flowId - 1) % flowColors.length] : '#f8f9fa';

                // Get block SVG for preview (use stored snapshot)
                // Get block SVG for preview (use stored snapshot)
                const blockSvg = session.blockPreviewData;

                html += `
                    <div style="margin-bottom: 8px; border: 1px solid #e0e0e0; border-radius: 10px; overflow: hidden; background: #fff;">
                        <div onclick="toggleSessionExpand(${index})" style="background: ${bgColor}; padding: 12px; cursor: pointer; display: flex; align-items: center; gap: 12px; border-bottom: ${session.expanded ? '1px solid #e0e0e0' : 'none'};">
                            <span style="color: #666; font-size: 12px;">${expandIcon}</span>
                            <div style="background: #FFBF00; border-radius: 10px; padding: 8px; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center;">
                                <img src="${session.title && (session.title.includes('Condition') || session.title.includes('Koşul')) ? ICON_BOLT : ICON_START}" width="24" height="24" style="display:block;">
                            </div>
                            <div style="flex: 1;">
                                <div style="font-weight: bold; color: #333; font-size: 16px;">${session.title ? session.title : (isTr ? 'Kod Çalıştırıldı' : 'Code Executed') + flowLabel}</div>
                                <div style="font-size: 13px; color: #666; margin-top: 2px;">${dateStr} ${startTimeStr} • ${logCount} ${isTr ? 'işlem' : 'actions'}</div>
                            </div>
                            <div style="font-size: 20px;">${statusIcon}</div>
                        </div>
                        ${session.expanded ? `
                            <div style="display: flex; gap: 8px; padding: 8px; background: #fafafa;">
                                <!-- Left: Logs -->
                                <div style="flex: 1; max-height: 400px; overflow-y: auto; min-width: 0;">
                                    ${session.logs.length === 0 ? `<div style="color: #999; text-align: center; padding: 10px;">${isTr ? 'Log yok' : 'No logs'}</div>` : ''}
                                    ${session.logs.map(log => `
                                        <div style="margin-bottom: 4px; padding: 6px 10px; margin-left: ${log.depth ? log.depth * 20 : 0}px; background: #fff; border: 1px solid #eee; border-left: ${log.depth ? '3px solid #ddd' : '1px solid #eee'}; border-radius: 6px; font-size: 12px; display: flex; align-items: center; gap: 6px;">
                                            <span style="color: #999; font-size: 10px; white-space: nowrap;">[${log.time}]</span>
                                            <span style="color: #333;">${log.message}</span>
                                        </div>
                                    `).join('')}
                                </div>
                                <!-- Right: Block Preview -->
                                ${blockSvg ? `
                                    <div style="flex: 0 0 auto; width: 220px; max-height: 400px; overflow: auto; background: #f5f5f5; border-radius: 8px; padding: 10px; border: 1px solid #e0e0e0;">
                                        <img src="${blockSvg}" style="display: block; width: 100%; height: auto;" alt="Block Preview">
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''
                    }
                    </div>
                    `;
            });

            container.innerHTML = html;
        }

        function logDeviceAction(action, deviceName, deviceType) {
            const date = new Date().toLocaleString();
            const logEntry = { date, action, deviceName, deviceType };
            deviceLogs.push(logEntry);

            const modal = document.getElementById('infoModal');
            if (modal.classList.contains('show') && document.getElementById('tab-devices').style.display !== 'none') {
                renderDeviceLogs();
            }
        }

        function getDeviceImageHTML(type) {
            let imgSrc = '';

            if (type === 'motor') imgSrc = 'img/single-motor.png';
            else if (type === 'double_motor') imgSrc = 'img/double-motor.png';
            else if (type === 'color_sensor') imgSrc = 'img/color-sensor.png';
            else if (type === 'controller') imgSrc = 'img/controller.png';
            else if (type === 'spike_essential') imgSrc = 'img/spike_essential_icon.png';
            else if (type === 'spike_prime') imgSrc = 'img/spike_prime_icon.png';
            else if (type === 'technic_medium_hub') imgSrc = 'img/technic-hub.png';
            else if (type === 'city_hub') imgSrc = 'img/city-hub.png';
            else if (type === 'boost_move_hub') imgSrc = 'img/boost-hub.png';

            if (imgSrc) {
                return `<img src="${imgSrc}" style="width: 32px; height: 32px; object-fit: contain;">`;
            }
            return '📱';
        }

        function getDeviceTypeName(type, isTr) {
            const names = {
                'motor': { tr: 'Motor', en: 'Motor' },
                'color_sensor': { tr: 'Renk Sensörü', en: 'Color Sensor' },
                'controller': { tr: 'Kumanda', en: 'Controller' }
            };
            if (names[type]) {
                return isTr ? names[type].tr : names[type].en;
            }
            return type || 'Device';
        }

        function renderDeviceLogs() {
            const list = document.getElementById('deviceLogsList');
            const isTr = currentLanguage === 'tr';
            if (deviceLogs.length === 0) {
                list.innerHTML = `<div style="padding: 30px; color: #999; text-align: center;">${isTr ? 'Henüz cihaz işlemi yok' : 'No device actions yet'}</div>`;
                return;
            }

            list.innerHTML = deviceLogs.map(log => {
                const iconHtml = getDeviceImageHTML(log.deviceType);
                const typeName = getDeviceTypeName(log.deviceType, isTr);
                const isAdd = log.action === 'add';
                const actionText = isAdd
                    ? (isTr ? '+ Eklendi' : '+ Added')
                    : (isTr ? '- Kaldırıldı' : '- Removed');
                const actionColor = isAdd ? '#2e7d32' : '#c62828';
                const bgColor = isAdd ? '#e8f5e9' : '#ffebee';

                return `
                    <li style="padding: 12px 15px; border-bottom: 1px solid #eee; display: flex; align-items: center; gap: 12px;">
                        <div style="background: transparent; border-radius: 10px; padding: 4px; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-size: 20px;">
                            ${iconHtml}
                        </div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; color: #333; font-size: 15px;">${log.deviceName || typeName}</div>
                            <div style="font-size: 12px; color: #666; margin-top: 2px;">${log.date}</div>
                        </div>
                        <div style="background: ${bgColor}; color: ${actionColor}; padding: 4px 10px; border-radius: 12px; font-size: 12px; font-weight: 600;">
                            ${actionText}
                        </div>
                    </li>
                    `;
            }).reverse().join('');
        }

        // ========== LED GRAPH FUNCTIONALITY ==========
        // Store LED data points with timestamps (max 1 hour = 3600 seconds)
        const ledGraphData = {
            red: [],    // { timestamp: Date, value: number }
            green: [],
            blue: []
        };
        const MAX_GRAPH_DATA_AGE = 3600 * 1000; // 1 hour in ms
        const APP_START_TIME = Date.now(); // Track when app was opened

        // Numbers graph data (RGB numeric values)
        const numbersGraphData = {
            red: [],    // { timestamp: Date, value: number }
            green: [],
            blue: []
        };

        // Buttons graph data (mapped as A: Red, Y: Green, X: Blue)
        const buttonsGraphData = {
            A: [],
            Y: [],
            X: []
        };

        // Zoom state (shared between both graphs)
        let graphViewStart = null; // null = auto (app start or 1 hour ago, whichever is later)
        let graphViewEnd = null;   // null = auto (now)
        let isGraphZoomed = false;

        // Drag selection state
        let isDragging = false;
        let dragStartX = 0;
        let dragEndX = 0;

        // Initialize all colors & buttons with starting values
        ['red', 'green', 'blue'].forEach(color => {
            ledGraphData[color].push({ timestamp: APP_START_TIME, value: 0 });
            numbersGraphData[color].push({ timestamp: APP_START_TIME, value: 0 });
        });

        ['A', 'Y', 'X'].forEach(btn => {
            buttonsGraphData[btn].push({ timestamp: APP_START_TIME, value: 0 });
        });

        function logLedValue(color, value) {
            const now = Date.now();
            ledGraphData[color].push({ timestamp: now, value: value });

            // Cleanup old data (older than 1 hour)
            const cutoff = now - MAX_GRAPH_DATA_AGE;
            ledGraphData[color] = ledGraphData[color].filter(d => d.timestamp > cutoff);
        }

        function logNumberValue(color, value) {
            const now = Date.now();
            numbersGraphData[color].push({ timestamp: now, value: value });

            // Cleanup old data (older than 1 hour)
            const cutoff = now - MAX_GRAPH_DATA_AGE;
            numbersGraphData[color] = numbersGraphData[color].filter(d => d.timestamp > cutoff);
        }

        function logButtonValue(btn, value) {
            const now = Date.now();
            if (buttonsGraphData[btn]) {
                buttonsGraphData[btn].push({ timestamp: now, value: value });
                const cutoff = now - MAX_GRAPH_DATA_AGE;
                buttonsGraphData[btn] = buttonsGraphData[btn].filter(d => d.timestamp > cutoff);
            }
        }

        function refreshLedGraph() {
            // Reset to default 1 hour view
            graphViewStart = null;
            graphViewEnd = null;
            isGraphZoomed = false;
            document.getElementById('cancelZoomBtn').style.display = 'none';
            renderLedGraph();
            renderNumbersGraph();
            renderButtonsGraph();
        }

        function cancelGraphZoom() {
            refreshLedGraph();
        }

        function formatTime(timestamp) {
            const d = new Date(timestamp);
            // 24-hour format: HH:MM:SS
            return d.toLocaleTimeString('tr-TR', { hour12: false });
        }

        function renderLedGraph() {
            const canvas = document.getElementById('ledGraphCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.fillStyle = '#fafafa';
            ctx.fillRect(0, 0, width, height);

            // Graph area (with padding for labels) - adjusted for smaller height
            const padding = { left: 30, right: 10, top: 8, bottom: 18 };
            const graphWidth = width - padding.left - padding.right;
            const graphHeight = height - padding.top - padding.bottom;

            const now = Date.now();
            const viewEnd = graphViewEnd || now;
            // Use app start time as minimum - don't show time before app was opened
            const defaultStart = Math.max(APP_START_TIME, now - MAX_GRAPH_DATA_AGE);
            const viewStart = graphViewStart || defaultStart;
            const rangeMs = viewEnd - viewStart;

            // Update time labels
            const startLabel = document.getElementById('graphTimeStart');
            const endLabel = document.getElementById('graphTimeEnd');
            if (startLabel) startLabel.textContent = formatTime(viewStart);
            if (endLabel) endLabel.textContent = formatTime(viewEnd);

            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;

            // Only 2 horizontal lines: On and Off
            const isTr = currentLanguage === 'tr';
            const onLabel = isTr ? 'Açık' : 'On';
            const offLabel = isTr ? 'Kapalı' : 'Off';

            // On line (top)
            const yOn = padding.top;
            ctx.beginPath();
            ctx.moveTo(padding.left, yOn);
            ctx.lineTo(padding.left + graphWidth, yOn);
            ctx.stroke();
            ctx.fillStyle = '#888';
            ctx.font = '9px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText(onLabel, padding.left - 3, yOn + 3);

            // Off line (bottom)
            const yOff = padding.top + graphHeight;
            ctx.beginPath();
            ctx.moveTo(padding.left, yOff);
            ctx.lineTo(padding.left + graphWidth, yOff);
            ctx.stroke();
            ctx.fillText(offLabel, padding.left - 3, yOff + 3);

            // Draw border
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.strokeRect(padding.left, padding.top, graphWidth, graphHeight);

            // Draw LED lines
            const colors = {
                red: '#ff4444',
                green: '#44bb44',
                blue: '#4488ff'
            };

            let hasData = false;
            const transitionPoints = []; // Collect transition points for labels

            ['red', 'green', 'blue'].forEach(color => {
                const data = ledGraphData[color].filter(d => d.timestamp >= viewStart && d.timestamp <= viewEnd);
                if (data.length === 0) return;

                hasData = true;
                ctx.strokeStyle = colors[color];
                ctx.lineWidth = 2;
                ctx.beginPath();

                // Binary: value > 0 = On (top), value = 0 = Off (bottom)
                let lastValue = data[0].value > 0 ? 1 : 0;
                data.forEach((point, index) => {
                    const x = padding.left + ((point.timestamp - viewStart) / rangeMs) * graphWidth;
                    const isOn = point.value > 0 ? 1 : 0;
                    const y = padding.top + graphHeight - isOn * graphHeight;

                    if (index === 0) {
                        const startX = padding.left;
                        ctx.moveTo(startX, y);
                        ctx.lineTo(x, y);
                    } else {
                        const prevY = padding.top + graphHeight - lastValue * graphHeight;
                        ctx.lineTo(x, prevY);
                        ctx.lineTo(x, y);

                        // Record transition point (when value changes)
                        if (isOn !== lastValue) {
                            transitionPoints.push({
                                x: x,
                                timestamp: point.timestamp,
                                color: colors[color]
                            });
                        }
                    }
                    lastValue = isOn;
                });

                // Extend to current time
                const endX = padding.left + graphWidth;
                const endY = padding.top + graphHeight - lastValue * graphHeight;
                ctx.lineTo(endX, endY);

                ctx.stroke();
            });

            // Draw transition time labels (avoid overlap by spacing)
            ctx.font = '8px sans-serif';
            ctx.textAlign = 'center';
            let lastLabelX = -50; // Track last label position to avoid overlap

            transitionPoints
                .sort((a, b) => a.timestamp - b.timestamp)
                .forEach(point => {
                    // Only draw label if far enough from last one (30px minimum)
                    if (point.x - lastLabelX > 30) {
                        // Draw small tick mark
                        ctx.strokeStyle = point.color;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(point.x, padding.top + graphHeight);
                        ctx.lineTo(point.x, padding.top + graphHeight + 4);
                        ctx.stroke();

                        // Draw time label
                        ctx.fillStyle = '#666';
                        const timeStr = formatTime(point.timestamp);
                        // Show only HH:MM:SS (already in 24h format)
                        ctx.fillText(timeStr, point.x, padding.top + graphHeight + 12);

                        lastLabelX = point.x;
                    }
                });

            // Update status
            const status = document.getElementById('graphStatus');
            if (status) {
                const totalPoints = ledGraphData.red.length + ledGraphData.green.length + ledGraphData.blue.length;
                if (isGraphZoomed) {
                    const durationSec = Math.round(rangeMs / 1000);
                    status.textContent = isTr
                        ? `Zoom: ${durationSec} saniye gösteriliyor`
                        : `Zoom: Showing ${durationSec} seconds`;
                } else if (hasData) {
                    status.textContent = isTr
                        ? `${totalPoints} veri noktası • Son 1 saat gösteriliyor`
                        : `${totalPoints} data points • Showing last 1 hour`;
                } else {
                    status.textContent = isTr ? 'Henüz LED verisi yok' : 'No LED data yet';
                }
            }

            // Also render numbers graph
            renderNumbersGraph();
        }

        function renderNumbersGraph() {
            const canvas = document.getElementById('numbersGraphCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.fillStyle = '#fafafa';
            ctx.fillRect(0, 0, width, height);

            // Graph area
            const padding = { left: 30, right: 10, top: 10, bottom: 20 };
            const graphWidth = width - padding.left - padding.right;
            const graphHeight = height - padding.top - padding.bottom;

            const now = Date.now();
            const viewEnd = graphViewEnd || now;
            const defaultStart = Math.max(APP_START_TIME, now - MAX_GRAPH_DATA_AGE);
            const viewStart = graphViewStart || defaultStart;
            const rangeMs = viewEnd - viewStart;

            // Y-axis range: 0-10
            const maxValue = 10;

            // Draw horizontal grid lines
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            ctx.font = '9px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillStyle = '#888';

            for (let v = 0; v <= maxValue; v += 2) {
                const y = padding.top + graphHeight - (v / maxValue) * graphHeight;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + graphWidth, y);
                ctx.stroke();
                ctx.fillText(v.toString(), padding.left - 3, y + 3);
            }

            // Draw border
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.strokeRect(padding.left, padding.top, graphWidth, graphHeight);

            // Draw number lines
            const colors = {
                red: '#ff4444',
                green: '#44bb44',
                blue: '#4488ff'
            };

            const transitionPoints = []; // Collect transition points for labels

            ['red', 'green', 'blue'].forEach(color => {
                const data = numbersGraphData[color].filter(d => d.timestamp >= viewStart && d.timestamp <= viewEnd);
                if (data.length === 0) return;

                ctx.strokeStyle = colors[color];
                ctx.lineWidth = 2;
                ctx.beginPath();

                let lastValue = Math.min(data[0].value, maxValue);
                data.forEach((point, index) => {
                    const x = padding.left + ((point.timestamp - viewStart) / rangeMs) * graphWidth;
                    const clampedValue = Math.min(point.value, maxValue);
                    const y = padding.top + graphHeight - (clampedValue / maxValue) * graphHeight;

                    if (index === 0) {
                        const startX = padding.left;
                        ctx.moveTo(startX, y);
                        ctx.lineTo(x, y);
                    } else {
                        // Step graph for discrete values
                        const prevY = padding.top + graphHeight - (lastValue / maxValue) * graphHeight;
                        ctx.lineTo(x, prevY);
                        ctx.lineTo(x, y);

                        // Record transition point (when value changes)
                        if (clampedValue !== lastValue) {
                            transitionPoints.push({
                                x: x,
                                timestamp: point.timestamp,
                                color: colors[color],
                                value: clampedValue
                            });
                        }
                    }
                    lastValue = clampedValue;
                });

                // Extend to current time
                const endX = padding.left + graphWidth;
                const endY = padding.top + graphHeight - (lastValue / maxValue) * graphHeight;
                ctx.lineTo(endX, endY);

                ctx.stroke();
            });

            // Draw transition time labels (avoid overlap by spacing)
            ctx.font = '8px sans-serif';
            ctx.textAlign = 'center';
            let lastLabelX = -50;

            transitionPoints
                .sort((a, b) => a.timestamp - b.timestamp)
                .forEach(point => {
                    // Only draw label if far enough from last one (30px minimum)
                    if (point.x - lastLabelX > 30) {
                        // Draw small tick mark
                        ctx.strokeStyle = point.color;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(point.x, padding.top + graphHeight);
                        ctx.lineTo(point.x, padding.top + graphHeight + 4);
                        ctx.stroke();

                        // Draw time label
                        ctx.fillStyle = '#666';
                        const timeStr = formatTime(point.timestamp);
                        ctx.fillText(timeStr, point.x, padding.top + graphHeight + 12);

                        lastLabelX = point.x;
                    }
                });
        }



        function renderButtonsGraph() {
            const canvas = document.getElementById('buttonsGraphCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.fillStyle = '#fafafa';
            ctx.fillRect(0, 0, width, height);

            // Graph area
            const padding = { left: 40, right: 10, top: 12, bottom: 12 };
            const graphWidth = width - padding.left - padding.right;
            const graphHeight = height - padding.top - padding.bottom;

            const now = Date.now();
            const viewEnd = graphViewEnd || now;
            const defaultStart = Math.max(APP_START_TIME, now - MAX_GRAPH_DATA_AGE);
            const viewStart = graphViewStart || defaultStart;
            const rangeMs = viewEnd - viewStart;

            // Draw border
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.strokeRect(padding.left, padding.top, graphWidth, graphHeight);

            // Labels setup
            ctx.font = '9px sans-serif';
            ctx.textAlign = 'right';

            // Labels setup
            ctx.font = '9px sans-serif';
            ctx.textAlign = 'right';
            const isTr = currentLanguage === 'tr';
            const onLabel = isTr ? 'Basılı' : 'Pressed';
            const offLabel = isTr ? 'Serbest' : 'Released';

            // Draw Top Line (On)
            const yOn = padding.top;
            ctx.beginPath();
            ctx.moveTo(padding.left, yOn);
            ctx.lineTo(padding.left + graphWidth, yOn);
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.fillStyle = '#888';
            ctx.fillText(onLabel, padding.left - 4, yOn + 3);

            // Draw Bottom Line (Off)
            const yOff = padding.top + graphHeight;
            ctx.beginPath();
            ctx.moveTo(padding.left, yOff);
            ctx.lineTo(padding.left + graphWidth, yOff);
            ctx.strokeStyle = '#e0e0e0';
            ctx.stroke();
            ctx.fillText(offLabel, padding.left - 4, yOff + 3);

            // Draw Data
            const displayButtons = ['A', 'Y', 'X'];
            const colors = { A: '#E74C3C', Y: '#2ECC71', X: '#3498DB' };
            const offsets = { A: 0, Y: 2, X: 4 };

            displayButtons.forEach(btn => {
                const color = colors[btn];
                const offset = offsets[btn];

                // Draw Data
                const data = buttonsGraphData[btn].filter(d => d.timestamp >= viewStart && d.timestamp <= viewEnd);

                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();

                // Initial State Logic
                let lastValue = 0;
                if (data.length > 0 && data[0].timestamp > viewStart) {
                    const allData = buttonsGraphData[btn];
                    const firstIdx = allData.indexOf(data[0]);
                    if (firstIdx > 0) {
                        lastValue = allData[firstIdx - 1].value > 0 ? 1 : 0;
                    }
                } else if (data.length === 0) {
                    // No data in view, check if there is data before
                    const allData = buttonsGraphData[btn];
                    if (allData.length > 0 && allData[allData.length - 1].timestamp < viewStart) {
                        lastValue = allData[allData.length - 1].value > 0 ? 1 : 0;
                    }
                }

                // Initial move
                const yOnBtn = yOn + offset;
                const yOffBtn = yOff - offset;
                const startY = lastValue ? yOnBtn : yOffBtn;
                ctx.moveTo(padding.left, startY);

                if (data.length > 0) {
                    data.forEach((point, index) => {
                        const x = padding.left + ((point.timestamp - viewStart) / rangeMs) * graphWidth;
                        const isOn = point.value > 0 ? 1 : 0;
                        const currentY = isOn ? yOnBtn : yOffBtn;
                        const prevY = lastValue ? yOnBtn : yOffBtn;

                        // Step chart logic
                        ctx.lineTo(x, prevY);
                        ctx.lineTo(x, currentY);

                        lastValue = isOn;
                    });
                }

                // Extend to end
                const endX = padding.left + graphWidth;
                const endY = lastValue ? yOnBtn : yOffBtn;
                ctx.lineTo(endX, endY);
                ctx.stroke();
            });
        }

        function initGraphZoom() {
            // Setup zoom for both LED and Numbers graphs
            setupCanvasZoom('ledGraphCanvas', 'graphSelectionOverlay');
            setupCanvasZoom('numbersGraphCanvas', 'numbersSelectionOverlay');
            setupCanvasZoom('buttonsGraphCanvas', 'buttonsSelectionOverlay');
        }

        function setupCanvasZoom(canvasId, overlayId) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const overlay = document.getElementById(overlayId);
            const padding = { left: 30, right: 10 };
            const graphWidth = canvas.width - padding.left - padding.right;

            function getCanvasX(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                return (e.clientX - rect.left) * scaleX;
            }

            function clampToGraph(x) {
                return Math.max(padding.left, Math.min(x, padding.left + graphWidth));
            }

            function updateOverlay() {
                if (!overlay) return;
                const rect = canvas.getBoundingClientRect();
                const containerPadding = 10;

                const left = Math.min(dragStartX, dragEndX);
                const right = Math.max(dragStartX, dragEndX);
                const width = right - left;

                const screenLeft = (left / canvas.width) * rect.width + containerPadding;
                const screenWidth = (width / canvas.width) * rect.width;

                overlay.style.left = `${screenLeft} px`;
                overlay.style.width = `${screenWidth} px`;
            }

            canvas.addEventListener('mousedown', (e) => {
                const x = clampToGraph(getCanvasX(e));

                isDragging = true;
                dragStartX = x;
                dragEndX = x;
                if (overlay) {
                    overlay.style.display = 'block';
                    updateOverlay();
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                dragEndX = clampToGraph(getCanvasX(e));
                updateOverlay();
            });

            function finishSelection() {
                if (!isDragging) return;
                isDragging = false;
                if (overlay) overlay.style.display = 'none';

                const minDrag = 10;
                if (Math.abs(dragEndX - dragStartX) < minDrag) return;

                const now = Date.now();
                const defaultStart = Math.max(APP_START_TIME, now - MAX_GRAPH_DATA_AGE);
                const currentStart = graphViewStart || defaultStart;
                const currentEnd = graphViewEnd || now;
                const rangeMs = currentEnd - currentStart;

                const left = Math.min(dragStartX, dragEndX);
                const right = Math.max(dragStartX, dragEndX);

                const leftRatio = (left - padding.left) / graphWidth;
                const rightRatio = (right - padding.left) / graphWidth;

                const newStart = currentStart + leftRatio * rangeMs;
                const newEnd = currentStart + rightRatio * rangeMs;
                const newRange = newEnd - newStart;

                const MIN_ZOOM_RANGE = 5000;
                if (newRange < MIN_ZOOM_RANGE) {
                    return;
                }

                graphViewStart = newStart;
                graphViewEnd = newEnd;
                isGraphZoomed = true;

                document.getElementById('cancelZoomBtn').style.display = 'inline-block';
                renderLedGraph();
                renderNumbersGraph();
                renderButtonsGraph();
            }

            canvas.addEventListener('mouseup', finishSelection);

            document.addEventListener('mouseup', (e) => {
                if (isDragging && e.target !== canvas) {
                    const x = getCanvasX(e);
                    dragEndX = clampToGraph(x);
                    finishSelection();
                }
            });

            canvas.addEventListener('mouseleave', (e) => {
                if (isDragging) {
                    dragEndX = clampToGraph(getCanvasX(e));
                    updateOverlay();
                }
            });
        }

        // Initialize zoom on load
        setTimeout(initGraphZoom, 500);

        // Make functions globally available
        window.refreshLedGraph = refreshLedGraph;
        window.cancelGraphZoom = cancelGraphZoom;
        window.renderLedGraph = renderLedGraph;
        // ========== END LED GRAPH FUNCTIONALITY ==========

        // ==========================================
        // DOUBLE MOTOR RUNTIME FUNCTIONS (LPF2)
        // ==========================================

        async function getDoubleMotorWriteChar(deviceId) {
            // connectedDevices global array
            const deviceData = connectedDevices.find(d => d.id === deviceId);
            if (!deviceData) {
                console.error('❌ Double Motor device not found:', deviceId);
                return null;
            }

            // connectedCharacteristics global object (Step 990'da notifyChar.uuid ile kaydedildi)
            // Ancak writeChar ayrı olabilir.
            // deviceData.characteristics içindeki write özellikli karakteristiği bulalım.
            if (deviceData.characteristics) {
                const chars = Object.values(deviceData.characteristics);
                const writeChar = chars.find(c => c.properties.write || c.properties.writeWithoutResponse);
                if (writeChar) return writeChar;
            }

            // Eğer characteristics içinde yoksa, server üzerinden bulmayı deneyebiliriz (ama connected ise olmalı)
            console.error('❌ Double Motor Write Characteristic bulunamadı');
            return null;
        }

        async function runDoubleMotorToPosition(deviceId, motorIndex, angle) {
            console.log(`🚀 Double Motor GOTO: Device=${deviceId} Index=${motorIndex}, Angle=${angle}`);
            const writeChar = await getDoubleMotorWriteChar(deviceId);
            if (!writeChar) return;

            // Port ID: Left=1 -> 0x00, Right=2 -> 0x01
            const portId = (motorIndex == 1) ? 0x00 : 0x01;

            const targetAngle = parseInt(angle);
            const speed = 50;
            const endState = 126; // Hold

            // LPF2: GOTO_ABSOLUTE_POSITION (0x0D)
            const buffer = new ArrayBuffer(14);
            const view = new DataView(buffer);
            view.setUint8(0, 14); // Length
            view.setUint8(1, 0x00);
            view.setUint8(2, 0x81); // Port Output Command
            view.setUint8(3, portId);
            view.setUint8(4, 0x11); // Execute immediately, No Feedback
            view.setUint8(5, 0x0D); // Op: GOTO_ABS_POS
            view.setInt32(6, targetAngle, true); // Angle (Little Endian)
            view.setUint8(10, speed);
            view.setUint8(11, 100); // MaxPower
            view.setUint8(12, endState);
            view.setUint8(13, 0x03); // Profile: Accel+Decel

            try {
                await writeChar.writeValueWithoutResponse(new Uint8Array(buffer));
                console.log(`✅ CMD Sent (Port ${portId})`);
            } catch (e) {
                console.error(`❌ CMD Error:`, e);
            }
        }

        async function startDoubleMotor(deviceId, motorIndex, direction) {
            const writeChar = await getDoubleMotorWriteChar(deviceId);
            if (!writeChar) return;

            const portId = (motorIndex == 1) ? 0x00 : 0x01;
            let speed = 50;
            if (direction === 'CCW') speed = -50;

            // LPF2: START_SPEED (0x07)
            const buffer = new ArrayBuffer(9);
            const view = new DataView(buffer);
            view.setUint8(0, 9);
            view.setUint8(1, 0x00);
            view.setUint8(2, 0x81);
            view.setUint8(3, portId);
            view.setUint8(4, 0x11);
            view.setUint8(5, 0x07); // Op: START_SPEED
            view.setInt8(6, speed);
            view.setUint8(7, 100); // MaxPower
            view.setUint8(8, 0x03); // Profile

            try {
                await writeChar.writeValueWithoutResponse(new Uint8Array(buffer));
            } catch (e) { console.error(e); }
        }

        async function stopDoubleMotor(deviceId, motorIndex) {
            const writeChar = await getDoubleMotorWriteChar(deviceId);
            if (!writeChar) return;

            const portId = (motorIndex == 1) ? 0x00 : 0x01;

            // LPF2: START_SPEED (0x07) with Speed 0
            const buffer = new ArrayBuffer(9);
            const view = new DataView(buffer);
            view.setUint8(0, 9);
            view.setUint8(1, 0x00);
            view.setUint8(2, 0x81);
            view.setUint8(3, portId);
            view.setUint8(4, 0x11);
            view.setUint8(5, 0x07);
            view.setInt8(6, 0); // Speed 0 = Hold/Float depending on implementation, usually Hold if prev was run
            view.setUint8(7, 100);
            view.setUint8(8, 0x03);

            try {
                await writeChar.writeValueWithoutResponse(new Uint8Array(buffer));
            } catch (e) { console.error(e); }
        }

        async function setDoubleMotorSpeed(deviceId, motorIndex, speedVal) {
            const writeChar = await getDoubleMotorWriteChar(deviceId);
            if (!writeChar) return;

            const portId = (motorIndex == 1) ? 0x00 : 0x01;
            let s = parseInt(speedVal);
            if (s > 100) s = 100;
            if (s < -100) s = -100;

            const buffer = new ArrayBuffer(9);
            const view = new DataView(buffer);
            view.setUint8(0, 9);
            view.setUint8(1, 0x00);
            view.setUint8(2, 0x81);
            view.setUint8(3, portId);
            view.setUint8(4, 0x11);
            view.setUint8(5, 0x07); // START_SPEED
            view.setInt8(6, s);
            view.setUint8(7, 100);
            view.setUint8(8, 0x03);

            try {
                await writeChar.writeValueWithoutResponse(new Uint8Array(buffer));
            } catch (e) { console.error(e); }
        }

        async function runDoubleMotorRotations(deviceId, motorIndex, rotations, direction) {
            const writeChar = await getDoubleMotorWriteChar(deviceId);
            if (!writeChar) return;

            const portId = (motorIndex == 1) ? 0x00 : 0x01;
            const degrees = parseInt(rotations) * 360;
            let speed = 50;
            if (direction === 'CCW') speed = -50;

            // LPF2: START_SPEED_FOR_DEGREES (0x0C)
            const buffer = new ArrayBuffer(14);
            const view = new DataView(buffer);
            view.setUint8(0, 14);
            view.setUint8(1, 0x00);
            view.setUint8(2, 0x81);
            view.setUint8(3, portId);
            view.setUint8(4, 0x11);
            view.setUint8(5, 0x0C); // Op: DEGREES
            view.setInt32(6, degrees, true);
            view.setInt8(10, speed);
            view.setUint8(11, 100);
            view.setUint8(12, 126); // Hold
            view.setUint8(13, 0x03);

            try {
                await writeChar.writeValueWithoutResponse(new Uint8Array(buffer));
            } catch (e) { console.error(e); }
        }

        // Window'a expose et
        window.runDoubleMotorToPosition = runDoubleMotorToPosition;
        window.startDoubleMotor = startDoubleMotor;
        window.stopDoubleMotor = stopDoubleMotor;
        window.setDoubleMotorSpeed = setDoubleMotorSpeed;
        window.runDoubleMotorRotations = runDoubleMotorRotations;

        window.addEventListener('load', initBlockly);
        window.addEventListener('resize', () => Blockly.svgResize(workspace));
    </script>
</body>

</html>
